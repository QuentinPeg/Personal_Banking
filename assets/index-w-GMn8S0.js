var sw = Object.defineProperty; var ow = (t, e, n) => e in t ? sw(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n; var J = (t, e, n) => ow(t, typeof e != "symbol" ? e + "" : e, n); function aw(t, e) { for (var n = 0; n < e.length; n++) { const r = e[n]; if (typeof r != "string" && !Array.isArray(r)) { for (const i in r) if (i !== "default" && !(i in t)) { const s = Object.getOwnPropertyDescriptor(r, i); s && Object.defineProperty(t, i, s.get ? s : { enumerable: !0, get: () => r[i] }) } } } return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })) } (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const s of i) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(i) { if (i.ep) return; i.ep = !0; const s = n(i); fetch(i.href, s) } })(); var At = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function Vd(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } function lw(t) { if (t.__esModule) return t; var e = t.default; if (typeof e == "function") { var n = function r() { return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments) }; n.prototype = e.prototype } else n = {}; return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function (r) { var i = Object.getOwnPropertyDescriptor(t, r); Object.defineProperty(n, r, i.get ? i : { enumerable: !0, get: function () { return t[r] } }) }), n } var fv = { exports: {} }, Ol = {}, pv = { exports: {} }, te = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var uo = Symbol.for("react.element"), uw = Symbol.for("react.portal"), cw = Symbol.for("react.fragment"), dw = Symbol.for("react.strict_mode"), hw = Symbol.for("react.profiler"), fw = Symbol.for("react.provider"), pw = Symbol.for("react.context"), gw = Symbol.for("react.forward_ref"), mw = Symbol.for("react.suspense"), vw = Symbol.for("react.memo"), yw = Symbol.for("react.lazy"), Lf = Symbol.iterator; function bw(t) { return t === null || typeof t != "object" ? null : (t = Lf && t[Lf] || t["@@iterator"], typeof t == "function" ? t : null) } var gv = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, mv = Object.assign, vv = {}; function Ai(t, e, n) { this.props = t, this.context = e, this.refs = vv, this.updater = n || gv } Ai.prototype.isReactComponent = {}; Ai.prototype.setState = function (t, e) { if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, t, e, "setState") }; Ai.prototype.forceUpdate = function (t) { this.updater.enqueueForceUpdate(this, t, "forceUpdate") }; function yv() { } yv.prototype = Ai.prototype; function Bd(t, e, n) { this.props = t, this.context = e, this.refs = vv, this.updater = n || gv } var Ud = Bd.prototype = new yv; Ud.constructor = Bd; mv(Ud, Ai.prototype); Ud.isPureReactComponent = !0; var Df = Array.isArray, bv = Object.prototype.hasOwnProperty, Hd = { current: null }, _v = { key: !0, ref: !0, __self: !0, __source: !0 }; function wv(t, e, n) { var r, i = {}, s = null, o = null; if (e != null) for (r in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) bv.call(e, r) && !_v.hasOwnProperty(r) && (i[r] = e[r]); var a = arguments.length - 2; if (a === 1) i.children = n; else if (1 < a) { for (var l = Array(a), u = 0; u < a; u++)l[u] = arguments[u + 2]; i.children = l } if (t && t.defaultProps) for (r in a = t.defaultProps, a) i[r] === void 0 && (i[r] = a[r]); return { $$typeof: uo, type: t, key: s, ref: o, props: i, _owner: Hd.current } } function _w(t, e) { return { $$typeof: uo, type: t.type, key: e, ref: t.ref, props: t.props, _owner: t._owner } } function Wd(t) { return typeof t == "object" && t !== null && t.$$typeof === uo } function ww(t) { var e = { "=": "=0", ":": "=2" }; return "$" + t.replace(/[=:]/g, function (n) { return e[n] }) } var Af = /\/+/g; function wu(t, e) { return typeof t == "object" && t !== null && t.key != null ? ww("" + t.key) : e.toString(36) } function fa(t, e, n, r, i) { var s = typeof t; (s === "undefined" || s === "boolean") && (t = null); var o = !1; if (t === null) o = !0; else switch (s) { case "string": case "number": o = !0; break; case "object": switch (t.$$typeof) { case uo: case uw: o = !0 } }if (o) return o = t, i = i(o), t = r === "" ? "." + wu(o, 0) : r, Df(i) ? (n = "", t != null && (n = t.replace(Af, "$&/") + "/"), fa(i, e, n, "", function (u) { return u })) : i != null && (Wd(i) && (i = _w(i, n + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(Af, "$&/") + "/") + t)), e.push(i)), 1; if (o = 0, r = r === "" ? "." : r + ":", Df(t)) for (var a = 0; a < t.length; a++) { s = t[a]; var l = r + wu(s, a); o += fa(s, e, n, l, i) } else if (l = bw(t), typeof l == "function") for (t = l.call(t), a = 0; !(s = t.next()).done;)s = s.value, l = r + wu(s, a++), o += fa(s, e, n, l, i); else if (s === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return o } function Co(t, e, n) { if (t == null) return t; var r = [], i = 0; return fa(t, r, "", "", function (s) { return e.call(n, s, i++) }), r } function Sw(t) { if (t._status === -1) { var e = t._result; e = e(), e.then(function (n) { (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n) }, function (n) { (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n) }), t._status === -1 && (t._status = 0, t._result = e) } if (t._status === 1) return t._result.default; throw t._result } var it = { current: null }, pa = { transition: null }, xw = { ReactCurrentDispatcher: it, ReactCurrentBatchConfig: pa, ReactCurrentOwner: Hd }; function Sv() { throw Error("act(...) is not supported in production builds of React.") } te.Children = { map: Co, forEach: function (t, e, n) { Co(t, function () { e.apply(this, arguments) }, n) }, count: function (t) { var e = 0; return Co(t, function () { e++ }), e }, toArray: function (t) { return Co(t, function (e) { return e }) || [] }, only: function (t) { if (!Wd(t)) throw Error("React.Children.only expected to receive a single React element child."); return t } }; te.Component = Ai; te.Fragment = cw; te.Profiler = hw; te.PureComponent = Bd; te.StrictMode = dw; te.Suspense = mw; te.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = xw; te.act = Sv; te.cloneElement = function (t, e, n) { if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + "."); var r = mv({}, t.props), i = t.key, s = t.ref, o = t._owner; if (e != null) { if (e.ref !== void 0 && (s = e.ref, o = Hd.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps) var a = t.type.defaultProps; for (l in e) bv.call(e, l) && !_v.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]) } var l = arguments.length - 2; if (l === 1) r.children = n; else if (1 < l) { a = Array(l); for (var u = 0; u < l; u++)a[u] = arguments[u + 2]; r.children = a } return { $$typeof: uo, type: t.type, key: i, ref: s, props: r, _owner: o } }; te.createContext = function (t) { return t = { $$typeof: pw, _currentValue: t, _currentValue2: t, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, t.Provider = { $$typeof: fw, _context: t }, t.Consumer = t }; te.createElement = wv; te.createFactory = function (t) { var e = wv.bind(null, t); return e.type = t, e }; te.createRef = function () { return { current: null } }; te.forwardRef = function (t) { return { $$typeof: gw, render: t } }; te.isValidElement = Wd; te.lazy = function (t) { return { $$typeof: yw, _payload: { _status: -1, _result: t }, _init: Sw } }; te.memo = function (t, e) { return { $$typeof: vw, type: t, compare: e === void 0 ? null : e } }; te.startTransition = function (t) { var e = pa.transition; pa.transition = {}; try { t() } finally { pa.transition = e } }; te.unstable_act = Sv; te.useCallback = function (t, e) { return it.current.useCallback(t, e) }; te.useContext = function (t) { return it.current.useContext(t) }; te.useDebugValue = function () { }; te.useDeferredValue = function (t) { return it.current.useDeferredValue(t) }; te.useEffect = function (t, e) { return it.current.useEffect(t, e) }; te.useId = function () { return it.current.useId() }; te.useImperativeHandle = function (t, e, n) { return it.current.useImperativeHandle(t, e, n) }; te.useInsertionEffect = function (t, e) { return it.current.useInsertionEffect(t, e) }; te.useLayoutEffect = function (t, e) { return it.current.useLayoutEffect(t, e) }; te.useMemo = function (t, e) { return it.current.useMemo(t, e) }; te.useReducer = function (t, e, n) { return it.current.useReducer(t, e, n) }; te.useRef = function (t) { return it.current.useRef(t) }; te.useState = function (t) { return it.current.useState(t) }; te.useSyncExternalStore = function (t, e, n) { return it.current.useSyncExternalStore(t, e, n) }; te.useTransition = function () { return it.current.useTransition() }; te.version = "18.3.1"; pv.exports = te; var R = pv.exports; const _t = Vd(R), wc = aw({ __proto__: null, default: _t }, [R]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var kw = R, Cw = Symbol.for("react.element"), Ow = Symbol.for("react.fragment"), Pw = Object.prototype.hasOwnProperty, Ew = kw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, Tw = { key: !0, ref: !0, __self: !0, __source: !0 }; function xv(t, e, n) { var r, i = {}, s = null, o = null; n !== void 0 && (s = "" + n), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref); for (r in e) Pw.call(e, r) && !Tw.hasOwnProperty(r) && (i[r] = e[r]); if (t && t.defaultProps) for (r in e = t.defaultProps, e) i[r] === void 0 && (i[r] = e[r]); return { $$typeof: Cw, type: t, key: s, ref: o, props: i, _owner: Ew.current } } Ol.Fragment = Ow; Ol.jsx = xv; Ol.jsxs = xv; fv.exports = Ol; var A = fv.exports, kv = { exports: {} }, kt = {}, Cv = { exports: {} }, Ov = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (t) { function e(j, _) { var x = j.length; j.push(_); e: for (; 0 < x;) { var C = x - 1 >>> 1, w = j[C]; if (0 < i(w, _)) j[C] = _, j[x] = w, x = C; else break e } } function n(j) { return j.length === 0 ? null : j[0] } function r(j) { if (j.length === 0) return null; var _ = j[0], x = j.pop(); if (x !== _) { j[0] = x; e: for (var C = 0, w = j.length, O = w >>> 1; C < O;) { var D = 2 * (C + 1) - 1, F = j[D], z = D + 1, W = j[z]; if (0 > i(F, x)) z < w && 0 > i(W, F) ? (j[C] = W, j[z] = x, C = z) : (j[C] = F, j[D] = x, C = D); else if (z < w && 0 > i(W, x)) j[C] = W, j[z] = x, C = z; else break e } } return _ } function i(j, _) { var x = j.sortIndex - _.sortIndex; return x !== 0 ? x : j.id - _.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; t.unstable_now = function () { return s.now() } } else { var o = Date, a = o.now(); t.unstable_now = function () { return o.now() - a } } var l = [], u = [], c = 1, d = null, h = 3, f = !1, g = !1, m = !1, y = typeof setTimeout == "function" ? setTimeout : null, p = typeof clearTimeout == "function" ? clearTimeout : null, v = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function b(j) { for (var _ = n(u); _ !== null;) { if (_.callback === null) r(u); else if (_.startTime <= j) r(u), _.sortIndex = _.expirationTime, e(l, _); else break; _ = n(u) } } function S(j) { if (m = !1, b(j), !g) if (n(l) !== null) g = !0, V(P); else { var _ = n(u); _ !== null && q(S, _.startTime - j) } } function P(j, _) { g = !1, m && (m = !1, p(k), k = -1), f = !0; var x = h; try { for (b(_), d = n(l); d !== null && (!(d.expirationTime > _) || j && !L());) { var C = d.callback; if (typeof C == "function") { d.callback = null, h = d.priorityLevel; var w = C(d.expirationTime <= _); _ = t.unstable_now(), typeof w == "function" ? d.callback = w : d === n(l) && r(l), b(_) } else r(l); d = n(l) } if (d !== null) var O = !0; else { var D = n(u); D !== null && q(S, D.startTime - _), O = !1 } return O } finally { d = null, h = x, f = !1 } } var I = !1, T = null, k = -1, E = 5, M = -1; function L() { return !(t.unstable_now() - M < E) } function N() { if (T !== null) { var j = t.unstable_now(); M = j; var _ = !0; try { _ = T(!0, j) } finally { _ ? $() : (I = !1, T = null) } } else I = !1 } var $; if (typeof v == "function") $ = function () { v(N) }; else if (typeof MessageChannel < "u") { var B = new MessageChannel, H = B.port2; B.port1.onmessage = N, $ = function () { H.postMessage(null) } } else $ = function () { y(N, 0) }; function V(j) { T = j, I || (I = !0, $()) } function q(j, _) { k = y(function () { j(t.unstable_now()) }, _) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (j) { j.callback = null }, t.unstable_continueExecution = function () { g || f || (g = !0, V(P)) }, t.unstable_forceFrameRate = function (j) { 0 > j || 125 < j ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : E = 0 < j ? Math.floor(1e3 / j) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return h }, t.unstable_getFirstCallbackNode = function () { return n(l) }, t.unstable_next = function (j) { switch (h) { case 1: case 2: case 3: var _ = 3; break; default: _ = h }var x = h; h = _; try { return j() } finally { h = x } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (j, _) { switch (j) { case 1: case 2: case 3: case 4: case 5: break; default: j = 3 }var x = h; h = j; try { return _() } finally { h = x } }, t.unstable_scheduleCallback = function (j, _, x) { var C = t.unstable_now(); switch (typeof x == "object" && x !== null ? (x = x.delay, x = typeof x == "number" && 0 < x ? C + x : C) : x = C, j) { case 1: var w = -1; break; case 2: w = 250; break; case 5: w = 1073741823; break; case 4: w = 1e4; break; default: w = 5e3 }return w = x + w, j = { id: c++, callback: _, priorityLevel: j, startTime: x, expirationTime: w, sortIndex: -1 }, x > C ? (j.sortIndex = x, e(u, j), n(l) === null && j === n(u) && (m ? (p(k), k = -1) : m = !0, q(S, x - C))) : (j.sortIndex = w, e(l, j), g || f || (g = !0, V(P))), j }, t.unstable_shouldYield = L, t.unstable_wrapCallback = function (j) { var _ = h; return function () { var x = h; h = _; try { return j.apply(this, arguments) } finally { h = x } } } })(Ov); Cv.exports = Ov; var Iw = Cv.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Rw = R, xt = Iw; function U(t) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)e += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Pv = new Set, Ls = {}; function Fr(t, e) { Si(t, e), Si(t + "Capture", e) } function Si(t, e) { for (Ls[t] = e, t = 0; t < e.length; t++)Pv.add(e[t]) } var Sn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Sc = Object.prototype.hasOwnProperty, Mw = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, jf = {}, Nf = {}; function Lw(t) { return Sc.call(Nf, t) ? !0 : Sc.call(jf, t) ? !1 : Mw.test(t) ? Nf[t] = !0 : (jf[t] = !0, !1) } function Dw(t, e, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-"); default: return !1 } } function Aw(t, e, n, r) { if (e === null || typeof e > "u" || Dw(t, e, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function st(t, e, n, r, i, s, o) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o } var We = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) { We[t] = new st(t, 0, !1, t, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) { var e = t[0]; We[e] = new st(e, 1, !1, t[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) { We[t] = new st(t, 2, !1, t.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) { We[t] = new st(t, 2, !1, t, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) { We[t] = new st(t, 3, !1, t.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (t) { We[t] = new st(t, 3, !0, t, null, !1, !1) });["capture", "download"].forEach(function (t) { We[t] = new st(t, 4, !1, t, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (t) { We[t] = new st(t, 6, !1, t, null, !1, !1) });["rowSpan", "start"].forEach(function (t) { We[t] = new st(t, 5, !1, t.toLowerCase(), null, !1, !1) }); var qd = /[\-:]([a-z])/g; function Kd(t) { return t[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) { var e = t.replace(qd, Kd); We[e] = new st(e, 1, !1, t, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) { var e = t.replace(qd, Kd); We[e] = new st(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (t) { var e = t.replace(qd, Kd); We[e] = new st(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (t) { We[t] = new st(t, 1, !1, t.toLowerCase(), null, !1, !1) }); We.xlinkHref = new st("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (t) { We[t] = new st(t, 1, !1, t.toLowerCase(), null, !0, !0) }); function Gd(t, e, n, r) { var i = We.hasOwnProperty(e) ? We[e] : null; (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (Aw(e, n, i, r) && (n = null), r || i === null ? Lw(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (e = i.attributeName, r = i.attributeNamespace, n === null ? t.removeAttribute(e) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n)))) } var Pn = Rw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Oo = Symbol.for("react.element"), Zr = Symbol.for("react.portal"), ei = Symbol.for("react.fragment"), Yd = Symbol.for("react.strict_mode"), xc = Symbol.for("react.profiler"), Ev = Symbol.for("react.provider"), Tv = Symbol.for("react.context"), Qd = Symbol.for("react.forward_ref"), kc = Symbol.for("react.suspense"), Cc = Symbol.for("react.suspense_list"), Xd = Symbol.for("react.memo"), Mn = Symbol.for("react.lazy"), Iv = Symbol.for("react.offscreen"), Ff = Symbol.iterator; function qi(t) { return t === null || typeof t != "object" ? null : (t = Ff && t[Ff] || t["@@iterator"], typeof t == "function" ? t : null) } var xe = Object.assign, Su; function us(t) {
  if (Su === void 0) try { throw Error() } catch (n) { var e = n.stack.trim().match(/\n( *(at )?)/); Su = e && e[1] || "" } return `
`+ Su + t
} var xu = !1; function ku(t, e) {
  if (!t || xu) return ""; xu = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (u) { var r = u } Reflect.construct(t, [], e) } else { try { e.call() } catch (u) { r = u } t.call(e.prototype) } else { try { throw Error() } catch (u) { r = u } t() } } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (var i = u.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (i[o] !== s[a]) {
        if (o !== 1 || a !== 1) do if (o--, a--, 0 > a || i[o] !== s[a]) {
          var l = `
`+ i[o].replace(" at new ", " at "); return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)), l
        } while (1 <= o && 0 <= a); break
      }
    }
  } finally { xu = !1, Error.prepareStackTrace = n } return (t = t ? t.displayName || t.name : "") ? us(t) : ""
} function jw(t) { switch (t.tag) { case 5: return us(t.type); case 16: return us("Lazy"); case 13: return us("Suspense"); case 19: return us("SuspenseList"); case 0: case 2: case 15: return t = ku(t.type, !1), t; case 11: return t = ku(t.type.render, !1), t; case 1: return t = ku(t.type, !0), t; default: return "" } } function Oc(t) { if (t == null) return null; if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t; switch (t) { case ei: return "Fragment"; case Zr: return "Portal"; case xc: return "Profiler"; case Yd: return "StrictMode"; case kc: return "Suspense"; case Cc: return "SuspenseList" }if (typeof t == "object") switch (t.$$typeof) { case Tv: return (t.displayName || "Context") + ".Consumer"; case Ev: return (t._context.displayName || "Context") + ".Provider"; case Qd: var e = t.render; return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t; case Xd: return e = t.displayName || null, e !== null ? e : Oc(t.type) || "Memo"; case Mn: e = t._payload, t = t._init; try { return Oc(t(e)) } catch { } }return null } function Nw(t) { var e = t.type; switch (t.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Oc(e); case 8: return e === Yd ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function nr(t) { switch (typeof t) { case "boolean": case "number": case "string": case "undefined": return t; case "object": return t; default: return "" } } function Rv(t) { var e = t.type; return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function Fw(t) { var e = Rv(t) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), r = "" + t[e]; if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, s = n.set; return Object.defineProperty(t, e, { configurable: !0, get: function () { return i.call(this) }, set: function (o) { r = "" + o, s.call(this, o) } }), Object.defineProperty(t, e, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (o) { r = "" + o }, stopTracking: function () { t._valueTracker = null, delete t[e] } } } } function Po(t) { t._valueTracker || (t._valueTracker = Fw(t)) } function Mv(t) { if (!t) return !1; var e = t._valueTracker; if (!e) return !0; var n = e.getValue(), r = ""; return t && (r = Rv(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== n ? (e.setValue(t), !0) : !1 } function Da(t) { if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null; try { return t.activeElement || t.body } catch { return t.body } } function Pc(t, e) { var n = e.checked; return xe({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? t._wrapperState.initialChecked }) } function $f(t, e) { var n = e.defaultValue == null ? "" : e.defaultValue, r = e.checked != null ? e.checked : e.defaultChecked; n = nr(e.value != null ? e.value : n), t._wrapperState = { initialChecked: r, initialValue: n, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function Lv(t, e) { e = e.checked, e != null && Gd(t, "checked", e, !1) } function Ec(t, e) { Lv(t, e); var n = nr(e.value), r = e.type; if (n != null) r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n); else if (r === "submit" || r === "reset") { t.removeAttribute("value"); return } e.hasOwnProperty("value") ? Tc(t, e.type, n) : e.hasOwnProperty("defaultValue") && Tc(t, e.type, nr(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked) } function zf(t, e, n) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var r = e.type; if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e } n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n) } function Tc(t, e, n) { (e !== "number" || Da(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n)) } var cs = Array.isArray; function fi(t, e, n, r) { if (t = t.options, e) { e = {}; for (var i = 0; i < n.length; i++)e["$" + n[i]] = !0; for (n = 0; n < t.length; n++)i = e.hasOwnProperty("$" + t[n].value), t[n].selected !== i && (t[n].selected = i), i && r && (t[n].defaultSelected = !0) } else { for (n = "" + nr(n), e = null, i = 0; i < t.length; i++) { if (t[i].value === n) { t[i].selected = !0, r && (t[i].defaultSelected = !0); return } e !== null || t[i].disabled || (e = t[i]) } e !== null && (e.selected = !0) } } function Ic(t, e) { if (e.dangerouslySetInnerHTML != null) throw Error(U(91)); return xe({}, e, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue }) } function Vf(t, e) { var n = e.value; if (n == null) { if (n = e.children, e = e.defaultValue, n != null) { if (e != null) throw Error(U(92)); if (cs(n)) { if (1 < n.length) throw Error(U(93)); n = n[0] } e = n } e == null && (e = ""), n = e } t._wrapperState = { initialValue: nr(n) } } function Dv(t, e) { var n = nr(e.value), r = nr(e.defaultValue); n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), r != null && (t.defaultValue = "" + r) } function Bf(t) { var e = t.textContent; e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e) } function Av(t) { switch (t) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Rc(t, e) { return t == null || t === "http://www.w3.org/1999/xhtml" ? Av(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t } var Eo, jv = function (t) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return t(e, n, r, i) }) } : t }(function (t, e) { if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e; else { for (Eo = Eo || document.createElement("div"), Eo.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Eo.firstChild; t.firstChild;)t.removeChild(t.firstChild); for (; e.firstChild;)t.appendChild(e.firstChild) } }); function Ds(t, e) { if (e) { var n = t.firstChild; if (n && n === t.lastChild && n.nodeType === 3) { n.nodeValue = e; return } } t.textContent = e } var ys = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, $w = ["Webkit", "ms", "Moz", "O"]; Object.keys(ys).forEach(function (t) { $w.forEach(function (e) { e = e + t.charAt(0).toUpperCase() + t.substring(1), ys[e] = ys[t] }) }); function Nv(t, e, n) { return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || ys.hasOwnProperty(t) && ys[t] ? ("" + e).trim() : e + "px" } function Fv(t, e) { t = t.style; for (var n in e) if (e.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = Nv(n, e[n], r); n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : t[n] = i } } var zw = xe({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Mc(t, e) { if (e) { if (zw[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(U(137, t)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(U(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(U(61)) } if (e.style != null && typeof e.style != "object") throw Error(U(62)) } } function Lc(t, e) { if (t.indexOf("-") === -1) return typeof e.is == "string"; switch (t) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Dc = null; function Jd(t) { return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t } var Ac = null, pi = null, gi = null; function Uf(t) { if (t = fo(t)) { if (typeof Ac != "function") throw Error(U(280)); var e = t.stateNode; e && (e = Rl(e), Ac(t.stateNode, t.type, e)) } } function $v(t) { pi ? gi ? gi.push(t) : gi = [t] : pi = t } function zv() { if (pi) { var t = pi, e = gi; if (gi = pi = null, Uf(t), e) for (t = 0; t < e.length; t++)Uf(e[t]) } } function Vv(t, e) { return t(e) } function Bv() { } var Cu = !1; function Uv(t, e, n) { if (Cu) return t(e, n); Cu = !0; try { return Vv(t, e, n) } finally { Cu = !1, (pi !== null || gi !== null) && (Bv(), zv()) } } function As(t, e) { var n = t.stateNode; if (n === null) return null; var r = Rl(n); if (r === null) return null; n = r[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r; break e; default: t = !1 }if (t) return null; if (n && typeof n != "function") throw Error(U(231, e, typeof n)); return n } var jc = !1; if (Sn) try { var Ki = {}; Object.defineProperty(Ki, "passive", { get: function () { jc = !0 } }), window.addEventListener("test", Ki, Ki), window.removeEventListener("test", Ki, Ki) } catch { jc = !1 } function Vw(t, e, n, r, i, s, o, a, l) { var u = Array.prototype.slice.call(arguments, 3); try { e.apply(n, u) } catch (c) { this.onError(c) } } var bs = !1, Aa = null, ja = !1, Nc = null, Bw = { onError: function (t) { bs = !0, Aa = t } }; function Uw(t, e, n, r, i, s, o, a, l) { bs = !1, Aa = null, Vw.apply(Bw, arguments) } function Hw(t, e, n, r, i, s, o, a, l) { if (Uw.apply(this, arguments), bs) { if (bs) { var u = Aa; bs = !1, Aa = null } else throw Error(U(198)); ja || (ja = !0, Nc = u) } } function $r(t) { var e = t, n = t; if (t.alternate) for (; e.return;)e = e.return; else { t = e; do e = t, e.flags & 4098 && (n = e.return), t = e.return; while (t) } return e.tag === 3 ? n : null } function Hv(t) { if (t.tag === 13) { var e = t.memoizedState; if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated } return null } function Hf(t) { if ($r(t) !== t) throw Error(U(188)) } function Ww(t) { var e = t.alternate; if (!e) { if (e = $r(t), e === null) throw Error(U(188)); return e !== t ? null : t } for (var n = t, r = e; ;) { var i = n.return; if (i === null) break; var s = i.alternate; if (s === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === s.child) { for (s = i.child; s;) { if (s === n) return Hf(i), t; if (s === r) return Hf(i), e; s = s.sibling } throw Error(U(188)) } if (n.return !== r.return) n = i, r = s; else { for (var o = !1, a = i.child; a;) { if (a === n) { o = !0, n = i, r = s; break } if (a === r) { o = !0, r = i, n = s; break } a = a.sibling } if (!o) { for (a = s.child; a;) { if (a === n) { o = !0, n = s, r = i; break } if (a === r) { o = !0, r = s, n = i; break } a = a.sibling } if (!o) throw Error(U(189)) } } if (n.alternate !== r) throw Error(U(190)) } if (n.tag !== 3) throw Error(U(188)); return n.stateNode.current === n ? t : e } function Wv(t) { return t = Ww(t), t !== null ? qv(t) : null } function qv(t) { if (t.tag === 5 || t.tag === 6) return t; for (t = t.child; t !== null;) { var e = qv(t); if (e !== null) return e; t = t.sibling } return null } var Kv = xt.unstable_scheduleCallback, Wf = xt.unstable_cancelCallback, qw = xt.unstable_shouldYield, Kw = xt.unstable_requestPaint, Pe = xt.unstable_now, Gw = xt.unstable_getCurrentPriorityLevel, Zd = xt.unstable_ImmediatePriority, Gv = xt.unstable_UserBlockingPriority, Na = xt.unstable_NormalPriority, Yw = xt.unstable_LowPriority, Yv = xt.unstable_IdlePriority, Pl = null, sn = null; function Qw(t) { if (sn && typeof sn.onCommitFiberRoot == "function") try { sn.onCommitFiberRoot(Pl, t, void 0, (t.current.flags & 128) === 128) } catch { } } var qt = Math.clz32 ? Math.clz32 : Zw, Xw = Math.log, Jw = Math.LN2; function Zw(t) { return t >>>= 0, t === 0 ? 32 : 31 - (Xw(t) / Jw | 0) | 0 } var To = 64, Io = 4194304; function ds(t) { switch (t & -t) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return t & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return t } } function Fa(t, e) { var n = t.pendingLanes; if (n === 0) return 0; var r = 0, i = t.suspendedLanes, s = t.pingedLanes, o = n & 268435455; if (o !== 0) { var a = o & ~i; a !== 0 ? r = ds(a) : (s &= o, s !== 0 && (r = ds(s))) } else o = n & ~i, o !== 0 ? r = ds(o) : s !== 0 && (r = ds(s)); if (r === 0) return 0; if (e !== 0 && e !== r && !(e & i) && (i = r & -r, s = e & -e, i >= s || i === 16 && (s & 4194240) !== 0)) return e; if (r & 4 && (r |= n & 16), e = t.entangledLanes, e !== 0) for (t = t.entanglements, e &= r; 0 < e;)n = 31 - qt(e), i = 1 << n, r |= t[n], e &= ~i; return r } function eS(t, e) { switch (t) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function tS(t, e) { for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, s = t.pendingLanes; 0 < s;) { var o = 31 - qt(s), a = 1 << o, l = i[o]; l === -1 ? (!(a & n) || a & r) && (i[o] = eS(a, e)) : l <= e && (t.expiredLanes |= a), s &= ~a } } function Fc(t) { return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0 } function Qv() { var t = To; return To <<= 1, !(To & 4194240) && (To = 64), t } function Ou(t) { for (var e = [], n = 0; 31 > n; n++)e.push(t); return e } function co(t, e, n) { t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - qt(e), t[e] = n } function nS(t, e) { var n = t.pendingLanes & ~e; t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements; var r = t.eventTimes; for (t = t.expirationTimes; 0 < n;) { var i = 31 - qt(n), s = 1 << i; e[i] = 0, r[i] = -1, t[i] = -1, n &= ~s } } function eh(t, e) { var n = t.entangledLanes |= e; for (t = t.entanglements; n;) { var r = 31 - qt(n), i = 1 << r; i & e | t[r] & e && (t[r] |= e), n &= ~i } } var de = 0; function Xv(t) { return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1 } var Jv, th, Zv, ey, ty, $c = !1, Ro = [], Wn = null, qn = null, Kn = null, js = new Map, Ns = new Map, An = [], rS = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function qf(t, e) { switch (t) { case "focusin": case "focusout": Wn = null; break; case "dragenter": case "dragleave": qn = null; break; case "mouseover": case "mouseout": Kn = null; break; case "pointerover": case "pointerout": js.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": Ns.delete(e.pointerId) } } function Gi(t, e, n, r, i, s) { return t === null || t.nativeEvent !== s ? (t = { blockedOn: e, domEventName: n, eventSystemFlags: r, nativeEvent: s, targetContainers: [i] }, e !== null && (e = fo(e), e !== null && th(e)), t) : (t.eventSystemFlags |= r, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t) } function iS(t, e, n, r, i) { switch (e) { case "focusin": return Wn = Gi(Wn, t, e, n, r, i), !0; case "dragenter": return qn = Gi(qn, t, e, n, r, i), !0; case "mouseover": return Kn = Gi(Kn, t, e, n, r, i), !0; case "pointerover": var s = i.pointerId; return js.set(s, Gi(js.get(s) || null, t, e, n, r, i)), !0; case "gotpointercapture": return s = i.pointerId, Ns.set(s, Gi(Ns.get(s) || null, t, e, n, r, i)), !0 }return !1 } function ny(t) { var e = xr(t.target); if (e !== null) { var n = $r(e); if (n !== null) { if (e = n.tag, e === 13) { if (e = Hv(n), e !== null) { t.blockedOn = e, ty(t.priority, function () { Zv(n) }); return } } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) { t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } t.blockedOn = null } function ga(t) { if (t.blockedOn !== null) return !1; for (var e = t.targetContainers; 0 < e.length;) { var n = zc(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent); if (n === null) { n = t.nativeEvent; var r = new n.constructor(n.type, n); Dc = r, n.target.dispatchEvent(r), Dc = null } else return e = fo(n), e !== null && th(e), t.blockedOn = n, !1; e.shift() } return !0 } function Kf(t, e, n) { ga(t) && n.delete(e) } function sS() { $c = !1, Wn !== null && ga(Wn) && (Wn = null), qn !== null && ga(qn) && (qn = null), Kn !== null && ga(Kn) && (Kn = null), js.forEach(Kf), Ns.forEach(Kf) } function Yi(t, e) { t.blockedOn === e && (t.blockedOn = null, $c || ($c = !0, xt.unstable_scheduleCallback(xt.unstable_NormalPriority, sS))) } function Fs(t) { function e(i) { return Yi(i, t) } if (0 < Ro.length) { Yi(Ro[0], t); for (var n = 1; n < Ro.length; n++) { var r = Ro[n]; r.blockedOn === t && (r.blockedOn = null) } } for (Wn !== null && Yi(Wn, t), qn !== null && Yi(qn, t), Kn !== null && Yi(Kn, t), js.forEach(e), Ns.forEach(e), n = 0; n < An.length; n++)r = An[n], r.blockedOn === t && (r.blockedOn = null); for (; 0 < An.length && (n = An[0], n.blockedOn === null);)ny(n), n.blockedOn === null && An.shift() } var mi = Pn.ReactCurrentBatchConfig, $a = !0; function oS(t, e, n, r) { var i = de, s = mi.transition; mi.transition = null; try { de = 1, nh(t, e, n, r) } finally { de = i, mi.transition = s } } function aS(t, e, n, r) { var i = de, s = mi.transition; mi.transition = null; try { de = 4, nh(t, e, n, r) } finally { de = i, mi.transition = s } } function nh(t, e, n, r) { if ($a) { var i = zc(t, e, n, r); if (i === null) ju(t, e, r, za, n), qf(t, r); else if (iS(i, t, e, n, r)) r.stopPropagation(); else if (qf(t, r), e & 4 && -1 < rS.indexOf(t)) { for (; i !== null;) { var s = fo(i); if (s !== null && Jv(s), s = zc(t, e, n, r), s === null && ju(t, e, r, za, n), s === i) break; i = s } i !== null && r.stopPropagation() } else ju(t, e, r, null, n) } } var za = null; function zc(t, e, n, r) { if (za = null, t = Jd(r), t = xr(t), t !== null) if (e = $r(t), e === null) t = null; else if (n = e.tag, n === 13) { if (t = Hv(e), t !== null) return t; t = null } else if (n === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; t = null } else e !== t && (t = null); return za = t, null } function ry(t) { switch (t) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Gw()) { case Zd: return 1; case Gv: return 4; case Na: case Yw: return 16; case Yv: return 536870912; default: return 16 }default: return 16 } } var Fn = null, rh = null, ma = null; function iy() { if (ma) return ma; var t, e = rh, n = e.length, r, i = "value" in Fn ? Fn.value : Fn.textContent, s = i.length; for (t = 0; t < n && e[t] === i[t]; t++); var o = n - t; for (r = 1; r <= o && e[n - r] === i[s - r]; r++); return ma = i.slice(t, 1 < r ? 1 - r : void 0) } function va(t) { var e = t.keyCode; return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0 } function Mo() { return !0 } function Gf() { return !1 } function Ct(t) { function e(n, r, i, s, o) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = s, this.target = o, this.currentTarget = null; for (var a in t) t.hasOwnProperty(a) && (n = t[a], this[a] = n ? n(s) : s[a]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Mo : Gf, this.isPropagationStopped = Gf, this } return xe(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Mo) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Mo) }, persist: function () { }, isPersistent: Mo }), e } var ji = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (t) { return t.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, ih = Ct(ji), ho = xe({}, ji, { view: 0, detail: 0 }), lS = Ct(ho), Pu, Eu, Qi, El = xe({}, ho, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: sh, button: 0, buttons: 0, relatedTarget: function (t) { return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget }, movementX: function (t) { return "movementX" in t ? t.movementX : (t !== Qi && (Qi && t.type === "mousemove" ? (Pu = t.screenX - Qi.screenX, Eu = t.screenY - Qi.screenY) : Eu = Pu = 0, Qi = t), Pu) }, movementY: function (t) { return "movementY" in t ? t.movementY : Eu } }), Yf = Ct(El), uS = xe({}, El, { dataTransfer: 0 }), cS = Ct(uS), dS = xe({}, ho, { relatedTarget: 0 }), Tu = Ct(dS), hS = xe({}, ji, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), fS = Ct(hS), pS = xe({}, ji, { clipboardData: function (t) { return "clipboardData" in t ? t.clipboardData : window.clipboardData } }), gS = Ct(pS), mS = xe({}, ji, { data: 0 }), Qf = Ct(mS), vS = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, yS = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, bS = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function _S(t) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(t) : (t = bS[t]) ? !!e[t] : !1 } function sh() { return _S } var wS = xe({}, ho, { key: function (t) { if (t.key) { var e = vS[t.key] || t.key; if (e !== "Unidentified") return e } return t.type === "keypress" ? (t = va(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? yS[t.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: sh, charCode: function (t) { return t.type === "keypress" ? va(t) : 0 }, keyCode: function (t) { return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 }, which: function (t) { return t.type === "keypress" ? va(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 } }), SS = Ct(wS), xS = xe({}, El, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Xf = Ct(xS), kS = xe({}, ho, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: sh }), CS = Ct(kS), OS = xe({}, ji, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), PS = Ct(OS), ES = xe({}, El, { deltaX: function (t) { return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0 }, deltaY: function (t) { return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), TS = Ct(ES), IS = [9, 13, 27, 32], oh = Sn && "CompositionEvent" in window, _s = null; Sn && "documentMode" in document && (_s = document.documentMode); var RS = Sn && "TextEvent" in window && !_s, sy = Sn && (!oh || _s && 8 < _s && 11 >= _s), Jf = " ", Zf = !1; function oy(t, e) { switch (t) { case "keyup": return IS.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function ay(t) { return t = t.detail, typeof t == "object" && "data" in t ? t.data : null } var ti = !1; function MS(t, e) { switch (t) { case "compositionend": return ay(e); case "keypress": return e.which !== 32 ? null : (Zf = !0, Jf); case "textInput": return t = e.data, t === Jf && Zf ? null : t; default: return null } } function LS(t, e) { if (ti) return t === "compositionend" || !oh && oy(t, e) ? (t = iy(), ma = rh = Fn = null, ti = !1, t) : null; switch (t) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return sy && e.locale !== "ko" ? null : e.data; default: return null } } var DS = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function ep(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e === "input" ? !!DS[t.type] : e === "textarea" } function ly(t, e, n, r) { $v(r), e = Va(e, "onChange"), 0 < e.length && (n = new ih("onChange", "change", null, n, r), t.push({ event: n, listeners: e })) } var ws = null, $s = null; function AS(t) { by(t, 0) } function Tl(t) { var e = ii(t); if (Mv(e)) return t } function jS(t, e) { if (t === "change") return e } var uy = !1; if (Sn) { var Iu; if (Sn) { var Ru = "oninput" in document; if (!Ru) { var tp = document.createElement("div"); tp.setAttribute("oninput", "return;"), Ru = typeof tp.oninput == "function" } Iu = Ru } else Iu = !1; uy = Iu && (!document.documentMode || 9 < document.documentMode) } function np() { ws && (ws.detachEvent("onpropertychange", cy), $s = ws = null) } function cy(t) { if (t.propertyName === "value" && Tl($s)) { var e = []; ly(e, $s, t, Jd(t)), Uv(AS, e) } } function NS(t, e, n) { t === "focusin" ? (np(), ws = e, $s = n, ws.attachEvent("onpropertychange", cy)) : t === "focusout" && np() } function FS(t) { if (t === "selectionchange" || t === "keyup" || t === "keydown") return Tl($s) } function $S(t, e) { if (t === "click") return Tl(e) } function zS(t, e) { if (t === "input" || t === "change") return Tl(e) } function VS(t, e) { return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e } var Gt = typeof Object.is == "function" ? Object.is : VS; function zs(t, e) { if (Gt(t, e)) return !0; if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1; var n = Object.keys(t), r = Object.keys(e); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!Sc.call(e, i) || !Gt(t[i], e[i])) return !1 } return !0 } function rp(t) { for (; t && t.firstChild;)t = t.firstChild; return t } function ip(t, e) { var n = rp(t); t = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = t + n.textContent.length, t <= e && r >= e) return { node: n, offset: e - t }; t = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = rp(n) } } function dy(t, e) { return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? dy(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1 } function hy() { for (var t = window, e = Da(); e instanceof t.HTMLIFrameElement;) { try { var n = typeof e.contentWindow.location.href == "string" } catch { n = !1 } if (n) t = e.contentWindow; else break; e = Da(t.document) } return e } function ah(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true") } function BS(t) { var e = hy(), n = t.focusedElem, r = t.selectionRange; if (e !== n && n && n.ownerDocument && dy(n.ownerDocument.documentElement, n)) { if (r !== null && ah(n)) { if (e = r.start, t = r.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length); else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) { t = t.getSelection(); var i = n.textContent.length, s = Math.min(r.start, i); r = r.end === void 0 ? s : Math.min(r.end, i), !t.extend && s > r && (i = r, r = s, s = i), i = ip(n, s); var o = ip(n, r); i && o && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), t.removeAllRanges(), s > r ? (t.addRange(e), t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), t.addRange(e))) } } for (e = [], t = n; t = t.parentNode;)t.nodeType === 1 && e.push({ element: t, left: t.scrollLeft, top: t.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top } } var US = Sn && "documentMode" in document && 11 >= document.documentMode, ni = null, Vc = null, Ss = null, Bc = !1; function sp(t, e, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Bc || ni == null || ni !== Da(r) || (r = ni, "selectionStart" in r && ah(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), Ss && zs(Ss, r) || (Ss = r, r = Va(Vc, "onSelect"), 0 < r.length && (e = new ih("onSelect", "select", null, e, n), t.push({ event: e, listeners: r }), e.target = ni))) } function Lo(t, e) { var n = {}; return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n } var ri = { animationend: Lo("Animation", "AnimationEnd"), animationiteration: Lo("Animation", "AnimationIteration"), animationstart: Lo("Animation", "AnimationStart"), transitionend: Lo("Transition", "TransitionEnd") }, Mu = {}, fy = {}; Sn && (fy = document.createElement("div").style, "AnimationEvent" in window || (delete ri.animationend.animation, delete ri.animationiteration.animation, delete ri.animationstart.animation), "TransitionEvent" in window || delete ri.transitionend.transition); function Il(t) { if (Mu[t]) return Mu[t]; if (!ri[t]) return t; var e = ri[t], n; for (n in e) if (e.hasOwnProperty(n) && n in fy) return Mu[t] = e[n]; return t } var py = Il("animationend"), gy = Il("animationiteration"), my = Il("animationstart"), vy = Il("transitionend"), yy = new Map, op = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function sr(t, e) { yy.set(t, e), Fr(e, [t]) } for (var Lu = 0; Lu < op.length; Lu++) { var Du = op[Lu], HS = Du.toLowerCase(), WS = Du[0].toUpperCase() + Du.slice(1); sr(HS, "on" + WS) } sr(py, "onAnimationEnd"); sr(gy, "onAnimationIteration"); sr(my, "onAnimationStart"); sr("dblclick", "onDoubleClick"); sr("focusin", "onFocus"); sr("focusout", "onBlur"); sr(vy, "onTransitionEnd"); Si("onMouseEnter", ["mouseout", "mouseover"]); Si("onMouseLeave", ["mouseout", "mouseover"]); Si("onPointerEnter", ["pointerout", "pointerover"]); Si("onPointerLeave", ["pointerout", "pointerover"]); Fr("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Fr("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Fr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Fr("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Fr("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Fr("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var hs = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), qS = new Set("cancel close invalid load scroll toggle".split(" ").concat(hs)); function ap(t, e, n) { var r = t.type || "unknown-event"; t.currentTarget = n, Hw(r, e, void 0, t), t.currentTarget = null } function by(t, e) { e = (e & 4) !== 0; for (var n = 0; n < t.length; n++) { var r = t[n], i = r.event; r = r.listeners; e: { var s = void 0; if (e) for (var o = r.length - 1; 0 <= o; o--) { var a = r[o], l = a.instance, u = a.currentTarget; if (a = a.listener, l !== s && i.isPropagationStopped()) break e; ap(i, a, u), s = l } else for (o = 0; o < r.length; o++) { if (a = r[o], l = a.instance, u = a.currentTarget, a = a.listener, l !== s && i.isPropagationStopped()) break e; ap(i, a, u), s = l } } } if (ja) throw t = Nc, ja = !1, Nc = null, t } function ve(t, e) { var n = e[Kc]; n === void 0 && (n = e[Kc] = new Set); var r = t + "__bubble"; n.has(r) || (_y(e, t, 2, !1), n.add(r)) } function Au(t, e, n) { var r = 0; e && (r |= 4), _y(n, t, r, e) } var Do = "_reactListening" + Math.random().toString(36).slice(2); function Vs(t) { if (!t[Do]) { t[Do] = !0, Pv.forEach(function (n) { n !== "selectionchange" && (qS.has(n) || Au(n, !1, t), Au(n, !0, t)) }); var e = t.nodeType === 9 ? t : t.ownerDocument; e === null || e[Do] || (e[Do] = !0, Au("selectionchange", !1, e)) } } function _y(t, e, n, r) { switch (ry(e)) { case 1: var i = oS; break; case 4: i = aS; break; default: i = nh }n = i.bind(null, e, n, t), i = void 0, !jc || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0), r ? i !== void 0 ? t.addEventListener(e, n, { capture: !0, passive: i }) : t.addEventListener(e, n, !0) : i !== void 0 ? t.addEventListener(e, n, { passive: i }) : t.addEventListener(e, n, !1) } function ju(t, e, n, r, i) { var s = r; if (!(e & 1) && !(e & 2) && r !== null) e: for (; ;) { if (r === null) return; var o = r.tag; if (o === 3 || o === 4) { var a = r.stateNode.containerInfo; if (a === i || a.nodeType === 8 && a.parentNode === i) break; if (o === 4) for (o = r.return; o !== null;) { var l = o.tag; if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return; o = o.return } for (; a !== null;) { if (o = xr(a), o === null) return; if (l = o.tag, l === 5 || l === 6) { r = s = o; continue e } a = a.parentNode } } r = r.return } Uv(function () { var u = s, c = Jd(n), d = []; e: { var h = yy.get(t); if (h !== void 0) { var f = ih, g = t; switch (t) { case "keypress": if (va(n) === 0) break e; case "keydown": case "keyup": f = SS; break; case "focusin": g = "focus", f = Tu; break; case "focusout": g = "blur", f = Tu; break; case "beforeblur": case "afterblur": f = Tu; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": f = Yf; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": f = cS; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": f = CS; break; case py: case gy: case my: f = fS; break; case vy: f = PS; break; case "scroll": f = lS; break; case "wheel": f = TS; break; case "copy": case "cut": case "paste": f = gS; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": f = Xf }var m = (e & 4) !== 0, y = !m && t === "scroll", p = m ? h !== null ? h + "Capture" : null : h; m = []; for (var v = u, b; v !== null;) { b = v; var S = b.stateNode; if (b.tag === 5 && S !== null && (b = S, p !== null && (S = As(v, p), S != null && m.push(Bs(v, S, b)))), y) break; v = v.return } 0 < m.length && (h = new f(h, g, null, n, c), d.push({ event: h, listeners: m })) } } if (!(e & 7)) { e: { if (h = t === "mouseover" || t === "pointerover", f = t === "mouseout" || t === "pointerout", h && n !== Dc && (g = n.relatedTarget || n.fromElement) && (xr(g) || g[xn])) break e; if ((f || h) && (h = c.window === c ? c : (h = c.ownerDocument) ? h.defaultView || h.parentWindow : window, f ? (g = n.relatedTarget || n.toElement, f = u, g = g ? xr(g) : null, g !== null && (y = $r(g), g !== y || g.tag !== 5 && g.tag !== 6) && (g = null)) : (f = null, g = u), f !== g)) { if (m = Yf, S = "onMouseLeave", p = "onMouseEnter", v = "mouse", (t === "pointerout" || t === "pointerover") && (m = Xf, S = "onPointerLeave", p = "onPointerEnter", v = "pointer"), y = f == null ? h : ii(f), b = g == null ? h : ii(g), h = new m(S, v + "leave", f, n, c), h.target = y, h.relatedTarget = b, S = null, xr(c) === u && (m = new m(p, v + "enter", g, n, c), m.target = b, m.relatedTarget = y, S = m), y = S, f && g) t: { for (m = f, p = g, v = 0, b = m; b; b = qr(b))v++; for (b = 0, S = p; S; S = qr(S))b++; for (; 0 < v - b;)m = qr(m), v--; for (; 0 < b - v;)p = qr(p), b--; for (; v--;) { if (m === p || p !== null && m === p.alternate) break t; m = qr(m), p = qr(p) } m = null } else m = null; f !== null && lp(d, h, f, m, !1), g !== null && y !== null && lp(d, y, g, m, !0) } } e: { if (h = u ? ii(u) : window, f = h.nodeName && h.nodeName.toLowerCase(), f === "select" || f === "input" && h.type === "file") var P = jS; else if (ep(h)) if (uy) P = zS; else { P = FS; var I = NS } else (f = h.nodeName) && f.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (P = $S); if (P && (P = P(t, u))) { ly(d, P, n, c); break e } I && I(t, h, u), t === "focusout" && (I = h._wrapperState) && I.controlled && h.type === "number" && Tc(h, "number", h.value) } switch (I = u ? ii(u) : window, t) { case "focusin": (ep(I) || I.contentEditable === "true") && (ni = I, Vc = u, Ss = null); break; case "focusout": Ss = Vc = ni = null; break; case "mousedown": Bc = !0; break; case "contextmenu": case "mouseup": case "dragend": Bc = !1, sp(d, n, c); break; case "selectionchange": if (US) break; case "keydown": case "keyup": sp(d, n, c) }var T; if (oh) e: { switch (t) { case "compositionstart": var k = "onCompositionStart"; break e; case "compositionend": k = "onCompositionEnd"; break e; case "compositionupdate": k = "onCompositionUpdate"; break e }k = void 0 } else ti ? oy(t, n) && (k = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (k = "onCompositionStart"); k && (sy && n.locale !== "ko" && (ti || k !== "onCompositionStart" ? k === "onCompositionEnd" && ti && (T = iy()) : (Fn = c, rh = "value" in Fn ? Fn.value : Fn.textContent, ti = !0)), I = Va(u, k), 0 < I.length && (k = new Qf(k, t, null, n, c), d.push({ event: k, listeners: I }), T ? k.data = T : (T = ay(n), T !== null && (k.data = T)))), (T = RS ? MS(t, n) : LS(t, n)) && (u = Va(u, "onBeforeInput"), 0 < u.length && (c = new Qf("onBeforeInput", "beforeinput", null, n, c), d.push({ event: c, listeners: u }), c.data = T)) } by(d, e) }) } function Bs(t, e, n) { return { instance: t, listener: e, currentTarget: n } } function Va(t, e) { for (var n = e + "Capture", r = []; t !== null;) { var i = t, s = i.stateNode; i.tag === 5 && s !== null && (i = s, s = As(t, n), s != null && r.unshift(Bs(t, s, i)), s = As(t, e), s != null && r.push(Bs(t, s, i))), t = t.return } return r } function qr(t) { if (t === null) return null; do t = t.return; while (t && t.tag !== 5); return t || null } function lp(t, e, n, r, i) { for (var s = e._reactName, o = []; n !== null && n !== r;) { var a = n, l = a.alternate, u = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && u !== null && (a = u, i ? (l = As(n, s), l != null && o.unshift(Bs(n, l, a))) : i || (l = As(n, s), l != null && o.push(Bs(n, l, a)))), n = n.return } o.length !== 0 && t.push({ event: e, listeners: o }) } var KS = /\r\n?/g, GS = /\u0000|\uFFFD/g; function up(t) {
  return (typeof t == "string" ? t : "" + t).replace(KS, `
`).replace(GS, "")
} function Ao(t, e, n) { if (e = up(e), up(t) !== e && n) throw Error(U(425)) } function Ba() { } var Uc = null, Hc = null; function Wc(t, e) { return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var qc = typeof setTimeout == "function" ? setTimeout : void 0, YS = typeof clearTimeout == "function" ? clearTimeout : void 0, cp = typeof Promise == "function" ? Promise : void 0, QS = typeof queueMicrotask == "function" ? queueMicrotask : typeof cp < "u" ? function (t) { return cp.resolve(null).then(t).catch(XS) } : qc; function XS(t) { setTimeout(function () { throw t }) } function Nu(t, e) { var n = e, r = 0; do { var i = n.nextSibling; if (t.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { t.removeChild(i), Fs(e); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); Fs(e) } function Gn(t) { for (; t != null; t = t.nextSibling) { var e = t.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = t.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return t } function dp(t) { t = t.previousSibling; for (var e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "$" || n === "$!" || n === "$?") { if (e === 0) return t; e-- } else n === "/$" && e++ } t = t.previousSibling } return null } var Ni = Math.random().toString(36).slice(2), rn = "__reactFiber$" + Ni, Us = "__reactProps$" + Ni, xn = "__reactContainer$" + Ni, Kc = "__reactEvents$" + Ni, JS = "__reactListeners$" + Ni, ZS = "__reactHandles$" + Ni; function xr(t) { var e = t[rn]; if (e) return e; for (var n = t.parentNode; n;) { if (e = n[xn] || n[rn]) { if (n = e.alternate, e.child !== null || n !== null && n.child !== null) for (t = dp(t); t !== null;) { if (n = t[rn]) return n; t = dp(t) } return e } t = n, n = t.parentNode } return null } function fo(t) { return t = t[rn] || t[xn], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t } function ii(t) { if (t.tag === 5 || t.tag === 6) return t.stateNode; throw Error(U(33)) } function Rl(t) { return t[Us] || null } var Gc = [], si = -1; function or(t) { return { current: t } } function ye(t) { 0 > si || (t.current = Gc[si], Gc[si] = null, si--) } function me(t, e) { si++, Gc[si] = t.current, t.current = e } var rr = {}, Ze = or(rr), dt = or(!1), Ir = rr; function xi(t, e) { var n = t.type.contextTypes; if (!n) return rr; var r = t.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext; var i = {}, s; for (s in n) i[s] = e[s]; return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i } function ht(t) { return t = t.childContextTypes, t != null } function Ua() { ye(dt), ye(Ze) } function hp(t, e, n) { if (Ze.current !== rr) throw Error(U(168)); me(Ze, e), me(dt, n) } function wy(t, e, n) { var r = t.stateNode; if (e = e.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in e)) throw Error(U(108, Nw(t) || "Unknown", i)); return xe({}, n, r) } function Ha(t) { return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || rr, Ir = Ze.current, me(Ze, t), me(dt, dt.current), !0 } function fp(t, e, n) { var r = t.stateNode; if (!r) throw Error(U(169)); n ? (t = wy(t, e, Ir), r.__reactInternalMemoizedMergedChildContext = t, ye(dt), ye(Ze), me(Ze, t)) : ye(dt), me(dt, n) } var mn = null, Ml = !1, Fu = !1; function Sy(t) { mn === null ? mn = [t] : mn.push(t) } function ex(t) { Ml = !0, Sy(t) } function ar() { if (!Fu && mn !== null) { Fu = !0; var t = 0, e = de; try { var n = mn; for (de = 1; t < n.length; t++) { var r = n[t]; do r = r(!0); while (r !== null) } mn = null, Ml = !1 } catch (i) { throw mn !== null && (mn = mn.slice(t + 1)), Kv(Zd, ar), i } finally { de = e, Fu = !1 } } return null } var oi = [], ai = 0, Wa = null, qa = 0, Tt = [], It = 0, Rr = null, yn = 1, bn = ""; function yr(t, e) { oi[ai++] = qa, oi[ai++] = Wa, Wa = t, qa = e } function xy(t, e, n) { Tt[It++] = yn, Tt[It++] = bn, Tt[It++] = Rr, Rr = t; var r = yn; t = bn; var i = 32 - qt(r) - 1; r &= ~(1 << i), n += 1; var s = 32 - qt(e) + i; if (30 < s) { var o = i - i % 5; s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, yn = 1 << 32 - qt(e) + i | n << i | r, bn = s + t } else yn = 1 << s | n << i | r, bn = t } function lh(t) { t.return !== null && (yr(t, 1), xy(t, 1, 0)) } function uh(t) { for (; t === Wa;)Wa = oi[--ai], oi[ai] = null, qa = oi[--ai], oi[ai] = null; for (; t === Rr;)Rr = Tt[--It], Tt[It] = null, bn = Tt[--It], Tt[It] = null, yn = Tt[--It], Tt[It] = null } var wt = null, yt = null, be = !1, Ht = null; function ky(t, e) { var n = Mt(5, null, null, 0); n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n) } function pp(t, e) { switch (t.tag) { case 5: var n = t.type; return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, wt = t, yt = Gn(e.firstChild), !0) : !1; case 6: return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, wt = t, yt = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (n = Rr !== null ? { id: yn, overflow: bn } : null, t.memoizedState = { dehydrated: e, treeContext: n, retryLane: 1073741824 }, n = Mt(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, wt = t, yt = null, !0) : !1; default: return !1 } } function Yc(t) { return (t.mode & 1) !== 0 && (t.flags & 128) === 0 } function Qc(t) { if (be) { var e = yt; if (e) { var n = e; if (!pp(t, e)) { if (Yc(t)) throw Error(U(418)); e = Gn(n.nextSibling); var r = wt; e && pp(t, e) ? ky(r, n) : (t.flags = t.flags & -4097 | 2, be = !1, wt = t) } } else { if (Yc(t)) throw Error(U(418)); t.flags = t.flags & -4097 | 2, be = !1, wt = t } } } function gp(t) { for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;)t = t.return; wt = t } function jo(t) { if (t !== wt) return !1; if (!be) return gp(t), be = !0, !1; var e; if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !Wc(t.type, t.memoizedProps)), e && (e = yt)) { if (Yc(t)) throw Cy(), Error(U(418)); for (; e;)ky(t, e), e = Gn(e.nextSibling) } if (gp(t), t.tag === 13) { if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(U(317)); e: { for (t = t.nextSibling, e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "/$") { if (e === 0) { yt = Gn(t.nextSibling); break e } e-- } else n !== "$" && n !== "$!" && n !== "$?" || e++ } t = t.nextSibling } yt = null } } else yt = wt ? Gn(t.stateNode.nextSibling) : null; return !0 } function Cy() { for (var t = yt; t;)t = Gn(t.nextSibling) } function ki() { yt = wt = null, be = !1 } function ch(t) { Ht === null ? Ht = [t] : Ht.push(t) } var tx = Pn.ReactCurrentBatchConfig; function Xi(t, e, n) { if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(U(309)); var r = n.stateNode } if (!r) throw Error(U(147, t)); var i = r, s = "" + t; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function (o) { var a = i.refs; o === null ? delete a[s] : a[s] = o }, e._stringRef = s, e) } if (typeof t != "string") throw Error(U(284)); if (!n._owner) throw Error(U(290, t)) } return t } function No(t, e) { throw t = Object.prototype.toString.call(e), Error(U(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t)) } function mp(t) { var e = t._init; return e(t._payload) } function Oy(t) { function e(p, v) { if (t) { var b = p.deletions; b === null ? (p.deletions = [v], p.flags |= 16) : b.push(v) } } function n(p, v) { if (!t) return null; for (; v !== null;)e(p, v), v = v.sibling; return null } function r(p, v) { for (p = new Map; v !== null;)v.key !== null ? p.set(v.key, v) : p.set(v.index, v), v = v.sibling; return p } function i(p, v) { return p = Jn(p, v), p.index = 0, p.sibling = null, p } function s(p, v, b) { return p.index = b, t ? (b = p.alternate, b !== null ? (b = b.index, b < v ? (p.flags |= 2, v) : b) : (p.flags |= 2, v)) : (p.flags |= 1048576, v) } function o(p) { return t && p.alternate === null && (p.flags |= 2), p } function a(p, v, b, S) { return v === null || v.tag !== 6 ? (v = Wu(b, p.mode, S), v.return = p, v) : (v = i(v, b), v.return = p, v) } function l(p, v, b, S) { var P = b.type; return P === ei ? c(p, v, b.props.children, S, b.key) : v !== null && (v.elementType === P || typeof P == "object" && P !== null && P.$$typeof === Mn && mp(P) === v.type) ? (S = i(v, b.props), S.ref = Xi(p, v, b), S.return = p, S) : (S = ka(b.type, b.key, b.props, null, p.mode, S), S.ref = Xi(p, v, b), S.return = p, S) } function u(p, v, b, S) { return v === null || v.tag !== 4 || v.stateNode.containerInfo !== b.containerInfo || v.stateNode.implementation !== b.implementation ? (v = qu(b, p.mode, S), v.return = p, v) : (v = i(v, b.children || []), v.return = p, v) } function c(p, v, b, S, P) { return v === null || v.tag !== 7 ? (v = Pr(b, p.mode, S, P), v.return = p, v) : (v = i(v, b), v.return = p, v) } function d(p, v, b) { if (typeof v == "string" && v !== "" || typeof v == "number") return v = Wu("" + v, p.mode, b), v.return = p, v; if (typeof v == "object" && v !== null) { switch (v.$$typeof) { case Oo: return b = ka(v.type, v.key, v.props, null, p.mode, b), b.ref = Xi(p, null, v), b.return = p, b; case Zr: return v = qu(v, p.mode, b), v.return = p, v; case Mn: var S = v._init; return d(p, S(v._payload), b) }if (cs(v) || qi(v)) return v = Pr(v, p.mode, b, null), v.return = p, v; No(p, v) } return null } function h(p, v, b, S) { var P = v !== null ? v.key : null; if (typeof b == "string" && b !== "" || typeof b == "number") return P !== null ? null : a(p, v, "" + b, S); if (typeof b == "object" && b !== null) { switch (b.$$typeof) { case Oo: return b.key === P ? l(p, v, b, S) : null; case Zr: return b.key === P ? u(p, v, b, S) : null; case Mn: return P = b._init, h(p, v, P(b._payload), S) }if (cs(b) || qi(b)) return P !== null ? null : c(p, v, b, S, null); No(p, b) } return null } function f(p, v, b, S, P) { if (typeof S == "string" && S !== "" || typeof S == "number") return p = p.get(b) || null, a(v, p, "" + S, P); if (typeof S == "object" && S !== null) { switch (S.$$typeof) { case Oo: return p = p.get(S.key === null ? b : S.key) || null, l(v, p, S, P); case Zr: return p = p.get(S.key === null ? b : S.key) || null, u(v, p, S, P); case Mn: var I = S._init; return f(p, v, b, I(S._payload), P) }if (cs(S) || qi(S)) return p = p.get(b) || null, c(v, p, S, P, null); No(v, S) } return null } function g(p, v, b, S) { for (var P = null, I = null, T = v, k = v = 0, E = null; T !== null && k < b.length; k++) { T.index > k ? (E = T, T = null) : E = T.sibling; var M = h(p, T, b[k], S); if (M === null) { T === null && (T = E); break } t && T && M.alternate === null && e(p, T), v = s(M, v, k), I === null ? P = M : I.sibling = M, I = M, T = E } if (k === b.length) return n(p, T), be && yr(p, k), P; if (T === null) { for (; k < b.length; k++)T = d(p, b[k], S), T !== null && (v = s(T, v, k), I === null ? P = T : I.sibling = T, I = T); return be && yr(p, k), P } for (T = r(p, T); k < b.length; k++)E = f(T, p, k, b[k], S), E !== null && (t && E.alternate !== null && T.delete(E.key === null ? k : E.key), v = s(E, v, k), I === null ? P = E : I.sibling = E, I = E); return t && T.forEach(function (L) { return e(p, L) }), be && yr(p, k), P } function m(p, v, b, S) { var P = qi(b); if (typeof P != "function") throw Error(U(150)); if (b = P.call(b), b == null) throw Error(U(151)); for (var I = P = null, T = v, k = v = 0, E = null, M = b.next(); T !== null && !M.done; k++, M = b.next()) { T.index > k ? (E = T, T = null) : E = T.sibling; var L = h(p, T, M.value, S); if (L === null) { T === null && (T = E); break } t && T && L.alternate === null && e(p, T), v = s(L, v, k), I === null ? P = L : I.sibling = L, I = L, T = E } if (M.done) return n(p, T), be && yr(p, k), P; if (T === null) { for (; !M.done; k++, M = b.next())M = d(p, M.value, S), M !== null && (v = s(M, v, k), I === null ? P = M : I.sibling = M, I = M); return be && yr(p, k), P } for (T = r(p, T); !M.done; k++, M = b.next())M = f(T, p, k, M.value, S), M !== null && (t && M.alternate !== null && T.delete(M.key === null ? k : M.key), v = s(M, v, k), I === null ? P = M : I.sibling = M, I = M); return t && T.forEach(function (N) { return e(p, N) }), be && yr(p, k), P } function y(p, v, b, S) { if (typeof b == "object" && b !== null && b.type === ei && b.key === null && (b = b.props.children), typeof b == "object" && b !== null) { switch (b.$$typeof) { case Oo: e: { for (var P = b.key, I = v; I !== null;) { if (I.key === P) { if (P = b.type, P === ei) { if (I.tag === 7) { n(p, I.sibling), v = i(I, b.props.children), v.return = p, p = v; break e } } else if (I.elementType === P || typeof P == "object" && P !== null && P.$$typeof === Mn && mp(P) === I.type) { n(p, I.sibling), v = i(I, b.props), v.ref = Xi(p, I, b), v.return = p, p = v; break e } n(p, I); break } else e(p, I); I = I.sibling } b.type === ei ? (v = Pr(b.props.children, p.mode, S, b.key), v.return = p, p = v) : (S = ka(b.type, b.key, b.props, null, p.mode, S), S.ref = Xi(p, v, b), S.return = p, p = S) } return o(p); case Zr: e: { for (I = b.key; v !== null;) { if (v.key === I) if (v.tag === 4 && v.stateNode.containerInfo === b.containerInfo && v.stateNode.implementation === b.implementation) { n(p, v.sibling), v = i(v, b.children || []), v.return = p, p = v; break e } else { n(p, v); break } else e(p, v); v = v.sibling } v = qu(b, p.mode, S), v.return = p, p = v } return o(p); case Mn: return I = b._init, y(p, v, I(b._payload), S) }if (cs(b)) return g(p, v, b, S); if (qi(b)) return m(p, v, b, S); No(p, b) } return typeof b == "string" && b !== "" || typeof b == "number" ? (b = "" + b, v !== null && v.tag === 6 ? (n(p, v.sibling), v = i(v, b), v.return = p, p = v) : (n(p, v), v = Wu(b, p.mode, S), v.return = p, p = v), o(p)) : n(p, v) } return y } var Ci = Oy(!0), Py = Oy(!1), Ka = or(null), Ga = null, li = null, dh = null; function hh() { dh = li = Ga = null } function fh(t) { var e = Ka.current; ye(Ka), t._currentValue = e } function Xc(t, e, n) { for (; t !== null;) { var r = t.alternate; if ((t.childLanes & e) !== e ? (t.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), t === n) break; t = t.return } } function vi(t, e) { Ga = t, dh = li = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (ct = !0), t.firstContext = null) } function jt(t) { var e = t._currentValue; if (dh !== t) if (t = { context: t, memoizedValue: e, next: null }, li === null) { if (Ga === null) throw Error(U(308)); li = t, Ga.dependencies = { lanes: 0, firstContext: t } } else li = li.next = t; return e } var kr = null; function ph(t) { kr === null ? kr = [t] : kr.push(t) } function Ey(t, e, n, r) { var i = e.interleaved; return i === null ? (n.next = n, ph(e)) : (n.next = i.next, i.next = n), e.interleaved = n, kn(t, r) } function kn(t, e) { t.lanes |= e; var n = t.alternate; for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;)t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return; return n.tag === 3 ? n.stateNode : null } var Ln = !1; function gh(t) { t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Ty(t, e) { t = t.updateQueue, e.updateQueue === t && (e.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects }) } function _n(t, e) { return { eventTime: t, lane: e, tag: 0, payload: null, callback: null, next: null } } function Yn(t, e, n) { var r = t.updateQueue; if (r === null) return null; if (r = r.shared, re & 2) { var i = r.pending; return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, kn(t, n) } return i = r.interleaved, i === null ? (e.next = e, ph(r)) : (e.next = i.next, i.next = e), r.interleaved = e, kn(t, n) } function ya(t, e, n) { if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) { var r = e.lanes; r &= t.pendingLanes, n |= r, e.lanes = n, eh(t, n) } } function vp(t, e) { var n = t.updateQueue, r = t.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var i = null, s = null; if (n = n.firstBaseUpdate, n !== null) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; s === null ? i = s = o : s = s.next = o, n = n.next } while (n !== null); s === null ? i = s = e : s = s.next = e } else i = s = e; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: s, shared: r.shared, effects: r.effects }, t.updateQueue = n; return } t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e } function Ya(t, e, n, r) { var i = t.updateQueue; Ln = !1; var s = i.firstBaseUpdate, o = i.lastBaseUpdate, a = i.shared.pending; if (a !== null) { i.shared.pending = null; var l = a, u = l.next; l.next = null, o === null ? s = u : o.next = u, o = l; var c = t.alternate; c !== null && (c = c.updateQueue, a = c.lastBaseUpdate, a !== o && (a === null ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l)) } if (s !== null) { var d = i.baseState; o = 0, c = u = l = null, a = s; do { var h = a.lane, f = a.eventTime; if ((r & h) === h) { c !== null && (c = c.next = { eventTime: f, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var g = t, m = a; switch (h = e, f = n, m.tag) { case 1: if (g = m.payload, typeof g == "function") { d = g.call(f, d, h); break e } d = g; break e; case 3: g.flags = g.flags & -65537 | 128; case 0: if (g = m.payload, h = typeof g == "function" ? g.call(f, d, h) : g, h == null) break e; d = xe({}, d, h); break e; case 2: Ln = !0 } } a.callback !== null && a.lane !== 0 && (t.flags |= 64, h = i.effects, h === null ? i.effects = [a] : h.push(a)) } else f = { eventTime: f, lane: h, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, c === null ? (u = c = f, l = d) : c = c.next = f, o |= h; if (a = a.next, a === null) { if (a = i.shared.pending, a === null) break; h = a, a = h.next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null } } while (!0); if (c === null && (l = d), i.baseState = l, i.firstBaseUpdate = u, i.lastBaseUpdate = c, e = i.shared.interleaved, e !== null) { i = e; do o |= i.lane, i = i.next; while (i !== e) } else s === null && (i.shared.lanes = 0); Lr |= o, t.lanes = o, t.memoizedState = d } } function yp(t, e, n) { if (t = e.effects, e.effects = null, t !== null) for (e = 0; e < t.length; e++) { var r = t[e], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(U(191, i)); i.call(r) } } } var po = {}, on = or(po), Hs = or(po), Ws = or(po); function Cr(t) { if (t === po) throw Error(U(174)); return t } function mh(t, e) { switch (me(Ws, e), me(Hs, t), me(on, po), t = e.nodeType, t) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : Rc(null, ""); break; default: t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = Rc(e, t) }ye(on), me(on, e) } function Oi() { ye(on), ye(Hs), ye(Ws) } function Iy(t) { Cr(Ws.current); var e = Cr(on.current), n = Rc(e, t.type); e !== n && (me(Hs, t), me(on, n)) } function vh(t) { Hs.current === t && (ye(on), ye(Hs)) } var _e = or(0); function Qa(t) { for (var e = t; e !== null;) { if (e.tag === 13) { var n = e.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var $u = []; function yh() { for (var t = 0; t < $u.length; t++)$u[t]._workInProgressVersionPrimary = null; $u.length = 0 } var ba = Pn.ReactCurrentDispatcher, zu = Pn.ReactCurrentBatchConfig, Mr = 0, Se = null, Me = null, Ae = null, Xa = !1, xs = !1, qs = 0, nx = 0; function Ke() { throw Error(U(321)) } function bh(t, e) { if (e === null) return !1; for (var n = 0; n < e.length && n < t.length; n++)if (!Gt(t[n], e[n])) return !1; return !0 } function _h(t, e, n, r, i, s) { if (Mr = s, Se = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, ba.current = t === null || t.memoizedState === null ? ox : ax, t = n(r, i), xs) { s = 0; do { if (xs = !1, qs = 0, 25 <= s) throw Error(U(301)); s += 1, Ae = Me = null, e.updateQueue = null, ba.current = lx, t = n(r, i) } while (xs) } if (ba.current = Ja, e = Me !== null && Me.next !== null, Mr = 0, Ae = Me = Se = null, Xa = !1, e) throw Error(U(300)); return t } function wh() { var t = qs !== 0; return qs = 0, t } function Jt() { var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ae === null ? Se.memoizedState = Ae = t : Ae = Ae.next = t, Ae } function Nt() { if (Me === null) { var t = Se.alternate; t = t !== null ? t.memoizedState : null } else t = Me.next; var e = Ae === null ? Se.memoizedState : Ae.next; if (e !== null) Ae = e, Me = t; else { if (t === null) throw Error(U(310)); Me = t, t = { memoizedState: Me.memoizedState, baseState: Me.baseState, baseQueue: Me.baseQueue, queue: Me.queue, next: null }, Ae === null ? Se.memoizedState = Ae = t : Ae = Ae.next = t } return Ae } function Ks(t, e) { return typeof e == "function" ? e(t) : e } function Vu(t) { var e = Nt(), n = e.queue; if (n === null) throw Error(U(311)); n.lastRenderedReducer = t; var r = Me, i = r.baseQueue, s = n.pending; if (s !== null) { if (i !== null) { var o = i.next; i.next = s.next, s.next = o } r.baseQueue = i = s, n.pending = null } if (i !== null) { s = i.next, r = r.baseState; var a = o = null, l = null, u = s; do { var c = u.lane; if ((Mr & c) === c) l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : t(r, u.action); else { var d = { lane: c, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; l === null ? (a = l = d, o = r) : l = l.next = d, Se.lanes |= c, Lr |= c } u = u.next } while (u !== null && u !== s); l === null ? o = r : l.next = a, Gt(r, e.memoizedState) || (ct = !0), e.memoizedState = r, e.baseState = o, e.baseQueue = l, n.lastRenderedState = r } if (t = n.interleaved, t !== null) { i = t; do s = i.lane, Se.lanes |= s, Lr |= s, i = i.next; while (i !== t) } else i === null && (n.lanes = 0); return [e.memoizedState, n.dispatch] } function Bu(t) { var e = Nt(), n = e.queue; if (n === null) throw Error(U(311)); n.lastRenderedReducer = t; var r = n.dispatch, i = n.pending, s = e.memoizedState; if (i !== null) { n.pending = null; var o = i = i.next; do s = t(s, o.action), o = o.next; while (o !== i); Gt(s, e.memoizedState) || (ct = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), n.lastRenderedState = s } return [s, r] } function Ry() { } function My(t, e) { var n = Se, r = Nt(), i = e(), s = !Gt(r.memoizedState, i); if (s && (r.memoizedState = i, ct = !0), r = r.queue, Sh(Ay.bind(null, n, r, t), [t]), r.getSnapshot !== e || s || Ae !== null && Ae.memoizedState.tag & 1) { if (n.flags |= 2048, Gs(9, Dy.bind(null, n, r, i, e), void 0, null), Fe === null) throw Error(U(349)); Mr & 30 || Ly(n, e, i) } return i } function Ly(t, e, n) { t.flags |= 16384, t = { getSnapshot: e, value: n }, e = Se.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Se.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t)) } function Dy(t, e, n, r) { e.value = n, e.getSnapshot = r, jy(e) && Ny(t) } function Ay(t, e, n) { return n(function () { jy(e) && Ny(t) }) } function jy(t) { var e = t.getSnapshot; t = t.value; try { var n = e(); return !Gt(t, n) } catch { return !0 } } function Ny(t) { var e = kn(t, 1); e !== null && Kt(e, t, 1, -1) } function bp(t) { var e = Jt(); return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ks, lastRenderedState: t }, e.queue = t, t = t.dispatch = sx.bind(null, Se, t), [e.memoizedState, t] } function Gs(t, e, n, r) { return t = { tag: t, create: e, destroy: n, deps: r, next: null }, e = Se.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Se.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t)), t } function Fy() { return Nt().memoizedState } function _a(t, e, n, r) { var i = Jt(); Se.flags |= t, i.memoizedState = Gs(1 | e, n, void 0, r === void 0 ? null : r) } function Ll(t, e, n, r) { var i = Nt(); r = r === void 0 ? null : r; var s = void 0; if (Me !== null) { var o = Me.memoizedState; if (s = o.destroy, r !== null && bh(r, o.deps)) { i.memoizedState = Gs(e, n, s, r); return } } Se.flags |= t, i.memoizedState = Gs(1 | e, n, s, r) } function _p(t, e) { return _a(8390656, 8, t, e) } function Sh(t, e) { return Ll(2048, 8, t, e) } function $y(t, e) { return Ll(4, 2, t, e) } function zy(t, e) { return Ll(4, 4, t, e) } function Vy(t, e) { if (typeof e == "function") return t = t(), e(t), function () { e(null) }; if (e != null) return t = t(), e.current = t, function () { e.current = null } } function By(t, e, n) { return n = n != null ? n.concat([t]) : null, Ll(4, 4, Vy.bind(null, e, t), n) } function xh() { } function Uy(t, e) { var n = Nt(); e = e === void 0 ? null : e; var r = n.memoizedState; return r !== null && e !== null && bh(e, r[1]) ? r[0] : (n.memoizedState = [t, e], t) } function Hy(t, e) { var n = Nt(); e = e === void 0 ? null : e; var r = n.memoizedState; return r !== null && e !== null && bh(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [t, e], t) } function Wy(t, e, n) { return Mr & 21 ? (Gt(n, e) || (n = Qv(), Se.lanes |= n, Lr |= n, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, ct = !0), t.memoizedState = n) } function rx(t, e) { var n = de; de = n !== 0 && 4 > n ? n : 4, t(!0); var r = zu.transition; zu.transition = {}; try { t(!1), e() } finally { de = n, zu.transition = r } } function qy() { return Nt().memoizedState } function ix(t, e, n) { var r = Xn(t); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, Ky(t)) Gy(e, n); else if (n = Ey(t, e, n, r), n !== null) { var i = rt(); Kt(n, t, r, i), Yy(n, e, r) } } function sx(t, e, n) { var r = Xn(t), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Ky(t)) Gy(e, i); else { var s = t.alternate; if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try { var o = e.lastRenderedState, a = s(o, n); if (i.hasEagerState = !0, i.eagerState = a, Gt(a, o)) { var l = e.interleaved; l === null ? (i.next = i, ph(e)) : (i.next = l.next, l.next = i), e.interleaved = i; return } } catch { } finally { } n = Ey(t, e, i, r), n !== null && (i = rt(), Kt(n, t, r, i), Yy(n, e, r)) } } function Ky(t) { var e = t.alternate; return t === Se || e !== null && e === Se } function Gy(t, e) { xs = Xa = !0; var n = t.pending; n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e } function Yy(t, e, n) { if (n & 4194240) { var r = e.lanes; r &= t.pendingLanes, n |= r, e.lanes = n, eh(t, n) } } var Ja = { readContext: jt, useCallback: Ke, useContext: Ke, useEffect: Ke, useImperativeHandle: Ke, useInsertionEffect: Ke, useLayoutEffect: Ke, useMemo: Ke, useReducer: Ke, useRef: Ke, useState: Ke, useDebugValue: Ke, useDeferredValue: Ke, useTransition: Ke, useMutableSource: Ke, useSyncExternalStore: Ke, useId: Ke, unstable_isNewReconciler: !1 }, ox = { readContext: jt, useCallback: function (t, e) { return Jt().memoizedState = [t, e === void 0 ? null : e], t }, useContext: jt, useEffect: _p, useImperativeHandle: function (t, e, n) { return n = n != null ? n.concat([t]) : null, _a(4194308, 4, Vy.bind(null, e, t), n) }, useLayoutEffect: function (t, e) { return _a(4194308, 4, t, e) }, useInsertionEffect: function (t, e) { return _a(4, 2, t, e) }, useMemo: function (t, e) { var n = Jt(); return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t }, useReducer: function (t, e, n) { var r = Jt(); return e = n !== void 0 ? n(e) : e, r.memoizedState = r.baseState = e, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: e }, r.queue = t, t = t.dispatch = ix.bind(null, Se, t), [r.memoizedState, t] }, useRef: function (t) { var e = Jt(); return t = { current: t }, e.memoizedState = t }, useState: bp, useDebugValue: xh, useDeferredValue: function (t) { return Jt().memoizedState = t }, useTransition: function () { var t = bp(!1), e = t[0]; return t = rx.bind(null, t[1]), Jt().memoizedState = t, [e, t] }, useMutableSource: function () { }, useSyncExternalStore: function (t, e, n) { var r = Se, i = Jt(); if (be) { if (n === void 0) throw Error(U(407)); n = n() } else { if (n = e(), Fe === null) throw Error(U(349)); Mr & 30 || Ly(r, e, n) } i.memoizedState = n; var s = { value: n, getSnapshot: e }; return i.queue = s, _p(Ay.bind(null, r, s, t), [t]), r.flags |= 2048, Gs(9, Dy.bind(null, r, s, n, e), void 0, null), n }, useId: function () { var t = Jt(), e = Fe.identifierPrefix; if (be) { var n = bn, r = yn; n = (r & ~(1 << 32 - qt(r) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = qs++, 0 < n && (e += "H" + n.toString(32)), e += ":" } else n = nx++, e = ":" + e + "r" + n.toString(32) + ":"; return t.memoizedState = e }, unstable_isNewReconciler: !1 }, ax = { readContext: jt, useCallback: Uy, useContext: jt, useEffect: Sh, useImperativeHandle: By, useInsertionEffect: $y, useLayoutEffect: zy, useMemo: Hy, useReducer: Vu, useRef: Fy, useState: function () { return Vu(Ks) }, useDebugValue: xh, useDeferredValue: function (t) { var e = Nt(); return Wy(e, Me.memoizedState, t) }, useTransition: function () { var t = Vu(Ks)[0], e = Nt().memoizedState; return [t, e] }, useMutableSource: Ry, useSyncExternalStore: My, useId: qy, unstable_isNewReconciler: !1 }, lx = { readContext: jt, useCallback: Uy, useContext: jt, useEffect: Sh, useImperativeHandle: By, useInsertionEffect: $y, useLayoutEffect: zy, useMemo: Hy, useReducer: Bu, useRef: Fy, useState: function () { return Bu(Ks) }, useDebugValue: xh, useDeferredValue: function (t) { var e = Nt(); return Me === null ? e.memoizedState = t : Wy(e, Me.memoizedState, t) }, useTransition: function () { var t = Bu(Ks)[0], e = Nt().memoizedState; return [t, e] }, useMutableSource: Ry, useSyncExternalStore: My, useId: qy, unstable_isNewReconciler: !1 }; function Vt(t, e) { if (t && t.defaultProps) { e = xe({}, e), t = t.defaultProps; for (var n in t) e[n] === void 0 && (e[n] = t[n]); return e } return e } function Jc(t, e, n, r) { e = t.memoizedState, n = n(r, e), n = n == null ? e : xe({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n) } var Dl = { isMounted: function (t) { return (t = t._reactInternals) ? $r(t) === t : !1 }, enqueueSetState: function (t, e, n) { t = t._reactInternals; var r = rt(), i = Xn(t), s = _n(r, i); s.payload = e, n != null && (s.callback = n), e = Yn(t, s, i), e !== null && (Kt(e, t, i, r), ya(e, t, i)) }, enqueueReplaceState: function (t, e, n) { t = t._reactInternals; var r = rt(), i = Xn(t), s = _n(r, i); s.tag = 1, s.payload = e, n != null && (s.callback = n), e = Yn(t, s, i), e !== null && (Kt(e, t, i, r), ya(e, t, i)) }, enqueueForceUpdate: function (t, e) { t = t._reactInternals; var n = rt(), r = Xn(t), i = _n(n, r); i.tag = 2, e != null && (i.callback = e), e = Yn(t, i, r), e !== null && (Kt(e, t, r, n), ya(e, t, r)) } }; function wp(t, e, n, r, i, s, o) { return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, s, o) : e.prototype && e.prototype.isPureReactComponent ? !zs(n, r) || !zs(i, s) : !0 } function Qy(t, e, n) { var r = !1, i = rr, s = e.contextType; return typeof s == "object" && s !== null ? s = jt(s) : (i = ht(e) ? Ir : Ze.current, r = e.contextTypes, s = (r = r != null) ? xi(t, i) : rr), e = new e(n, s), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = Dl, t.stateNode = e, e._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = s), e } function Sp(t, e, n, r) { t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && Dl.enqueueReplaceState(e, e.state, null) } function Zc(t, e, n, r) { var i = t.stateNode; i.props = n, i.state = t.memoizedState, i.refs = {}, gh(t); var s = e.contextType; typeof s == "object" && s !== null ? i.context = jt(s) : (s = ht(e) ? Ir : Ze.current, i.context = xi(t, s)), i.state = t.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (Jc(t, e, s, n), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && Dl.enqueueReplaceState(i, i.state, null), Ya(t, n, i, r), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308) } function Pi(t, e) {
  try { var n = "", r = e; do n += jw(r), r = r.return; while (r); var i = n } catch (s) {
    i = `
Error generating stack: `+ s.message + `
`+ s.stack
  } return { value: t, source: e, stack: i, digest: null }
} function Uu(t, e, n) { return { value: t, source: null, stack: n ?? null, digest: e ?? null } } function ed(t, e) { try { console.error(e.value) } catch (n) { setTimeout(function () { throw n }) } } var ux = typeof WeakMap == "function" ? WeakMap : Map; function Xy(t, e, n) { n = _n(-1, n), n.tag = 3, n.payload = { element: null }; var r = e.value; return n.callback = function () { el || (el = !0, cd = r), ed(t, e) }, n } function Jy(t, e, n) { n = _n(-1, n), n.tag = 3; var r = t.type.getDerivedStateFromError; if (typeof r == "function") { var i = e.value; n.payload = function () { return r(i) }, n.callback = function () { ed(t, e) } } var s = t.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function () { ed(t, e), typeof r != "function" && (Qn === null ? Qn = new Set([this]) : Qn.add(this)); var o = e.stack; this.componentDidCatch(e.value, { componentStack: o !== null ? o : "" }) }), n } function xp(t, e, n) { var r = t.pingCache; if (r === null) { r = t.pingCache = new ux; var i = new Set; r.set(e, i) } else i = r.get(e), i === void 0 && (i = new Set, r.set(e, i)); i.has(n) || (i.add(n), t = xx.bind(null, t, e, n), e.then(t, t)) } function kp(t) { do { var e; if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t; t = t.return } while (t !== null); return null } function Cp(t, e, n, r, i) { return t.mode & 1 ? (t.flags |= 65536, t.lanes = i, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = _n(-1, 1), e.tag = 2, Yn(n, e, 1))), n.lanes |= 1), t) } var cx = Pn.ReactCurrentOwner, ct = !1; function nt(t, e, n, r) { e.child = t === null ? Py(e, null, n, r) : Ci(e, t.child, n, r) } function Op(t, e, n, r, i) { n = n.render; var s = e.ref; return vi(e, i), r = _h(t, e, n, r, s, i), n = wh(), t !== null && !ct ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Cn(t, e, i)) : (be && n && lh(e), e.flags |= 1, nt(t, e, r, i), e.child) } function Pp(t, e, n, r, i) { if (t === null) { var s = n.type; return typeof s == "function" && !Rh(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = s, Zy(t, e, s, r, i)) : (t = ka(n.type, null, r, e, e.mode, i), t.ref = e.ref, t.return = e, e.child = t) } if (s = t.child, !(t.lanes & i)) { var o = s.memoizedProps; if (n = n.compare, n = n !== null ? n : zs, n(o, r) && t.ref === e.ref) return Cn(t, e, i) } return e.flags |= 1, t = Jn(s, r), t.ref = e.ref, t.return = e, e.child = t } function Zy(t, e, n, r, i) { if (t !== null) { var s = t.memoizedProps; if (zs(s, r) && t.ref === e.ref) if (ct = !1, e.pendingProps = r = s, (t.lanes & i) !== 0) t.flags & 131072 && (ct = !0); else return e.lanes = t.lanes, Cn(t, e, i) } return td(t, e, n, r, i) } function e0(t, e, n) { var r = e.pendingProps, i = r.children, s = t !== null ? t.memoizedState : null; if (r.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, me(ci, vt), vt |= n; else { if (!(n & 1073741824)) return t = s !== null ? s.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, e.updateQueue = null, me(ci, vt), vt |= t, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = s !== null ? s.baseLanes : n, me(ci, vt), vt |= r } else s !== null ? (r = s.baseLanes | n, e.memoizedState = null) : r = n, me(ci, vt), vt |= r; return nt(t, e, i, n), e.child } function t0(t, e) { var n = e.ref; (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152) } function td(t, e, n, r, i) { var s = ht(n) ? Ir : Ze.current; return s = xi(e, s), vi(e, i), n = _h(t, e, n, r, s, i), r = wh(), t !== null && !ct ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Cn(t, e, i)) : (be && r && lh(e), e.flags |= 1, nt(t, e, n, i), e.child) } function Ep(t, e, n, r, i) { if (ht(n)) { var s = !0; Ha(e) } else s = !1; if (vi(e, i), e.stateNode === null) wa(t, e), Qy(e, n, r), Zc(e, n, r, i), r = !0; else if (t === null) { var o = e.stateNode, a = e.memoizedProps; o.props = a; var l = o.context, u = n.contextType; typeof u == "object" && u !== null ? u = jt(u) : (u = ht(n) ? Ir : Ze.current, u = xi(e, u)); var c = n.getDerivedStateFromProps, d = typeof c == "function" || typeof o.getSnapshotBeforeUpdate == "function"; d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== u) && Sp(e, o, r, u), Ln = !1; var h = e.memoizedState; o.state = h, Ya(e, r, o, i), l = e.memoizedState, a !== r || h !== l || dt.current || Ln ? (typeof c == "function" && (Jc(e, n, c, r), l = e.memoizedState), (a = Ln || wp(e, n, a, r, h, l, u)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = l), o.props = r, o.state = l, o.context = u, r = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), r = !1) } else { o = e.stateNode, Ty(t, e), a = e.memoizedProps, u = e.type === e.elementType ? a : Vt(e.type, a), o.props = u, d = e.pendingProps, h = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = jt(l) : (l = ht(n) ? Ir : Ze.current, l = xi(e, l)); var f = n.getDerivedStateFromProps; (c = typeof f == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || h !== l) && Sp(e, o, r, l), Ln = !1, h = e.memoizedState, o.state = h, Ya(e, r, o, i); var g = e.memoizedState; a !== d || h !== g || dt.current || Ln ? (typeof f == "function" && (Jc(e, n, f, r), g = e.memoizedState), (u = Ln || wp(e, n, u, r, h, g, l) || !1) ? (c || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, g, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, g, l)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = g), o.props = r, o.state = g, o.context = l, r = u) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 1024), r = !1) } return nd(t, e, n, r, s, i) } function nd(t, e, n, r, i, s) { t0(t, e); var o = (e.flags & 128) !== 0; if (!r && !o) return i && fp(e, n, !1), Cn(t, e, s); r = e.stateNode, cx.current = e; var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return e.flags |= 1, t !== null && o ? (e.child = Ci(e, t.child, null, s), e.child = Ci(e, null, a, s)) : nt(t, e, a, s), e.memoizedState = r.state, i && fp(e, n, !0), e.child } function n0(t) { var e = t.stateNode; e.pendingContext ? hp(t, e.pendingContext, e.pendingContext !== e.context) : e.context && hp(t, e.context, !1), mh(t, e.containerInfo) } function Tp(t, e, n, r, i) { return ki(), ch(i), e.flags |= 256, nt(t, e, n, r), e.child } var rd = { dehydrated: null, treeContext: null, retryLane: 0 }; function id(t) { return { baseLanes: t, cachePool: null, transitions: null } } function r0(t, e, n) { var r = e.pendingProps, i = _e.current, s = !1, o = (e.flags & 128) !== 0, a; if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1), me(_e, i & 1), t === null) return Qc(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = r.children, t = r.fallback, s ? (r = e.mode, s = e.child, o = { mode: "hidden", children: o }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = Nl(o, r, 0, null), t = Pr(t, r, n, null), s.return = e, t.return = e, s.sibling = t, e.child = s, e.child.memoizedState = id(n), e.memoizedState = rd, t) : kh(e, o)); if (i = t.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return dx(t, e, o, r, a, i, n); if (s) { s = r.fallback, o = e.mode, i = t.child, a = i.sibling; var l = { mode: "hidden", children: r.children }; return !(o & 1) && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = l, e.deletions = null) : (r = Jn(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? s = Jn(a, s) : (s = Pr(s, o, n, null), s.flags |= 2), s.return = e, r.return = e, r.sibling = s, e.child = r, r = s, s = e.child, o = t.child.memoizedState, o = o === null ? id(n) : { baseLanes: o.baseLanes | n, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = t.childLanes & ~n, e.memoizedState = rd, r } return s = t.child, t = s.sibling, r = Jn(s, { mode: "visible", children: r.children }), !(e.mode & 1) && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = r, e.memoizedState = null, r } function kh(t, e) { return e = Nl({ mode: "visible", children: e }, t.mode, 0, null), e.return = t, t.child = e } function Fo(t, e, n, r) { return r !== null && ch(r), Ci(e, t.child, null, n), t = kh(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t } function dx(t, e, n, r, i, s, o) { if (n) return e.flags & 256 ? (e.flags &= -257, r = Uu(Error(U(422))), Fo(t, e, o, r)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (s = r.fallback, i = e.mode, r = Nl({ mode: "visible", children: r.children }, i, 0, null), s = Pr(s, i, o, null), s.flags |= 2, r.return = e, s.return = e, r.sibling = s, e.child = r, e.mode & 1 && Ci(e, t.child, null, o), e.child.memoizedState = id(o), e.memoizedState = rd, s); if (!(e.mode & 1)) return Fo(t, e, o, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst; return r = a, s = Error(U(419)), r = Uu(s, r, void 0), Fo(t, e, o, r) } if (a = (o & t.childLanes) !== 0, ct || a) { if (r = Fe, r !== null) { switch (o & -o) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, kn(t, i), Kt(r, t, i, -1)) } return Ih(), r = Uu(Error(U(421))), Fo(t, e, o, r) } return i.data === "$?" ? (e.flags |= 128, e.child = t.child, e = kx.bind(null, t), i._reactRetry = e, null) : (t = s.treeContext, yt = Gn(i.nextSibling), wt = e, be = !0, Ht = null, t !== null && (Tt[It++] = yn, Tt[It++] = bn, Tt[It++] = Rr, yn = t.id, bn = t.overflow, Rr = e), e = kh(e, r.children), e.flags |= 4096, e) } function Ip(t, e, n) { t.lanes |= e; var r = t.alternate; r !== null && (r.lanes |= e), Xc(t.return, e, n) } function Hu(t, e, n, r, i) { var s = t.memoizedState; s === null ? t.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i) } function i0(t, e, n) { var r = e.pendingProps, i = r.revealOrder, s = r.tail; if (nt(t, e, r.children, n), r = _e.current, r & 2) r = r & 1 | 2, e.flags |= 128; else { if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) { if (t.tag === 13) t.memoizedState !== null && Ip(t, n, e); else if (t.tag === 19) Ip(t, n, e); else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break e; for (; t.sibling === null;) { if (t.return === null || t.return === e) break e; t = t.return } t.sibling.return = t.return, t = t.sibling } r &= 1 } if (me(_e, r), !(e.mode & 1)) e.memoizedState = null; else switch (i) { case "forwards": for (n = e.child, i = null; n !== null;)t = n.alternate, t !== null && Qa(t) === null && (i = n), n = n.sibling; n = i, n === null ? (i = e.child, e.child = null) : (i = n.sibling, n.sibling = null), Hu(e, !1, i, n, s); break; case "backwards": for (n = null, i = e.child, e.child = null; i !== null;) { if (t = i.alternate, t !== null && Qa(t) === null) { e.child = i; break } t = i.sibling, i.sibling = n, n = i, i = t } Hu(e, !0, n, null, s); break; case "together": Hu(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function wa(t, e) { !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2) } function Cn(t, e, n) { if (t !== null && (e.dependencies = t.dependencies), Lr |= e.lanes, !(n & e.childLanes)) return null; if (t !== null && e.child !== t.child) throw Error(U(153)); if (e.child !== null) { for (t = e.child, n = Jn(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;)t = t.sibling, n = n.sibling = Jn(t, t.pendingProps), n.return = e; n.sibling = null } return e.child } function hx(t, e, n) { switch (e.tag) { case 3: n0(e), ki(); break; case 5: Iy(e); break; case 1: ht(e.type) && Ha(e); break; case 4: mh(e, e.stateNode.containerInfo); break; case 10: var r = e.type._context, i = e.memoizedProps.value; me(Ka, r._currentValue), r._currentValue = i; break; case 13: if (r = e.memoizedState, r !== null) return r.dehydrated !== null ? (me(_e, _e.current & 1), e.flags |= 128, null) : n & e.child.childLanes ? r0(t, e, n) : (me(_e, _e.current & 1), t = Cn(t, e, n), t !== null ? t.sibling : null); me(_e, _e.current & 1); break; case 19: if (r = (n & e.childLanes) !== 0, t.flags & 128) { if (r) return i0(t, e, n); e.flags |= 128 } if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), me(_e, _e.current), r) break; return null; case 22: case 23: return e.lanes = 0, e0(t, e, n) }return Cn(t, e, n) } var s0, sd, o0, a0; s0 = function (t, e) { for (var n = e.child; n !== null;) { if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; sd = function () { }; o0 = function (t, e, n, r) { var i = t.memoizedProps; if (i !== r) { t = e.stateNode, Cr(on.current); var s = null; switch (n) { case "input": i = Pc(t, i), r = Pc(t, r), s = []; break; case "select": i = xe({}, i, { value: void 0 }), r = xe({}, r, { value: void 0 }), s = []; break; case "textarea": i = Ic(t, i), r = Ic(t, r), s = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = Ba) }Mc(n, r); var o; n = null; for (u in i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null) if (u === "style") { var a = i[u]; for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (Ls.hasOwnProperty(u) ? s || (s = []) : (s = s || []).push(u, null)); for (u in r) { var l = r[u]; if (a = i != null ? i[u] : void 0, r.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === "style") if (a) { for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o]) } else n || (s || (s = []), s.push(u, n)), n = l; else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (Ls.hasOwnProperty(u) ? (l != null && u === "onScroll" && ve("scroll", t), s || a === l || (s = [])) : (s = s || []).push(u, l)) } n && (s = s || []).push("style", n); var u = s; (e.updateQueue = u) && (e.flags |= 4) } }; a0 = function (t, e, n, r) { n !== r && (e.flags |= 4) }; function Ji(t, e) { if (!be) switch (t.tailMode) { case "hidden": e = t.tail; for (var n = null; e !== null;)e.alternate !== null && (n = e), e = e.sibling; n === null ? t.tail = null : n.sibling = null; break; case "collapsed": n = t.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null } } function Ge(t) { var e = t.alternate !== null && t.alternate.child === t.child, n = 0, r = 0; if (e) for (var i = t.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = t, i = i.sibling; else for (i = t.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = t, i = i.sibling; return t.subtreeFlags |= r, t.childLanes = n, e } function fx(t, e, n) { var r = e.pendingProps; switch (uh(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ge(e), null; case 1: return ht(e.type) && Ua(), Ge(e), null; case 3: return r = e.stateNode, Oi(), ye(dt), ye(Ze), yh(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (jo(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, Ht !== null && (fd(Ht), Ht = null))), sd(t, e), Ge(e), null; case 5: vh(e); var i = Cr(Ws.current); if (n = e.type, t !== null && e.stateNode != null) o0(t, e, n, r, i), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!r) { if (e.stateNode === null) throw Error(U(166)); return Ge(e), null } if (t = Cr(on.current), jo(e)) { r = e.stateNode, n = e.type; var s = e.memoizedProps; switch (r[rn] = e, r[Us] = s, t = (e.mode & 1) !== 0, n) { case "dialog": ve("cancel", r), ve("close", r); break; case "iframe": case "object": case "embed": ve("load", r); break; case "video": case "audio": for (i = 0; i < hs.length; i++)ve(hs[i], r); break; case "source": ve("error", r); break; case "img": case "image": case "link": ve("error", r), ve("load", r); break; case "details": ve("toggle", r); break; case "input": $f(r, s), ve("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!s.multiple }, ve("invalid", r); break; case "textarea": Vf(r, s), ve("invalid", r) }Mc(n, s), i = null; for (var o in s) if (s.hasOwnProperty(o)) { var a = s[o]; o === "children" ? typeof a == "string" ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && Ao(r.textContent, a, t), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Ao(r.textContent, a, t), i = ["children", "" + a]) : Ls.hasOwnProperty(o) && a != null && o === "onScroll" && ve("scroll", r) } switch (n) { case "input": Po(r), zf(r, s, !0); break; case "textarea": Po(r), Bf(r); break; case "select": case "option": break; default: typeof s.onClick == "function" && (r.onclick = Ba) }r = i, e.updateQueue = r, r !== null && (e.flags |= 4) } else { o = i.nodeType === 9 ? i : i.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = Av(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = o.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = o.createElement(n, { is: r.is }) : (t = o.createElement(n), n === "select" && (o = t, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : t = o.createElementNS(t, n), t[rn] = e, t[Us] = r, s0(t, e, !1, !1), e.stateNode = t; e: { switch (o = Lc(n, r), n) { case "dialog": ve("cancel", t), ve("close", t), i = r; break; case "iframe": case "object": case "embed": ve("load", t), i = r; break; case "video": case "audio": for (i = 0; i < hs.length; i++)ve(hs[i], t); i = r; break; case "source": ve("error", t), i = r; break; case "img": case "image": case "link": ve("error", t), ve("load", t), i = r; break; case "details": ve("toggle", t), i = r; break; case "input": $f(t, r), i = Pc(t, r), ve("invalid", t); break; case "option": i = r; break; case "select": t._wrapperState = { wasMultiple: !!r.multiple }, i = xe({}, r, { value: void 0 }), ve("invalid", t); break; case "textarea": Vf(t, r), i = Ic(t, r), ve("invalid", t); break; default: i = r }Mc(n, i), a = i; for (s in a) if (a.hasOwnProperty(s)) { var l = a[s]; s === "style" ? Fv(t, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && jv(t, l)) : s === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && Ds(t, l) : typeof l == "number" && Ds(t, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Ls.hasOwnProperty(s) ? l != null && s === "onScroll" && ve("scroll", t) : l != null && Gd(t, s, l, o)) } switch (n) { case "input": Po(t), zf(t, r, !1); break; case "textarea": Po(t), Bf(t); break; case "option": r.value != null && t.setAttribute("value", "" + nr(r.value)); break; case "select": t.multiple = !!r.multiple, s = r.value, s != null ? fi(t, !!r.multiple, s, !1) : r.defaultValue != null && fi(t, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (t.onclick = Ba) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return Ge(e), null; case 6: if (t && e.stateNode != null) a0(t, e, t.memoizedProps, r); else { if (typeof r != "string" && e.stateNode === null) throw Error(U(166)); if (n = Cr(Ws.current), Cr(on.current), jo(e)) { if (r = e.stateNode, n = e.memoizedProps, r[rn] = e, (s = r.nodeValue !== n) && (t = wt, t !== null)) switch (t.tag) { case 3: Ao(r.nodeValue, n, (t.mode & 1) !== 0); break; case 5: t.memoizedProps.suppressHydrationWarning !== !0 && Ao(r.nodeValue, n, (t.mode & 1) !== 0) }s && (e.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[rn] = e, e.stateNode = r } return Ge(e), null; case 13: if (ye(_e), r = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) { if (be && yt !== null && e.mode & 1 && !(e.flags & 128)) Cy(), ki(), e.flags |= 98560, s = !1; else if (s = jo(e), r !== null && r.dehydrated !== null) { if (t === null) { if (!s) throw Error(U(318)); if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(U(317)); s[rn] = e } else ki(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; Ge(e), s = !1 } else Ht !== null && (fd(Ht), Ht = null), s = !0; if (!s) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = n, e) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192, e.mode & 1 && (t === null || _e.current & 1 ? Le === 0 && (Le = 3) : Ih())), e.updateQueue !== null && (e.flags |= 4), Ge(e), null); case 4: return Oi(), sd(t, e), t === null && Vs(e.stateNode.containerInfo), Ge(e), null; case 10: return fh(e.type._context), Ge(e), null; case 17: return ht(e.type) && Ua(), Ge(e), null; case 19: if (ye(_e), s = e.memoizedState, s === null) return Ge(e), null; if (r = (e.flags & 128) !== 0, o = s.rendering, o === null) if (r) Ji(s, !1); else { if (Le !== 0 || t !== null && t.flags & 128) for (t = e.child; t !== null;) { if (o = Qa(t), o !== null) { for (e.flags |= 128, Ji(s, !1), r = o.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = n, n = e.child; n !== null;)s = n, t = r, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = t, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, t = o.dependencies, s.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), n = n.sibling; return me(_e, _e.current & 1 | 2), e.child } t = t.sibling } s.tail !== null && Pe() > Ei && (e.flags |= 128, r = !0, Ji(s, !1), e.lanes = 4194304) } else { if (!r) if (t = Qa(o), t !== null) { if (e.flags |= 128, r = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), Ji(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !be) return Ge(e), null } else 2 * Pe() - s.renderingStartTime > Ei && n !== 1073741824 && (e.flags |= 128, r = !0, Ji(s, !1), e.lanes = 4194304); s.isBackwards ? (o.sibling = e.child, e.child = o) : (n = s.last, n !== null ? n.sibling = o : e.child = o, s.last = o) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = Pe(), e.sibling = null, n = _e.current, me(_e, r ? n & 1 | 2 : n & 1), e) : (Ge(e), null); case 22: case 23: return Th(), r = e.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (e.flags |= 8192), r && e.mode & 1 ? vt & 1073741824 && (Ge(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Ge(e), null; case 24: return null; case 25: return null }throw Error(U(156, e.tag)) } function px(t, e) { switch (uh(e), e.tag) { case 1: return ht(e.type) && Ua(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 3: return Oi(), ye(dt), ye(Ze), yh(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null; case 5: return vh(e), null; case 13: if (ye(_e), t = e.memoizedState, t !== null && t.dehydrated !== null) { if (e.alternate === null) throw Error(U(340)); ki() } return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 19: return ye(_e), null; case 4: return Oi(), null; case 10: return fh(e.type._context), null; case 22: case 23: return Th(), null; case 24: return null; default: return null } } var $o = !1, Je = !1, gx = typeof WeakSet == "function" ? WeakSet : Set, G = null; function ui(t, e) { var n = t.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { ke(t, e, r) } else n.current = null } function od(t, e, n) { try { n() } catch (r) { ke(t, e, r) } } var Rp = !1; function mx(t, e) { if (Uc = $a, t = hy(), ah(t)) { if ("selectionStart" in t) var n = { start: t.selectionStart, end: t.selectionEnd }; else e: { n = (n = t.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, s = r.focusNode; r = r.focusOffset; try { n.nodeType, s.nodeType } catch { n = null; break e } var o = 0, a = -1, l = -1, u = 0, c = 0, d = t, h = null; t: for (; ;) { for (var f; d !== n || i !== 0 && d.nodeType !== 3 || (a = o + i), d !== s || r !== 0 && d.nodeType !== 3 || (l = o + r), d.nodeType === 3 && (o += d.nodeValue.length), (f = d.firstChild) !== null;)h = d, d = f; for (; ;) { if (d === t) break t; if (h === n && ++u === i && (a = o), h === s && ++c === r && (l = o), (f = d.nextSibling) !== null) break; d = h, h = d.parentNode } d = f } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (Hc = { focusedElem: t, selectionRange: n }, $a = !1, G = e; G !== null;)if (e = G, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, G = t; else for (; G !== null;) { e = G; try { var g = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (g !== null) { var m = g.memoizedProps, y = g.memoizedState, p = e.stateNode, v = p.getSnapshotBeforeUpdate(e.elementType === e.type ? m : Vt(e.type, m), y); p.__reactInternalSnapshotBeforeUpdate = v } break; case 3: var b = e.stateNode.containerInfo; b.nodeType === 1 ? b.textContent = "" : b.nodeType === 9 && b.documentElement && b.removeChild(b.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(U(163)) } } catch (S) { ke(e, e.return, S) } if (t = e.sibling, t !== null) { t.return = e.return, G = t; break } G = e.return } return g = Rp, Rp = !1, g } function ks(t, e, n) { var r = e.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & t) === t) { var s = i.destroy; i.destroy = void 0, s !== void 0 && od(e, n, s) } i = i.next } while (i !== r) } } function Al(t, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var n = e = e.next; do { if ((n.tag & t) === t) { var r = n.create; n.destroy = r() } n = n.next } while (n !== e) } } function ad(t) { var e = t.ref; if (e !== null) { var n = t.stateNode; switch (t.tag) { case 5: t = n; break; default: t = n }typeof e == "function" ? e(t) : e.current = t } } function l0(t) { var e = t.alternate; e !== null && (t.alternate = null, l0(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[rn], delete e[Us], delete e[Kc], delete e[JS], delete e[ZS])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null } function u0(t) { return t.tag === 5 || t.tag === 3 || t.tag === 4 } function Mp(t) { e: for (; ;) { for (; t.sibling === null;) { if (t.return === null || u0(t.return)) return null; t = t.return } for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) { if (t.flags & 2 || t.child === null || t.tag === 4) continue e; t.child.return = t, t = t.child } if (!(t.flags & 2)) return t.stateNode } } function ld(t, e, n) { var r = t.tag; if (r === 5 || r === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = Ba)); else if (r !== 4 && (t = t.child, t !== null)) for (ld(t, e, n), t = t.sibling; t !== null;)ld(t, e, n), t = t.sibling } function ud(t, e, n) { var r = t.tag; if (r === 5 || r === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t); else if (r !== 4 && (t = t.child, t !== null)) for (ud(t, e, n), t = t.sibling; t !== null;)ud(t, e, n), t = t.sibling } var Be = null, Bt = !1; function Tn(t, e, n) { for (n = n.child; n !== null;)c0(t, e, n), n = n.sibling } function c0(t, e, n) { if (sn && typeof sn.onCommitFiberUnmount == "function") try { sn.onCommitFiberUnmount(Pl, n) } catch { } switch (n.tag) { case 5: Je || ui(n, e); case 6: var r = Be, i = Bt; Be = null, Tn(t, e, n), Be = r, Bt = i, Be !== null && (Bt ? (t = Be, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : Be.removeChild(n.stateNode)); break; case 18: Be !== null && (Bt ? (t = Be, n = n.stateNode, t.nodeType === 8 ? Nu(t.parentNode, n) : t.nodeType === 1 && Nu(t, n), Fs(t)) : Nu(Be, n.stateNode)); break; case 4: r = Be, i = Bt, Be = n.stateNode.containerInfo, Bt = !0, Tn(t, e, n), Be = r, Bt = i; break; case 0: case 11: case 14: case 15: if (!Je && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var s = i, o = s.destroy; s = s.tag, o !== void 0 && (s & 2 || s & 4) && od(n, e, o), i = i.next } while (i !== r) } Tn(t, e, n); break; case 1: if (!Je && (ui(n, e), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { ke(n, e, a) } Tn(t, e, n); break; case 21: Tn(t, e, n); break; case 22: n.mode & 1 ? (Je = (r = Je) || n.memoizedState !== null, Tn(t, e, n), Je = r) : Tn(t, e, n); break; default: Tn(t, e, n) } } function Lp(t) { var e = t.updateQueue; if (e !== null) { t.updateQueue = null; var n = t.stateNode; n === null && (n = t.stateNode = new gx), e.forEach(function (r) { var i = Cx.bind(null, t, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function Ft(t, e) { var n = e.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var s = t, o = e, a = o; e: for (; a !== null;) { switch (a.tag) { case 5: Be = a.stateNode, Bt = !1; break e; case 3: Be = a.stateNode.containerInfo, Bt = !0; break e; case 4: Be = a.stateNode.containerInfo, Bt = !0; break e }a = a.return } if (Be === null) throw Error(U(160)); c0(s, o, i), Be = null, Bt = !1; var l = i.alternate; l !== null && (l.return = null), i.return = null } catch (u) { ke(i, e, u) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)d0(e, t), e = e.sibling } function d0(t, e) { var n = t.alternate, r = t.flags; switch (t.tag) { case 0: case 11: case 14: case 15: if (Ft(e, t), Qt(t), r & 4) { try { ks(3, t, t.return), Al(3, t) } catch (m) { ke(t, t.return, m) } try { ks(5, t, t.return) } catch (m) { ke(t, t.return, m) } } break; case 1: Ft(e, t), Qt(t), r & 512 && n !== null && ui(n, n.return); break; case 5: if (Ft(e, t), Qt(t), r & 512 && n !== null && ui(n, n.return), t.flags & 32) { var i = t.stateNode; try { Ds(i, "") } catch (m) { ke(t, t.return, m) } } if (r & 4 && (i = t.stateNode, i != null)) { var s = t.memoizedProps, o = n !== null ? n.memoizedProps : s, a = t.type, l = t.updateQueue; if (t.updateQueue = null, l !== null) try { a === "input" && s.type === "radio" && s.name != null && Lv(i, s), Lc(a, o); var u = Lc(a, s); for (o = 0; o < l.length; o += 2) { var c = l[o], d = l[o + 1]; c === "style" ? Fv(i, d) : c === "dangerouslySetInnerHTML" ? jv(i, d) : c === "children" ? Ds(i, d) : Gd(i, c, d, u) } switch (a) { case "input": Ec(i, s); break; case "textarea": Dv(i, s); break; case "select": var h = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!s.multiple; var f = s.value; f != null ? fi(i, !!s.multiple, f, !1) : h !== !!s.multiple && (s.defaultValue != null ? fi(i, !!s.multiple, s.defaultValue, !0) : fi(i, !!s.multiple, s.multiple ? [] : "", !1)) }i[Us] = s } catch (m) { ke(t, t.return, m) } } break; case 6: if (Ft(e, t), Qt(t), r & 4) { if (t.stateNode === null) throw Error(U(162)); i = t.stateNode, s = t.memoizedProps; try { i.nodeValue = s } catch (m) { ke(t, t.return, m) } } break; case 3: if (Ft(e, t), Qt(t), r & 4 && n !== null && n.memoizedState.isDehydrated) try { Fs(e.containerInfo) } catch (m) { ke(t, t.return, m) } break; case 4: Ft(e, t), Qt(t); break; case 13: Ft(e, t), Qt(t), i = t.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (Ph = Pe())), r & 4 && Lp(t); break; case 22: if (c = n !== null && n.memoizedState !== null, t.mode & 1 ? (Je = (u = Je) || c, Ft(e, t), Je = u) : Ft(e, t), Qt(t), r & 8192) { if (u = t.memoizedState !== null, (t.stateNode.isHidden = u) && !c && t.mode & 1) for (G = t, c = t.child; c !== null;) { for (d = G = c; G !== null;) { switch (h = G, f = h.child, h.tag) { case 0: case 11: case 14: case 15: ks(4, h, h.return); break; case 1: ui(h, h.return); var g = h.stateNode; if (typeof g.componentWillUnmount == "function") { r = h, n = h.return; try { e = r, g.props = e.memoizedProps, g.state = e.memoizedState, g.componentWillUnmount() } catch (m) { ke(r, n, m) } } break; case 5: ui(h, h.return); break; case 22: if (h.memoizedState !== null) { Ap(d); continue } }f !== null ? (f.return = h, G = f) : Ap(d) } c = c.sibling } e: for (c = null, d = t; ;) { if (d.tag === 5) { if (c === null) { c = d; try { i = d.stateNode, u ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = Nv("display", o)) } catch (m) { ke(t, t.return, m) } } } else if (d.tag === 6) { if (c === null) try { d.stateNode.nodeValue = u ? "" : d.memoizedProps } catch (m) { ke(t, t.return, m) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === t) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === t) break e; for (; d.sibling === null;) { if (d.return === null || d.return === t) break e; c === d && (c = null), d = d.return } c === d && (c = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: Ft(e, t), Qt(t), r & 4 && Lp(t); break; case 21: break; default: Ft(e, t), Qt(t) } } function Qt(t) { var e = t.flags; if (e & 2) { try { e: { for (var n = t.return; n !== null;) { if (u0(n)) { var r = n; break e } n = n.return } throw Error(U(160)) } switch (r.tag) { case 5: var i = r.stateNode; r.flags & 32 && (Ds(i, ""), r.flags &= -33); var s = Mp(t); ud(t, s, i); break; case 3: case 4: var o = r.stateNode.containerInfo, a = Mp(t); ld(t, a, o); break; default: throw Error(U(161)) } } catch (l) { ke(t, t.return, l) } t.flags &= -3 } e & 4096 && (t.flags &= -4097) } function vx(t, e, n) { G = t, h0(t) } function h0(t, e, n) { for (var r = (t.mode & 1) !== 0; G !== null;) { var i = G, s = i.child; if (i.tag === 22 && r) { var o = i.memoizedState !== null || $o; if (!o) { var a = i.alternate, l = a !== null && a.memoizedState !== null || Je; a = $o; var u = Je; if ($o = o, (Je = l) && !u) for (G = i; G !== null;)o = G, l = o.child, o.tag === 22 && o.memoizedState !== null ? jp(i) : l !== null ? (l.return = o, G = l) : jp(i); for (; s !== null;)G = s, h0(s), s = s.sibling; G = i, $o = a, Je = u } Dp(t) } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, G = s) : Dp(t) } } function Dp(t) { for (; G !== null;) { var e = G; if (e.flags & 8772) { var n = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: Je || Al(5, e); break; case 1: var r = e.stateNode; if (e.flags & 4 && !Je) if (n === null) r.componentDidMount(); else { var i = e.elementType === e.type ? n.memoizedProps : Vt(e.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var s = e.updateQueue; s !== null && yp(e, s, r); break; case 3: var o = e.updateQueue; if (o !== null) { if (n = null, e.child !== null) switch (e.child.tag) { case 5: n = e.child.stateNode; break; case 1: n = e.child.stateNode }yp(e, o, n) } break; case 5: var a = e.stateNode; if (n === null && e.flags & 4) { n = a; var l = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var u = e.alternate; if (u !== null) { var c = u.memoizedState; if (c !== null) { var d = c.dehydrated; d !== null && Fs(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(U(163)) }Je || e.flags & 512 && ad(e) } catch (h) { ke(e, e.return, h) } } if (e === t) { G = null; break } if (n = e.sibling, n !== null) { n.return = e.return, G = n; break } G = e.return } } function Ap(t) { for (; G !== null;) { var e = G; if (e === t) { G = null; break } var n = e.sibling; if (n !== null) { n.return = e.return, G = n; break } G = e.return } } function jp(t) { for (; G !== null;) { var e = G; try { switch (e.tag) { case 0: case 11: case 15: var n = e.return; try { Al(4, e) } catch (l) { ke(e, n, l) } break; case 1: var r = e.stateNode; if (typeof r.componentDidMount == "function") { var i = e.return; try { r.componentDidMount() } catch (l) { ke(e, i, l) } } var s = e.return; try { ad(e) } catch (l) { ke(e, s, l) } break; case 5: var o = e.return; try { ad(e) } catch (l) { ke(e, o, l) } } } catch (l) { ke(e, e.return, l) } if (e === t) { G = null; break } var a = e.sibling; if (a !== null) { a.return = e.return, G = a; break } G = e.return } } var yx = Math.ceil, Za = Pn.ReactCurrentDispatcher, Ch = Pn.ReactCurrentOwner, Dt = Pn.ReactCurrentBatchConfig, re = 0, Fe = null, Ie = null, He = 0, vt = 0, ci = or(0), Le = 0, Ys = null, Lr = 0, jl = 0, Oh = 0, Cs = null, lt = null, Ph = 0, Ei = 1 / 0, gn = null, el = !1, cd = null, Qn = null, zo = !1, $n = null, tl = 0, Os = 0, dd = null, Sa = -1, xa = 0; function rt() { return re & 6 ? Pe() : Sa !== -1 ? Sa : Sa = Pe() } function Xn(t) { return t.mode & 1 ? re & 2 && He !== 0 ? He & -He : tx.transition !== null ? (xa === 0 && (xa = Qv()), xa) : (t = de, t !== 0 || (t = window.event, t = t === void 0 ? 16 : ry(t.type)), t) : 1 } function Kt(t, e, n, r) { if (50 < Os) throw Os = 0, dd = null, Error(U(185)); co(t, n, r), (!(re & 2) || t !== Fe) && (t === Fe && (!(re & 2) && (jl |= n), Le === 4 && jn(t, He)), ft(t, r), n === 1 && re === 0 && !(e.mode & 1) && (Ei = Pe() + 500, Ml && ar())) } function ft(t, e) { var n = t.callbackNode; tS(t, e); var r = Fa(t, t === Fe ? He : 0); if (r === 0) n !== null && Wf(n), t.callbackNode = null, t.callbackPriority = 0; else if (e = r & -r, t.callbackPriority !== e) { if (n != null && Wf(n), e === 1) t.tag === 0 ? ex(Np.bind(null, t)) : Sy(Np.bind(null, t)), QS(function () { !(re & 6) && ar() }), n = null; else { switch (Xv(r)) { case 1: n = Zd; break; case 4: n = Gv; break; case 16: n = Na; break; case 536870912: n = Yv; break; default: n = Na }n = _0(n, f0.bind(null, t)) } t.callbackPriority = e, t.callbackNode = n } } function f0(t, e) { if (Sa = -1, xa = 0, re & 6) throw Error(U(327)); var n = t.callbackNode; if (yi() && t.callbackNode !== n) return null; var r = Fa(t, t === Fe ? He : 0); if (r === 0) return null; if (r & 30 || r & t.expiredLanes || e) e = nl(t, r); else { e = r; var i = re; re |= 2; var s = g0(); (Fe !== t || He !== e) && (gn = null, Ei = Pe() + 500, Or(t, e)); do try { wx(); break } catch (a) { p0(t, a) } while (!0); hh(), Za.current = s, re = i, Ie !== null ? e = 0 : (Fe = null, He = 0, e = Le) } if (e !== 0) { if (e === 2 && (i = Fc(t), i !== 0 && (r = i, e = hd(t, i))), e === 1) throw n = Ys, Or(t, 0), jn(t, r), ft(t, Pe()), n; if (e === 6) jn(t, r); else { if (i = t.current.alternate, !(r & 30) && !bx(i) && (e = nl(t, r), e === 2 && (s = Fc(t), s !== 0 && (r = s, e = hd(t, s))), e === 1)) throw n = Ys, Or(t, 0), jn(t, r), ft(t, Pe()), n; switch (t.finishedWork = i, t.finishedLanes = r, e) { case 0: case 1: throw Error(U(345)); case 2: br(t, lt, gn); break; case 3: if (jn(t, r), (r & 130023424) === r && (e = Ph + 500 - Pe(), 10 < e)) { if (Fa(t, 0) !== 0) break; if (i = t.suspendedLanes, (i & r) !== r) { rt(), t.pingedLanes |= t.suspendedLanes & i; break } t.timeoutHandle = qc(br.bind(null, t, lt, gn), e); break } br(t, lt, gn); break; case 4: if (jn(t, r), (r & 4194240) === r) break; for (e = t.eventTimes, i = -1; 0 < r;) { var o = 31 - qt(r); s = 1 << o, o = e[o], o > i && (i = o), r &= ~s } if (r = i, r = Pe() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * yx(r / 1960)) - r, 10 < r) { t.timeoutHandle = qc(br.bind(null, t, lt, gn), r); break } br(t, lt, gn); break; case 5: br(t, lt, gn); break; default: throw Error(U(329)) } } } return ft(t, Pe()), t.callbackNode === n ? f0.bind(null, t) : null } function hd(t, e) { var n = Cs; return t.current.memoizedState.isDehydrated && (Or(t, e).flags |= 256), t = nl(t, e), t !== 2 && (e = lt, lt = n, e !== null && fd(e)), t } function fd(t) { lt === null ? lt = t : lt.push.apply(lt, t) } function bx(t) { for (var e = t; ;) { if (e.flags & 16384) { var n = e.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], s = i.getSnapshot; i = i.value; try { if (!Gt(s(), i)) return !1 } catch { return !1 } } } if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n; else { if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function jn(t, e) { for (e &= ~Oh, e &= ~jl, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) { var n = 31 - qt(e), r = 1 << n; t[n] = -1, e &= ~r } } function Np(t) { if (re & 6) throw Error(U(327)); yi(); var e = Fa(t, 0); if (!(e & 1)) return ft(t, Pe()), null; var n = nl(t, e); if (t.tag !== 0 && n === 2) { var r = Fc(t); r !== 0 && (e = r, n = hd(t, r)) } if (n === 1) throw n = Ys, Or(t, 0), jn(t, e), ft(t, Pe()), n; if (n === 6) throw Error(U(345)); return t.finishedWork = t.current.alternate, t.finishedLanes = e, br(t, lt, gn), ft(t, Pe()), null } function Eh(t, e) { var n = re; re |= 1; try { return t(e) } finally { re = n, re === 0 && (Ei = Pe() + 500, Ml && ar()) } } function Dr(t) { $n !== null && $n.tag === 0 && !(re & 6) && yi(); var e = re; re |= 1; var n = Dt.transition, r = de; try { if (Dt.transition = null, de = 1, t) return t() } finally { de = r, Dt.transition = n, re = e, !(re & 6) && ar() } } function Th() { vt = ci.current, ye(ci) } function Or(t, e) { t.finishedWork = null, t.finishedLanes = 0; var n = t.timeoutHandle; if (n !== -1 && (t.timeoutHandle = -1, YS(n)), Ie !== null) for (n = Ie.return; n !== null;) { var r = n; switch (uh(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Ua(); break; case 3: Oi(), ye(dt), ye(Ze), yh(); break; case 5: vh(r); break; case 4: Oi(); break; case 13: ye(_e); break; case 19: ye(_e); break; case 10: fh(r.type._context); break; case 22: case 23: Th() }n = n.return } if (Fe = t, Ie = t = Jn(t.current, null), He = vt = e, Le = 0, Ys = null, Oh = jl = Lr = 0, lt = Cs = null, kr !== null) { for (e = 0; e < kr.length; e++)if (n = kr[e], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, s = n.pending; if (s !== null) { var o = s.next; s.next = i, r.next = o } n.pending = r } kr = null } return t } function p0(t, e) { do { var n = Ie; try { if (hh(), ba.current = Ja, Xa) { for (var r = Se.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } Xa = !1 } if (Mr = 0, Ae = Me = Se = null, xs = !1, qs = 0, Ch.current = null, n === null || n.return === null) { Le = 1, Ys = e, Ie = null; break } e: { var s = t, o = n.return, a = n, l = e; if (e = He, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var u = l, c = a, d = c.tag; if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) { var h = c.alternate; h ? (c.updateQueue = h.updateQueue, c.memoizedState = h.memoizedState, c.lanes = h.lanes) : (c.updateQueue = null, c.memoizedState = null) } var f = kp(o); if (f !== null) { f.flags &= -257, Cp(f, o, a, s, e), f.mode & 1 && xp(s, u, e), e = f, l = u; var g = e.updateQueue; if (g === null) { var m = new Set; m.add(l), e.updateQueue = m } else g.add(l); break e } else { if (!(e & 1)) { xp(s, u, e), Ih(); break e } l = Error(U(426)) } } else if (be && a.mode & 1) { var y = kp(o); if (y !== null) { !(y.flags & 65536) && (y.flags |= 256), Cp(y, o, a, s, e), ch(Pi(l, a)); break e } } s = l = Pi(l, a), Le !== 4 && (Le = 2), Cs === null ? Cs = [s] : Cs.push(s), s = o; do { switch (s.tag) { case 3: s.flags |= 65536, e &= -e, s.lanes |= e; var p = Xy(s, l, e); vp(s, p); break e; case 1: a = l; var v = s.type, b = s.stateNode; if (!(s.flags & 128) && (typeof v.getDerivedStateFromError == "function" || b !== null && typeof b.componentDidCatch == "function" && (Qn === null || !Qn.has(b)))) { s.flags |= 65536, e &= -e, s.lanes |= e; var S = Jy(s, a, e); vp(s, S); break e } }s = s.return } while (s !== null) } v0(n) } catch (P) { e = P, Ie === n && n !== null && (Ie = n = n.return); continue } break } while (!0) } function g0() { var t = Za.current; return Za.current = Ja, t === null ? Ja : t } function Ih() { (Le === 0 || Le === 3 || Le === 2) && (Le = 4), Fe === null || !(Lr & 268435455) && !(jl & 268435455) || jn(Fe, He) } function nl(t, e) { var n = re; re |= 2; var r = g0(); (Fe !== t || He !== e) && (gn = null, Or(t, e)); do try { _x(); break } catch (i) { p0(t, i) } while (!0); if (hh(), re = n, Za.current = r, Ie !== null) throw Error(U(261)); return Fe = null, He = 0, Le } function _x() { for (; Ie !== null;)m0(Ie) } function wx() { for (; Ie !== null && !qw();)m0(Ie) } function m0(t) { var e = b0(t.alternate, t, vt); t.memoizedProps = t.pendingProps, e === null ? v0(t) : Ie = e, Ch.current = null } function v0(t) { var e = t; do { var n = e.alternate; if (t = e.return, e.flags & 32768) { if (n = px(n, e), n !== null) { n.flags &= 32767, Ie = n; return } if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null; else { Le = 6, Ie = null; return } } else if (n = fx(n, e, vt), n !== null) { Ie = n; return } if (e = e.sibling, e !== null) { Ie = e; return } Ie = e = t } while (e !== null); Le === 0 && (Le = 5) } function br(t, e, n) { var r = de, i = Dt.transition; try { Dt.transition = null, de = 1, Sx(t, e, n, r) } finally { Dt.transition = i, de = r } return null } function Sx(t, e, n, r) { do yi(); while ($n !== null); if (re & 6) throw Error(U(327)); n = t.finishedWork; var i = t.finishedLanes; if (n === null) return null; if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(U(177)); t.callbackNode = null, t.callbackPriority = 0; var s = n.lanes | n.childLanes; if (nS(t, s), t === Fe && (Ie = Fe = null, He = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || zo || (zo = !0, _0(Na, function () { return yi(), null })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) { s = Dt.transition, Dt.transition = null; var o = de; de = 1; var a = re; re |= 4, Ch.current = null, mx(t, n), d0(n, t), BS(Hc), $a = !!Uc, Hc = Uc = null, t.current = n, vx(n), Kw(), re = a, de = o, Dt.transition = s } else t.current = n; if (zo && (zo = !1, $n = t, tl = i), s = t.pendingLanes, s === 0 && (Qn = null), Qw(n.stateNode), ft(t, Pe()), e !== null) for (r = t.onRecoverableError, n = 0; n < e.length; n++)i = e[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (el) throw el = !1, t = cd, cd = null, t; return tl & 1 && t.tag !== 0 && yi(), s = t.pendingLanes, s & 1 ? t === dd ? Os++ : (Os = 0, dd = t) : Os = 0, ar(), null } function yi() { if ($n !== null) { var t = Xv(tl), e = Dt.transition, n = de; try { if (Dt.transition = null, de = 16 > t ? 16 : t, $n === null) var r = !1; else { if (t = $n, $n = null, tl = 0, re & 6) throw Error(U(331)); var i = re; for (re |= 4, G = t.current; G !== null;) { var s = G, o = s.child; if (G.flags & 16) { var a = s.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var u = a[l]; for (G = u; G !== null;) { var c = G; switch (c.tag) { case 0: case 11: case 15: ks(8, c, s) }var d = c.child; if (d !== null) d.return = c, G = d; else for (; G !== null;) { c = G; var h = c.sibling, f = c.return; if (l0(c), c === u) { G = null; break } if (h !== null) { h.return = f, G = h; break } G = f } } } var g = s.alternate; if (g !== null) { var m = g.child; if (m !== null) { g.child = null; do { var y = m.sibling; m.sibling = null, m = y } while (m !== null) } } G = s } } if (s.subtreeFlags & 2064 && o !== null) o.return = s, G = o; else e: for (; G !== null;) { if (s = G, s.flags & 2048) switch (s.tag) { case 0: case 11: case 15: ks(9, s, s.return) }var p = s.sibling; if (p !== null) { p.return = s.return, G = p; break e } G = s.return } } var v = t.current; for (G = v; G !== null;) { o = G; var b = o.child; if (o.subtreeFlags & 2064 && b !== null) b.return = o, G = b; else e: for (o = v; G !== null;) { if (a = G, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: Al(9, a) } } catch (P) { ke(a, a.return, P) } if (a === o) { G = null; break e } var S = a.sibling; if (S !== null) { S.return = a.return, G = S; break e } G = a.return } } if (re = i, ar(), sn && typeof sn.onPostCommitFiberRoot == "function") try { sn.onPostCommitFiberRoot(Pl, t) } catch { } r = !0 } return r } finally { de = n, Dt.transition = e } } return !1 } function Fp(t, e, n) { e = Pi(n, e), e = Xy(t, e, 1), t = Yn(t, e, 1), e = rt(), t !== null && (co(t, 1, e), ft(t, e)) } function ke(t, e, n) { if (t.tag === 3) Fp(t, t, n); else for (; e !== null;) { if (e.tag === 3) { Fp(e, t, n); break } else if (e.tag === 1) { var r = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Qn === null || !Qn.has(r))) { t = Pi(n, t), t = Jy(e, t, 1), e = Yn(e, t, 1), t = rt(), e !== null && (co(e, 1, t), ft(e, t)); break } } e = e.return } } function xx(t, e, n) { var r = t.pingCache; r !== null && r.delete(e), e = rt(), t.pingedLanes |= t.suspendedLanes & n, Fe === t && (He & n) === n && (Le === 4 || Le === 3 && (He & 130023424) === He && 500 > Pe() - Ph ? Or(t, 0) : Oh |= n), ft(t, e) } function y0(t, e) { e === 0 && (t.mode & 1 ? (e = Io, Io <<= 1, !(Io & 130023424) && (Io = 4194304)) : e = 1); var n = rt(); t = kn(t, e), t !== null && (co(t, e, n), ft(t, n)) } function kx(t) { var e = t.memoizedState, n = 0; e !== null && (n = e.retryLane), y0(t, n) } function Cx(t, e) { var n = 0; switch (t.tag) { case 13: var r = t.stateNode, i = t.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = t.stateNode; break; default: throw Error(U(314)) }r !== null && r.delete(e), y0(t, n) } var b0; b0 = function (t, e, n) { if (t !== null) if (t.memoizedProps !== e.pendingProps || dt.current) ct = !0; else { if (!(t.lanes & n) && !(e.flags & 128)) return ct = !1, hx(t, e, n); ct = !!(t.flags & 131072) } else ct = !1, be && e.flags & 1048576 && xy(e, qa, e.index); switch (e.lanes = 0, e.tag) { case 2: var r = e.type; wa(t, e), t = e.pendingProps; var i = xi(e, Ze.current); vi(e, n), i = _h(null, e, r, t, i, n); var s = wh(); return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, ht(r) ? (s = !0, Ha(e)) : s = !1, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, gh(e), i.updater = Dl, e.stateNode = i, i._reactInternals = e, Zc(e, r, t, n), e = nd(null, e, r, !0, s, n)) : (e.tag = 0, be && s && lh(e), nt(null, e, i, n), e = e.child), e; case 16: r = e.elementType; e: { switch (wa(t, e), t = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = Px(r), t = Vt(r, t), i) { case 0: e = td(null, e, r, t, n); break e; case 1: e = Ep(null, e, r, t, n); break e; case 11: e = Op(null, e, r, t, n); break e; case 14: e = Pp(null, e, r, Vt(r.type, t), n); break e }throw Error(U(306, r, "")) } return e; case 0: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Vt(r, i), td(t, e, r, i, n); case 1: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Vt(r, i), Ep(t, e, r, i, n); case 3: e: { if (n0(e), t === null) throw Error(U(387)); r = e.pendingProps, s = e.memoizedState, i = s.element, Ty(t, e), Ya(e, r, null, n); var o = e.memoizedState; if (r = o.element, s.isDehydrated) if (s = { element: r, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) { i = Pi(Error(U(423)), e), e = Tp(t, e, r, n, i); break e } else if (r !== i) { i = Pi(Error(U(424)), e), e = Tp(t, e, r, n, i); break e } else for (yt = Gn(e.stateNode.containerInfo.firstChild), wt = e, be = !0, Ht = null, n = Py(e, null, r, n), e.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (ki(), r === i) { e = Cn(t, e, n); break e } nt(t, e, r, n) } e = e.child } return e; case 5: return Iy(e), t === null && Qc(e), r = e.type, i = e.pendingProps, s = t !== null ? t.memoizedProps : null, o = i.children, Wc(r, i) ? o = null : s !== null && Wc(r, s) && (e.flags |= 32), t0(t, e), nt(t, e, o, n), e.child; case 6: return t === null && Qc(e), null; case 13: return r0(t, e, n); case 4: return mh(e, e.stateNode.containerInfo), r = e.pendingProps, t === null ? e.child = Ci(e, null, r, n) : nt(t, e, r, n), e.child; case 11: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Vt(r, i), Op(t, e, r, i, n); case 7: return nt(t, e, e.pendingProps, n), e.child; case 8: return nt(t, e, e.pendingProps.children, n), e.child; case 12: return nt(t, e, e.pendingProps.children, n), e.child; case 10: e: { if (r = e.type._context, i = e.pendingProps, s = e.memoizedProps, o = i.value, me(Ka, r._currentValue), r._currentValue = o, s !== null) if (Gt(s.value, o)) { if (s.children === i.children && !dt.current) { e = Cn(t, e, n); break e } } else for (s = e.child, s !== null && (s.return = e); s !== null;) { var a = s.dependencies; if (a !== null) { o = s.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (s.tag === 1) { l = _n(-1, n & -n), l.tag = 2; var u = s.updateQueue; if (u !== null) { u = u.shared; var c = u.pending; c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l } } s.lanes |= n, l = s.alternate, l !== null && (l.lanes |= n), Xc(s.return, n, e), a.lanes |= n; break } l = l.next } } else if (s.tag === 10) o = s.type === e.type ? null : s.child; else if (s.tag === 18) { if (o = s.return, o === null) throw Error(U(341)); o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), Xc(o, n, e), o = s.sibling } else o = s.child; if (o !== null) o.return = s; else for (o = s; o !== null;) { if (o === e) { o = null; break } if (s = o.sibling, s !== null) { s.return = o.return, o = s; break } o = o.return } s = o } nt(t, e, i.children, n), e = e.child } return e; case 9: return i = e.type, r = e.pendingProps.children, vi(e, n), i = jt(i), r = r(i), e.flags |= 1, nt(t, e, r, n), e.child; case 14: return r = e.type, i = Vt(r, e.pendingProps), i = Vt(r.type, i), Pp(t, e, r, i, n); case 15: return Zy(t, e, e.type, e.pendingProps, n); case 17: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Vt(r, i), wa(t, e), e.tag = 1, ht(r) ? (t = !0, Ha(e)) : t = !1, vi(e, n), Qy(e, r, i), Zc(e, r, i, n), nd(null, e, r, !0, t, n); case 19: return i0(t, e, n); case 22: return e0(t, e, n) }throw Error(U(156, e.tag)) }; function _0(t, e) { return Kv(t, e) } function Ox(t, e, n, r) { this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Mt(t, e, n, r) { return new Ox(t, e, n, r) } function Rh(t) { return t = t.prototype, !(!t || !t.isReactComponent) } function Px(t) { if (typeof t == "function") return Rh(t) ? 1 : 0; if (t != null) { if (t = t.$$typeof, t === Qd) return 11; if (t === Xd) return 14 } return 2 } function Jn(t, e) { var n = t.alternate; return n === null ? (n = Mt(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n } function ka(t, e, n, r, i, s) { var o = 2; if (r = t, typeof t == "function") Rh(t) && (o = 1); else if (typeof t == "string") o = 5; else e: switch (t) { case ei: return Pr(n.children, i, s, e); case Yd: o = 8, i |= 8; break; case xc: return t = Mt(12, n, e, i | 2), t.elementType = xc, t.lanes = s, t; case kc: return t = Mt(13, n, e, i), t.elementType = kc, t.lanes = s, t; case Cc: return t = Mt(19, n, e, i), t.elementType = Cc, t.lanes = s, t; case Iv: return Nl(n, i, s, e); default: if (typeof t == "object" && t !== null) switch (t.$$typeof) { case Ev: o = 10; break e; case Tv: o = 9; break e; case Qd: o = 11; break e; case Xd: o = 14; break e; case Mn: o = 16, r = null; break e }throw Error(U(130, t == null ? t : typeof t, "")) }return e = Mt(o, n, e, i), e.elementType = t, e.type = r, e.lanes = s, e } function Pr(t, e, n, r) { return t = Mt(7, t, r, e), t.lanes = n, t } function Nl(t, e, n, r) { return t = Mt(22, t, r, e), t.elementType = Iv, t.lanes = n, t.stateNode = { isHidden: !1 }, t } function Wu(t, e, n) { return t = Mt(6, t, null, e), t.lanes = n, t } function qu(t, e, n) { return e = Mt(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, e } function Ex(t, e, n, r, i) { this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ou(0), this.expirationTimes = Ou(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ou(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function Mh(t, e, n, r, i, s, o, a, l) { return t = new Ex(t, e, n, a, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = Mt(3, null, null, e), t.current = s, s.stateNode = t, s.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, gh(s), t } function Tx(t, e, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Zr, key: r == null ? null : "" + r, children: t, containerInfo: e, implementation: n } } function w0(t) { if (!t) return rr; t = t._reactInternals; e: { if ($r(t) !== t || t.tag !== 1) throw Error(U(170)); var e = t; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if (ht(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(U(171)) } if (t.tag === 1) { var n = t.type; if (ht(n)) return wy(t, n, e) } return e } function S0(t, e, n, r, i, s, o, a, l) { return t = Mh(n, r, !0, t, i, s, o, a, l), t.context = w0(null), n = t.current, r = rt(), i = Xn(n), s = _n(r, i), s.callback = e ?? null, Yn(n, s, i), t.current.lanes = i, co(t, i, r), ft(t, r), t } function Fl(t, e, n, r) { var i = e.current, s = rt(), o = Xn(i); return n = w0(n), e.context === null ? e.context = n : e.pendingContext = n, e = _n(s, o), e.payload = { element: t }, r = r === void 0 ? null : r, r !== null && (e.callback = r), t = Yn(i, e, o), t !== null && (Kt(t, i, o, s), ya(t, i, o)), o } function rl(t) { if (t = t.current, !t.child) return null; switch (t.child.tag) { case 5: return t.child.stateNode; default: return t.child.stateNode } } function $p(t, e) { if (t = t.memoizedState, t !== null && t.dehydrated !== null) { var n = t.retryLane; t.retryLane = n !== 0 && n < e ? n : e } } function Lh(t, e) { $p(t, e), (t = t.alternate) && $p(t, e) } function Ix() { return null } var x0 = typeof reportError == "function" ? reportError : function (t) { console.error(t) }; function Dh(t) { this._internalRoot = t } $l.prototype.render = Dh.prototype.render = function (t) { var e = this._internalRoot; if (e === null) throw Error(U(409)); Fl(t, e, null, null) }; $l.prototype.unmount = Dh.prototype.unmount = function () { var t = this._internalRoot; if (t !== null) { this._internalRoot = null; var e = t.containerInfo; Dr(function () { Fl(null, t, null, null) }), e[xn] = null } }; function $l(t) { this._internalRoot = t } $l.prototype.unstable_scheduleHydration = function (t) { if (t) { var e = ey(); t = { blockedOn: null, target: t, priority: e }; for (var n = 0; n < An.length && e !== 0 && e < An[n].priority; n++); An.splice(n, 0, t), n === 0 && ny(t) } }; function Ah(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) } function zl(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable ")) } function zp() { } function Rx(t, e, n, r, i) { if (i) { if (typeof r == "function") { var s = r; r = function () { var u = rl(o); s.call(u) } } var o = S0(e, r, t, 0, null, !1, !1, "", zp); return t._reactRootContainer = o, t[xn] = o.current, Vs(t.nodeType === 8 ? t.parentNode : t), Dr(), o } for (; i = t.lastChild;)t.removeChild(i); if (typeof r == "function") { var a = r; r = function () { var u = rl(l); a.call(u) } } var l = Mh(t, 0, !1, null, null, !1, !1, "", zp); return t._reactRootContainer = l, t[xn] = l.current, Vs(t.nodeType === 8 ? t.parentNode : t), Dr(function () { Fl(e, l, n, r) }), l } function Vl(t, e, n, r, i) { var s = n._reactRootContainer; if (s) { var o = s; if (typeof i == "function") { var a = i; i = function () { var l = rl(o); a.call(l) } } Fl(e, o, t, i) } else o = Rx(n, e, t, i, r); return rl(o) } Jv = function (t) { switch (t.tag) { case 3: var e = t.stateNode; if (e.current.memoizedState.isDehydrated) { var n = ds(e.pendingLanes); n !== 0 && (eh(e, n | 1), ft(e, Pe()), !(re & 6) && (Ei = Pe() + 500, ar())) } break; case 13: Dr(function () { var r = kn(t, 1); if (r !== null) { var i = rt(); Kt(r, t, 1, i) } }), Lh(t, 1) } }; th = function (t) { if (t.tag === 13) { var e = kn(t, 134217728); if (e !== null) { var n = rt(); Kt(e, t, 134217728, n) } Lh(t, 134217728) } }; Zv = function (t) { if (t.tag === 13) { var e = Xn(t), n = kn(t, e); if (n !== null) { var r = rt(); Kt(n, t, e, r) } Lh(t, e) } }; ey = function () { return de }; ty = function (t, e) { var n = de; try { return de = t, e() } finally { de = n } }; Ac = function (t, e, n) { switch (e) { case "input": if (Ec(t, n), e = n.name, n.type === "radio" && e != null) { for (n = t; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) { var r = n[e]; if (r !== t && r.form === t.form) { var i = Rl(r); if (!i) throw Error(U(90)); Mv(r), Ec(r, i) } } } break; case "textarea": Dv(t, n); break; case "select": e = n.value, e != null && fi(t, !!n.multiple, e, !1) } }; Vv = Eh; Bv = Dr; var Mx = { usingClientEntryPoint: !1, Events: [fo, ii, Rl, $v, zv, Eh] }, Zi = { findFiberByHostInstance: xr, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, Lx = { bundleType: Zi.bundleType, version: Zi.version, rendererPackageName: Zi.rendererPackageName, rendererConfig: Zi.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Pn.ReactCurrentDispatcher, findHostInstanceByFiber: function (t) { return t = Wv(t), t === null ? null : t.stateNode }, findFiberByHostInstance: Zi.findFiberByHostInstance || Ix, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Vo = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Vo.isDisabled && Vo.supportsFiber) try { Pl = Vo.inject(Lx), sn = Vo } catch { } } kt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Mx; kt.createPortal = function (t, e) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Ah(e)) throw Error(U(200)); return Tx(t, e, null, n) }; kt.createRoot = function (t, e) { if (!Ah(t)) throw Error(U(299)); var n = !1, r = "", i = x0; return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = Mh(t, 1, !1, null, null, n, !1, r, i), t[xn] = e.current, Vs(t.nodeType === 8 ? t.parentNode : t), new Dh(e) }; kt.findDOMNode = function (t) { if (t == null) return null; if (t.nodeType === 1) return t; var e = t._reactInternals; if (e === void 0) throw typeof t.render == "function" ? Error(U(188)) : (t = Object.keys(t).join(","), Error(U(268, t))); return t = Wv(e), t = t === null ? null : t.stateNode, t }; kt.flushSync = function (t) { return Dr(t) }; kt.hydrate = function (t, e, n) { if (!zl(e)) throw Error(U(200)); return Vl(null, t, e, !0, n) }; kt.hydrateRoot = function (t, e, n) { if (!Ah(t)) throw Error(U(405)); var r = n != null && n.hydratedSources || null, i = !1, s = "", o = x0; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), e = S0(e, null, t, 1, n ?? null, i, !1, s, o), t[xn] = e.current, Vs(t), r) for (t = 0; t < r.length; t++)n = r[t], i = n._getVersion, i = i(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, i] : e.mutableSourceEagerHydrationData.push(n, i); return new $l(e) }; kt.render = function (t, e, n) { if (!zl(e)) throw Error(U(200)); return Vl(null, t, e, !1, n) }; kt.unmountComponentAtNode = function (t) { if (!zl(t)) throw Error(U(40)); return t._reactRootContainer ? (Dr(function () { Vl(null, null, t, !1, function () { t._reactRootContainer = null, t[xn] = null }) }), !0) : !1 }; kt.unstable_batchedUpdates = Eh; kt.unstable_renderSubtreeIntoContainer = function (t, e, n, r) { if (!zl(n)) throw Error(U(200)); if (t == null || t._reactInternals === void 0) throw Error(U(38)); return Vl(t, e, n, !1, r) }; kt.version = "18.3.1-next-f1338f8080-20240426"; function k0() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(k0) } catch (t) { console.error(t) } } k0(), kv.exports = kt; var C0 = kv.exports, O0, Vp = C0; O0 = Vp.createRoot, Vp.hydrateRoot;/**
 * @remix-run/router v1.18.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Qs() { return Qs = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Qs.apply(this, arguments) } var zn; (function (t) { t.Pop = "POP", t.Push = "PUSH", t.Replace = "REPLACE" })(zn || (zn = {})); const Bp = "popstate"; function Dx(t) { t === void 0 && (t = {}); function e(r, i) { let { pathname: s, search: o, hash: a } = r.location; return pd("", { pathname: s, search: o, hash: a }, i.state && i.state.usr || null, i.state && i.state.key || "default") } function n(r, i) { return typeof i == "string" ? i : il(i) } return jx(e, n, null, t) } function Ee(t, e) { if (t === !1 || t === null || typeof t > "u") throw new Error(e) } function P0(t, e) { if (!t) { typeof console < "u" && console.warn(e); try { throw new Error(e) } catch { } } } function Ax() { return Math.random().toString(36).substr(2, 8) } function Up(t, e) { return { usr: t.state, key: t.key, idx: e } } function pd(t, e, n, r) { return n === void 0 && (n = null), Qs({ pathname: typeof t == "string" ? t : t.pathname, search: "", hash: "" }, typeof e == "string" ? Fi(e) : e, { state: n, key: e && e.key || r || Ax() }) } function il(t) { let { pathname: e = "/", search: n = "", hash: r = "" } = t; return n && n !== "?" && (e += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r), e } function Fi(t) { let e = {}; if (t) { let n = t.indexOf("#"); n >= 0 && (e.hash = t.substr(n), t = t.substr(0, n)); let r = t.indexOf("?"); r >= 0 && (e.search = t.substr(r), t = t.substr(0, r)), t && (e.pathname = t) } return e } function jx(t, e, n, r) { r === void 0 && (r = {}); let { window: i = document.defaultView, v5Compat: s = !1 } = r, o = i.history, a = zn.Pop, l = null, u = c(); u == null && (u = 0, o.replaceState(Qs({}, o.state, { idx: u }), "")); function c() { return (o.state || { idx: null }).idx } function d() { a = zn.Pop; let y = c(), p = y == null ? null : y - u; u = y, l && l({ action: a, location: m.location, delta: p }) } function h(y, p) { a = zn.Push; let v = pd(m.location, y, p); u = c() + 1; let b = Up(v, u), S = m.createHref(v); try { o.pushState(b, "", S) } catch (P) { if (P instanceof DOMException && P.name === "DataCloneError") throw P; i.location.assign(S) } s && l && l({ action: a, location: m.location, delta: 1 }) } function f(y, p) { a = zn.Replace; let v = pd(m.location, y, p); u = c(); let b = Up(v, u), S = m.createHref(v); o.replaceState(b, "", S), s && l && l({ action: a, location: m.location, delta: 0 }) } function g(y) { let p = i.location.origin !== "null" ? i.location.origin : i.location.href, v = typeof y == "string" ? y : il(y); return v = v.replace(/ $/, "%20"), Ee(p, "No window.location.(origin|href) available to create URL for href: " + v), new URL(v, p) } let m = { get action() { return a }, get location() { return t(i, o) }, listen(y) { if (l) throw new Error("A history only accepts one active listener"); return i.addEventListener(Bp, d), l = y, () => { i.removeEventListener(Bp, d), l = null } }, createHref(y) { return e(i, y) }, createURL: g, encodeLocation(y) { let p = g(y); return { pathname: p.pathname, search: p.search, hash: p.hash } }, push: h, replace: f, go(y) { return o.go(y) } }; return m } var Hp; (function (t) { t.data = "data", t.deferred = "deferred", t.redirect = "redirect", t.error = "error" })(Hp || (Hp = {})); function Nx(t, e, n) { return n === void 0 && (n = "/"), Fx(t, e, n, !1) } function Fx(t, e, n, r) { let i = typeof e == "string" ? Fi(e) : e, s = jh(i.pathname || "/", n); if (s == null) return null; let o = E0(t); $x(o); let a = null; for (let l = 0; a == null && l < o.length; ++l) { let u = Qx(s); a = Gx(o[l], u, r) } return a } function E0(t, e, n, r) { e === void 0 && (e = []), n === void 0 && (n = []), r === void 0 && (r = ""); let i = (s, o, a) => { let l = { relativePath: a === void 0 ? s.path || "" : a, caseSensitive: s.caseSensitive === !0, childrenIndex: o, route: s }; l.relativePath.startsWith("/") && (Ee(l.relativePath.startsWith(r), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(r.length)); let u = Zn([r, l.relativePath]), c = n.concat(l); s.children && s.children.length > 0 && (Ee(s.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + u + '".')), E0(s.children, e, c, u)), !(s.path == null && !s.index) && e.push({ path: u, score: qx(u, s.index), routesMeta: c }) }; return t.forEach((s, o) => { var a; if (s.path === "" || !((a = s.path) != null && a.includes("?"))) i(s, o); else for (let l of T0(s.path)) i(s, o, l) }), e } function T0(t) { let e = t.split("/"); if (e.length === 0) return []; let [n, ...r] = e, i = n.endsWith("?"), s = n.replace(/\?$/, ""); if (r.length === 0) return i ? [s, ""] : [s]; let o = T0(r.join("/")), a = []; return a.push(...o.map(l => l === "" ? s : [s, l].join("/"))), i && a.push(...o), a.map(l => t.startsWith("/") && l === "" ? "/" : l) } function $x(t) { t.sort((e, n) => e.score !== n.score ? n.score - e.score : Kx(e.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex))) } const zx = /^:[\w-]+$/, Vx = 3, Bx = 2, Ux = 1, Hx = 10, Wx = -2, Wp = t => t === "*"; function qx(t, e) { let n = t.split("/"), r = n.length; return n.some(Wp) && (r += Wx), e && (r += Bx), n.filter(i => !Wp(i)).reduce((i, s) => i + (zx.test(s) ? Vx : s === "" ? Ux : Hx), r) } function Kx(t, e) { return t.length === e.length && t.slice(0, -1).every((r, i) => r === e[i]) ? t[t.length - 1] - e[e.length - 1] : 0 } function Gx(t, e, n) { let { routesMeta: r } = t, i = {}, s = "/", o = []; for (let a = 0; a < r.length; ++a) { let l = r[a], u = a === r.length - 1, c = s === "/" ? e : e.slice(s.length) || "/", d = qp({ path: l.relativePath, caseSensitive: l.caseSensitive, end: u }, c), h = l.route; if (!d && u && n && !r[r.length - 1].route.index && (d = qp({ path: l.relativePath, caseSensitive: l.caseSensitive, end: !1 }, c)), !d) return null; Object.assign(i, d.params), o.push({ params: i, pathname: Zn([s, d.pathname]), pathnameBase: e1(Zn([s, d.pathnameBase])), route: h }), d.pathnameBase !== "/" && (s = Zn([s, d.pathnameBase])) } return o } function qp(t, e) { typeof t == "string" && (t = { path: t, caseSensitive: !1, end: !0 }); let [n, r] = Yx(t.path, t.caseSensitive, t.end), i = e.match(n); if (!i) return null; let s = i[0], o = s.replace(/(.)\/+$/, "$1"), a = i.slice(1); return { params: r.reduce((u, c, d) => { let { paramName: h, isOptional: f } = c; if (h === "*") { let m = a[d] || ""; o = s.slice(0, s.length - m.length).replace(/(.)\/+$/, "$1") } const g = a[d]; return f && !g ? u[h] = void 0 : u[h] = (g || "").replace(/%2F/g, "/"), u }, {}), pathname: s, pathnameBase: o, pattern: t } } function Yx(t, e, n) { e === void 0 && (e = !1), n === void 0 && (n = !0), P0(t === "*" || !t.endsWith("*") || t.endsWith("/*"), 'Route path "' + t + '" will be treated as if it were ' + ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + t.replace(/\*$/, "/*") + '".')); let r = [], i = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, a, l) => (r.push({ paramName: a, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")); return t.endsWith("*") ? (r.push({ paramName: "*" }), i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : t !== "" && t !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, e ? void 0 : "i"), r] } function Qx(t) { try { return t.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/") } catch (e) { return P0(!1, 'The URL path "' + t + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), t } } function jh(t, e) { if (e === "/") return t; if (!t.toLowerCase().startsWith(e.toLowerCase())) return null; let n = e.endsWith("/") ? e.length - 1 : e.length, r = t.charAt(n); return r && r !== "/" ? null : t.slice(n) || "/" } function Xx(t, e) { e === void 0 && (e = "/"); let { pathname: n, search: r = "", hash: i = "" } = typeof t == "string" ? Fi(t) : t; return { pathname: n ? n.startsWith("/") ? n : Jx(n, e) : e, search: t1(r), hash: n1(i) } } function Jx(t, e) { let n = e.replace(/\/+$/, "").split("/"); return t.split("/").forEach(i => { i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i) }), n.length > 1 ? n.join("/") : "/" } function Ku(t, e, n, r) { return "Cannot include a '" + t + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function Zx(t) { return t.filter((e, n) => n === 0 || e.route.path && e.route.path.length > 0) } function Nh(t, e) { let n = Zx(t); return e ? n.map((r, i) => i === n.length - 1 ? r.pathname : r.pathnameBase) : n.map(r => r.pathnameBase) } function Fh(t, e, n, r) { r === void 0 && (r = !1); let i; typeof t == "string" ? i = Fi(t) : (i = Qs({}, t), Ee(!i.pathname || !i.pathname.includes("?"), Ku("?", "pathname", "search", i)), Ee(!i.pathname || !i.pathname.includes("#"), Ku("#", "pathname", "hash", i)), Ee(!i.search || !i.search.includes("#"), Ku("#", "search", "hash", i))); let s = t === "" || i.pathname === "", o = s ? "/" : i.pathname, a; if (o == null) a = n; else { let d = e.length - 1; if (!r && o.startsWith("..")) { let h = o.split("/"); for (; h[0] === "..";)h.shift(), d -= 1; i.pathname = h.join("/") } a = d >= 0 ? e[d] : "/" } let l = Xx(i, a), u = o && o !== "/" && o.endsWith("/"), c = (s || o === ".") && n.endsWith("/"); return !l.pathname.endsWith("/") && (u || c) && (l.pathname += "/"), l } const Zn = t => t.join("/").replace(/\/\/+/g, "/"), e1 = t => t.replace(/\/+$/, "").replace(/^\/*/, "/"), t1 = t => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t, n1 = t => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t; function r1(t) { return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.internal == "boolean" && "data" in t } const I0 = ["post", "put", "patch", "delete"]; new Set(I0); const i1 = ["get", ...I0]; new Set(i1);/**
 * React Router v6.25.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Xs() { return Xs = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Xs.apply(this, arguments) } const $h = R.createContext(null), s1 = R.createContext(null), lr = R.createContext(null), Bl = R.createContext(null), ur = R.createContext({ outlet: null, matches: [], isDataRoute: !1 }), R0 = R.createContext(null); function o1(t, e) { let { relative: n } = e === void 0 ? {} : e; $i() || Ee(!1); let { basename: r, navigator: i } = R.useContext(lr), { hash: s, pathname: o, search: a } = L0(t, { relative: n }), l = o; return r !== "/" && (l = o === "/" ? r : Zn([r, o])), i.createHref({ pathname: l, search: a, hash: s }) } function $i() { return R.useContext(Bl) != null } function go() { return $i() || Ee(!1), R.useContext(Bl).location } function M0(t) { R.useContext(lr).static || R.useLayoutEffect(t) } function Ul() { let { isDataRoute: t } = R.useContext(ur); return t ? b1() : a1() } function a1() { $i() || Ee(!1); let t = R.useContext($h), { basename: e, future: n, navigator: r } = R.useContext(lr), { matches: i } = R.useContext(ur), { pathname: s } = go(), o = JSON.stringify(Nh(i, n.v7_relativeSplatPath)), a = R.useRef(!1); return M0(() => { a.current = !0 }), R.useCallback(function (u, c) { if (c === void 0 && (c = {}), !a.current) return; if (typeof u == "number") { r.go(u); return } let d = Fh(u, JSON.parse(o), s, c.relative === "path"); t == null && e !== "/" && (d.pathname = d.pathname === "/" ? e : Zn([e, d.pathname])), (c.replace ? r.replace : r.push)(d, c.state, c) }, [e, r, o, s, t]) } function L0(t, e) { let { relative: n } = e === void 0 ? {} : e, { future: r } = R.useContext(lr), { matches: i } = R.useContext(ur), { pathname: s } = go(), o = JSON.stringify(Nh(i, r.v7_relativeSplatPath)); return R.useMemo(() => Fh(t, JSON.parse(o), s, n === "path"), [t, o, s, n]) } function l1(t, e) { return u1(t, e) } function u1(t, e, n, r) { $i() || Ee(!1); let { navigator: i } = R.useContext(lr), { matches: s } = R.useContext(ur), o = s[s.length - 1], a = o ? o.params : {}; o && o.pathname; let l = o ? o.pathnameBase : "/"; o && o.route; let u = go(), c; if (e) { var d; let y = typeof e == "string" ? Fi(e) : e; l === "/" || (d = y.pathname) != null && d.startsWith(l) || Ee(!1), c = y } else c = u; let h = c.pathname || "/", f = h; if (l !== "/") { let y = l.replace(/^\//, "").split("/"); f = "/" + h.replace(/^\//, "").split("/").slice(y.length).join("/") } let g = Nx(t, { pathname: f }), m = p1(g && g.map(y => Object.assign({}, y, { params: Object.assign({}, a, y.params), pathname: Zn([l, i.encodeLocation ? i.encodeLocation(y.pathname).pathname : y.pathname]), pathnameBase: y.pathnameBase === "/" ? l : Zn([l, i.encodeLocation ? i.encodeLocation(y.pathnameBase).pathname : y.pathnameBase]) })), s, n, r); return e && m ? R.createElement(Bl.Provider, { value: { location: Xs({ pathname: "/", search: "", hash: "", state: null, key: "default" }, c), navigationType: zn.Pop } }, m) : m } function c1() { let t = y1(), e = r1(t) ? t.status + " " + t.statusText : t instanceof Error ? t.message : JSON.stringify(t), n = t instanceof Error ? t.stack : null, i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return R.createElement(R.Fragment, null, R.createElement("h2", null, "Unexpected Application Error!"), R.createElement("h3", { style: { fontStyle: "italic" } }, e), n ? R.createElement("pre", { style: i }, n) : null, null) } const d1 = R.createElement(c1, null); class h1 extends R.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, n) { return n.location !== e.location || n.revalidation !== "idle" && e.revalidation === "idle" ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: e.error !== void 0 ? e.error : n.error, location: n.location, revalidation: e.revalidation || n.revalidation } } componentDidCatch(e, n) { console.error("React Router caught the following error during render", e, n) } render() { return this.state.error !== void 0 ? R.createElement(ur.Provider, { value: this.props.routeContext }, R.createElement(R0.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function f1(t) { let { routeContext: e, match: n, children: r } = t, i = R.useContext($h); return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id), R.createElement(ur.Provider, { value: e }, r) } function p1(t, e, n, r) { var i; if (e === void 0 && (e = []), n === void 0 && (n = null), r === void 0 && (r = null), t == null) { var s; if ((s = n) != null && s.errors) t = n.matches; else return null } let o = t, a = (i = n) == null ? void 0 : i.errors; if (a != null) { let c = o.findIndex(d => d.route.id && (a == null ? void 0 : a[d.route.id]) !== void 0); c >= 0 || Ee(!1), o = o.slice(0, Math.min(o.length, c + 1)) } let l = !1, u = -1; if (n && r && r.v7_partialHydration) for (let c = 0; c < o.length; c++) { let d = o[c]; if ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (u = c), d.route.id) { let { loaderData: h, errors: f } = n, g = d.route.loader && h[d.route.id] === void 0 && (!f || f[d.route.id] === void 0); if (d.route.lazy || g) { l = !0, u >= 0 ? o = o.slice(0, u + 1) : o = [o[0]]; break } } } return o.reduceRight((c, d, h) => { let f, g = !1, m = null, y = null; n && (f = a && d.route.id ? a[d.route.id] : void 0, m = d.route.errorElement || d1, l && (u < 0 && h === 0 ? (g = !0, y = null) : u === h && (g = !0, y = d.route.hydrateFallbackElement || null))); let p = e.concat(o.slice(0, h + 1)), v = () => { let b; return f ? b = m : g ? b = y : d.route.Component ? b = R.createElement(d.route.Component, null) : d.route.element ? b = d.route.element : b = c, R.createElement(f1, { match: d, routeContext: { outlet: c, matches: p, isDataRoute: n != null }, children: b }) }; return n && (d.route.ErrorBoundary || d.route.errorElement || h === 0) ? R.createElement(h1, { location: n.location, revalidation: n.revalidation, component: m, error: f, children: v(), routeContext: { outlet: null, matches: p, isDataRoute: !0 } }) : v() }, null) } var D0 = function (t) { return t.UseBlocker = "useBlocker", t.UseRevalidator = "useRevalidator", t.UseNavigateStable = "useNavigate", t }(D0 || {}), sl = function (t) { return t.UseBlocker = "useBlocker", t.UseLoaderData = "useLoaderData", t.UseActionData = "useActionData", t.UseRouteError = "useRouteError", t.UseNavigation = "useNavigation", t.UseRouteLoaderData = "useRouteLoaderData", t.UseMatches = "useMatches", t.UseRevalidator = "useRevalidator", t.UseNavigateStable = "useNavigate", t.UseRouteId = "useRouteId", t }(sl || {}); function g1(t) { let e = R.useContext($h); return e || Ee(!1), e } function m1(t) { let e = R.useContext(s1); return e || Ee(!1), e } function v1(t) { let e = R.useContext(ur); return e || Ee(!1), e } function A0(t) { let e = v1(), n = e.matches[e.matches.length - 1]; return n.route.id || Ee(!1), n.route.id } function y1() { var t; let e = R.useContext(R0), n = m1(sl.UseRouteError), r = A0(sl.UseRouteError); return e !== void 0 ? e : (t = n.errors) == null ? void 0 : t[r] } function b1() { let { router: t } = g1(D0.UseNavigateStable), e = A0(sl.UseNavigateStable), n = R.useRef(!1); return M0(() => { n.current = !0 }), R.useCallback(function (i, s) { s === void 0 && (s = {}), n.current && (typeof i == "number" ? t.navigate(i) : t.navigate(i, Xs({ fromRouteId: e }, s))) }, [t, e]) } function cr(t) { let { to: e, replace: n, state: r, relative: i } = t; $i() || Ee(!1); let { future: s, static: o } = R.useContext(lr), { matches: a } = R.useContext(ur), { pathname: l } = go(), u = Ul(), c = Fh(e, Nh(a, s.v7_relativeSplatPath), l, i === "path"), d = JSON.stringify(c); return R.useEffect(() => u(JSON.parse(d), { replace: n, state: r, relative: i }), [u, d, i, n, r]), null } function hn(t) { Ee(!1) } function _1(t) { let { basename: e = "/", children: n = null, location: r, navigationType: i = zn.Pop, navigator: s, static: o = !1, future: a } = t; $i() && Ee(!1); let l = e.replace(/^\/*/, "/"), u = R.useMemo(() => ({ basename: l, navigator: s, static: o, future: Xs({ v7_relativeSplatPath: !1 }, a) }), [l, a, s, o]); typeof r == "string" && (r = Fi(r)); let { pathname: c = "/", search: d = "", hash: h = "", state: f = null, key: g = "default" } = r, m = R.useMemo(() => { let y = jh(c, l); return y == null ? null : { location: { pathname: y, search: d, hash: h, state: f, key: g }, navigationType: i } }, [l, c, d, h, f, g, i]); return m == null ? null : R.createElement(lr.Provider, { value: u }, R.createElement(Bl.Provider, { children: n, value: m })) } function w1(t) { let { children: e, location: n } = t; return l1(gd(e), n) } new Promise(() => { }); function gd(t, e) { e === void 0 && (e = []); let n = []; return R.Children.forEach(t, (r, i) => { if (!R.isValidElement(r)) return; let s = [...e, i]; if (r.type === R.Fragment) { n.push.apply(n, gd(r.props.children, s)); return } r.type !== hn && Ee(!1), !r.props.index || !r.props.children || Ee(!1); let o = { id: r.props.id || s.join("-"), caseSensitive: r.props.caseSensitive, element: r.props.element, Component: r.props.Component, index: r.props.index, path: r.props.path, loader: r.props.loader, action: r.props.action, errorElement: r.props.errorElement, ErrorBoundary: r.props.ErrorBoundary, hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null, shouldRevalidate: r.props.shouldRevalidate, handle: r.props.handle, lazy: r.props.lazy }; r.props.children && (o.children = gd(r.props.children, s)), n.push(o) }), n }/**
 * React Router DOM v6.25.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function md() { return md = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, md.apply(this, arguments) } function S1(t, e) { if (t == null) return {}; var n = {}, r = Object.keys(t), i, s; for (s = 0; s < r.length; s++)i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]); return n } function x1(t) { return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) } function k1(t, e) { return t.button === 0 && (!e || e === "_self") && !x1(t) } const C1 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"], O1 = "6"; try { window.__reactRouterVersion = O1 } catch { } const P1 = "startTransition", Kp = wc[P1]; function E1(t) { let { basename: e, children: n, future: r, window: i } = t, s = R.useRef(); s.current == null && (s.current = Dx({ window: i, v5Compat: !0 })); let o = s.current, [a, l] = R.useState({ action: o.action, location: o.location }), { v7_startTransition: u } = r || {}, c = R.useCallback(d => { u && Kp ? Kp(() => l(d)) : l(d) }, [l, u]); return R.useLayoutEffect(() => o.listen(c), [o, c]), R.createElement(_1, { basename: e, children: n, location: a.location, navigationType: a.action, navigator: o, future: r }) } const T1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", I1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Jr = R.forwardRef(function (e, n) { let { onClick: r, relative: i, reloadDocument: s, replace: o, state: a, target: l, to: u, preventScrollReset: c, unstable_viewTransition: d } = e, h = S1(e, C1), { basename: f } = R.useContext(lr), g, m = !1; if (typeof u == "string" && I1.test(u) && (g = u, T1)) try { let b = new URL(window.location.href), S = u.startsWith("//") ? new URL(b.protocol + u) : new URL(u), P = jh(S.pathname, f); S.origin === b.origin && P != null ? u = P + S.search + S.hash : m = !0 } catch { } let y = o1(u, { relative: i }), p = R1(u, { replace: o, state: a, target: l, preventScrollReset: c, relative: i, unstable_viewTransition: d }); function v(b) { r && r(b), b.defaultPrevented || p(b) } return R.createElement("a", md({}, h, { href: g || y, onClick: m || s ? r : v, ref: n, target: l })) }); var Gp; (function (t) { t.UseScrollRestoration = "useScrollRestoration", t.UseSubmit = "useSubmit", t.UseSubmitFetcher = "useSubmitFetcher", t.UseFetcher = "useFetcher", t.useViewTransitionState = "useViewTransitionState" })(Gp || (Gp = {})); var Yp; (function (t) { t.UseFetcher = "useFetcher", t.UseFetchers = "useFetchers", t.UseScrollRestoration = "useScrollRestoration" })(Yp || (Yp = {})); function R1(t, e) { let { target: n, replace: r, state: i, preventScrollReset: s, relative: o, unstable_viewTransition: a } = e === void 0 ? {} : e, l = Ul(), u = go(), c = L0(t, { relative: o }); return R.useCallback(d => { if (k1(d, n)) { d.preventDefault(); let h = r !== void 0 ? r : il(u) === il(c); l(t, { replace: h, state: i, preventScrollReset: s, relative: o, unstable_viewTransition: a }) } }, [u, l, c, r, i, n, t, s, o, a]) } const M1 = "modulepreload", L1 = function (t) { return "/" + t }, Qp = {}, Ti = function (e, n, r) { let i = Promise.resolve(); if (n && n.length > 0) { document.getElementsByTagName("link"); const s = document.querySelector("meta[property=csp-nonce]"), o = (s == null ? void 0 : s.nonce) || (s == null ? void 0 : s.getAttribute("nonce")); i = Promise.all(n.map(a => { if (a = L1(a), a in Qp) return; Qp[a] = !0; const l = a.endsWith(".css"), u = l ? '[rel="stylesheet"]' : ""; if (document.querySelector(`link[href="${a}"]${u}`)) return; const c = document.createElement("link"); if (c.rel = l ? "stylesheet" : M1, l || (c.as = "script", c.crossOrigin = ""), c.href = a, o && c.setAttribute("nonce", o), document.head.appendChild(c), l) return new Promise((d, h) => { c.addEventListener("load", d), c.addEventListener("error", () => h(new Error(`Unable to preload CSS for ${a}`))) }) })) } return i.then(() => e()).catch(s => { const o = new Event("vite:preloadError", { cancelable: !0 }); if (o.payload = s, window.dispatchEvent(o), !o.defaultPrevented) throw s }) }, D1 = t => { let e; return t ? e = t : typeof fetch > "u" ? e = (...n) => Ti(async () => { const { default: r } = await Promise.resolve().then(() => zi); return { default: r } }, void 0).then(({ default: r }) => r(...n)) : e = fetch, (...n) => e(...n) }; class zh extends Error { constructor(e, n = "FunctionsError", r) { super(e), this.name = n, this.context = r } } class A1 extends zh { constructor(e) { super("Failed to send a request to the Edge Function", "FunctionsFetchError", e) } } class j1 extends zh { constructor(e) { super("Relay Error invoking the Edge Function", "FunctionsRelayError", e) } } class N1 extends zh { constructor(e) { super("Edge Function returned a non-2xx status code", "FunctionsHttpError", e) } } var vd; (function (t) { t.Any = "any", t.ApNortheast1 = "ap-northeast-1", t.ApNortheast2 = "ap-northeast-2", t.ApSouth1 = "ap-south-1", t.ApSoutheast1 = "ap-southeast-1", t.ApSoutheast2 = "ap-southeast-2", t.CaCentral1 = "ca-central-1", t.EuCentral1 = "eu-central-1", t.EuWest1 = "eu-west-1", t.EuWest2 = "eu-west-2", t.EuWest3 = "eu-west-3", t.SaEast1 = "sa-east-1", t.UsEast1 = "us-east-1", t.UsWest1 = "us-west-1", t.UsWest2 = "us-west-2" })(vd || (vd = {})); var F1 = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; class $1 { constructor(e, { headers: n = {}, customFetch: r, region: i = vd.Any } = {}) { this.url = e, this.headers = n, this.region = i, this.fetch = D1(r) } setAuth(e) { this.headers.Authorization = `Bearer ${e}` } invoke(e, n = {}) { var r; return F1(this, void 0, void 0, function* () { try { const { headers: i, method: s, body: o } = n; let a = {}, { region: l } = n; l || (l = this.region), l && l !== "any" && (a["x-region"] = l); let u; o && (i && !Object.prototype.hasOwnProperty.call(i, "Content-Type") || !i) && (typeof Blob < "u" && o instanceof Blob || o instanceof ArrayBuffer ? (a["Content-Type"] = "application/octet-stream", u = o) : typeof o == "string" ? (a["Content-Type"] = "text/plain", u = o) : typeof FormData < "u" && o instanceof FormData ? u = o : (a["Content-Type"] = "application/json", u = JSON.stringify(o))); const c = yield this.fetch(`${this.url}/${e}`, { method: s || "POST", headers: Object.assign(Object.assign(Object.assign({}, a), this.headers), i), body: u }).catch(g => { throw new A1(g) }), d = c.headers.get("x-relay-error"); if (d && d === "true") throw new j1(c); if (!c.ok) throw new N1(c); let h = ((r = c.headers.get("Content-Type")) !== null && r !== void 0 ? r : "text/plain").split(";")[0].trim(), f; return h === "application/json" ? f = yield c.json() : h === "application/octet-stream" ? f = yield c.blob() : h === "text/event-stream" ? f = c : h === "multipart/form-data" ? f = yield c.formData() : f = yield c.text(), { data: f, error: null } } catch (i) { return { data: null, error: i } } }) } } var Rt = {}, Vh = {}, Hl = {}, mo = {}, Wl = {}, ql = {}, z1 = function () { if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("unable to locate global object") }, Ii = z1(); const V1 = Ii.fetch, j0 = Ii.fetch.bind(Ii), N0 = Ii.Headers, B1 = Ii.Request, U1 = Ii.Response, zi = Object.freeze(Object.defineProperty({ __proto__: null, Headers: N0, Request: B1, Response: U1, default: j0, fetch: V1 }, Symbol.toStringTag, { value: "Module" })), H1 = lw(zi); var Bh = {}; Object.defineProperty(Bh, "__esModule", { value: !0 }); class W1 extends Error { constructor(e) { super(e.message), this.name = "PostgrestError", this.details = e.details, this.hint = e.hint, this.code = e.code } } Bh.default = W1; var F0 = At && At.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(ql, "__esModule", { value: !0 }); const q1 = F0(H1), K1 = F0(Bh); let G1 = class { constructor(e) { this.shouldThrowOnError = !1, this.method = e.method, this.url = e.url, this.headers = e.headers, this.schema = e.schema, this.body = e.body, this.shouldThrowOnError = e.shouldThrowOnError, this.signal = e.signal, this.isMaybeSingle = e.isMaybeSingle, e.fetch ? this.fetch = e.fetch : typeof fetch > "u" ? this.fetch = q1.default : this.fetch = fetch } throwOnError() { return this.shouldThrowOnError = !0, this } then(e, n) { this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers["Accept-Profile"] = this.schema : this.headers["Content-Profile"] = this.schema), this.method !== "GET" && this.method !== "HEAD" && (this.headers["Content-Type"] = "application/json"); const r = this.fetch; let i = r(this.url.toString(), { method: this.method, headers: this.headers, body: JSON.stringify(this.body), signal: this.signal }).then(async s => { var o, a, l; let u = null, c = null, d = null, h = s.status, f = s.statusText; if (s.ok) { if (this.method !== "HEAD") { const p = await s.text(); p === "" || (this.headers.Accept === "text/csv" || this.headers.Accept && this.headers.Accept.includes("application/vnd.pgrst.plan+text") ? c = p : c = JSON.parse(p)) } const m = (o = this.headers.Prefer) === null || o === void 0 ? void 0 : o.match(/count=(exact|planned|estimated)/), y = (a = s.headers.get("content-range")) === null || a === void 0 ? void 0 : a.split("/"); m && y && y.length > 1 && (d = parseInt(y[1])), this.isMaybeSingle && this.method === "GET" && Array.isArray(c) && (c.length > 1 ? (u = { code: "PGRST116", details: `Results contain ${c.length} rows, application/vnd.pgrst.object+json requires 1 row`, hint: null, message: "JSON object requested, multiple (or no) rows returned" }, c = null, d = null, h = 406, f = "Not Acceptable") : c.length === 1 ? c = c[0] : c = null) } else { const m = await s.text(); try { u = JSON.parse(m), Array.isArray(u) && s.status === 404 && (c = [], u = null, h = 200, f = "OK") } catch { s.status === 404 && m === "" ? (h = 204, f = "No Content") : u = { message: m } } if (u && this.isMaybeSingle && (!((l = u == null ? void 0 : u.details) === null || l === void 0) && l.includes("0 rows")) && (u = null, h = 200, f = "OK"), u && this.shouldThrowOnError) throw new K1.default(u) } return { error: u, data: c, count: d, status: h, statusText: f } }); return this.shouldThrowOnError || (i = i.catch(s => { var o, a, l; return { error: { message: `${(o = s == null ? void 0 : s.name) !== null && o !== void 0 ? o : "FetchError"}: ${s == null ? void 0 : s.message}`, details: `${(a = s == null ? void 0 : s.stack) !== null && a !== void 0 ? a : ""}`, hint: "", code: `${(l = s == null ? void 0 : s.code) !== null && l !== void 0 ? l : ""}` }, data: null, count: null, status: 0, statusText: "" } })), i.then(e, n) } }; ql.default = G1; var Y1 = At && At.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(Wl, "__esModule", { value: !0 }); const Q1 = Y1(ql); let X1 = class extends Q1.default { select(e) { let n = !1; const r = (e ?? "*").split("").map(i => /\s/.test(i) && !n ? "" : (i === '"' && (n = !n), i)).join(""); return this.url.searchParams.set("select", r), this.headers.Prefer && (this.headers.Prefer += ","), this.headers.Prefer += "return=representation", this } order(e, { ascending: n = !0, nullsFirst: r, foreignTable: i, referencedTable: s = i } = {}) { const o = s ? `${s}.order` : "order", a = this.url.searchParams.get(o); return this.url.searchParams.set(o, `${a ? `${a},` : ""}${e}.${n ? "asc" : "desc"}${r === void 0 ? "" : r ? ".nullsfirst" : ".nullslast"}`), this } limit(e, { foreignTable: n, referencedTable: r = n } = {}) { const i = typeof r > "u" ? "limit" : `${r}.limit`; return this.url.searchParams.set(i, `${e}`), this } range(e, n, { foreignTable: r, referencedTable: i = r } = {}) { const s = typeof i > "u" ? "offset" : `${i}.offset`, o = typeof i > "u" ? "limit" : `${i}.limit`; return this.url.searchParams.set(s, `${e}`), this.url.searchParams.set(o, `${n - e + 1}`), this } abortSignal(e) { return this.signal = e, this } single() { return this.headers.Accept = "application/vnd.pgrst.object+json", this } maybeSingle() { return this.method === "GET" ? this.headers.Accept = "application/json" : this.headers.Accept = "application/vnd.pgrst.object+json", this.isMaybeSingle = !0, this } csv() { return this.headers.Accept = "text/csv", this } geojson() { return this.headers.Accept = "application/geo+json", this } explain({ analyze: e = !1, verbose: n = !1, settings: r = !1, buffers: i = !1, wal: s = !1, format: o = "text" } = {}) { var a; const l = [e ? "analyze" : null, n ? "verbose" : null, r ? "settings" : null, i ? "buffers" : null, s ? "wal" : null].filter(Boolean).join("|"), u = (a = this.headers.Accept) !== null && a !== void 0 ? a : "application/json"; return this.headers.Accept = `application/vnd.pgrst.plan+${o}; for="${u}"; options=${l};`, o === "json" ? this : this } rollback() { var e; return ((e = this.headers.Prefer) !== null && e !== void 0 ? e : "").trim().length > 0 ? this.headers.Prefer += ",tx=rollback" : this.headers.Prefer = "tx=rollback", this } returns() { return this } }; Wl.default = X1; var J1 = At && At.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(mo, "__esModule", { value: !0 }); const Z1 = J1(Wl); let ek = class extends Z1.default { eq(e, n) { return this.url.searchParams.append(e, `eq.${n}`), this } neq(e, n) { return this.url.searchParams.append(e, `neq.${n}`), this } gt(e, n) { return this.url.searchParams.append(e, `gt.${n}`), this } gte(e, n) { return this.url.searchParams.append(e, `gte.${n}`), this } lt(e, n) { return this.url.searchParams.append(e, `lt.${n}`), this } lte(e, n) { return this.url.searchParams.append(e, `lte.${n}`), this } like(e, n) { return this.url.searchParams.append(e, `like.${n}`), this } likeAllOf(e, n) { return this.url.searchParams.append(e, `like(all).{${n.join(",")}}`), this } likeAnyOf(e, n) { return this.url.searchParams.append(e, `like(any).{${n.join(",")}}`), this } ilike(e, n) { return this.url.searchParams.append(e, `ilike.${n}`), this } ilikeAllOf(e, n) { return this.url.searchParams.append(e, `ilike(all).{${n.join(",")}}`), this } ilikeAnyOf(e, n) { return this.url.searchParams.append(e, `ilike(any).{${n.join(",")}}`), this } is(e, n) { return this.url.searchParams.append(e, `is.${n}`), this } in(e, n) { const r = Array.from(new Set(n)).map(i => typeof i == "string" && new RegExp("[,()]").test(i) ? `"${i}"` : `${i}`).join(","); return this.url.searchParams.append(e, `in.(${r})`), this } contains(e, n) { return typeof n == "string" ? this.url.searchParams.append(e, `cs.${n}`) : Array.isArray(n) ? this.url.searchParams.append(e, `cs.{${n.join(",")}}`) : this.url.searchParams.append(e, `cs.${JSON.stringify(n)}`), this } containedBy(e, n) { return typeof n == "string" ? this.url.searchParams.append(e, `cd.${n}`) : Array.isArray(n) ? this.url.searchParams.append(e, `cd.{${n.join(",")}}`) : this.url.searchParams.append(e, `cd.${JSON.stringify(n)}`), this } rangeGt(e, n) { return this.url.searchParams.append(e, `sr.${n}`), this } rangeGte(e, n) { return this.url.searchParams.append(e, `nxl.${n}`), this } rangeLt(e, n) { return this.url.searchParams.append(e, `sl.${n}`), this } rangeLte(e, n) { return this.url.searchParams.append(e, `nxr.${n}`), this } rangeAdjacent(e, n) { return this.url.searchParams.append(e, `adj.${n}`), this } overlaps(e, n) { return typeof n == "string" ? this.url.searchParams.append(e, `ov.${n}`) : this.url.searchParams.append(e, `ov.{${n.join(",")}}`), this } textSearch(e, n, { config: r, type: i } = {}) { let s = ""; i === "plain" ? s = "pl" : i === "phrase" ? s = "ph" : i === "websearch" && (s = "w"); const o = r === void 0 ? "" : `(${r})`; return this.url.searchParams.append(e, `${s}fts${o}.${n}`), this } match(e) { return Object.entries(e).forEach(([n, r]) => { this.url.searchParams.append(n, `eq.${r}`) }), this } not(e, n, r) { return this.url.searchParams.append(e, `not.${n}.${r}`), this } or(e, { foreignTable: n, referencedTable: r = n } = {}) { const i = r ? `${r}.or` : "or"; return this.url.searchParams.append(i, `(${e})`), this } filter(e, n, r) { return this.url.searchParams.append(e, `${n}.${r}`), this } }; mo.default = ek; var tk = At && At.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(Hl, "__esModule", { value: !0 }); const es = tk(mo); let nk = class { constructor(e, { headers: n = {}, schema: r, fetch: i }) { this.url = e, this.headers = n, this.schema = r, this.fetch = i } select(e, { head: n = !1, count: r } = {}) { const i = n ? "HEAD" : "GET"; let s = !1; const o = (e ?? "*").split("").map(a => /\s/.test(a) && !s ? "" : (a === '"' && (s = !s), a)).join(""); return this.url.searchParams.set("select", o), r && (this.headers.Prefer = `count=${r}`), new es.default({ method: i, url: this.url, headers: this.headers, schema: this.schema, fetch: this.fetch, allowEmpty: !1 }) } insert(e, { count: n, defaultToNull: r = !0 } = {}) { const i = "POST", s = []; if (this.headers.Prefer && s.push(this.headers.Prefer), n && s.push(`count=${n}`), r || s.push("missing=default"), this.headers.Prefer = s.join(","), Array.isArray(e)) { const o = e.reduce((a, l) => a.concat(Object.keys(l)), []); if (o.length > 0) { const a = [...new Set(o)].map(l => `"${l}"`); this.url.searchParams.set("columns", a.join(",")) } } return new es.default({ method: i, url: this.url, headers: this.headers, schema: this.schema, body: e, fetch: this.fetch, allowEmpty: !1 }) } upsert(e, { onConflict: n, ignoreDuplicates: r = !1, count: i, defaultToNull: s = !0 } = {}) { const o = "POST", a = [`resolution=${r ? "ignore" : "merge"}-duplicates`]; if (n !== void 0 && this.url.searchParams.set("on_conflict", n), this.headers.Prefer && a.push(this.headers.Prefer), i && a.push(`count=${i}`), s || a.push("missing=default"), this.headers.Prefer = a.join(","), Array.isArray(e)) { const l = e.reduce((u, c) => u.concat(Object.keys(c)), []); if (l.length > 0) { const u = [...new Set(l)].map(c => `"${c}"`); this.url.searchParams.set("columns", u.join(",")) } } return new es.default({ method: o, url: this.url, headers: this.headers, schema: this.schema, body: e, fetch: this.fetch, allowEmpty: !1 }) } update(e, { count: n } = {}) { const r = "PATCH", i = []; return this.headers.Prefer && i.push(this.headers.Prefer), n && i.push(`count=${n}`), this.headers.Prefer = i.join(","), new es.default({ method: r, url: this.url, headers: this.headers, schema: this.schema, body: e, fetch: this.fetch, allowEmpty: !1 }) } delete({ count: e } = {}) { const n = "DELETE", r = []; return e && r.push(`count=${e}`), this.headers.Prefer && r.unshift(this.headers.Prefer), this.headers.Prefer = r.join(","), new es.default({ method: n, url: this.url, headers: this.headers, schema: this.schema, fetch: this.fetch, allowEmpty: !1 }) } }; Hl.default = nk; var Kl = {}, Gl = {}; Object.defineProperty(Gl, "__esModule", { value: !0 }); Gl.version = void 0; Gl.version = "0.0.0-automated"; Object.defineProperty(Kl, "__esModule", { value: !0 }); Kl.DEFAULT_HEADERS = void 0; const rk = Gl; Kl.DEFAULT_HEADERS = { "X-Client-Info": `postgrest-js/${rk.version}` }; var $0 = At && At.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(Vh, "__esModule", { value: !0 }); const ik = $0(Hl), sk = $0(mo), ok = Kl; let ak = class z0 { constructor(e, { headers: n = {}, schema: r, fetch: i } = {}) { this.url = e, this.headers = Object.assign(Object.assign({}, ok.DEFAULT_HEADERS), n), this.schemaName = r, this.fetch = i } from(e) { const n = new URL(`${this.url}/${e}`); return new ik.default(n, { headers: Object.assign({}, this.headers), schema: this.schemaName, fetch: this.fetch }) } schema(e) { return new z0(this.url, { headers: this.headers, schema: e, fetch: this.fetch }) } rpc(e, n = {}, { head: r = !1, get: i = !1, count: s } = {}) { let o; const a = new URL(`${this.url}/rpc/${e}`); let l; r || i ? (o = r ? "HEAD" : "GET", Object.entries(n).filter(([c, d]) => d !== void 0).map(([c, d]) => [c, Array.isArray(d) ? `{${d.join(",")}}` : `${d}`]).forEach(([c, d]) => { a.searchParams.append(c, d) })) : (o = "POST", l = n); const u = Object.assign({}, this.headers); return s && (u.Prefer = `count=${s}`), new sk.default({ method: o, url: a, headers: u, schema: this.schemaName, body: l, fetch: this.fetch, allowEmpty: !1 }) } }; Vh.default = ak; var vo = At && At.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(Rt, "__esModule", { value: !0 }); Rt.PostgrestBuilder = Rt.PostgrestTransformBuilder = Rt.PostgrestFilterBuilder = Rt.PostgrestQueryBuilder = Rt.PostgrestClient = void 0; const V0 = vo(Vh); Rt.PostgrestClient = V0.default; const B0 = vo(Hl); Rt.PostgrestQueryBuilder = B0.default; const U0 = vo(mo); Rt.PostgrestFilterBuilder = U0.default; const H0 = vo(Wl); Rt.PostgrestTransformBuilder = H0.default; const W0 = vo(ql); Rt.PostgrestBuilder = W0.default; var lk = Rt.default = { PostgrestClient: V0.default, PostgrestQueryBuilder: B0.default, PostgrestFilterBuilder: U0.default, PostgrestTransformBuilder: H0.default, PostgrestBuilder: W0.default }; const { PostgrestClient: uk, PostgrestQueryBuilder: WD, PostgrestFilterBuilder: qD, PostgrestTransformBuilder: KD, PostgrestBuilder: GD } = lk, ck = "2.10.2", dk = { "X-Client-Info": `realtime-js/${ck}` }, hk = "1.0.0", q0 = 1e4, fk = 1e3; var bi; (function (t) { t[t.connecting = 0] = "connecting", t[t.open = 1] = "open", t[t.closing = 2] = "closing", t[t.closed = 3] = "closed" })(bi || (bi = {})); var gt; (function (t) { t.closed = "closed", t.errored = "errored", t.joined = "joined", t.joining = "joining", t.leaving = "leaving" })(gt || (gt = {})); var Ut; (function (t) { t.close = "phx_close", t.error = "phx_error", t.join = "phx_join", t.reply = "phx_reply", t.leave = "phx_leave", t.access_token = "access_token" })(Ut || (Ut = {})); var yd; (function (t) { t.websocket = "websocket" })(yd || (yd = {})); var Sr; (function (t) { t.Connecting = "connecting", t.Open = "open", t.Closing = "closing", t.Closed = "closed" })(Sr || (Sr = {})); class pk { constructor() { this.HEADER_LENGTH = 1 } decode(e, n) { return e.constructor === ArrayBuffer ? n(this._binaryDecode(e)) : n(typeof e == "string" ? JSON.parse(e) : {}) } _binaryDecode(e) { const n = new DataView(e), r = new TextDecoder; return this._decodeBroadcast(e, n, r) } _decodeBroadcast(e, n, r) { const i = n.getUint8(1), s = n.getUint8(2); let o = this.HEADER_LENGTH + 2; const a = r.decode(e.slice(o, o + i)); o = o + i; const l = r.decode(e.slice(o, o + s)); o = o + s; const u = JSON.parse(r.decode(e.slice(o, e.byteLength))); return { ref: null, topic: a, event: l, payload: u } } } class K0 { constructor(e, n) { this.callback = e, this.timerCalc = n, this.timer = void 0, this.tries = 0, this.callback = e, this.timerCalc = n } reset() { this.tries = 0, clearTimeout(this.timer) } scheduleTimeout() { clearTimeout(this.timer), this.timer = setTimeout(() => { this.tries = this.tries + 1, this.callback() }, this.timerCalc(this.tries + 1)) } } var pe; (function (t) { t.abstime = "abstime", t.bool = "bool", t.date = "date", t.daterange = "daterange", t.float4 = "float4", t.float8 = "float8", t.int2 = "int2", t.int4 = "int4", t.int4range = "int4range", t.int8 = "int8", t.int8range = "int8range", t.json = "json", t.jsonb = "jsonb", t.money = "money", t.numeric = "numeric", t.oid = "oid", t.reltime = "reltime", t.text = "text", t.time = "time", t.timestamp = "timestamp", t.timestamptz = "timestamptz", t.timetz = "timetz", t.tsrange = "tsrange", t.tstzrange = "tstzrange" })(pe || (pe = {})); const Xp = (t, e, n = {}) => { var r; const i = (r = n.skipTypes) !== null && r !== void 0 ? r : []; return Object.keys(e).reduce((s, o) => (s[o] = gk(o, t, e, i), s), {}) }, gk = (t, e, n, r) => { const i = e.find(a => a.name === t), s = i == null ? void 0 : i.type, o = n[t]; return s && !r.includes(s) ? G0(s, o) : bd(o) }, G0 = (t, e) => { if (t.charAt(0) === "_") { const n = t.slice(1, t.length); return bk(e, n) } switch (t) { case pe.bool: return mk(e); case pe.float4: case pe.float8: case pe.int2: case pe.int4: case pe.int8: case pe.numeric: case pe.oid: return vk(e); case pe.json: case pe.jsonb: return yk(e); case pe.timestamp: return _k(e); case pe.abstime: case pe.date: case pe.daterange: case pe.int4range: case pe.int8range: case pe.money: case pe.reltime: case pe.text: case pe.time: case pe.timestamptz: case pe.timetz: case pe.tsrange: case pe.tstzrange: return bd(e); default: return bd(e) } }, bd = t => t, mk = t => { switch (t) { case "t": return !0; case "f": return !1; default: return t } }, vk = t => { if (typeof t == "string") { const e = parseFloat(t); if (!Number.isNaN(e)) return e } return t }, yk = t => { if (typeof t == "string") try { return JSON.parse(t) } catch (e) { return console.log(`JSON parse error: ${e}`), t } return t }, bk = (t, e) => { if (typeof t != "string") return t; const n = t.length - 1, r = t[n]; if (t[0] === "{" && r === "}") { let s; const o = t.slice(1, n); try { s = JSON.parse("[" + o + "]") } catch { s = o ? o.split(",") : [] } return s.map(a => G0(e, a)) } return t }, _k = t => typeof t == "string" ? t.replace(" ", "T") : t, Y0 = t => { let e = t; return e = e.replace(/^ws/i, "http"), e = e.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, ""), e.replace(/\/+$/, "") }; class Gu { constructor(e, n, r = {}, i = q0) { this.channel = e, this.event = n, this.payload = r, this.timeout = i, this.sent = !1, this.timeoutTimer = void 0, this.ref = "", this.receivedResp = null, this.recHooks = [], this.refEvent = null } resend(e) { this.timeout = e, this._cancelRefEvent(), this.ref = "", this.refEvent = null, this.receivedResp = null, this.sent = !1, this.send() } send() { this._hasReceived("timeout") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({ topic: this.channel.topic, event: this.event, payload: this.payload, ref: this.ref, join_ref: this.channel._joinRef() })) } updatePayload(e) { this.payload = Object.assign(Object.assign({}, this.payload), e) } receive(e, n) { var r; return this._hasReceived(e) && n((r = this.receivedResp) === null || r === void 0 ? void 0 : r.response), this.recHooks.push({ status: e, callback: n }), this } startTimeout() { if (this.timeoutTimer) return; this.ref = this.channel.socket._makeRef(), this.refEvent = this.channel._replyEventName(this.ref); const e = n => { this._cancelRefEvent(), this._cancelTimeout(), this.receivedResp = n, this._matchReceive(n) }; this.channel._on(this.refEvent, {}, e), this.timeoutTimer = setTimeout(() => { this.trigger("timeout", {}) }, this.timeout) } trigger(e, n) { this.refEvent && this.channel._trigger(this.refEvent, { status: e, response: n }) } destroy() { this._cancelRefEvent(), this._cancelTimeout() } _cancelRefEvent() { this.refEvent && this.channel._off(this.refEvent, {}) } _cancelTimeout() { clearTimeout(this.timeoutTimer), this.timeoutTimer = void 0 } _matchReceive({ status: e, response: n }) { this.recHooks.filter(r => r.status === e).forEach(r => r.callback(n)) } _hasReceived(e) { return this.receivedResp && this.receivedResp.status === e } } var Jp; (function (t) { t.SYNC = "sync", t.JOIN = "join", t.LEAVE = "leave" })(Jp || (Jp = {})); class Ps { constructor(e, n) { this.channel = e, this.state = {}, this.pendingDiffs = [], this.joinRef = null, this.caller = { onJoin: () => { }, onLeave: () => { }, onSync: () => { } }; const r = (n == null ? void 0 : n.events) || { state: "presence_state", diff: "presence_diff" }; this.channel._on(r.state, {}, i => { const { onJoin: s, onLeave: o, onSync: a } = this.caller; this.joinRef = this.channel._joinRef(), this.state = Ps.syncState(this.state, i, s, o), this.pendingDiffs.forEach(l => { this.state = Ps.syncDiff(this.state, l, s, o) }), this.pendingDiffs = [], a() }), this.channel._on(r.diff, {}, i => { const { onJoin: s, onLeave: o, onSync: a } = this.caller; this.inPendingSyncState() ? this.pendingDiffs.push(i) : (this.state = Ps.syncDiff(this.state, i, s, o), a()) }), this.onJoin((i, s, o) => { this.channel._trigger("presence", { event: "join", key: i, currentPresences: s, newPresences: o }) }), this.onLeave((i, s, o) => { this.channel._trigger("presence", { event: "leave", key: i, currentPresences: s, leftPresences: o }) }), this.onSync(() => { this.channel._trigger("presence", { event: "sync" }) }) } static syncState(e, n, r, i) { const s = this.cloneDeep(e), o = this.transformState(n), a = {}, l = {}; return this.map(s, (u, c) => { o[u] || (l[u] = c) }), this.map(o, (u, c) => { const d = s[u]; if (d) { const h = c.map(y => y.presence_ref), f = d.map(y => y.presence_ref), g = c.filter(y => f.indexOf(y.presence_ref) < 0), m = d.filter(y => h.indexOf(y.presence_ref) < 0); g.length > 0 && (a[u] = g), m.length > 0 && (l[u] = m) } else a[u] = c }), this.syncDiff(s, { joins: a, leaves: l }, r, i) } static syncDiff(e, n, r, i) { const { joins: s, leaves: o } = { joins: this.transformState(n.joins), leaves: this.transformState(n.leaves) }; return r || (r = () => { }), i || (i = () => { }), this.map(s, (a, l) => { var u; const c = (u = e[a]) !== null && u !== void 0 ? u : []; if (e[a] = this.cloneDeep(l), c.length > 0) { const d = e[a].map(f => f.presence_ref), h = c.filter(f => d.indexOf(f.presence_ref) < 0); e[a].unshift(...h) } r(a, c, l) }), this.map(o, (a, l) => { let u = e[a]; if (!u) return; const c = l.map(d => d.presence_ref); u = u.filter(d => c.indexOf(d.presence_ref) < 0), e[a] = u, i(a, u, l), u.length === 0 && delete e[a] }), e } static map(e, n) { return Object.getOwnPropertyNames(e).map(r => n(r, e[r])) } static transformState(e) { return e = this.cloneDeep(e), Object.getOwnPropertyNames(e).reduce((n, r) => { const i = e[r]; return "metas" in i ? n[r] = i.metas.map(s => (s.presence_ref = s.phx_ref, delete s.phx_ref, delete s.phx_ref_prev, s)) : n[r] = i, n }, {}) } static cloneDeep(e) { return JSON.parse(JSON.stringify(e)) } onJoin(e) { this.caller.onJoin = e } onLeave(e) { this.caller.onLeave = e } onSync(e) { this.caller.onSync = e } inPendingSyncState() { return !this.joinRef || this.joinRef !== this.channel._joinRef() } } var Zp; (function (t) { t.ALL = "*", t.INSERT = "INSERT", t.UPDATE = "UPDATE", t.DELETE = "DELETE" })(Zp || (Zp = {})); var eg; (function (t) { t.BROADCAST = "broadcast", t.PRESENCE = "presence", t.POSTGRES_CHANGES = "postgres_changes" })(eg || (eg = {})); var tg; (function (t) { t.SUBSCRIBED = "SUBSCRIBED", t.TIMED_OUT = "TIMED_OUT", t.CLOSED = "CLOSED", t.CHANNEL_ERROR = "CHANNEL_ERROR" })(tg || (tg = {})); class Uh { constructor(e, n = { config: {} }, r) { this.topic = e, this.params = n, this.socket = r, this.bindings = {}, this.state = gt.closed, this.joinedOnce = !1, this.pushBuffer = [], this.subTopic = e.replace(/^realtime:/i, ""), this.params.config = Object.assign({ broadcast: { ack: !1, self: !1 }, presence: { key: "" }, private: !1 }, n.config), this.timeout = this.socket.timeout, this.joinPush = new Gu(this, Ut.join, this.params, this.timeout), this.rejoinTimer = new K0(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs), this.joinPush.receive("ok", () => { this.state = gt.joined, this.rejoinTimer.reset(), this.pushBuffer.forEach(i => i.send()), this.pushBuffer = [] }), this._onClose(() => { this.rejoinTimer.reset(), this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`), this.state = gt.closed, this.socket._remove(this) }), this._onError(i => { this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, i), this.state = gt.errored, this.rejoinTimer.scheduleTimeout()) }), this.joinPush.receive("timeout", () => { this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout), this.state = gt.errored, this.rejoinTimer.scheduleTimeout()) }), this._on(Ut.reply, {}, (i, s) => { this._trigger(this._replyEventName(s), i) }), this.presence = new Ps(this), this.broadcastEndpointURL = Y0(this.socket.endPoint) + "/api/broadcast" } subscribe(e, n = this.timeout) { var r, i; if (this.socket.isConnected() || this.socket.connect(), this.joinedOnce) throw "tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance"; { const { config: { broadcast: s, presence: o, private: a } } = this.params; this._onError(c => e && e("CHANNEL_ERROR", c)), this._onClose(() => e && e("CLOSED")); const l = {}, u = { broadcast: s, presence: o, postgres_changes: (i = (r = this.bindings.postgres_changes) === null || r === void 0 ? void 0 : r.map(c => c.filter)) !== null && i !== void 0 ? i : [], private: a }; this.socket.accessToken && (l.access_token = this.socket.accessToken), this.updateJoinPayload(Object.assign({ config: u }, l)), this.joinedOnce = !0, this._rejoin(n), this.joinPush.receive("ok", ({ postgres_changes: c }) => { var d; if (this.socket.accessToken && this.socket.setAuth(this.socket.accessToken), c === void 0) { e && e("SUBSCRIBED"); return } else { const h = this.bindings.postgres_changes, f = (d = h == null ? void 0 : h.length) !== null && d !== void 0 ? d : 0, g = []; for (let m = 0; m < f; m++) { const y = h[m], { filter: { event: p, schema: v, table: b, filter: S } } = y, P = c && c[m]; if (P && P.event === p && P.schema === v && P.table === b && P.filter === S) g.push(Object.assign(Object.assign({}, y), { id: P.id })); else { this.unsubscribe(), e && e("CHANNEL_ERROR", new Error("mismatch between server and client bindings for postgres changes")); return } } this.bindings.postgres_changes = g, e && e("SUBSCRIBED"); return } }).receive("error", c => { e && e("CHANNEL_ERROR", new Error(JSON.stringify(Object.values(c).join(", ") || "error"))) }).receive("timeout", () => { e && e("TIMED_OUT") }) } return this } presenceState() { return this.presence.state } async track(e, n = {}) { return await this.send({ type: "presence", event: "track", payload: e }, n.timeout || this.timeout) } async untrack(e = {}) { return await this.send({ type: "presence", event: "untrack" }, e) } on(e, n, r) { return this._on(e, n, r) } async send(e, n = {}) { var r, i; if (!this._canPush() && e.type === "broadcast") { const { event: s, payload: o } = e, a = { method: "POST", headers: { Authorization: this.socket.accessToken ? `Bearer ${this.socket.accessToken}` : "", apikey: this.socket.apiKey ? this.socket.apiKey : "", "Content-Type": "application/json" }, body: JSON.stringify({ messages: [{ topic: this.subTopic, event: s, payload: o }] }) }; try { const l = await this._fetchWithTimeout(this.broadcastEndpointURL, a, (r = n.timeout) !== null && r !== void 0 ? r : this.timeout); return await ((i = l.body) === null || i === void 0 ? void 0 : i.cancel()), l.ok ? "ok" : "error" } catch (l) { return l.name === "AbortError" ? "timed out" : "error" } } else return new Promise(s => { var o, a, l; const u = this._push(e.type, e, n.timeout || this.timeout); e.type === "broadcast" && !(!((l = (a = (o = this.params) === null || o === void 0 ? void 0 : o.config) === null || a === void 0 ? void 0 : a.broadcast) === null || l === void 0) && l.ack) && s("ok"), u.receive("ok", () => s("ok")), u.receive("error", () => s("error")), u.receive("timeout", () => s("timed out")) }) } updateJoinPayload(e) { this.joinPush.updatePayload(e) } unsubscribe(e = this.timeout) { this.state = gt.leaving; const n = () => { this.socket.log("channel", `leave ${this.topic}`), this._trigger(Ut.close, "leave", this._joinRef()) }; return this.rejoinTimer.reset(), this.joinPush.destroy(), new Promise(r => { const i = new Gu(this, Ut.leave, {}, e); i.receive("ok", () => { n(), r("ok") }).receive("timeout", () => { n(), r("timed out") }).receive("error", () => { r("error") }), i.send(), this._canPush() || i.trigger("ok", {}) }) } async _fetchWithTimeout(e, n, r) { const i = new AbortController, s = setTimeout(() => i.abort(), r), o = await this.socket.fetch(e, Object.assign(Object.assign({}, n), { signal: i.signal })); return clearTimeout(s), o } _push(e, n, r = this.timeout) { if (!this.joinedOnce) throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`; let i = new Gu(this, e, n, r); return this._canPush() ? i.send() : (i.startTimeout(), this.pushBuffer.push(i)), i } _onMessage(e, n, r) { return n } _isMember(e) { return this.topic === e } _joinRef() { return this.joinPush.ref } _trigger(e, n, r) { var i, s; const o = e.toLocaleLowerCase(), { close: a, error: l, leave: u, join: c } = Ut; if (r && [a, l, u, c].indexOf(o) >= 0 && r !== this._joinRef()) return; let h = this._onMessage(o, n, r); if (n && !h) throw "channel onMessage callbacks must return the payload, modified or unmodified";["insert", "update", "delete"].includes(o) ? (i = this.bindings.postgres_changes) === null || i === void 0 || i.filter(f => { var g, m, y; return ((g = f.filter) === null || g === void 0 ? void 0 : g.event) === "*" || ((y = (m = f.filter) === null || m === void 0 ? void 0 : m.event) === null || y === void 0 ? void 0 : y.toLocaleLowerCase()) === o }).map(f => f.callback(h, r)) : (s = this.bindings[o]) === null || s === void 0 || s.filter(f => { var g, m, y, p, v, b; if (["broadcast", "presence", "postgres_changes"].includes(o)) if ("id" in f) { const S = f.id, P = (g = f.filter) === null || g === void 0 ? void 0 : g.event; return S && ((m = n.ids) === null || m === void 0 ? void 0 : m.includes(S)) && (P === "*" || (P == null ? void 0 : P.toLocaleLowerCase()) === ((y = n.data) === null || y === void 0 ? void 0 : y.type.toLocaleLowerCase())) } else { const S = (v = (p = f == null ? void 0 : f.filter) === null || p === void 0 ? void 0 : p.event) === null || v === void 0 ? void 0 : v.toLocaleLowerCase(); return S === "*" || S === ((b = n == null ? void 0 : n.event) === null || b === void 0 ? void 0 : b.toLocaleLowerCase()) } else return f.type.toLocaleLowerCase() === o }).map(f => { if (typeof h == "object" && "ids" in h) { const g = h.data, { schema: m, table: y, commit_timestamp: p, type: v, errors: b } = g; h = Object.assign(Object.assign({}, { schema: m, table: y, commit_timestamp: p, eventType: v, new: {}, old: {}, errors: b }), this._getPayloadRecords(g)) } f.callback(h, r) }) } _isClosed() { return this.state === gt.closed } _isJoined() { return this.state === gt.joined } _isJoining() { return this.state === gt.joining } _isLeaving() { return this.state === gt.leaving } _replyEventName(e) { return `chan_reply_${e}` } _on(e, n, r) { const i = e.toLocaleLowerCase(), s = { type: i, filter: n, callback: r }; return this.bindings[i] ? this.bindings[i].push(s) : this.bindings[i] = [s], this } _off(e, n) { const r = e.toLocaleLowerCase(); return this.bindings[r] = this.bindings[r].filter(i => { var s; return !(((s = i.type) === null || s === void 0 ? void 0 : s.toLocaleLowerCase()) === r && Uh.isEqual(i.filter, n)) }), this } static isEqual(e, n) { if (Object.keys(e).length !== Object.keys(n).length) return !1; for (const r in e) if (e[r] !== n[r]) return !1; return !0 } _rejoinUntilConnected() { this.rejoinTimer.scheduleTimeout(), this.socket.isConnected() && this._rejoin() } _onClose(e) { this._on(Ut.close, {}, e) } _onError(e) { this._on(Ut.error, {}, n => e(n)) } _canPush() { return this.socket.isConnected() && this._isJoined() } _rejoin(e = this.timeout) { this._isLeaving() || (this.socket._leaveOpenTopic(this.topic), this.state = gt.joining, this.joinPush.resend(e)) } _getPayloadRecords(e) { const n = { new: {}, old: {} }; return (e.type === "INSERT" || e.type === "UPDATE") && (n.new = Xp(e.columns, e.record)), (e.type === "UPDATE" || e.type === "DELETE") && (n.old = Xp(e.columns, e.old_record)), n } } const wk = () => { }, Sk = typeof WebSocket < "u"; class xk { constructor(e, n) { var r; this.accessToken = null, this.apiKey = null, this.channels = [], this.endPoint = "", this.httpEndpoint = "", this.headers = dk, this.params = {}, this.timeout = q0, this.heartbeatIntervalMs = 3e4, this.heartbeatTimer = void 0, this.pendingHeartbeatRef = null, this.ref = 0, this.logger = wk, this.conn = null, this.sendBuffer = [], this.serializer = new pk, this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] }, this._resolveFetch = s => { let o; return s ? o = s : typeof fetch > "u" ? o = (...a) => Ti(async () => { const { default: l } = await Promise.resolve().then(() => zi); return { default: l } }, void 0).then(({ default: l }) => l(...a)) : o = fetch, (...a) => o(...a) }, this.endPoint = `${e}/${yd.websocket}`, this.httpEndpoint = Y0(e), n != null && n.transport ? this.transport = n.transport : this.transport = null, n != null && n.params && (this.params = n.params), n != null && n.headers && (this.headers = Object.assign(Object.assign({}, this.headers), n.headers)), n != null && n.timeout && (this.timeout = n.timeout), n != null && n.logger && (this.logger = n.logger), n != null && n.heartbeatIntervalMs && (this.heartbeatIntervalMs = n.heartbeatIntervalMs); const i = (r = n == null ? void 0 : n.params) === null || r === void 0 ? void 0 : r.apikey; i && (this.accessToken = i, this.apiKey = i), this.reconnectAfterMs = n != null && n.reconnectAfterMs ? n.reconnectAfterMs : s => [1e3, 2e3, 5e3, 1e4][s - 1] || 1e4, this.encode = n != null && n.encode ? n.encode : (s, o) => o(JSON.stringify(s)), this.decode = n != null && n.decode ? n.decode : this.serializer.decode.bind(this.serializer), this.reconnectTimer = new K0(async () => { this.disconnect(), this.connect() }, this.reconnectAfterMs), this.fetch = this._resolveFetch(n == null ? void 0 : n.fetch) } connect() { if (!this.conn) { if (this.transport) { this.conn = new this.transport(this._endPointURL(), void 0, { headers: this.headers }); return } if (Sk) { this.conn = new WebSocket(this._endPointURL()), this.setupConnection(); return } this.conn = new kk(this._endPointURL(), void 0, { close: () => { this.conn = null } }), Ti(async () => { const { default: e } = await import("./browser-Divo5eUj.js").then(n => n.b); return { default: e } }, []).then(({ default: e }) => { this.conn = new e(this._endPointURL(), void 0, { headers: this.headers }), this.setupConnection() }) } } disconnect(e, n) { this.conn && (this.conn.onclose = function () { }, e ? this.conn.close(e, n ?? "") : this.conn.close(), this.conn = null, this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.reconnectTimer.reset()) } getChannels() { return this.channels } async removeChannel(e) { const n = await e.unsubscribe(); return this.channels.length === 0 && this.disconnect(), n } async removeAllChannels() { const e = await Promise.all(this.channels.map(n => n.unsubscribe())); return this.disconnect(), e } log(e, n, r) { this.logger(e, n, r) } connectionState() { switch (this.conn && this.conn.readyState) { case bi.connecting: return Sr.Connecting; case bi.open: return Sr.Open; case bi.closing: return Sr.Closing; default: return Sr.Closed } } isConnected() { return this.connectionState() === Sr.Open } channel(e, n = { config: {} }) { const r = new Uh(`realtime:${e}`, n, this); return this.channels.push(r), r } push(e) { const { topic: n, event: r, payload: i, ref: s } = e, o = () => { this.encode(e, a => { var l; (l = this.conn) === null || l === void 0 || l.send(a) }) }; this.log("push", `${n} ${r} (${s})`, i), this.isConnected() ? o() : this.sendBuffer.push(o) } setAuth(e) { this.accessToken = e, this.channels.forEach(n => { e && n.updateJoinPayload({ access_token: e }), n.joinedOnce && n._isJoined() && n._push(Ut.access_token, { access_token: e }) }) } _makeRef() { let e = this.ref + 1; return e === this.ref ? this.ref = 0 : this.ref = e, this.ref.toString() } _leaveOpenTopic(e) { let n = this.channels.find(r => r.topic === e && (r._isJoined() || r._isJoining())); n && (this.log("transport", `leaving duplicate topic "${e}"`), n.unsubscribe()) } _remove(e) { this.channels = this.channels.filter(n => n._joinRef() !== e._joinRef()) } setupConnection() { this.conn && (this.conn.binaryType = "arraybuffer", this.conn.onopen = () => this._onConnOpen(), this.conn.onerror = e => this._onConnError(e), this.conn.onmessage = e => this._onConnMessage(e), this.conn.onclose = e => this._onConnClose(e)) } _endPointURL() { return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: hk })) } _onConnMessage(e) { this.decode(e.data, n => { let { topic: r, event: i, payload: s, ref: o } = n; (o && o === this.pendingHeartbeatRef || i === (s == null ? void 0 : s.type)) && (this.pendingHeartbeatRef = null), this.log("receive", `${s.status || ""} ${r} ${i} ${o && "(" + o + ")" || ""}`, s), this.channels.filter(a => a._isMember(r)).forEach(a => a._trigger(i, s, o)), this.stateChangeCallbacks.message.forEach(a => a(n)) }) } _onConnOpen() { this.log("transport", `connected to ${this._endPointURL()}`), this._flushSendBuffer(), this.reconnectTimer.reset(), this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs), this.stateChangeCallbacks.open.forEach(e => e()) } _onConnClose(e) { this.log("transport", "close", e), this._triggerChanError(), this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.reconnectTimer.scheduleTimeout(), this.stateChangeCallbacks.close.forEach(n => n(e)) } _onConnError(e) { this.log("transport", e.message), this._triggerChanError(), this.stateChangeCallbacks.error.forEach(n => n(e)) } _triggerChanError() { this.channels.forEach(e => e._trigger(Ut.error)) } _appendParams(e, n) { if (Object.keys(n).length === 0) return e; const r = e.match(/\?/) ? "&" : "?", i = new URLSearchParams(n); return `${e}${r}${i}` } _flushSendBuffer() { this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(e => e()), this.sendBuffer = []) } _sendHeartbeat() { var e; if (this.isConnected()) { if (this.pendingHeartbeatRef) { this.pendingHeartbeatRef = null, this.log("transport", "heartbeat timeout. Attempting to re-establish connection"), (e = this.conn) === null || e === void 0 || e.close(fk, "hearbeat timeout"); return } this.pendingHeartbeatRef = this._makeRef(), this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef }), this.setAuth(this.accessToken) } } } class kk { constructor(e, n, r) { this.binaryType = "arraybuffer", this.onclose = () => { }, this.onerror = () => { }, this.onmessage = () => { }, this.onopen = () => { }, this.readyState = bi.connecting, this.send = () => { }, this.url = null, this.url = e, this.close = r.close } } class Hh extends Error { constructor(e) { super(e), this.__isStorageError = !0, this.name = "StorageError" } } function Xe(t) { return typeof t == "object" && t !== null && "__isStorageError" in t } class Ck extends Hh { constructor(e, n) { super(e), this.name = "StorageApiError", this.status = n } toJSON() { return { name: this.name, message: this.message, status: this.status } } } class ng extends Hh { constructor(e, n) { super(e), this.name = "StorageUnknownError", this.originalError = n } } var Ok = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; const Q0 = t => { let e; return t ? e = t : typeof fetch > "u" ? e = (...n) => Ti(async () => { const { default: r } = await Promise.resolve().then(() => zi); return { default: r } }, void 0).then(({ default: r }) => r(...n)) : e = fetch, (...n) => e(...n) }, Pk = () => Ok(void 0, void 0, void 0, function* () { return typeof Response > "u" ? (yield Ti(() => Promise.resolve().then(() => zi), void 0)).Response : Response }); var Vi = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; const Yu = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t), Ek = (t, e) => Vi(void 0, void 0, void 0, function* () { const n = yield Pk(); t instanceof n ? t.json().then(r => { e(new Ck(Yu(r), t.status || 500)) }).catch(r => { e(new ng(Yu(r), r)) }) : e(new ng(Yu(t), t)) }), Tk = (t, e, n, r) => { const i = { method: t, headers: (e == null ? void 0 : e.headers) || {} }; return t === "GET" ? i : (i.headers = Object.assign({ "Content-Type": "application/json" }, e == null ? void 0 : e.headers), i.body = JSON.stringify(r), Object.assign(Object.assign({}, i), n)) }; function Yl(t, e, n, r, i, s) { return Vi(this, void 0, void 0, function* () { return new Promise((o, a) => { t(n, Tk(e, r, i, s)).then(l => { if (!l.ok) throw l; return r != null && r.noResolveJson ? l : l.json() }).then(l => o(l)).catch(l => Ek(l, a)) }) }) } function _d(t, e, n, r) { return Vi(this, void 0, void 0, function* () { return Yl(t, "GET", e, n, r) }) } function Dn(t, e, n, r, i) { return Vi(this, void 0, void 0, function* () { return Yl(t, "POST", e, r, i, n) }) } function Ik(t, e, n, r, i) { return Vi(this, void 0, void 0, function* () { return Yl(t, "PUT", e, r, i, n) }) } function X0(t, e, n, r, i) { return Vi(this, void 0, void 0, function* () { return Yl(t, "DELETE", e, r, i, n) }) } var Pt = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; const Rk = { limit: 100, offset: 0, sortBy: { column: "name", order: "asc" } }, rg = { cacheControl: "3600", contentType: "text/plain;charset=UTF-8", upsert: !1 }; class Mk { constructor(e, n = {}, r, i) { this.url = e, this.headers = n, this.bucketId = r, this.fetch = Q0(i) } uploadOrUpdate(e, n, r, i) { return Pt(this, void 0, void 0, function* () { try { let s; const o = Object.assign(Object.assign({}, rg), i), a = Object.assign(Object.assign({}, this.headers), e === "POST" && { "x-upsert": String(o.upsert) }); typeof Blob < "u" && r instanceof Blob ? (s = new FormData, s.append("cacheControl", o.cacheControl), s.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (s = r, s.append("cacheControl", o.cacheControl)) : (s = r, a["cache-control"] = `max-age=${o.cacheControl}`, a["content-type"] = o.contentType); const l = this._removeEmptyFolders(n), u = this._getFinalPath(l), c = yield this.fetch(`${this.url}/object/${u}`, Object.assign({ method: e, body: s, headers: a }, o != null && o.duplex ? { duplex: o.duplex } : {})), d = yield c.json(); return c.ok ? { data: { path: l, id: d.Id, fullPath: d.Key }, error: null } : { data: null, error: d } } catch (s) { if (Xe(s)) return { data: null, error: s }; throw s } }) } upload(e, n, r) { return Pt(this, void 0, void 0, function* () { return this.uploadOrUpdate("POST", e, n, r) }) } uploadToSignedUrl(e, n, r, i) { return Pt(this, void 0, void 0, function* () { const s = this._removeEmptyFolders(e), o = this._getFinalPath(s), a = new URL(this.url + `/object/upload/sign/${o}`); a.searchParams.set("token", n); try { let l; const u = Object.assign({ upsert: rg.upsert }, i), c = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(u.upsert) }); typeof Blob < "u" && r instanceof Blob ? (l = new FormData, l.append("cacheControl", u.cacheControl), l.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (l = r, l.append("cacheControl", u.cacheControl)) : (l = r, c["cache-control"] = `max-age=${u.cacheControl}`, c["content-type"] = u.contentType); const d = yield this.fetch(a.toString(), { method: "PUT", body: l, headers: c }), h = yield d.json(); return d.ok ? { data: { path: s, fullPath: h.Key }, error: null } : { data: null, error: h } } catch (l) { if (Xe(l)) return { data: null, error: l }; throw l } }) } createSignedUploadUrl(e, n) { return Pt(this, void 0, void 0, function* () { try { let r = this._getFinalPath(e); const i = Object.assign({}, this.headers); n != null && n.upsert && (i["x-upsert"] = "true"); const s = yield Dn(this.fetch, `${this.url}/object/upload/sign/${r}`, {}, { headers: i }), o = new URL(this.url + s.url), a = o.searchParams.get("token"); if (!a) throw new Hh("No token returned by API"); return { data: { signedUrl: o.toString(), path: e, token: a }, error: null } } catch (r) { if (Xe(r)) return { data: null, error: r }; throw r } }) } update(e, n, r) { return Pt(this, void 0, void 0, function* () { return this.uploadOrUpdate("PUT", e, n, r) }) } move(e, n, r) { return Pt(this, void 0, void 0, function* () { try { return { data: yield Dn(this.fetch, `${this.url}/object/move`, { bucketId: this.bucketId, sourceKey: e, destinationKey: n, destinationBucket: r == null ? void 0 : r.destinationBucket }, { headers: this.headers }), error: null } } catch (i) { if (Xe(i)) return { data: null, error: i }; throw i } }) } copy(e, n, r) { return Pt(this, void 0, void 0, function* () { try { return { data: { path: (yield Dn(this.fetch, `${this.url}/object/copy`, { bucketId: this.bucketId, sourceKey: e, destinationKey: n, destinationBucket: r == null ? void 0 : r.destinationBucket }, { headers: this.headers })).Key }, error: null } } catch (i) { if (Xe(i)) return { data: null, error: i }; throw i } }) } createSignedUrl(e, n, r) { return Pt(this, void 0, void 0, function* () { try { let i = this._getFinalPath(e), s = yield Dn(this.fetch, `${this.url}/object/sign/${i}`, Object.assign({ expiresIn: n }, r != null && r.transform ? { transform: r.transform } : {}), { headers: this.headers }); const o = r != null && r.download ? `&download=${r.download === !0 ? "" : r.download}` : ""; return s = { signedUrl: encodeURI(`${this.url}${s.signedURL}${o}`) }, { data: s, error: null } } catch (i) { if (Xe(i)) return { data: null, error: i }; throw i } }) } createSignedUrls(e, n, r) { return Pt(this, void 0, void 0, function* () { try { const i = yield Dn(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn: n, paths: e }, { headers: this.headers }), s = r != null && r.download ? `&download=${r.download === !0 ? "" : r.download}` : ""; return { data: i.map(o => Object.assign(Object.assign({}, o), { signedUrl: o.signedURL ? encodeURI(`${this.url}${o.signedURL}${s}`) : null })), error: null } } catch (i) { if (Xe(i)) return { data: null, error: i }; throw i } }) } download(e, n) { return Pt(this, void 0, void 0, function* () { const i = typeof (n == null ? void 0 : n.transform) < "u" ? "render/image/authenticated" : "object", s = this.transformOptsToQueryString((n == null ? void 0 : n.transform) || {}), o = s ? `?${s}` : ""; try { const a = this._getFinalPath(e); return { data: yield (yield _d(this.fetch, `${this.url}/${i}/${a}${o}`, { headers: this.headers, noResolveJson: !0 })).blob(), error: null } } catch (a) { if (Xe(a)) return { data: null, error: a }; throw a } }) } getPublicUrl(e, n) { const r = this._getFinalPath(e), i = [], s = n != null && n.download ? `download=${n.download === !0 ? "" : n.download}` : ""; s !== "" && i.push(s); const a = typeof (n == null ? void 0 : n.transform) < "u" ? "render/image" : "object", l = this.transformOptsToQueryString((n == null ? void 0 : n.transform) || {}); l !== "" && i.push(l); let u = i.join("&"); return u !== "" && (u = `?${u}`), { data: { publicUrl: encodeURI(`${this.url}/${a}/public/${r}${u}`) } } } remove(e) { return Pt(this, void 0, void 0, function* () { try { return { data: yield X0(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: e }, { headers: this.headers }), error: null } } catch (n) { if (Xe(n)) return { data: null, error: n }; throw n } }) } list(e, n, r) { return Pt(this, void 0, void 0, function* () { try { const i = Object.assign(Object.assign(Object.assign({}, Rk), n), { prefix: e || "" }); return { data: yield Dn(this.fetch, `${this.url}/object/list/${this.bucketId}`, i, { headers: this.headers }, r), error: null } } catch (i) { if (Xe(i)) return { data: null, error: i }; throw i } }) } _getFinalPath(e) { return `${this.bucketId}/${e}` } _removeEmptyFolders(e) { return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/") } transformOptsToQueryString(e) { const n = []; return e.width && n.push(`width=${e.width}`), e.height && n.push(`height=${e.height}`), e.resize && n.push(`resize=${e.resize}`), e.format && n.push(`format=${e.format}`), e.quality && n.push(`quality=${e.quality}`), n.join("&") } } const Lk = "2.6.0", Dk = { "X-Client-Info": `storage-js/${Lk}` }; var Kr = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; class Ak { constructor(e, n = {}, r) { this.url = e, this.headers = Object.assign(Object.assign({}, Dk), n), this.fetch = Q0(r) } listBuckets() { return Kr(this, void 0, void 0, function* () { try { return { data: yield _d(this.fetch, `${this.url}/bucket`, { headers: this.headers }), error: null } } catch (e) { if (Xe(e)) return { data: null, error: e }; throw e } }) } getBucket(e) { return Kr(this, void 0, void 0, function* () { try { return { data: yield _d(this.fetch, `${this.url}/bucket/${e}`, { headers: this.headers }), error: null } } catch (n) { if (Xe(n)) return { data: null, error: n }; throw n } }) } createBucket(e, n = { public: !1 }) { return Kr(this, void 0, void 0, function* () { try { return { data: yield Dn(this.fetch, `${this.url}/bucket`, { id: e, name: e, public: n.public, file_size_limit: n.fileSizeLimit, allowed_mime_types: n.allowedMimeTypes }, { headers: this.headers }), error: null } } catch (r) { if (Xe(r)) return { data: null, error: r }; throw r } }) } updateBucket(e, n) { return Kr(this, void 0, void 0, function* () { try { return { data: yield Ik(this.fetch, `${this.url}/bucket/${e}`, { id: e, name: e, public: n.public, file_size_limit: n.fileSizeLimit, allowed_mime_types: n.allowedMimeTypes }, { headers: this.headers }), error: null } } catch (r) { if (Xe(r)) return { data: null, error: r }; throw r } }) } emptyBucket(e) { return Kr(this, void 0, void 0, function* () { try { return { data: yield Dn(this.fetch, `${this.url}/bucket/${e}/empty`, {}, { headers: this.headers }), error: null } } catch (n) { if (Xe(n)) return { data: null, error: n }; throw n } }) } deleteBucket(e) { return Kr(this, void 0, void 0, function* () { try { return { data: yield X0(this.fetch, `${this.url}/bucket/${e}`, {}, { headers: this.headers }), error: null } } catch (n) { if (Xe(n)) return { data: null, error: n }; throw n } }) } } class jk extends Ak { constructor(e, n = {}, r) { super(e, n, r) } from(e) { return new Mk(this.url, this.headers, e, this.fetch) } } const Nk = "2.44.4"; let fs = ""; typeof Deno < "u" ? fs = "deno" : typeof document < "u" ? fs = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? fs = "react-native" : fs = "node"; const Fk = { "X-Client-Info": `supabase-js-${fs}/${Nk}` }, $k = { headers: Fk }, zk = { schema: "public" }, Vk = { autoRefreshToken: !0, persistSession: !0, detectSessionInUrl: !0, flowType: "implicit" }, Bk = {}; var Uk = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; const Hk = t => { let e; return t ? e = t : typeof fetch > "u" ? e = j0 : e = fetch, (...n) => e(...n) }, Wk = () => typeof Headers > "u" ? N0 : Headers, qk = (t, e, n) => { const r = Hk(n), i = Wk(); return (s, o) => Uk(void 0, void 0, void 0, function* () { var a; const l = (a = yield e()) !== null && a !== void 0 ? a : t; let u = new i(o == null ? void 0 : o.headers); return u.has("apikey") || u.set("apikey", t), u.has("Authorization") || u.set("Authorization", `Bearer ${l}`), r(s, Object.assign(Object.assign({}, o), { headers: u })) }) }; function Kk(t) { return t.replace(/\/$/, "") } function Gk(t, e) { const { db: n, auth: r, realtime: i, global: s } = t, { db: o, auth: a, realtime: l, global: u } = e; return { db: Object.assign(Object.assign({}, o), n), auth: Object.assign(Object.assign({}, a), r), realtime: Object.assign(Object.assign({}, l), i), global: Object.assign(Object.assign({}, u), s) } } const J0 = "2.64.4", Yk = "http://localhost:9999", Qk = "supabase.auth.token", Xk = { "X-Client-Info": `gotrue-js/${J0}` }, ig = 10, wd = "X-Supabase-Api-Version", Z0 = { "2024-01-01": { timestamp: Date.parse("2024-01-01T00:00:00.0Z"), name: "2024-01-01" } }; function Jk(t) { return Math.round(Date.now() / 1e3) + t } function Zk() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (t) { const e = Math.random() * 16 | 0; return (t == "x" ? e : e & 3 | 8).toString(16) }) } const zt = () => typeof document < "u", dr = { tested: !1, writable: !1 }, Es = () => { if (!zt()) return !1; try { if (typeof globalThis.localStorage != "object") return !1 } catch { return !1 } if (dr.tested) return dr.writable; const t = `lswt-${Math.random()}${Math.random()}`; try { globalThis.localStorage.setItem(t, t), globalThis.localStorage.removeItem(t), dr.tested = !0, dr.writable = !0 } catch { dr.tested = !0, dr.writable = !1 } return dr.writable }; function Qu(t) { const e = {}, n = new URL(t); if (n.hash && n.hash[0] === "#") try { new URLSearchParams(n.hash.substring(1)).forEach((i, s) => { e[s] = i }) } catch { } return n.searchParams.forEach((r, i) => { e[i] = r }), e } const eb = t => { let e; return t ? e = t : typeof fetch > "u" ? e = (...n) => Ti(async () => { const { default: r } = await Promise.resolve().then(() => zi); return { default: r } }, void 0).then(({ default: r }) => r(...n)) : e = fetch, (...n) => e(...n) }, eC = t => typeof t == "object" && t !== null && "status" in t && "ok" in t && "json" in t && typeof t.json == "function", tb = async (t, e, n) => { await t.setItem(e, JSON.stringify(n)) }, Bo = async (t, e) => { const n = await t.getItem(e); if (!n) return null; try { return JSON.parse(n) } catch { return n } }, Xu = async (t, e) => { await t.removeItem(e) }; function tC(t) { const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; let n = "", r, i, s, o, a, l, u, c = 0; for (t = t.replace("-", "+").replace("_", "/"); c < t.length;)o = e.indexOf(t.charAt(c++)), a = e.indexOf(t.charAt(c++)), l = e.indexOf(t.charAt(c++)), u = e.indexOf(t.charAt(c++)), r = o << 2 | a >> 4, i = (a & 15) << 4 | l >> 2, s = (l & 3) << 6 | u, n = n + String.fromCharCode(r), l != 64 && i != 0 && (n = n + String.fromCharCode(i)), u != 64 && s != 0 && (n = n + String.fromCharCode(s)); return n } class Ql { constructor() { this.promise = new Ql.promiseConstructor((e, n) => { this.resolve = e, this.reject = n }) } } Ql.promiseConstructor = Promise; function sg(t) { const e = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i, n = t.split("."); if (n.length !== 3) throw new Error("JWT is not valid: not a JWT structure"); if (!e.test(n[1])) throw new Error("JWT is not valid: payload is not in base64url format"); const r = n[1]; return JSON.parse(tC(r)) } async function nC(t) { return await new Promise(e => { setTimeout(() => e(null), t) }) } function rC(t, e) { return new Promise((r, i) => { (async () => { for (let s = 0; s < 1 / 0; s++)try { const o = await t(s); if (!e(s, null, o)) { r(o); return } } catch (o) { if (!e(s, o)) { i(o); return } } })() }) } function iC(t) { return ("0" + t.toString(16)).substr(-2) } function sC() { const e = new Uint32Array(56); if (typeof crypto > "u") { const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~", r = n.length; let i = ""; for (let s = 0; s < 56; s++)i += n.charAt(Math.floor(Math.random() * r)); return i } return crypto.getRandomValues(e), Array.from(e, iC).join("") } async function oC(t) { const n = new TextEncoder().encode(t), r = await crypto.subtle.digest("SHA-256", n), i = new Uint8Array(r); return Array.from(i).map(s => String.fromCharCode(s)).join("") } function aC(t) { return btoa(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "") } async function lC(t) { if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u")) return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."), t; const n = await oC(t); return aC(n) } async function Gr(t, e, n = !1) { const r = sC(); let i = r; n && (i += "/PASSWORD_RECOVERY"), await tb(t, `${e}-code-verifier`, i); const s = await lC(r); return [s, r === s ? "plain" : "s256"] } const uC = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i; function cC(t) { const e = t.headers.get(wd); if (!e || !e.match(uC)) return null; try { return new Date(`${e}T00:00:00.0Z`) } catch { return null } } class Wh extends Error { constructor(e, n, r) { super(e), this.__isAuthError = !0, this.name = "AuthError", this.status = n, this.code = r } } function ee(t) { return typeof t == "object" && t !== null && "__isAuthError" in t } class dC extends Wh { constructor(e, n, r) { super(e, n, r), this.name = "AuthApiError", this.status = n, this.code = r } } function hC(t) { return ee(t) && t.name === "AuthApiError" } class nb extends Wh { constructor(e, n) { super(e), this.name = "AuthUnknownError", this.originalError = n } } class zr extends Wh { constructor(e, n, r, i) { super(e, r, i), this.name = n, this.status = r } } class hr extends zr { constructor() { super("Auth session missing!", "AuthSessionMissingError", 400, void 0) } } class Ju extends zr { constructor() { super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0) } } class Uo extends zr { constructor(e) { super(e, "AuthInvalidCredentialsError", 400, void 0) } } class Ho extends zr { constructor(e, n = null) { super(e, "AuthImplicitGrantRedirectError", 500, void 0), this.details = null, this.details = n } toJSON() { return { name: this.name, message: this.message, status: this.status, details: this.details } } } class og extends zr { constructor(e, n = null) { super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0), this.details = null, this.details = n } toJSON() { return { name: this.name, message: this.message, status: this.status, details: this.details } } } class Sd extends zr { constructor(e, n) { super(e, "AuthRetryableFetchError", n, void 0) } } function Zu(t) { return ee(t) && t.name === "AuthRetryableFetchError" } class ag extends zr { constructor(e, n, r) { super(e, "AuthWeakPasswordError", n, "weak_password"), this.reasons = r } } var fC = function (t, e) { var n = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]); return n }; const _r = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t), pC = [502, 503, 504]; async function lg(t) { var e; if (!eC(t)) throw new Sd(_r(t), 0); if (pC.includes(t.status)) throw new Sd(_r(t), t.status); let n; try { n = await t.json() } catch (s) { throw new nb(_r(s), s) } let r; const i = cC(t); if (i && i.getTime() >= Z0["2024-01-01"].timestamp && typeof n == "object" && n && typeof n.code == "string" ? r = n.code : typeof n == "object" && n && typeof n.error_code == "string" && (r = n.error_code), r) { if (r === "weak_password") throw new ag(_r(n), t.status, ((e = n.weak_password) === null || e === void 0 ? void 0 : e.reasons) || []) } else if (typeof n == "object" && n && typeof n.weak_password == "object" && n.weak_password && Array.isArray(n.weak_password.reasons) && n.weak_password.reasons.length && n.weak_password.reasons.reduce((s, o) => s && typeof o == "string", !0)) throw new ag(_r(n), t.status, n.weak_password.reasons); throw new dC(_r(n), t.status || 500, r) } const gC = (t, e, n, r) => { const i = { method: t, headers: (e == null ? void 0 : e.headers) || {} }; return t === "GET" ? i : (i.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, e == null ? void 0 : e.headers), i.body = JSON.stringify(r), Object.assign(Object.assign({}, i), n)) }; async function ne(t, e, n, r) { var i; const s = Object.assign({}, r == null ? void 0 : r.headers); s[wd] || (s[wd] = Z0["2024-01-01"].name), r != null && r.jwt && (s.Authorization = `Bearer ${r.jwt}`); const o = (i = r == null ? void 0 : r.query) !== null && i !== void 0 ? i : {}; r != null && r.redirectTo && (o.redirect_to = r.redirectTo); const a = Object.keys(o).length ? "?" + new URLSearchParams(o).toString() : "", l = await mC(t, e, n + a, { headers: s, noResolveJson: r == null ? void 0 : r.noResolveJson }, {}, r == null ? void 0 : r.body); return r != null && r.xform ? r == null ? void 0 : r.xform(l) : { data: Object.assign({}, l), error: null } } async function mC(t, e, n, r, i, s) { const o = gC(e, r, i, s); let a; try { a = await t(n, Object.assign({}, o)) } catch (l) { throw console.error(l), new Sd(_r(l), 0) } if (a.ok || await lg(a), r != null && r.noResolveJson) return a; try { return await a.json() } catch (l) { await lg(l) } } function Rn(t) { var e; let n = null; _C(t) && (n = Object.assign({}, t), t.expires_at || (n.expires_at = Jk(t.expires_in))); const r = (e = t.user) !== null && e !== void 0 ? e : t; return { data: { session: n, user: r }, error: null } } function ug(t) { const e = Rn(t); return !e.error && t.weak_password && typeof t.weak_password == "object" && Array.isArray(t.weak_password.reasons) && t.weak_password.reasons.length && t.weak_password.message && typeof t.weak_password.message == "string" && t.weak_password.reasons.reduce((n, r) => n && typeof r == "string", !0) && (e.data.weak_password = t.weak_password), e } function Nn(t) { var e; return { data: { user: (e = t.user) !== null && e !== void 0 ? e : t }, error: null } } function vC(t) { return { data: t, error: null } } function yC(t) { const { action_link: e, email_otp: n, hashed_token: r, redirect_to: i, verification_type: s } = t, o = fC(t, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]), a = { action_link: e, email_otp: n, hashed_token: r, redirect_to: i, verification_type: s }, l = Object.assign({}, o); return { data: { properties: a, user: l }, error: null } } function bC(t) { return t } function _C(t) { return t.access_token && t.refresh_token && t.expires_in } var wC = function (t, e) { var n = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]); return n }; class SC { constructor({ url: e = "", headers: n = {}, fetch: r }) { this.url = e, this.headers = n, this.fetch = eb(r), this.mfa = { listFactors: this._listFactors.bind(this), deleteFactor: this._deleteFactor.bind(this) } } async signOut(e, n = "global") { try { return await ne(this.fetch, "POST", `${this.url}/logout?scope=${n}`, { headers: this.headers, jwt: e, noResolveJson: !0 }), { data: null, error: null } } catch (r) { if (ee(r)) return { data: null, error: r }; throw r } } async inviteUserByEmail(e, n = {}) { try { return await ne(this.fetch, "POST", `${this.url}/invite`, { body: { email: e, data: n.data }, headers: this.headers, redirectTo: n.redirectTo, xform: Nn }) } catch (r) { if (ee(r)) return { data: { user: null }, error: r }; throw r } } async generateLink(e) { try { const { options: n } = e, r = wC(e, ["options"]), i = Object.assign(Object.assign({}, r), n); return "newEmail" in r && (i.new_email = r == null ? void 0 : r.newEmail, delete i.newEmail), await ne(this.fetch, "POST", `${this.url}/admin/generate_link`, { body: i, headers: this.headers, xform: yC, redirectTo: n == null ? void 0 : n.redirectTo }) } catch (n) { if (ee(n)) return { data: { properties: null, user: null }, error: n }; throw n } } async createUser(e) { try { return await ne(this.fetch, "POST", `${this.url}/admin/users`, { body: e, headers: this.headers, xform: Nn }) } catch (n) { if (ee(n)) return { data: { user: null }, error: n }; throw n } } async listUsers(e) { var n, r, i, s, o, a, l; try { const u = { nextPage: null, lastPage: 0, total: 0 }, c = await ne(this.fetch, "GET", `${this.url}/admin/users`, { headers: this.headers, noResolveJson: !0, query: { page: (r = (n = e == null ? void 0 : e.page) === null || n === void 0 ? void 0 : n.toString()) !== null && r !== void 0 ? r : "", per_page: (s = (i = e == null ? void 0 : e.perPage) === null || i === void 0 ? void 0 : i.toString()) !== null && s !== void 0 ? s : "" }, xform: bC }); if (c.error) throw c.error; const d = await c.json(), h = (o = c.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0, f = (l = (a = c.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : []; return f.length > 0 && (f.forEach(g => { const m = parseInt(g.split(";")[0].split("=")[1].substring(0, 1)), y = JSON.parse(g.split(";")[1].split("=")[1]); u[`${y}Page`] = m }), u.total = parseInt(h)), { data: Object.assign(Object.assign({}, d), u), error: null } } catch (u) { if (ee(u)) return { data: { users: [] }, error: u }; throw u } } async getUserById(e) { try { return await ne(this.fetch, "GET", `${this.url}/admin/users/${e}`, { headers: this.headers, xform: Nn }) } catch (n) { if (ee(n)) return { data: { user: null }, error: n }; throw n } } async updateUserById(e, n) { try { return await ne(this.fetch, "PUT", `${this.url}/admin/users/${e}`, { body: n, headers: this.headers, xform: Nn }) } catch (r) { if (ee(r)) return { data: { user: null }, error: r }; throw r } } async deleteUser(e, n = !1) { try { return await ne(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, { headers: this.headers, body: { should_soft_delete: n }, xform: Nn }) } catch (r) { if (ee(r)) return { data: { user: null }, error: r }; throw r } } async _listFactors(e) { try { const { data: n, error: r } = await ne(this.fetch, "GET", `${this.url}/admin/users/${e.userId}/factors`, { headers: this.headers, xform: i => ({ data: { factors: i }, error: null }) }); return { data: n, error: r } } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } } async _deleteFactor(e) { try { return { data: await ne(this.fetch, "DELETE", `${this.url}/admin/users/${e.userId}/factors/${e.id}`, { headers: this.headers }), error: null } } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } } } const xC = { getItem: t => Es() ? globalThis.localStorage.getItem(t) : null, setItem: (t, e) => { Es() && globalThis.localStorage.setItem(t, e) }, removeItem: t => { Es() && globalThis.localStorage.removeItem(t) } }; function cg(t = {}) { return { getItem: e => t[e] || null, setItem: (e, n) => { t[e] = n }, removeItem: e => { delete t[e] } } } function kC() { if (typeof globalThis != "object") try { Object.defineProperty(Object.prototype, "__magic__", { get: function () { return this }, configurable: !0 }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__ } catch { typeof self < "u" && (self.globalThis = self) } } const Yr = { debug: !!(globalThis && Es() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true") }; class rb extends Error { constructor(e) { super(e), this.isAcquireTimeout = !0 } } class CC extends rb { } async function OC(t, e, n) { Yr.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", t, e); const r = new globalThis.AbortController; return e > 0 && setTimeout(() => { r.abort(), Yr.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", t) }, e), await globalThis.navigator.locks.request(t, e === 0 ? { mode: "exclusive", ifAvailable: !0 } : { mode: "exclusive", signal: r.signal }, async i => { if (i) { Yr.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", t, i.name); try { return await n() } finally { Yr.debug && console.log("@supabase/gotrue-js: navigatorLock: released", t, i.name) } } else { if (e === 0) throw Yr.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", t), new CC(`Acquiring an exclusive Navigator LockManager lock "${t}" immediately failed`); if (Yr.debug) try { const s = await globalThis.navigator.locks.query(); console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(s, null, "  ")) } catch (s) { console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", s) } return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"), await n() } }) } kC(); const PC = { url: Yk, storageKey: Qk, autoRefreshToken: !0, persistSession: !0, detectSessionInUrl: !0, headers: Xk, flowType: "implicit", debug: !1, hasCustomAuthorizationHeader: !1 }, ts = 30 * 1e3, dg = 3; async function hg(t, e, n) { return await n() } class Js { constructor(e) { var n, r; this.memoryStorage = null, this.stateChangeEmitters = new Map, this.autoRefreshTicker = null, this.visibilityChangedCallback = null, this.refreshingDeferred = null, this.initializePromise = null, this.detectSessionInUrl = !0, this.hasCustomAuthorizationHeader = !1, this.suppressGetSessionWarning = !1, this.lockAcquired = !1, this.pendingInLock = [], this.broadcastChannel = null, this.logger = console.log, this.instanceID = Js.nextInstanceID, Js.nextInstanceID += 1, this.instanceID > 0 && zt() && console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key."); const i = Object.assign(Object.assign({}, PC), e); if (this.logDebugMessages = !!i.debug, typeof i.debug == "function" && (this.logger = i.debug), this.persistSession = i.persistSession, this.storageKey = i.storageKey, this.autoRefreshToken = i.autoRefreshToken, this.admin = new SC({ url: i.url, headers: i.headers, fetch: i.fetch }), this.url = i.url, this.headers = i.headers, this.fetch = eb(i.fetch), this.lock = i.lock || hg, this.detectSessionInUrl = i.detectSessionInUrl, this.flowType = i.flowType, this.hasCustomAuthorizationHeader = i.hasCustomAuthorizationHeader, i.lock ? this.lock = i.lock : zt() && (!((n = globalThis == null ? void 0 : globalThis.navigator) === null || n === void 0) && n.locks) ? this.lock = OC : this.lock = hg, this.mfa = { verify: this._verify.bind(this), enroll: this._enroll.bind(this), unenroll: this._unenroll.bind(this), challenge: this._challenge.bind(this), listFactors: this._listFactors.bind(this), challengeAndVerify: this._challengeAndVerify.bind(this), getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this) }, this.persistSession ? i.storage ? this.storage = i.storage : Es() ? this.storage = xC : (this.memoryStorage = {}, this.storage = cg(this.memoryStorage)) : (this.memoryStorage = {}, this.storage = cg(this.memoryStorage)), zt() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) { try { this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey) } catch (s) { console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", s) } (r = this.broadcastChannel) === null || r === void 0 || r.addEventListener("message", async s => { this._debug("received broadcast notification from other tab or client", s), await this._notifyAllSubscribers(s.data.event, s.data.session, !1) }) } this.initialize() } _debug(...e) { return this.logDebugMessages && this.logger(`GoTrueClient@${this.instanceID} (${J0}) ${new Date().toISOString()}`, ...e), this } async initialize() { return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))(), await this.initializePromise) } async _initialize() { try { const e = zt() ? await this._isPKCEFlow() : !1; if (this._debug("#_initialize()", "begin", "is PKCE flow", e), e || this.detectSessionInUrl && this._isImplicitGrantFlow()) { const { data: n, error: r } = await this._getSessionFromURL(e); if (r) return this._debug("#_initialize()", "error detecting session from URL", r), (r == null ? void 0 : r.message) === "Identity is already linked" || (r == null ? void 0 : r.message) === "Identity is already linked to another user" ? { error: r } : (await this._removeSession(), { error: r }); const { session: i, redirectType: s } = n; return this._debug("#_initialize()", "detected session in URL", i, "redirect type", s), await this._saveSession(i), setTimeout(async () => { s === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", i) : await this._notifyAllSubscribers("SIGNED_IN", i) }, 0), { error: null } } return await this._recoverAndRefresh(), { error: null } } catch (e) { return ee(e) ? { error: e } : { error: new nb("Unexpected error during initialization", e) } } finally { await this._handleVisibilityChange(), this._debug("#_initialize()", "end") } } async signInAnonymously(e) { var n, r, i; try { const s = await ne(this.fetch, "POST", `${this.url}/signup`, { headers: this.headers, body: { data: (r = (n = e == null ? void 0 : e.options) === null || n === void 0 ? void 0 : n.data) !== null && r !== void 0 ? r : {}, gotrue_meta_security: { captcha_token: (i = e == null ? void 0 : e.options) === null || i === void 0 ? void 0 : i.captchaToken } }, xform: Rn }), { data: o, error: a } = s; if (a || !o) return { data: { user: null, session: null }, error: a }; const l = o.session, u = o.user; return o.session && (await this._saveSession(o.session), await this._notifyAllSubscribers("SIGNED_IN", l)), { data: { user: u, session: l }, error: null } } catch (s) { if (ee(s)) return { data: { user: null, session: null }, error: s }; throw s } } async signUp(e) { var n, r, i; try { let s; if ("email" in e) { const { email: c, password: d, options: h } = e; let f = null, g = null; this.flowType === "pkce" && ([f, g] = await Gr(this.storage, this.storageKey)), s = await ne(this.fetch, "POST", `${this.url}/signup`, { headers: this.headers, redirectTo: h == null ? void 0 : h.emailRedirectTo, body: { email: c, password: d, data: (n = h == null ? void 0 : h.data) !== null && n !== void 0 ? n : {}, gotrue_meta_security: { captcha_token: h == null ? void 0 : h.captchaToken }, code_challenge: f, code_challenge_method: g }, xform: Rn }) } else if ("phone" in e) { const { phone: c, password: d, options: h } = e; s = await ne(this.fetch, "POST", `${this.url}/signup`, { headers: this.headers, body: { phone: c, password: d, data: (r = h == null ? void 0 : h.data) !== null && r !== void 0 ? r : {}, channel: (i = h == null ? void 0 : h.channel) !== null && i !== void 0 ? i : "sms", gotrue_meta_security: { captcha_token: h == null ? void 0 : h.captchaToken } }, xform: Rn }) } else throw new Uo("You must provide either an email or phone number and a password"); const { data: o, error: a } = s; if (a || !o) return { data: { user: null, session: null }, error: a }; const l = o.session, u = o.user; return o.session && (await this._saveSession(o.session), await this._notifyAllSubscribers("SIGNED_IN", l)), { data: { user: u, session: l }, error: null } } catch (s) { if (ee(s)) return { data: { user: null, session: null }, error: s }; throw s } } async signInWithPassword(e) { try { let n; if ("email" in e) { const { email: s, password: o, options: a } = e; n = await ne(this.fetch, "POST", `${this.url}/token?grant_type=password`, { headers: this.headers, body: { email: s, password: o, gotrue_meta_security: { captcha_token: a == null ? void 0 : a.captchaToken } }, xform: ug }) } else if ("phone" in e) { const { phone: s, password: o, options: a } = e; n = await ne(this.fetch, "POST", `${this.url}/token?grant_type=password`, { headers: this.headers, body: { phone: s, password: o, gotrue_meta_security: { captcha_token: a == null ? void 0 : a.captchaToken } }, xform: ug }) } else throw new Uo("You must provide either an email or phone number and a password"); const { data: r, error: i } = n; return i ? { data: { user: null, session: null }, error: i } : !r || !r.session || !r.user ? { data: { user: null, session: null }, error: new Ju } : (r.session && (await this._saveSession(r.session), await this._notifyAllSubscribers("SIGNED_IN", r.session)), { data: Object.assign({ user: r.user, session: r.session }, r.weak_password ? { weakPassword: r.weak_password } : null), error: i }) } catch (n) { if (ee(n)) return { data: { user: null, session: null }, error: n }; throw n } } async signInWithOAuth(e) { var n, r, i, s; return await this._handleProviderSignIn(e.provider, { redirectTo: (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo, scopes: (r = e.options) === null || r === void 0 ? void 0 : r.scopes, queryParams: (i = e.options) === null || i === void 0 ? void 0 : i.queryParams, skipBrowserRedirect: (s = e.options) === null || s === void 0 ? void 0 : s.skipBrowserRedirect }) } async exchangeCodeForSession(e) { return await this.initializePromise, this._acquireLock(-1, async () => this._exchangeCodeForSession(e)) } async _exchangeCodeForSession(e) { const n = await Bo(this.storage, `${this.storageKey}-code-verifier`), [r, i] = (n ?? "").split("/"), { data: s, error: o } = await ne(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, { headers: this.headers, body: { auth_code: e, code_verifier: r }, xform: Rn }); return await Xu(this.storage, `${this.storageKey}-code-verifier`), o ? { data: { user: null, session: null, redirectType: null }, error: o } : !s || !s.session || !s.user ? { data: { user: null, session: null, redirectType: null }, error: new Ju } : (s.session && (await this._saveSession(s.session), await this._notifyAllSubscribers("SIGNED_IN", s.session)), { data: Object.assign(Object.assign({}, s), { redirectType: i ?? null }), error: o }) } async signInWithIdToken(e) { try { const { options: n, provider: r, token: i, access_token: s, nonce: o } = e, a = await ne(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, { headers: this.headers, body: { provider: r, id_token: i, access_token: s, nonce: o, gotrue_meta_security: { captcha_token: n == null ? void 0 : n.captchaToken } }, xform: Rn }), { data: l, error: u } = a; return u ? { data: { user: null, session: null }, error: u } : !l || !l.session || !l.user ? { data: { user: null, session: null }, error: new Ju } : (l.session && (await this._saveSession(l.session), await this._notifyAllSubscribers("SIGNED_IN", l.session)), { data: l, error: u }) } catch (n) { if (ee(n)) return { data: { user: null, session: null }, error: n }; throw n } } async signInWithOtp(e) { var n, r, i, s, o; try { if ("email" in e) { const { email: a, options: l } = e; let u = null, c = null; this.flowType === "pkce" && ([u, c] = await Gr(this.storage, this.storageKey)); const { error: d } = await ne(this.fetch, "POST", `${this.url}/otp`, { headers: this.headers, body: { email: a, data: (n = l == null ? void 0 : l.data) !== null && n !== void 0 ? n : {}, create_user: (r = l == null ? void 0 : l.shouldCreateUser) !== null && r !== void 0 ? r : !0, gotrue_meta_security: { captcha_token: l == null ? void 0 : l.captchaToken }, code_challenge: u, code_challenge_method: c }, redirectTo: l == null ? void 0 : l.emailRedirectTo }); return { data: { user: null, session: null }, error: d } } if ("phone" in e) { const { phone: a, options: l } = e, { data: u, error: c } = await ne(this.fetch, "POST", `${this.url}/otp`, { headers: this.headers, body: { phone: a, data: (i = l == null ? void 0 : l.data) !== null && i !== void 0 ? i : {}, create_user: (s = l == null ? void 0 : l.shouldCreateUser) !== null && s !== void 0 ? s : !0, gotrue_meta_security: { captcha_token: l == null ? void 0 : l.captchaToken }, channel: (o = l == null ? void 0 : l.channel) !== null && o !== void 0 ? o : "sms" } }); return { data: { user: null, session: null, messageId: u == null ? void 0 : u.message_id }, error: c } } throw new Uo("You must provide either an email or phone number.") } catch (a) { if (ee(a)) return { data: { user: null, session: null }, error: a }; throw a } } async verifyOtp(e) { var n, r; try { let i, s; "options" in e && (i = (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo, s = (r = e.options) === null || r === void 0 ? void 0 : r.captchaToken); const { data: o, error: a } = await ne(this.fetch, "POST", `${this.url}/verify`, { headers: this.headers, body: Object.assign(Object.assign({}, e), { gotrue_meta_security: { captcha_token: s } }), redirectTo: i, xform: Rn }); if (a) throw a; if (!o) throw new Error("An error occurred on token verification."); const l = o.session, u = o.user; return l != null && l.access_token && (await this._saveSession(l), await this._notifyAllSubscribers(e.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", l)), { data: { user: u, session: l }, error: null } } catch (i) { if (ee(i)) return { data: { user: null, session: null }, error: i }; throw i } } async signInWithSSO(e) { var n, r, i; try { let s = null, o = null; return this.flowType === "pkce" && ([s, o] = await Gr(this.storage, this.storageKey)), await ne(this.fetch, "POST", `${this.url}/sso`, { body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in e ? { provider_id: e.providerId } : null), "domain" in e ? { domain: e.domain } : null), { redirect_to: (r = (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo) !== null && r !== void 0 ? r : void 0 }), !((i = e == null ? void 0 : e.options) === null || i === void 0) && i.captchaToken ? { gotrue_meta_security: { captcha_token: e.options.captchaToken } } : null), { skip_http_redirect: !0, code_challenge: s, code_challenge_method: o }), headers: this.headers, xform: vC }) } catch (s) { if (ee(s)) return { data: null, error: s }; throw s } } async reauthenticate() { return await this.initializePromise, await this._acquireLock(-1, async () => await this._reauthenticate()) } async _reauthenticate() { try { return await this._useSession(async e => { const { data: { session: n }, error: r } = e; if (r) throw r; if (!n) throw new hr; const { error: i } = await ne(this.fetch, "GET", `${this.url}/reauthenticate`, { headers: this.headers, jwt: n.access_token }); return { data: { user: null, session: null }, error: i } }) } catch (e) { if (ee(e)) return { data: { user: null, session: null }, error: e }; throw e } } async resend(e) { try { const n = `${this.url}/resend`; if ("email" in e) { const { email: r, type: i, options: s } = e, { error: o } = await ne(this.fetch, "POST", n, { headers: this.headers, body: { email: r, type: i, gotrue_meta_security: { captcha_token: s == null ? void 0 : s.captchaToken } }, redirectTo: s == null ? void 0 : s.emailRedirectTo }); return { data: { user: null, session: null }, error: o } } else if ("phone" in e) { const { phone: r, type: i, options: s } = e, { data: o, error: a } = await ne(this.fetch, "POST", n, { headers: this.headers, body: { phone: r, type: i, gotrue_meta_security: { captcha_token: s == null ? void 0 : s.captchaToken } } }); return { data: { user: null, session: null, messageId: o == null ? void 0 : o.message_id }, error: a } } throw new Uo("You must provide either an email or phone number and a type") } catch (n) { if (ee(n)) return { data: { user: null, session: null }, error: n }; throw n } } async getSession() { return await this.initializePromise, await this._acquireLock(-1, async () => this._useSession(async n => n)) } async _acquireLock(e, n) { this._debug("#_acquireLock", "begin", e); try { if (this.lockAcquired) { const r = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve(), i = (async () => (await r, await n()))(); return this.pendingInLock.push((async () => { try { await i } catch { } })()), i } return await this.lock(`lock:${this.storageKey}`, e, async () => { this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey); try { this.lockAcquired = !0; const r = n(); for (this.pendingInLock.push((async () => { try { await r } catch { } })()), await r; this.pendingInLock.length;) { const i = [...this.pendingInLock]; await Promise.all(i), this.pendingInLock.splice(0, i.length) } return await r } finally { this._debug("#_acquireLock", "lock released for storage key", this.storageKey), this.lockAcquired = !1 } }) } finally { this._debug("#_acquireLock", "end") } } async _useSession(e) { this._debug("#_useSession", "begin"); try { const n = await this.__loadSession(); return await e(n) } finally { this._debug("#_useSession", "end") } } async __loadSession() { this._debug("#__loadSession()", "begin"), this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack); try { let e = null; const n = await Bo(this.storage, this.storageKey); if (this._debug("#getSession()", "session from storage", n), n !== null && (this._isValidSession(n) ? e = n : (this._debug("#getSession()", "session from storage is not valid"), await this._removeSession())), !e) return { data: { session: null }, error: null }; const r = e.expires_at ? e.expires_at <= Date.now() / 1e3 : !1; if (this._debug("#__loadSession()", `session has${r ? "" : " not"} expired`, "expires_at", e.expires_at), !r) { if (this.storage.isServer) { let o = this.suppressGetSessionWarning; e = new Proxy(e, { get: (l, u, c) => (!o && u === "user" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and many not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."), o = !0, this.suppressGetSessionWarning = !0), Reflect.get(l, u, c)) }) } return { data: { session: e }, error: null } } const { session: i, error: s } = await this._callRefreshToken(e.refresh_token); return s ? { data: { session: null }, error: s } : { data: { session: i }, error: null } } finally { this._debug("#__loadSession()", "end") } } async getUser(e) { return e ? await this._getUser(e) : (await this.initializePromise, await this._acquireLock(-1, async () => await this._getUser())) } async _getUser(e) { try { return e ? await ne(this.fetch, "GET", `${this.url}/user`, { headers: this.headers, jwt: e, xform: Nn }) : await this._useSession(async n => { var r, i, s; const { data: o, error: a } = n; if (a) throw a; return !(!((r = o.session) === null || r === void 0) && r.access_token) && !this.hasCustomAuthorizationHeader ? { data: { user: null }, error: new hr } : await ne(this.fetch, "GET", `${this.url}/user`, { headers: this.headers, jwt: (s = (i = o.session) === null || i === void 0 ? void 0 : i.access_token) !== null && s !== void 0 ? s : void 0, xform: Nn }) }) } catch (n) { if (ee(n)) return { data: { user: null }, error: n }; throw n } } async updateUser(e, n = {}) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._updateUser(e, n)) } async _updateUser(e, n = {}) { try { return await this._useSession(async r => { const { data: i, error: s } = r; if (s) throw s; if (!i.session) throw new hr; const o = i.session; let a = null, l = null; this.flowType === "pkce" && e.email != null && ([a, l] = await Gr(this.storage, this.storageKey)); const { data: u, error: c } = await ne(this.fetch, "PUT", `${this.url}/user`, { headers: this.headers, redirectTo: n == null ? void 0 : n.emailRedirectTo, body: Object.assign(Object.assign({}, e), { code_challenge: a, code_challenge_method: l }), jwt: o.access_token, xform: Nn }); if (c) throw c; return o.user = u.user, await this._saveSession(o), await this._notifyAllSubscribers("USER_UPDATED", o), { data: { user: o.user }, error: null } }) } catch (r) { if (ee(r)) return { data: { user: null }, error: r }; throw r } } _decodeJWT(e) { return sg(e) } async setSession(e) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._setSession(e)) } async _setSession(e) { try { if (!e.access_token || !e.refresh_token) throw new hr; const n = Date.now() / 1e3; let r = n, i = !0, s = null; const o = sg(e.access_token); if (o.exp && (r = o.exp, i = r <= n), i) { const { session: a, error: l } = await this._callRefreshToken(e.refresh_token); if (l) return { data: { user: null, session: null }, error: l }; if (!a) return { data: { user: null, session: null }, error: null }; s = a } else { const { data: a, error: l } = await this._getUser(e.access_token); if (l) throw l; s = { access_token: e.access_token, refresh_token: e.refresh_token, user: a.user, token_type: "bearer", expires_in: r - n, expires_at: r }, await this._saveSession(s), await this._notifyAllSubscribers("SIGNED_IN", s) } return { data: { user: s.user, session: s }, error: null } } catch (n) { if (ee(n)) return { data: { session: null, user: null }, error: n }; throw n } } async refreshSession(e) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._refreshSession(e)) } async _refreshSession(e) { try { return await this._useSession(async n => { var r; if (!e) { const { data: o, error: a } = n; if (a) throw a; e = (r = o.session) !== null && r !== void 0 ? r : void 0 } if (!(e != null && e.refresh_token)) throw new hr; const { session: i, error: s } = await this._callRefreshToken(e.refresh_token); return s ? { data: { user: null, session: null }, error: s } : i ? { data: { user: i.user, session: i }, error: null } : { data: { user: null, session: null }, error: null } }) } catch (n) { if (ee(n)) return { data: { user: null, session: null }, error: n }; throw n } } async _getSessionFromURL(e) { try { if (!zt()) throw new Ho("No browser detected."); if (this.flowType === "implicit" && !this._isImplicitGrantFlow()) throw new Ho("Not a valid implicit grant flow url."); if (this.flowType == "pkce" && !e) throw new og("Not a valid PKCE flow url."); const n = Qu(window.location.href); if (e) { if (!n.code) throw new og("No code detected."); const { data: v, error: b } = await this._exchangeCodeForSession(n.code); if (b) throw b; const S = new URL(window.location.href); return S.searchParams.delete("code"), window.history.replaceState(window.history.state, "", S.toString()), { data: { session: v.session, redirectType: null }, error: null } } if (n.error || n.error_description || n.error_code) throw new Ho(n.error_description || "Error in URL with unspecified error_description", { error: n.error || "unspecified_error", code: n.error_code || "unspecified_code" }); const { provider_token: r, provider_refresh_token: i, access_token: s, refresh_token: o, expires_in: a, expires_at: l, token_type: u } = n; if (!s || !a || !o || !u) throw new Ho("No session defined in URL"); const c = Math.round(Date.now() / 1e3), d = parseInt(a); let h = c + d; l && (h = parseInt(l)); const f = h - c; f * 1e3 <= ts && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${f}s, should have been closer to ${d}s`); const g = h - d; c - g >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", g, h, c) : c - g < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clok for skew", g, h, c); const { data: m, error: y } = await this._getUser(s); if (y) throw y; const p = { provider_token: r, provider_refresh_token: i, access_token: s, expires_in: d, expires_at: h, refresh_token: o, token_type: u, user: m.user }; return window.location.hash = "", this._debug("#_getSessionFromURL()", "clearing window.location.hash"), { data: { session: p, redirectType: n.type }, error: null } } catch (n) { if (ee(n)) return { data: { session: null, redirectType: null }, error: n }; throw n } } _isImplicitGrantFlow() { const e = Qu(window.location.href); return !!(zt() && (e.access_token || e.error_description)) } async _isPKCEFlow() { const e = Qu(window.location.href), n = await Bo(this.storage, `${this.storageKey}-code-verifier`); return !!(e.code && n) } async signOut(e = { scope: "global" }) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._signOut(e)) } async _signOut({ scope: e } = { scope: "global" }) { return await this._useSession(async n => { var r; const { data: i, error: s } = n; if (s) return { error: s }; const o = (r = i.session) === null || r === void 0 ? void 0 : r.access_token; if (o) { const { error: a } = await this.admin.signOut(o, e); if (a && !(hC(a) && (a.status === 404 || a.status === 401 || a.status === 403))) return { error: a } } return e !== "others" && (await this._removeSession(), await Xu(this.storage, `${this.storageKey}-code-verifier`), await this._notifyAllSubscribers("SIGNED_OUT", null)), { error: null } }) } onAuthStateChange(e) { const n = Zk(), r = { id: n, callback: e, unsubscribe: () => { this._debug("#unsubscribe()", "state change callback with id removed", n), this.stateChangeEmitters.delete(n) } }; return this._debug("#onAuthStateChange()", "registered callback with id", n), this.stateChangeEmitters.set(n, r), (async () => (await this.initializePromise, await this._acquireLock(-1, async () => { this._emitInitialSession(n) })))(), { data: { subscription: r } } } async _emitInitialSession(e) { return await this._useSession(async n => { var r, i; try { const { data: { session: s }, error: o } = n; if (o) throw o; await ((r = this.stateChangeEmitters.get(e)) === null || r === void 0 ? void 0 : r.callback("INITIAL_SESSION", s)), this._debug("INITIAL_SESSION", "callback id", e, "session", s) } catch (s) { await ((i = this.stateChangeEmitters.get(e)) === null || i === void 0 ? void 0 : i.callback("INITIAL_SESSION", null)), this._debug("INITIAL_SESSION", "callback id", e, "error", s), console.error(s) } }) } async resetPasswordForEmail(e, n = {}) { let r = null, i = null; this.flowType === "pkce" && ([r, i] = await Gr(this.storage, this.storageKey, !0)); try { return await ne(this.fetch, "POST", `${this.url}/recover`, { body: { email: e, code_challenge: r, code_challenge_method: i, gotrue_meta_security: { captcha_token: n.captchaToken } }, headers: this.headers, redirectTo: n.redirectTo }) } catch (s) { if (ee(s)) return { data: null, error: s }; throw s } } async getUserIdentities() { var e; try { const { data: n, error: r } = await this.getUser(); if (r) throw r; return { data: { identities: (e = n.user.identities) !== null && e !== void 0 ? e : [] }, error: null } } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } } async linkIdentity(e) { var n; try { const { data: r, error: i } = await this._useSession(async s => { var o, a, l, u, c; const { data: d, error: h } = s; if (h) throw h; const f = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, e.provider, { redirectTo: (o = e.options) === null || o === void 0 ? void 0 : o.redirectTo, scopes: (a = e.options) === null || a === void 0 ? void 0 : a.scopes, queryParams: (l = e.options) === null || l === void 0 ? void 0 : l.queryParams, skipBrowserRedirect: !0 }); return await ne(this.fetch, "GET", f, { headers: this.headers, jwt: (c = (u = d.session) === null || u === void 0 ? void 0 : u.access_token) !== null && c !== void 0 ? c : void 0 }) }); if (i) throw i; return zt() && !(!((n = e.options) === null || n === void 0) && n.skipBrowserRedirect) && window.location.assign(r == null ? void 0 : r.url), { data: { provider: e.provider, url: r == null ? void 0 : r.url }, error: null } } catch (r) { if (ee(r)) return { data: { provider: e.provider, url: null }, error: r }; throw r } } async unlinkIdentity(e) { try { return await this._useSession(async n => { var r, i; const { data: s, error: o } = n; if (o) throw o; return await ne(this.fetch, "DELETE", `${this.url}/user/identities/${e.identity_id}`, { headers: this.headers, jwt: (i = (r = s.session) === null || r === void 0 ? void 0 : r.access_token) !== null && i !== void 0 ? i : void 0 }) }) } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } } async _refreshAccessToken(e) { const n = `#_refreshAccessToken(${e.substring(0, 5)}...)`; this._debug(n, "begin"); try { const r = Date.now(); return await rC(async i => (i > 0 && await nC(200 * Math.pow(2, i - 1)), this._debug(n, "refreshing attempt", i), await ne(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, { body: { refresh_token: e }, headers: this.headers, xform: Rn })), (i, s) => { const o = 200 * Math.pow(2, i); return s && Zu(s) && Date.now() + o - r < ts }) } catch (r) { if (this._debug(n, "error", r), ee(r)) return { data: { session: null, user: null }, error: r }; throw r } finally { this._debug(n, "end") } } _isValidSession(e) { return typeof e == "object" && e !== null && "access_token" in e && "refresh_token" in e && "expires_at" in e } async _handleProviderSignIn(e, n) { const r = await this._getUrlForProvider(`${this.url}/authorize`, e, { redirectTo: n.redirectTo, scopes: n.scopes, queryParams: n.queryParams }); return this._debug("#_handleProviderSignIn()", "provider", e, "options", n, "url", r), zt() && !n.skipBrowserRedirect && window.location.assign(r), { data: { provider: e, url: r }, error: null } } async _recoverAndRefresh() { var e; const n = "#_recoverAndRefresh()"; this._debug(n, "begin"); try { const r = await Bo(this.storage, this.storageKey); if (this._debug(n, "session from storage", r), !this._isValidSession(r)) { this._debug(n, "session is not valid"), r !== null && await this._removeSession(); return } const i = Math.round(Date.now() / 1e3), s = ((e = r.expires_at) !== null && e !== void 0 ? e : 1 / 0) < i + ig; if (this._debug(n, `session has${s ? "" : " not"} expired with margin of ${ig}s`), s) { if (this.autoRefreshToken && r.refresh_token) { const { error: o } = await this._callRefreshToken(r.refresh_token); o && (console.error(o), Zu(o) || (this._debug(n, "refresh failed with a non-retryable error, removing the session", o), await this._removeSession())) } } else await this._notifyAllSubscribers("SIGNED_IN", r) } catch (r) { this._debug(n, "error", r), console.error(r); return } finally { this._debug(n, "end") } } async _callRefreshToken(e) { var n, r; if (!e) throw new hr; if (this.refreshingDeferred) return this.refreshingDeferred.promise; const i = `#_callRefreshToken(${e.substring(0, 5)}...)`; this._debug(i, "begin"); try { this.refreshingDeferred = new Ql; const { data: s, error: o } = await this._refreshAccessToken(e); if (o) throw o; if (!s.session) throw new hr; await this._saveSession(s.session), await this._notifyAllSubscribers("TOKEN_REFRESHED", s.session); const a = { session: s.session, error: null }; return this.refreshingDeferred.resolve(a), a } catch (s) { if (this._debug(i, "error", s), ee(s)) { const o = { session: null, error: s }; return Zu(s) || (await this._removeSession(), await this._notifyAllSubscribers("SIGNED_OUT", null)), (n = this.refreshingDeferred) === null || n === void 0 || n.resolve(o), o } throw (r = this.refreshingDeferred) === null || r === void 0 || r.reject(s), s } finally { this.refreshingDeferred = null, this._debug(i, "end") } } async _notifyAllSubscribers(e, n, r = !0) { const i = `#_notifyAllSubscribers(${e})`; this._debug(i, "begin", n, `broadcast = ${r}`); try { this.broadcastChannel && r && this.broadcastChannel.postMessage({ event: e, session: n }); const s = [], o = Array.from(this.stateChangeEmitters.values()).map(async a => { try { await a.callback(e, n) } catch (l) { s.push(l) } }); if (await Promise.all(o), s.length > 0) { for (let a = 0; a < s.length; a += 1)console.error(s[a]); throw s[0] } } finally { this._debug(i, "end") } } async _saveSession(e) { this._debug("#_saveSession()", e), this.suppressGetSessionWarning = !0, await tb(this.storage, this.storageKey, e) } async _removeSession() { this._debug("#_removeSession()"), await Xu(this.storage, this.storageKey) } _removeVisibilityChangedCallback() { this._debug("#_removeVisibilityChangedCallback()"); const e = this.visibilityChangedCallback; this.visibilityChangedCallback = null; try { e && zt() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", e) } catch (n) { console.error("removing visibilitychange callback failed", n) } } async _startAutoRefresh() { await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()"); const e = setInterval(() => this._autoRefreshTokenTick(), ts); this.autoRefreshTicker = e, e && typeof e == "object" && typeof e.unref == "function" ? e.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(e), setTimeout(async () => { await this.initializePromise, await this._autoRefreshTokenTick() }, 0) } async _stopAutoRefresh() { this._debug("#_stopAutoRefresh()"); const e = this.autoRefreshTicker; this.autoRefreshTicker = null, e && clearInterval(e) } async startAutoRefresh() { this._removeVisibilityChangedCallback(), await this._startAutoRefresh() } async stopAutoRefresh() { this._removeVisibilityChangedCallback(), await this._stopAutoRefresh() } async _autoRefreshTokenTick() { this._debug("#_autoRefreshTokenTick()", "begin"); try { await this._acquireLock(0, async () => { try { const e = Date.now(); try { return await this._useSession(async n => { const { data: { session: r } } = n; if (!r || !r.refresh_token || !r.expires_at) { this._debug("#_autoRefreshTokenTick()", "no session"); return } const i = Math.floor((r.expires_at * 1e3 - e) / ts); this._debug("#_autoRefreshTokenTick()", `access token expires in ${i} ticks, a tick lasts ${ts}ms, refresh threshold is ${dg} ticks`), i <= dg && await this._callRefreshToken(r.refresh_token) }) } catch (n) { console.error("Auto refresh tick failed with error. This is likely a transient error.", n) } } finally { this._debug("#_autoRefreshTokenTick()", "end") } }) } catch (e) { if (e.isAcquireTimeout || e instanceof rb) this._debug("auto refresh token tick lock not available"); else throw e } } async _handleVisibilityChange() { if (this._debug("#_handleVisibilityChange()"), !zt() || !(window != null && window.addEventListener)) return this.autoRefreshToken && this.startAutoRefresh(), !1; try { this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1), window == null || window.addEventListener("visibilitychange", this.visibilityChangedCallback), await this._onVisibilityChanged(!0) } catch (e) { console.error("_handleVisibilityChange", e) } } async _onVisibilityChanged(e) { const n = `#_onVisibilityChanged(${e})`; this._debug(n, "visibilityState", document.visibilityState), document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(), e || (await this.initializePromise, await this._acquireLock(-1, async () => { if (document.visibilityState !== "visible") { this._debug(n, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting"); return } await this._recoverAndRefresh() }))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh() } async _getUrlForProvider(e, n, r) { const i = [`provider=${encodeURIComponent(n)}`]; if (r != null && r.redirectTo && i.push(`redirect_to=${encodeURIComponent(r.redirectTo)}`), r != null && r.scopes && i.push(`scopes=${encodeURIComponent(r.scopes)}`), this.flowType === "pkce") { const [s, o] = await Gr(this.storage, this.storageKey), a = new URLSearchParams({ code_challenge: `${encodeURIComponent(s)}`, code_challenge_method: `${encodeURIComponent(o)}` }); i.push(a.toString()) } if (r != null && r.queryParams) { const s = new URLSearchParams(r.queryParams); i.push(s.toString()) } return r != null && r.skipBrowserRedirect && i.push(`skip_http_redirect=${r.skipBrowserRedirect}`), `${e}?${i.join("&")}` } async _unenroll(e) { try { return await this._useSession(async n => { var r; const { data: i, error: s } = n; return s ? { data: null, error: s } : await ne(this.fetch, "DELETE", `${this.url}/factors/${e.factorId}`, { headers: this.headers, jwt: (r = i == null ? void 0 : i.session) === null || r === void 0 ? void 0 : r.access_token }) }) } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } } async _enroll(e) { try { return await this._useSession(async n => { var r, i; const { data: s, error: o } = n; if (o) return { data: null, error: o }; const { data: a, error: l } = await ne(this.fetch, "POST", `${this.url}/factors`, { body: { friendly_name: e.friendlyName, factor_type: e.factorType, issuer: e.issuer }, headers: this.headers, jwt: (r = s == null ? void 0 : s.session) === null || r === void 0 ? void 0 : r.access_token }); return l ? { data: null, error: l } : (!((i = a == null ? void 0 : a.totp) === null || i === void 0) && i.qr_code && (a.totp.qr_code = `data:image/svg+xml;utf-8,${a.totp.qr_code}`), { data: a, error: null }) }) } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } } async _verify(e) { return this._acquireLock(-1, async () => { try { return await this._useSession(async n => { var r; const { data: i, error: s } = n; if (s) return { data: null, error: s }; const { data: o, error: a } = await ne(this.fetch, "POST", `${this.url}/factors/${e.factorId}/verify`, { body: { code: e.code, challenge_id: e.challengeId }, headers: this.headers, jwt: (r = i == null ? void 0 : i.session) === null || r === void 0 ? void 0 : r.access_token }); return a ? { data: null, error: a } : (await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + o.expires_in }, o)), await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", o), { data: o, error: a }) }) } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } }) } async _challenge(e) { return this._acquireLock(-1, async () => { try { return await this._useSession(async n => { var r; const { data: i, error: s } = n; return s ? { data: null, error: s } : await ne(this.fetch, "POST", `${this.url}/factors/${e.factorId}/challenge`, { headers: this.headers, jwt: (r = i == null ? void 0 : i.session) === null || r === void 0 ? void 0 : r.access_token }) }) } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } }) } async _challengeAndVerify(e) { const { data: n, error: r } = await this._challenge({ factorId: e.factorId }); return r ? { data: null, error: r } : await this._verify({ factorId: e.factorId, challengeId: n.id, code: e.code }) } async _listFactors() { const { data: { user: e }, error: n } = await this.getUser(); if (n) return { data: null, error: n }; const r = (e == null ? void 0 : e.factors) || [], i = r.filter(s => s.factor_type === "totp" && s.status === "verified"); return { data: { all: r, totp: i }, error: null } } async _getAuthenticatorAssuranceLevel() { return this._acquireLock(-1, async () => await this._useSession(async e => { var n, r; const { data: { session: i }, error: s } = e; if (s) return { data: null, error: s }; if (!i) return { data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] }, error: null }; const o = this._decodeJWT(i.access_token); let a = null; o.aal && (a = o.aal); let l = a; ((r = (n = i.user.factors) === null || n === void 0 ? void 0 : n.filter(d => d.status === "verified")) !== null && r !== void 0 ? r : []).length > 0 && (l = "aal2"); const c = o.amr || []; return { data: { currentLevel: a, nextLevel: l, currentAuthenticationMethods: c }, error: null } })) } } Js.nextInstanceID = 0; const EC = Js; class TC extends EC { constructor(e) { super(e) } } var IC = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; class RC { constructor(e, n, r) { var i, s, o; if (this.supabaseUrl = e, this.supabaseKey = n, !e) throw new Error("supabaseUrl is required."); if (!n) throw new Error("supabaseKey is required."); const a = Kk(e); this.realtimeUrl = `${a}/realtime/v1`.replace(/^http/i, "ws"), this.authUrl = `${a}/auth/v1`, this.storageUrl = `${a}/storage/v1`, this.functionsUrl = `${a}/functions/v1`; const l = `sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`, u = { db: zk, realtime: Bk, auth: Object.assign(Object.assign({}, Vk), { storageKey: l }), global: $k }, c = Gk(r ?? {}, u); this.storageKey = (i = c.auth.storageKey) !== null && i !== void 0 ? i : "", this.headers = (s = c.global.headers) !== null && s !== void 0 ? s : {}, this.auth = this._initSupabaseAuthClient((o = c.auth) !== null && o !== void 0 ? o : {}, this.headers, c.global.fetch), this.fetch = qk(n, this._getAccessToken.bind(this), c.global.fetch), this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers }, c.realtime)), this.rest = new uk(`${a}/rest/v1`, { headers: this.headers, schema: c.db.schema, fetch: this.fetch }), this._listenForAuthEvents() } get functions() { return new $1(this.functionsUrl, { headers: this.headers, customFetch: this.fetch }) } get storage() { return new jk(this.storageUrl, this.headers, this.fetch) } from(e) { return this.rest.from(e) } schema(e) { return this.rest.schema(e) } rpc(e, n = {}, r = {}) { return this.rest.rpc(e, n, r) } channel(e, n = { config: {} }) { return this.realtime.channel(e, n) } getChannels() { return this.realtime.getChannels() } removeChannel(e) { return this.realtime.removeChannel(e) } removeAllChannels() { return this.realtime.removeAllChannels() } _getAccessToken() { var e, n; return IC(this, void 0, void 0, function* () { const { data: r } = yield this.auth.getSession(); return (n = (e = r.session) === null || e === void 0 ? void 0 : e.access_token) !== null && n !== void 0 ? n : null }) } _initSupabaseAuthClient({ autoRefreshToken: e, persistSession: n, detectSessionInUrl: r, storage: i, storageKey: s, flowType: o, debug: a }, l, u) { var c; const d = { Authorization: `Bearer ${this.supabaseKey}`, apikey: `${this.supabaseKey}` }; return new TC({ url: this.authUrl, headers: Object.assign(Object.assign({}, d), l), storageKey: s, autoRefreshToken: e, persistSession: n, detectSessionInUrl: r, storage: i, flowType: o, debug: a, fetch: u, hasCustomAuthorizationHeader: (c = "Authorization" in this.headers) !== null && c !== void 0 ? c : !1 }) } _initRealtimeClient(e) { return new xk(this.realtimeUrl, Object.assign(Object.assign({}, e), { params: Object.assign({ apikey: this.supabaseKey }, e == null ? void 0 : e.params) })) } _listenForAuthEvents() { return this.auth.onAuthStateChange((n, r) => { this._handleTokenChanged(n, "CLIENT", r == null ? void 0 : r.access_token) }) } _handleTokenChanged(e, n, r) { (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") && this.changedAccessToken !== r ? (this.realtime.setAuth(r ?? null), this.changedAccessToken = r) : e === "SIGNED_OUT" && (this.realtime.setAuth(this.supabaseKey), n == "STORAGE" && this.auth.signOut(), this.changedAccessToken = void 0) } } const MC = (t, e, n) => new RC(t, e, n), LC = "https://kbkzeihbxlpsvkjpczms.supabase.co", DC = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imtia3plaWhieGxwc3ZranBjem1zIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjExOTk2NzQsImV4cCI6MjAzNjc3NTY3NH0.fRsuMrxSGlAYFNGhysj46ajeecKWf5IGaJtchtMQA2Y", je = MC(LC, DC), ol = "./assets/banking-B5UmtjCw.jpg", AC = () => { var l; const [t, e] = R.useState(null), [n, r] = R.useState(!1), i = R.useRef(null), s = Ul(); R.useEffect(() => { (async () => { const { data: { user: c } } = await je.auth.getUser(); e(c) })() }, []); const o = async () => { window.confirm("Êtes-vous sûr de vouloir vous déconnecter ?") && (await je.auth.signOut(), s("/Home")) }, a = () => { r(!n) }; return R.useEffect(() => { const u = c => { i.current && !i.current.contains(c.target) && r(!1) }; return document.addEventListener("mousedown", u), () => { document.removeEventListener("mousedown", u) } }, []), A.jsxs("nav", { className: "bg-blue-500 text-white p-4 flex justify-between items-center", children: [A.jsxs(Jr, { to: t ? "/accountform" : "/", className: "flex items-center text-white mr-4", children: [A.jsx("img", { src: ol, alt: "Logo", className: "w-12 rounded-full", style: { cursor: "pointer" } }), A.jsx("h1", { className: "text-2xl pl-3", children: "Gestion de Comptes" })] }), t ? A.jsxs("div", { className: "flex justify-evenly w-1/2 items-center", children: [A.jsx(Jr, { to: "/accountform", className: "text-white border border-gray-200 rounded-md p-2", children: "Accueil" }), A.jsx(Jr, { to: "/tableau", className: "text-white border border-gray-200 rounded-md p-2", children: "Tableau" }), A.jsx(Jr, { to: "/graphique", className: "text-white border border-gray-200 rounded-md p-2", children: "Graphique" })] }) : null, A.jsx("div", { className: "relative flex items-center", children: t ? A.jsxs("div", { className: "relative flex flex-col items-center pr-4", onClick: a, ref: i, children: [A.jsx("img", { src: ol, alt: "Avatar", className: "w-8 h-8 rounded-full cursor-pointer" }), A.jsx("span", { className: "text-sm cursor-pointer", children: ((l = t.user_metadata) == null ? void 0 : l.full_name) || t.email }), n && A.jsxs("div", { className: "absolute top-full mt-2 w-48 bg-white text-black rounded shadow-lg", children: [A.jsx("button", { onClick: () => s("/parametres"), className: "block w-full text-left px-4 py-2 bg-gray-200 hover:bg-slate-400", children: "Paramètres" }), A.jsx("button", { onClick: () => s("/contact"), className: "block w-full text-left px-4 py-2 bg-gray-200 hover:bg-slate-400", children: "Contact" }), A.jsx("button", { onClick: o, className: "block w-full text-left px-4 py-2 bg-gray-200 hover:bg-slate-400", children: "Déconnexion" })] })] }) : A.jsx(Jr, { to: "/auth", className: "text-white mr-4", children: "Connexion" }) })] }) }; var jC = { exports: {} }; (function (t) { var e = function (n) { var r = Object.prototype, i = r.hasOwnProperty, s = Object.defineProperty || function (_, x, C) { _[x] = C.value }, o, a = typeof Symbol == "function" ? Symbol : {}, l = a.iterator || "@@iterator", u = a.asyncIterator || "@@asyncIterator", c = a.toStringTag || "@@toStringTag"; function d(_, x, C) { return Object.defineProperty(_, x, { value: C, enumerable: !0, configurable: !0, writable: !0 }), _[x] } try { d({}, "") } catch { d = function (x, C, w) { return x[C] = w } } function h(_, x, C, w) { var O = x && x.prototype instanceof b ? x : b, D = Object.create(O.prototype), F = new V(w || []); return s(D, "_invoke", { value: N(_, C, F) }), D } n.wrap = h; function f(_, x, C) { try { return { type: "normal", arg: _.call(x, C) } } catch (w) { return { type: "throw", arg: w } } } var g = "suspendedStart", m = "suspendedYield", y = "executing", p = "completed", v = {}; function b() { } function S() { } function P() { } var I = {}; d(I, l, function () { return this }); var T = Object.getPrototypeOf, k = T && T(T(q([]))); k && k !== r && i.call(k, l) && (I = k); var E = P.prototype = b.prototype = Object.create(I); S.prototype = P, s(E, "constructor", { value: P, configurable: !0 }), s(P, "constructor", { value: S, configurable: !0 }), S.displayName = d(P, c, "GeneratorFunction"); function M(_) { ["next", "throw", "return"].forEach(function (x) { d(_, x, function (C) { return this._invoke(x, C) }) }) } n.isGeneratorFunction = function (_) { var x = typeof _ == "function" && _.constructor; return x ? x === S || (x.displayName || x.name) === "GeneratorFunction" : !1 }, n.mark = function (_) { return Object.setPrototypeOf ? Object.setPrototypeOf(_, P) : (_.__proto__ = P, d(_, c, "GeneratorFunction")), _.prototype = Object.create(E), _ }, n.awrap = function (_) { return { __await: _ } }; function L(_, x) { function C(D, F, z, W) { var K = f(_[D], _, F); if (K.type === "throw") W(K.arg); else { var Z = K.arg, ae = Z.value; return ae && typeof ae == "object" && i.call(ae, "__await") ? x.resolve(ae.__await).then(function (ue) { C("next", ue, z, W) }, function (ue) { C("throw", ue, z, W) }) : x.resolve(ae).then(function (ue) { Z.value = ue, z(Z) }, function (ue) { return C("throw", ue, z, W) }) } } var w; function O(D, F) { function z() { return new x(function (W, K) { C(D, F, W, K) }) } return w = w ? w.then(z, z) : z() } s(this, "_invoke", { value: O }) } M(L.prototype), d(L.prototype, u, function () { return this }), n.AsyncIterator = L, n.async = function (_, x, C, w, O) { O === void 0 && (O = Promise); var D = new L(h(_, x, C, w), O); return n.isGeneratorFunction(x) ? D : D.next().then(function (F) { return F.done ? F.value : D.next() }) }; function N(_, x, C) { var w = g; return function (D, F) { if (w === y) throw new Error("Generator is already running"); if (w === p) { if (D === "throw") throw F; return j() } for (C.method = D, C.arg = F; ;) { var z = C.delegate; if (z) { var W = $(z, C); if (W) { if (W === v) continue; return W } } if (C.method === "next") C.sent = C._sent = C.arg; else if (C.method === "throw") { if (w === g) throw w = p, C.arg; C.dispatchException(C.arg) } else C.method === "return" && C.abrupt("return", C.arg); w = y; var K = f(_, x, C); if (K.type === "normal") { if (w = C.done ? p : m, K.arg === v) continue; return { value: K.arg, done: C.done } } else K.type === "throw" && (w = p, C.method = "throw", C.arg = K.arg) } } } function $(_, x) { var C = x.method, w = _.iterator[C]; if (w === o) return x.delegate = null, C === "throw" && _.iterator.return && (x.method = "return", x.arg = o, $(_, x), x.method === "throw") || C !== "return" && (x.method = "throw", x.arg = new TypeError("The iterator does not provide a '" + C + "' method")), v; var O = f(w, _.iterator, x.arg); if (O.type === "throw") return x.method = "throw", x.arg = O.arg, x.delegate = null, v; var D = O.arg; if (!D) return x.method = "throw", x.arg = new TypeError("iterator result is not an object"), x.delegate = null, v; if (D.done) x[_.resultName] = D.value, x.next = _.nextLoc, x.method !== "return" && (x.method = "next", x.arg = o); else return D; return x.delegate = null, v } M(E), d(E, c, "Generator"), d(E, l, function () { return this }), d(E, "toString", function () { return "[object Generator]" }); function B(_) { var x = { tryLoc: _[0] }; 1 in _ && (x.catchLoc = _[1]), 2 in _ && (x.finallyLoc = _[2], x.afterLoc = _[3]), this.tryEntries.push(x) } function H(_) { var x = _.completion || {}; x.type = "normal", delete x.arg, _.completion = x } function V(_) { this.tryEntries = [{ tryLoc: "root" }], _.forEach(B, this), this.reset(!0) } n.keys = function (_) { var x = Object(_), C = []; for (var w in x) C.push(w); return C.reverse(), function O() { for (; C.length;) { var D = C.pop(); if (D in x) return O.value = D, O.done = !1, O } return O.done = !0, O } }; function q(_) { if (_) { var x = _[l]; if (x) return x.call(_); if (typeof _.next == "function") return _; if (!isNaN(_.length)) { var C = -1, w = function O() { for (; ++C < _.length;)if (i.call(_, C)) return O.value = _[C], O.done = !1, O; return O.value = o, O.done = !0, O }; return w.next = w } } return { next: j } } n.values = q; function j() { return { value: o, done: !0 } } return V.prototype = { constructor: V, reset: function (_) { if (this.prev = 0, this.next = 0, this.sent = this._sent = o, this.done = !1, this.delegate = null, this.method = "next", this.arg = o, this.tryEntries.forEach(H), !_) for (var x in this) x.charAt(0) === "t" && i.call(this, x) && !isNaN(+x.slice(1)) && (this[x] = o) }, stop: function () { this.done = !0; var _ = this.tryEntries[0], x = _.completion; if (x.type === "throw") throw x.arg; return this.rval }, dispatchException: function (_) { if (this.done) throw _; var x = this; function C(W, K) { return D.type = "throw", D.arg = _, x.next = W, K && (x.method = "next", x.arg = o), !!K } for (var w = this.tryEntries.length - 1; w >= 0; --w) { var O = this.tryEntries[w], D = O.completion; if (O.tryLoc === "root") return C("end"); if (O.tryLoc <= this.prev) { var F = i.call(O, "catchLoc"), z = i.call(O, "finallyLoc"); if (F && z) { if (this.prev < O.catchLoc) return C(O.catchLoc, !0); if (this.prev < O.finallyLoc) return C(O.finallyLoc) } else if (F) { if (this.prev < O.catchLoc) return C(O.catchLoc, !0) } else if (z) { if (this.prev < O.finallyLoc) return C(O.finallyLoc) } else throw new Error("try statement without catch or finally") } } }, abrupt: function (_, x) { for (var C = this.tryEntries.length - 1; C >= 0; --C) { var w = this.tryEntries[C]; if (w.tryLoc <= this.prev && i.call(w, "finallyLoc") && this.prev < w.finallyLoc) { var O = w; break } } O && (_ === "break" || _ === "continue") && O.tryLoc <= x && x <= O.finallyLoc && (O = null); var D = O ? O.completion : {}; return D.type = _, D.arg = x, O ? (this.method = "next", this.next = O.finallyLoc, v) : this.complete(D) }, complete: function (_, x) { if (_.type === "throw") throw _.arg; return _.type === "break" || _.type === "continue" ? this.next = _.arg : _.type === "return" ? (this.rval = this.arg = _.arg, this.method = "return", this.next = "end") : _.type === "normal" && x && (this.next = x), v }, finish: function (_) { for (var x = this.tryEntries.length - 1; x >= 0; --x) { var C = this.tryEntries[x]; if (C.finallyLoc === _) return this.complete(C.completion, C.afterLoc), H(C), v } }, catch: function (_) { for (var x = this.tryEntries.length - 1; x >= 0; --x) { var C = this.tryEntries[x]; if (C.tryLoc === _) { var w = C.completion; if (w.type === "throw") { var O = w.arg; H(C) } return O } } throw new Error("illegal catch attempt") }, delegateYield: function (_, x, C) { return this.delegate = { iterator: q(_), resultName: x, nextLoc: C }, this.method === "next" && (this.arg = o), v } }, n }(t.exports); try { regeneratorRuntime = e } catch { typeof globalThis == "object" ? globalThis.regeneratorRuntime = e : Function("r", "regeneratorRuntime = r")(e) } })(jC); var qh = (t, e) => `${t}-${e}-${Math.random().toString(16).slice(3, 8)}`; const NC = qh; let fg = 0; var ib = ({ id: t, action: e, payload: n = {} }) => { let r = t; return typeof r > "u" && (r = NC("Job", fg), fg += 1), { id: r, action: e, payload: n } }, Bi = {}; let Kh = !1; Bi.logging = Kh; Bi.setLogging = t => { Kh = t }; Bi.log = (...t) => Kh ? console.log.apply(void 0, t) : null; const FC = ib, { log: Wo } = Bi, $C = qh; let pg = 0; var zC = () => { const t = $C("Scheduler", pg), e = {}, n = {}; let r = []; pg += 1; const i = () => r.length, s = () => Object.keys(e).length, o = () => { if (r.length !== 0) { const d = Object.keys(e); for (let h = 0; h < d.length; h += 1)if (typeof n[d[h]] > "u") { r[0](e[d[h]]); break } } }, a = (d, h) => new Promise((f, g) => { const m = FC({ action: d, payload: h }); r.push(async y => { r.shift(), n[y.id] = m; try { f(await y[d].apply(void 0, [...h, m.id])) } catch (p) { g(p) } finally { delete n[y.id], o() } }), Wo(`[${t}]: Add ${m.id} to JobQueue`), Wo(`[${t}]: JobQueue length=${r.length}`), o() }); return { addWorker: d => (e[d.id] = d, Wo(`[${t}]: Add ${d.id}`), Wo(`[${t}]: Number of workers=${s()}`), o(), d.id), addJob: async (d, ...h) => { if (s() === 0) throw Error(`[${t}]: You need to have at least one worker before adding jobs`); return a(d, h) }, terminate: async () => { Object.keys(e).forEach(async d => { await e[d].terminate() }), r = [] }, getQueueLen: i, getNumWorkers: s } }; function VC(t) { throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.') } function BC() { return !!(typeof window < "u" && typeof window.process == "object" && window.process.type === "renderer" || typeof process < "u" && typeof process.versions == "object" && process.versions.electron || typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Electron") >= 0) } var UC = BC; const HC = UC; var WC = t => { const e = {}; return typeof WorkerGlobalScope < "u" ? e.type = "webworker" : HC() ? e.type = "electron" : typeof document == "object" ? e.type = "browser" : typeof process == "object" && typeof VC == "function" && (e.type = "node"), typeof t > "u" ? e : e[t] }; const qC = WC("type") === "browser", KC = qC ? t => new URL(t, window.location.href).href : t => t; var GC = t => { const e = { ...t }; return ["corePath", "workerPath", "langPath"].forEach(n => { t[n] && (e[n] = KC(e[n])) }), e }, YC = t => { const e = [], n = [], r = [], i = [], s = []; return t.blocks && t.blocks.forEach(o => { o.paragraphs.forEach(a => { a.lines.forEach(l => { l.words.forEach(u => { u.symbols.forEach(c => { s.push({ ...c, page: t, block: o, paragraph: a, line: l, word: u }) }), i.push({ ...u, page: t, block: o, paragraph: a, line: l }) }), r.push({ ...l, page: t, block: o, paragraph: a }) }), n.push({ ...a, page: t, block: o }) }), e.push({ ...o, page: t }) }), { ...t, blocks: e, paragraphs: n, lines: r, words: i, symbols: s } }, sb = { TESSERACT_ONLY: 0, LSTM_ONLY: 1, TESSERACT_LSTM_COMBINED: 2, DEFAULT: 3 }; const QC = "tesseract.js", XC = "5.1.0", JC = "Pure Javascript Multilingual OCR", ZC = "src/index.js", eO = "src/index.d.ts", tO = "dist/tesseract.min.js", nO = "dist/tesseract.min.js", rO = { start: "node scripts/server.js", build: "rimraf dist && webpack --config scripts/webpack.config.prod.js && rollup -c scripts/rollup.esm.mjs", "profile:tesseract": "webpack-bundle-analyzer dist/tesseract-stats.json", "profile:worker": "webpack-bundle-analyzer dist/worker-stats.json", prepublishOnly: "npm run build", wait: "rimraf dist && wait-on http://localhost:3000/dist/tesseract.min.js", test: "npm-run-all -p -r start test:all", "test:all": "npm-run-all wait test:browser:* test:node:all", "test:node": "nyc mocha --exit --bail --require ./scripts/test-helper.js", "test:node:all": "npm run test:node -- ./tests/*.test.js", "test:browser-tpl": "mocha-headless-chrome -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000", "test:browser:detect": "npm run test:browser-tpl -- -f ./tests/detect.test.html", "test:browser:recognize": "npm run test:browser-tpl -- -f ./tests/recognize.test.html", "test:browser:scheduler": "npm run test:browser-tpl -- -f ./tests/scheduler.test.html", "test:browser:FS": "npm run test:browser-tpl -- -f ./tests/FS.test.html", lint: "eslint src", "lint:fix": "eslint --fix src", postinstall: "opencollective-postinstall || true" }, iO = { "./src/worker/node/index.js": "./src/worker/browser/index.js" }, sO = "", oO = ["jeromewu"], aO = "Apache-2.0", lO = { "@babel/core": "^7.21.4", "@babel/eslint-parser": "^7.21.3", "@babel/preset-env": "^7.21.4", "@rollup/plugin-commonjs": "^24.1.0", acorn: "^8.8.2", "babel-loader": "^9.1.2", buffer: "^6.0.3", cors: "^2.8.5", eslint: "^7.32.0", "eslint-config-airbnb-base": "^14.2.1", "eslint-plugin-import": "^2.27.5", "expect.js": "^0.3.1", express: "^4.18.2", mocha: "^10.2.0", "mocha-headless-chrome": "^4.0.0", "npm-run-all": "^4.1.5", nyc: "^15.1.0", rimraf: "^5.0.0", rollup: "^3.20.7", "wait-on": "^7.0.1", webpack: "^5.79.0", "webpack-bundle-analyzer": "^4.8.0", "webpack-cli": "^5.0.1", "webpack-dev-middleware": "^6.0.2", "rollup-plugin-sourcemaps": "^0.6.3" }, uO = { "bmp-js": "^0.1.0", "idb-keyval": "^6.2.0", "is-electron": "^2.2.2", "is-url": "^1.2.4", "node-fetch": "^2.6.9", "opencollective-postinstall": "^2.0.3", "regenerator-runtime": "^0.13.3", "tesseract.js-core": "^5.1.0", "wasm-feature-detect": "^1.2.11", zlibjs: "^0.3.1" }, cO = { "@rollup/pluginutils": "^5.0.2" }, dO = { type: "git", url: "https://github.com/naptha/tesseract.js.git" }, hO = { url: "https://github.com/naptha/tesseract.js/issues" }, fO = "https://github.com/naptha/tesseract.js", pO = { type: "opencollective", url: "https://opencollective.com/tesseractjs" }, gO = { name: QC, version: XC, description: JC, main: ZC, types: eO, unpkg: tO, jsdelivr: nO, scripts: rO, browser: iO, author: sO, contributors: oO, license: aO, devDependencies: lO, dependencies: uO, overrides: cO, repository: dO, bugs: hO, homepage: fO, collective: pO }; var mO = { workerBlobURL: !0, logger: () => { } }; const vO = gO.version, yO = mO; var bO = { ...yO, workerPath: `https://cdn.jsdelivr.net/npm/tesseract.js@v${vO}/dist/worker.min.js` }, _O = ({ workerPath: t, workerBlobURL: e }) => { let n; if (Blob && URL && e) { const r = new Blob([`importScripts("${t}");`], { type: "application/javascript" }); n = new Worker(URL.createObjectURL(r)) } else n = new Worker(t); return n }, wO = t => { t.terminate() }, SO = (t, e) => { t.onmessage = ({ data: n }) => { e(n) } }, xO = async (t, e) => { t.postMessage(e) }; const ec = t => new Promise((e, n) => { const r = new FileReader; r.onload = () => { e(r.result) }, r.onerror = ({ target: { error: { code: i } } }) => { n(Error(`File could not be read! Code=${i}`)) }, r.readAsArrayBuffer(t) }), xd = async t => { let e = t; if (typeof t > "u") return "undefined"; if (typeof t == "string") /data:image\/([a-zA-Z]*);base64,([^"]*)/.test(t) ? e = atob(t.split(",")[1]).split("").map(n => n.charCodeAt(0)) : e = await (await fetch(t)).arrayBuffer(); else if (typeof HTMLElement < "u" && t instanceof HTMLElement) t.tagName === "IMG" && (e = await xd(t.src)), t.tagName === "VIDEO" && (e = await xd(t.poster)), t.tagName === "CANVAS" && await new Promise(n => { t.toBlob(async r => { e = await ec(r), n() }) }); else if (typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas) { const n = await t.convertToBlob(); e = await ec(n) } else (t instanceof File || t instanceof Blob) && (e = await ec(t)); return new Uint8Array(e) }; var kO = xd; const CO = bO, OO = _O, PO = wO, EO = SO, TO = xO, IO = kO; var RO = { defaultOptions: CO, spawnWorker: OO, terminateWorker: PO, onMessage: EO, send: TO, loadImage: IO }; const MO = GC, LO = YC, $t = ib, { log: gg } = Bi, DO = qh, fr = sb, { defaultOptions: AO, spawnWorker: jO, terminateWorker: NO, onMessage: FO, loadImage: mg, send: $O } = RO; let vg = 0; var ob = async (t = "eng", e = fr.LSTM_ONLY, n = {}, r = {}) => { const i = DO("Worker", vg), { logger: s, errorHandler: o, ...a } = MO({ ...AO, ...n }), l = {}, u = {}, c = typeof t == "string" ? t.split("+") : t; let d = e, h = r; const f = [fr.DEFAULT, fr.LSTM_ONLY].includes(e) && !a.legacyCore; let g, m; const y = new Promise((O, D) => { m = O, g = D }), p = O => { g(O.message) }; let v = jO(a); v.onerror = p, vg += 1; const b = (O, D) => { l[O] = D }, S = (O, D) => { u[O] = D }, P = ({ id: O, action: D, payload: F }) => new Promise((z, W) => { gg(`[${i}]: Start ${O}, action=${D}`); const K = `${D}-${O}`; b(K, z), S(K, W), $O(v, { workerId: i, jobId: O, action: D, payload: F }) }), I = () => console.warn("`load` is depreciated and should be removed from code (workers now come pre-loaded)"), T = O => P($t({ id: O, action: "load", payload: { options: { lstmOnly: f, corePath: a.corePath, logging: a.logging } } })), k = (O, D, F) => P($t({ id: F, action: "FS", payload: { method: "writeFile", args: [O, D] } })), E = (O, D) => P($t({ id: D, action: "FS", payload: { method: "readFile", args: [O, { encoding: "utf8" }] } })), M = (O, D) => P($t({ id: D, action: "FS", payload: { method: "unlink", args: [O] } })), L = (O, D, F) => P($t({ id: F, action: "FS", payload: { method: O, args: D } })), N = () => console.warn("`loadLanguage` is depreciated and should be removed from code (workers now come with language pre-loaded)"), $ = (O, D) => P($t({ id: D, action: "loadLanguage", payload: { langs: O, options: { langPath: a.langPath, dataPath: a.dataPath, cachePath: a.cachePath, cacheMethod: a.cacheMethod, gzip: a.gzip, lstmOnly: [fr.LSTM_ONLY, fr.TESSERACT_LSTM_COMBINED].includes(d) && !a.legacyLang } } })), B = () => console.warn("`initialize` is depreciated and should be removed from code (workers now come pre-initialized)"), H = (O, D, F, z) => P($t({ id: z, action: "initialize", payload: { langs: O, oem: D, config: F } })), V = (O = "eng", D, F, z) => { if (f && [fr.TESSERACT_ONLY, fr.TESSERACT_LSTM_COMBINED].includes(D)) throw Error("Legacy model requested but code missing."); const W = D || d; d = W; const K = F || h; h = K; const ae = (typeof O == "string" ? O.split("+") : O).filter(ue => !c.includes(ue)); return c.push(...ae), ae.length > 0 ? $(ae, z).then(() => H(O, W, K, z)) : H(O, W, K, z) }, q = (O = {}, D) => P($t({ id: D, action: "setParameters", payload: { params: O } })), j = async (O, D = {}, F = { blocks: !0, text: !0, hocr: !0, tsv: !0 }, z) => P($t({ id: z, action: "recognize", payload: { image: await mg(O), options: D, output: F } })), _ = (O = "Tesseract OCR Result", D = !1, F) => (console.log("`getPDF` function is depreciated. `recognize` option `savePDF` should be used instead."), P($t({ id: F, action: "getPDF", payload: { title: O, textonly: D } }))), x = async (O, D) => { if (f) throw Error("`worker.detect` requires Legacy model, which was not loaded."); return P($t({ id: D, action: "detect", payload: { image: await mg(O) } })) }, C = async () => (v !== null && (NO(v), v = null), Promise.resolve()); FO(v, ({ workerId: O, jobId: D, status: F, action: z, data: W }) => { const K = `${z}-${D}`; if (F === "resolve") { gg(`[${O}]: Complete ${D}`); let Z = W; z === "recognize" ? Z = LO(W) : z === "getPDF" && (Z = Array.from({ ...W, length: Object.keys(W).length })), l[K]({ jobId: D, data: Z }) } else if (F === "reject") if (u[K](W), z === "load" && g(W), o) o(W); else throw Error(W); else F === "progress" && s({ ...W, userJobId: D }) }); const w = { id: i, worker: v, setResolve: b, setReject: S, load: I, writeText: k, readText: E, removeFile: M, FS: L, loadLanguage: N, initialize: B, reinitialize: V, setParameters: q, recognize: j, getPDF: _, detect: x, terminate: C }; return T().then(() => $(t)).then(() => H(t, e, r)).then(() => m(w)).catch(() => { }), y }; const ab = ob, zO = async (t, e, n) => { const r = await ab(e, 1, n); return r.recognize(t).finally(async () => { await r.terminate() }) }, VO = async (t, e) => { const n = await ab("osd", 0, e); return n.detect(t).finally(async () => { await n.terminate() }) }; var BO = { recognize: zO, detect: VO }, UO = { AFR: "afr", AMH: "amh", ARA: "ara", ASM: "asm", AZE: "aze", AZE_CYRL: "aze_cyrl", BEL: "bel", BEN: "ben", BOD: "bod", BOS: "bos", BUL: "bul", CAT: "cat", CEB: "ceb", CES: "ces", CHI_SIM: "chi_sim", CHI_TRA: "chi_tra", CHR: "chr", CYM: "cym", DAN: "dan", DEU: "deu", DZO: "dzo", ELL: "ell", ENG: "eng", ENM: "enm", EPO: "epo", EST: "est", EUS: "eus", FAS: "fas", FIN: "fin", FRA: "fra", FRK: "frk", FRM: "frm", GLE: "gle", GLG: "glg", GRC: "grc", GUJ: "guj", HAT: "hat", HEB: "heb", HIN: "hin", HRV: "hrv", HUN: "hun", IKU: "iku", IND: "ind", ISL: "isl", ITA: "ita", ITA_OLD: "ita_old", JAV: "jav", JPN: "jpn", KAN: "kan", KAT: "kat", KAT_OLD: "kat_old", KAZ: "kaz", KHM: "khm", KIR: "kir", KOR: "kor", KUR: "kur", LAO: "lao", LAT: "lat", LAV: "lav", LIT: "lit", MAL: "mal", MAR: "mar", MKD: "mkd", MLT: "mlt", MSA: "msa", MYA: "mya", NEP: "nep", NLD: "nld", NOR: "nor", ORI: "ori", PAN: "pan", POL: "pol", POR: "por", PUS: "pus", RON: "ron", RUS: "rus", SAN: "san", SIN: "sin", SLK: "slk", SLV: "slv", SPA: "spa", SPA_OLD: "spa_old", SQI: "sqi", SRP: "srp", SRP_LATN: "srp_latn", SWA: "swa", SWE: "swe", SYR: "syr", TAM: "tam", TEL: "tel", TGK: "tgk", TGL: "tgl", THA: "tha", TIR: "tir", TUR: "tur", UIG: "uig", UKR: "ukr", URD: "urd", UZB: "uzb", UZB_CYRL: "uzb_cyrl", VIE: "vie", YID: "yid" }, HO = { OSD_ONLY: "0", AUTO_OSD: "1", AUTO_ONLY: "2", AUTO: "3", SINGLE_COLUMN: "4", SINGLE_BLOCK_VERT_TEXT: "5", SINGLE_BLOCK: "6", SINGLE_LINE: "7", SINGLE_WORD: "8", CIRCLE_WORD: "9", SINGLE_CHAR: "10", SPARSE_TEXT: "11", SPARSE_TEXT_OSD: "12", RAW_LINE: "13" }; const WO = zC, qO = ob, KO = BO, GO = UO, YO = sb, QO = HO, { setLogging: XO } = Bi; var JO = { languages: GO, OEM: YO, PSM: QO, createScheduler: WO, createWorker: qO, setLogging: XO, ...KO }; const ZO = Vd(JO), eP = t => { const e = new Date().getFullYear().toString(); let n = "", r = "", i = "", s = ""; console.log("Input text:", t); const a = /\d{2}\/\d{2}/g.exec(t); if (a) { const u = a.index, c = t.substring(u, u + 5), [d, h] = c.split("/"); n = `${e}-${h}-${d}`, r = t.substring(0, u - 1).replace(/X.{4}/, "").replace("(7)", "").replace(/\d{2}\/$/, "").replace(/[^a-zA-Z0-9\s]/g, ""), console.log("Extracted date:", n), console.log("Extracted name:", r) } const l = t.match(/([-+]?)\s?-?\s?\d+,\d{2}€?/); if (console.log("Amount match:", l), l) { let u = l[0].replace(",", ".").replace("€", "").replace(/\s+/g, "").trim(); console.log("Formatted amount:", u), u.startsWith("-") ? (i = "DepenseCarteBleue", s = u.replace("-", "")) : u.startsWith("+") ? (i = "ObtenuCarteBleue", s = u.replace("+", "")) : s = u, console.log("DepenseCarteBleue:", s), console.log("Selected option:", i) } return { Date: n, NomDeLaDepense: r, DepenseCarteBleue: s, selectedOption: i } }, tP = { CarteBleue: "Carte Bleue" }, lb = ({ accounts: t }) => { const [e, n] = R.useState([]), [r, i] = R.useState({}), [s, o] = R.useState(null); return R.useEffect(() => { (async () => { var u; const { data: { user: l } } = await je.auth.getUser(); o(l), (u = l == null ? void 0 : l.user_metadata) != null && u.livrets && n(l.user_metadata.livrets.filter(c => c && typeof c == "object")) })() }, []), R.useEffect(() => { const a = () => { const l = {}; e.forEach(u => { l[u.name] = 0 }), t.forEach(u => { e.forEach(c => { const d = c.name, h = parseFloat(u[`Depense${d}`] || "0"), f = parseFloat(u[`Obtenu${d}`] || "0"); let g = 0, m = 0; e.forEach(y => { if (d !== y.name) { const p = parseFloat(u[`Deplace${d}Vers${y.name}`] || "0"), v = parseFloat(u[`Deplace${y.name}Vers${d}`] || "0"); g += p, m += v } }), l[d] += f - h - g + m }) }), i(l) }; e.length > 0 && a() }, [t, e]), A.jsxs("div", { className: "account-summary p-4 rounded-md bg-transparent", children: [A.jsx("h2", { className: "text-xl mb-2", children: "Résumé des comptes" }), A.jsx("ul", { className: "flex justify-between gap-4 flex-wrap mb-4 mt-4", children: e.map(a => { const l = a.name, u = tP[l] || l, c = r[l] || 0; return A.jsxs("li", { className: "p-2 border border-gray-200 rounded-md", children: ["Sur le compte ", u, ": ", A.jsxs("span", { className: "font-semibold", children: [c.toFixed(2), " €"] })] }, l) }) }), A.jsx("hr", { className: "my-2" }), A.jsx("div", { className: "flex justify-center mt-4", children: A.jsxs("div", { className: "p-2 border border-gray-200 rounded-md inline-block", children: ["Total: ", A.jsxs("span", { className: "font-bold", children: [e.reduce((a, l) => a + (r[l.name] || 0), 0).toFixed(2), " €"] })] }) })] }) }; var Ve = []; for (var tc = 0; tc < 256; ++tc)Ve.push((tc + 256).toString(16).slice(1)); function nP(t, e = 0) { return (Ve[t[e + 0]] + Ve[t[e + 1]] + Ve[t[e + 2]] + Ve[t[e + 3]] + "-" + Ve[t[e + 4]] + Ve[t[e + 5]] + "-" + Ve[t[e + 6]] + Ve[t[e + 7]] + "-" + Ve[t[e + 8]] + Ve[t[e + 9]] + "-" + Ve[t[e + 10]] + Ve[t[e + 11]] + Ve[t[e + 12]] + Ve[t[e + 13]] + Ve[t[e + 14]] + Ve[t[e + 15]]).toLowerCase() } var qo, rP = new Uint8Array(16); function iP() { if (!qo && (qo = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !qo)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"); return qo(rP) } var sP = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto); const yg = { randomUUID: sP }; function ub(t, e, n) { if (yg.randomUUID && !e && !t) return yg.randomUUID(); t = t || {}; var r = t.random || (t.rng || iP)(); return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, nP(r) } var cb = {}, db = { exports: {} }, oP = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", aP = oP, lP = aP; function hb() { } function fb() { } fb.resetWarningCache = hb; var uP = function () { function t(r, i, s, o, a, l) { if (l !== lP) { var u = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw u.name = "Invariant Violation", u } } t.isRequired = t; function e() { return t } var n = { array: t, bigint: t, bool: t, func: t, number: t, object: t, string: t, symbol: t, any: t, arrayOf: e, element: t, elementType: t, instanceOf: e, node: t, objectOf: e, oneOf: e, oneOfType: e, shape: e, exact: e, checkPropTypes: fb, resetWarningCache: hb }; return n.PropTypes = n, n }; db.exports = uP(); var yo = db.exports; function cP(t, e) { if (t === e) return !0; if (!t || !e) return !1; var n = t.length; if (e.length !== n) return !1; for (var r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } var dP = cP, pb = {}, bg = function () { function t(e, n) { var r = [], i = !0, s = !1, o = void 0; try { for (var a = e[Symbol.iterator](), l; !(i = (l = a.next()).done) && (r.push(l.value), !(n && r.length === n)); i = !0); } catch (u) { s = !0, o = u } finally { try { !i && a.return && a.return() } finally { if (s) throw o } } return r } return function (e, n) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, n); throw new TypeError("Invalid attempt to destructure non-iterable instance") } }(), hP = function (t) { var e = t.data, n = t.multiSection; function r(l) { for (l === null ? l = 0 : l++; l < e.length && e[l] === 0;)l++; return l === e.length ? null : l } function i(l) { for (l === null ? l = e.length - 1 : l--; l >= 0 && e[l] === 0;)l--; return l === -1 ? null : l } function s(l) { var u = bg(l, 2), c = u[0], d = u[1]; return n ? d === null || d === e[c] - 1 ? (c = r(c), c === null ? [null, null] : [c, 0]) : [c, d + 1] : e === 0 || d === e - 1 ? [null, null] : d === null ? [null, 0] : [null, d + 1] } function o(l) { var u = bg(l, 2), c = u[0], d = u[1]; return n ? d === null || d === 0 ? (c = i(c), c === null ? [null, null] : [c, e[c] - 1]) : [c, d - 1] : e === 0 || d === 0 ? [null, null] : d === null ? [null, e - 1] : [null, d - 1] } function a(l) { return s(l)[1] === null } return { next: s, prev: o, isLast: a } }, kd = { exports: {} }, fP = Object.prototype.propertyIsEnumerable; function pP(t) { if (t == null) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(t) } function gP(t) { var e = Object.getOwnPropertyNames(t); return Object.getOwnPropertySymbols && (e = e.concat(Object.getOwnPropertySymbols(t))), e.filter(function (n) { return fP.call(t, n) }) } var mP = Object.assign || function (t, e) { for (var n, r, i = pP(t), s = 1; s < arguments.length; s++) { n = arguments[s], r = gP(Object(n)); for (var o = 0; o < r.length; o++)i[r[o]] = n[r[o]] } return i }; (function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }); var n = function () { function l(u, c) { var d = [], h = !0, f = !1, g = void 0; try { for (var m = u[Symbol.iterator](), y; !(h = (y = m.next()).done) && (d.push(y.value), !(c && d.length === c)); h = !0); } catch (p) { f = !0, g = p } finally { try { !h && m.return && m.return() } finally { if (f) throw g } } return d } return function (u, c) { if (Array.isArray(u)) return u; if (Symbol.iterator in Object(u)) return l(u, c); throw new TypeError("Invalid attempt to destructure non-iterable instance") } }(); function r(l) { return l && l.__esModule ? l : { default: l } } function i(l) { if (Array.isArray(l)) { for (var u = 0, c = Array(l.length); u < l.length; u++)c[u] = l[u]; return c } else return Array.from(l) } var s = mP, o = r(s), a = function (u) { return u }; e.default = function (l) { var u = Array.isArray(l) && l.length === 2 ? l : [l, null], c = n(u, 2), d = c[0], h = c[1]; return function (f) { for (var g = arguments.length, m = Array(g > 1 ? g - 1 : 0), y = 1; y < g; y++)m[y - 1] = arguments[y]; var p = m.map(function (v) { return d[v] }).filter(a); return typeof p[0] == "string" || typeof h == "function" ? { key: f, className: h ? h.apply(void 0, i(p)) : p.join(" ") } : { key: f, style: o.default.apply(void 0, [{}].concat(i(p))) } } }, t.exports = e.default })(kd, kd.exports); var vP = kd.exports, gb = {}, Xl = {}; (function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n; function e(r) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? e = function (s) { return typeof s } : e = function (s) { return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s }, e(r) } function n(r, i) { var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : []; if (r === i) return !1; var o = Object.keys(r), a = Object.keys(i); if (o.length !== a.length) return !0; var l = {}, u, c; for (u = 0, c = s.length; u < c; u++)l[s[u]] = !0; for (u = 0, c = o.length; u < c; u++) { var d = o[u], h = r[d], f = i[d]; if (h !== f) { if (!l[d] || h === null || f === null || e(h) !== "object" || e(f) !== "object") return !0; var g = Object.keys(h), m = Object.keys(f); if (g.length !== m.length) return !0; for (var y = 0, p = g.length; y < p; y++) { var v = g[y]; if (h[v] !== f[v]) return !0 } } } return !1 } })(Xl); (function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var e = o(R), n = i(yo), r = i(Xl); function i(S) { return S && S.__esModule ? S : { default: S } } function s() { if (typeof WeakMap != "function") return null; var S = new WeakMap; return s = function () { return S }, S } function o(S) { if (S && S.__esModule) return S; if (S === null || a(S) !== "object" && typeof S != "function") return { default: S }; var P = s(); if (P && P.has(S)) return P.get(S); var I = {}, T = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var k in S) if (Object.prototype.hasOwnProperty.call(S, k)) { var E = T ? Object.getOwnPropertyDescriptor(S, k) : null; E && (E.get || E.set) ? Object.defineProperty(I, k, E) : I[k] = S[k] } return I.default = S, P && P.set(S, I), I } function a(S) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? a = function (I) { return typeof I } : a = function (I) { return I && typeof Symbol == "function" && I.constructor === Symbol && I !== Symbol.prototype ? "symbol" : typeof I }, a(S) } function l(S, P) { if (!(S instanceof P)) throw new TypeError("Cannot call a class as a function") } function u(S, P) { for (var I = 0; I < P.length; I++) { var T = P[I]; T.enumerable = T.enumerable || !1, T.configurable = !0, "value" in T && (T.writable = !0), Object.defineProperty(S, T.key, T) } } function c(S, P, I) { return P && u(S.prototype, P), S } function d(S) { return function () { var P = m(S), I; if (g()) { var T = m(this).constructor; I = Reflect.construct(P, arguments, T) } else I = P.apply(this, arguments); return h(this, I) } } function h(S, P) { return P && (a(P) === "object" || typeof P == "function") ? P : f(S) } function f(S) { if (S === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return S } function g() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch { return !1 } } function m(S) { return m = Object.setPrototypeOf ? Object.getPrototypeOf : function (I) { return I.__proto__ || Object.getPrototypeOf(I) }, m(S) } function y(S, P) { if (typeof P != "function" && P !== null) throw new TypeError("Super expression must either be null or a function"); S.prototype = Object.create(P && P.prototype, { constructor: { value: S, writable: !0, configurable: !0 } }), P && p(S, P) } function p(S, P) { return p = Object.setPrototypeOf || function (T, k) { return T.__proto__ = k, T }, p(S, P) } function v(S, P, I) { return P in S ? Object.defineProperty(S, P, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : S[P] = I, S } var b = function (S) { y(I, S); var P = d(I); function I() { return l(this, I), P.apply(this, arguments) } return c(I, [{ key: "shouldComponentUpdate", value: function (k) { return (0, r.default)(k, this.props) } }, { key: "render", value: function () { var k = this.props, E = k.section, M = k.renderSectionTitle, L = k.theme, N = k.sectionKeyPrefix, $ = M(E); return $ ? e.default.createElement("div", L("".concat(N, "title"), "sectionTitle"), $) : null } }]), I }(e.Component); t.default = b, v(b, "propTypes", { section: n.default.any.isRequired, renderSectionTitle: n.default.func.isRequired, theme: n.default.func.isRequired, sectionKeyPrefix: n.default.string.isRequired }) })(gb); var mb = {}, vb = {}; (function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var e = o(R), n = i(yo), r = i(Xl); function i(E) { return E && E.__esModule ? E : { default: E } } function s() { if (typeof WeakMap != "function") return null; var E = new WeakMap; return s = function () { return E }, E } function o(E) { if (E && E.__esModule) return E; if (E === null || a(E) !== "object" && typeof E != "function") return { default: E }; var M = s(); if (M && M.has(E)) return M.get(E); var L = {}, N = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var $ in E) if (Object.prototype.hasOwnProperty.call(E, $)) { var B = N ? Object.getOwnPropertyDescriptor(E, $) : null; B && (B.get || B.set) ? Object.defineProperty(L, $, B) : L[$] = E[$] } return L.default = E, M && M.set(E, L), L } function a(E) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? a = function (L) { return typeof L } : a = function (L) { return L && typeof Symbol == "function" && L.constructor === Symbol && L !== Symbol.prototype ? "symbol" : typeof L }, a(E) } function l() { return l = Object.assign || function (E) { for (var M = 1; M < arguments.length; M++) { var L = arguments[M]; for (var N in L) Object.prototype.hasOwnProperty.call(L, N) && (E[N] = L[N]) } return E }, l.apply(this, arguments) } function u(E, M) { var L = Object.keys(E); if (Object.getOwnPropertySymbols) { var N = Object.getOwnPropertySymbols(E); M && (N = N.filter(function ($) { return Object.getOwnPropertyDescriptor(E, $).enumerable })), L.push.apply(L, N) } return L } function c(E) { for (var M = 1; M < arguments.length; M++) { var L = arguments[M] != null ? arguments[M] : {}; M % 2 ? u(Object(L), !0).forEach(function (N) { T(E, N, L[N]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(E, Object.getOwnPropertyDescriptors(L)) : u(Object(L)).forEach(function (N) { Object.defineProperty(E, N, Object.getOwnPropertyDescriptor(L, N)) }) } return E } function d(E, M) { if (E == null) return {}; var L = h(E, M), N, $; if (Object.getOwnPropertySymbols) { var B = Object.getOwnPropertySymbols(E); for ($ = 0; $ < B.length; $++)N = B[$], !(M.indexOf(N) >= 0) && Object.prototype.propertyIsEnumerable.call(E, N) && (L[N] = E[N]) } return L } function h(E, M) { if (E == null) return {}; var L = {}, N = Object.keys(E), $, B; for (B = 0; B < N.length; B++)$ = N[B], !(M.indexOf($) >= 0) && (L[$] = E[$]); return L } function f(E, M) { if (!(E instanceof M)) throw new TypeError("Cannot call a class as a function") } function g(E, M) { for (var L = 0; L < M.length; L++) { var N = M[L]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(E, N.key, N) } } function m(E, M, L) { return M && g(E.prototype, M), E } function y(E) { return function () { var M = S(E), L; if (b()) { var N = S(this).constructor; L = Reflect.construct(M, arguments, N) } else L = M.apply(this, arguments); return p(this, L) } } function p(E, M) { return M && (a(M) === "object" || typeof M == "function") ? M : v(E) } function v(E) { if (E === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return E } function b() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch { return !1 } } function S(E) { return S = Object.setPrototypeOf ? Object.getPrototypeOf : function (L) { return L.__proto__ || Object.getPrototypeOf(L) }, S(E) } function P(E, M) { if (typeof M != "function" && M !== null) throw new TypeError("Super expression must either be null or a function"); E.prototype = Object.create(M && M.prototype, { constructor: { value: E, writable: !0, configurable: !0 } }), M && I(E, M) } function I(E, M) { return I = Object.setPrototypeOf || function (N, $) { return N.__proto__ = $, N }, I(E, M) } function T(E, M, L) { return M in E ? Object.defineProperty(E, M, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : E[M] = L, E } var k = function (E) { P(L, E); var M = y(L); function L() { var N; f(this, L); for (var $ = arguments.length, B = new Array($), H = 0; H < $; H++)B[H] = arguments[H]; return N = M.call.apply(M, [this].concat(B)), T(v(N), "storeItemReference", function (V) { V !== null && (N.item = V) }), T(v(N), "onMouseEnter", function (V) { var q = N.props, j = q.sectionIndex, _ = q.itemIndex; N.props.onMouseEnter(V, { sectionIndex: j, itemIndex: _ }) }), T(v(N), "onMouseLeave", function (V) { var q = N.props, j = q.sectionIndex, _ = q.itemIndex; N.props.onMouseLeave(V, { sectionIndex: j, itemIndex: _ }) }), T(v(N), "onMouseDown", function (V) { var q = N.props, j = q.sectionIndex, _ = q.itemIndex; N.props.onMouseDown(V, { sectionIndex: j, itemIndex: _ }) }), T(v(N), "onClick", function (V) { var q = N.props, j = q.sectionIndex, _ = q.itemIndex; N.props.onClick(V, { sectionIndex: j, itemIndex: _ }) }), N } return m(L, [{ key: "shouldComponentUpdate", value: function ($) { return (0, r.default)($, this.props, ["renderItemData"]) } }, { key: "render", value: function () { var $ = this.props, B = $.isHighlighted, H = $.item, V = $.renderItem, q = $.renderItemData, j = d($, ["isHighlighted", "item", "renderItem", "renderItemData"]); return delete j.sectionIndex, delete j.itemIndex, typeof j.onMouseEnter == "function" && (j.onMouseEnter = this.onMouseEnter), typeof j.onMouseLeave == "function" && (j.onMouseLeave = this.onMouseLeave), typeof j.onMouseDown == "function" && (j.onMouseDown = this.onMouseDown), typeof j.onClick == "function" && (j.onClick = this.onClick), e.default.createElement("li", l({ role: "option" }, j, { ref: this.storeItemReference }), V(H, c({ isHighlighted: B }, q))) } }]), L }(e.Component); t.default = k, T(k, "propTypes", { sectionIndex: n.default.number, isHighlighted: n.default.bool.isRequired, itemIndex: n.default.number.isRequired, item: n.default.any.isRequired, renderItem: n.default.func.isRequired, renderItemData: n.default.object.isRequired, onMouseEnter: n.default.func, onMouseLeave: n.default.func, onMouseDown: n.default.func, onClick: n.default.func }) })(vb); (function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var e = a(R), n = s(yo), r = s(vb), i = s(Xl); function s(k) { return k && k.__esModule ? k : { default: k } } function o() { if (typeof WeakMap != "function") return null; var k = new WeakMap; return o = function () { return k }, k } function a(k) { if (k && k.__esModule) return k; if (k === null || l(k) !== "object" && typeof k != "function") return { default: k }; var E = o(); if (E && E.has(k)) return E.get(k); var M = {}, L = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var N in k) if (Object.prototype.hasOwnProperty.call(k, N)) { var $ = L ? Object.getOwnPropertyDescriptor(k, N) : null; $ && ($.get || $.set) ? Object.defineProperty(M, N, $) : M[N] = k[N] } return M.default = k, E && E.set(k, M), M } function l(k) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? l = function (M) { return typeof M } : l = function (M) { return M && typeof Symbol == "function" && M.constructor === Symbol && M !== Symbol.prototype ? "symbol" : typeof M }, l(k) } function u() { return u = Object.assign || function (k) { for (var E = 1; E < arguments.length; E++) { var M = arguments[E]; for (var L in M) Object.prototype.hasOwnProperty.call(M, L) && (k[L] = M[L]) } return k }, u.apply(this, arguments) } function c(k, E) { var M = Object.keys(k); if (Object.getOwnPropertySymbols) { var L = Object.getOwnPropertySymbols(k); E && (L = L.filter(function (N) { return Object.getOwnPropertyDescriptor(k, N).enumerable })), M.push.apply(M, L) } return M } function d(k) { for (var E = 1; E < arguments.length; E++) { var M = arguments[E] != null ? arguments[E] : {}; E % 2 ? c(Object(M), !0).forEach(function (L) { I(k, L, M[L]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(k, Object.getOwnPropertyDescriptors(M)) : c(Object(M)).forEach(function (L) { Object.defineProperty(k, L, Object.getOwnPropertyDescriptor(M, L)) }) } return k } function h(k, E) { if (!(k instanceof E)) throw new TypeError("Cannot call a class as a function") } function f(k, E) { for (var M = 0; M < E.length; M++) { var L = E[M]; L.enumerable = L.enumerable || !1, L.configurable = !0, "value" in L && (L.writable = !0), Object.defineProperty(k, L.key, L) } } function g(k, E, M) { return E && f(k.prototype, E), k } function m(k) { return function () { var E = b(k), M; if (v()) { var L = b(this).constructor; M = Reflect.construct(E, arguments, L) } else M = E.apply(this, arguments); return y(this, M) } } function y(k, E) { return E && (l(E) === "object" || typeof E == "function") ? E : p(k) } function p(k) { if (k === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return k } function v() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch { return !1 } } function b(k) { return b = Object.setPrototypeOf ? Object.getPrototypeOf : function (M) { return M.__proto__ || Object.getPrototypeOf(M) }, b(k) } function S(k, E) { if (typeof E != "function" && E !== null) throw new TypeError("Super expression must either be null or a function"); k.prototype = Object.create(E && E.prototype, { constructor: { value: k, writable: !0, configurable: !0 } }), E && P(k, E) } function P(k, E) { return P = Object.setPrototypeOf || function (L, N) { return L.__proto__ = N, L }, P(k, E) } function I(k, E, M) { return E in k ? Object.defineProperty(k, E, { value: M, enumerable: !0, configurable: !0, writable: !0 }) : k[E] = M, k } var T = function (k) { S(M, k); var E = m(M); function M() { var L; h(this, M); for (var N = arguments.length, $ = new Array(N), B = 0; B < N; B++)$[B] = arguments[B]; return L = E.call.apply(E, [this].concat($)), I(p(L), "storeHighlightedItemReference", function (H) { L.props.onHighlightedItemChange(H === null ? null : H.item) }), L } return g(M, [{ key: "shouldComponentUpdate", value: function (N) { return (0, i.default)(N, this.props, ["itemProps"]) } }, { key: "render", value: function () { var N = this, $ = this.props, B = $.items, H = $.itemProps, V = $.renderItem, q = $.renderItemData, j = $.sectionIndex, _ = $.highlightedItemIndex, x = $.getItemId, C = $.theme, w = $.keyPrefix, O = j === null ? w : "".concat(w, "section-").concat(j, "-"), D = typeof H == "function"; return e.default.createElement("ul", u({ role: "listbox" }, C("".concat(O, "items-list"), "itemsList")), B.map(function (F, z) { var W = z === 0, K = z === _, Z = "".concat(O, "item-").concat(z), ae = D ? H({ sectionIndex: j, itemIndex: z }) : H, ue = d({ id: x(j, z), "aria-selected": K }, C(Z, "item", W && "itemFirst", K && "itemHighlighted"), {}, ae); return K && (ue.ref = N.storeHighlightedItemReference), e.default.createElement(r.default, u({}, ue, { sectionIndex: j, isHighlighted: K, itemIndex: z, item: F, renderItem: V, renderItemData: q })) })) } }]), M }(e.Component); t.default = T, I(T, "propTypes", { items: n.default.array.isRequired, itemProps: n.default.oneOfType([n.default.object, n.default.func]), renderItem: n.default.func.isRequired, renderItemData: n.default.object.isRequired, sectionIndex: n.default.number, highlightedItemIndex: n.default.number, onHighlightedItemChange: n.default.func.isRequired, getItemId: n.default.func.isRequired, theme: n.default.func.isRequired, keyPrefix: n.default.string.isRequired }), I(T, "defaultProps", { sectionIndex: null }) })(mb); (function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var e = u(R), n = a(yo), r = a(hP), i = a(vP), s = a(gb), o = a(mb); function a(_) { return _ && _.__esModule ? _ : { default: _ } } function l() { if (typeof WeakMap != "function") return null; var _ = new WeakMap; return l = function () { return _ }, _ } function u(_) { if (_ && _.__esModule) return _; if (_ === null || v(_) !== "object" && typeof _ != "function") return { default: _ }; var x = l(); if (x && x.has(_)) return x.get(_); var C = {}, w = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var O in _) if (Object.prototype.hasOwnProperty.call(_, O)) { var D = w ? Object.getOwnPropertyDescriptor(_, O) : null; D && (D.get || D.set) ? Object.defineProperty(C, O, D) : C[O] = _[O] } return C.default = _, x && x.set(_, C), C } function c(_, x) { var C = Object.keys(_); if (Object.getOwnPropertySymbols) { var w = Object.getOwnPropertySymbols(_); x && (w = w.filter(function (O) { return Object.getOwnPropertyDescriptor(_, O).enumerable })), C.push.apply(C, w) } return C } function d(_) { for (var x = 1; x < arguments.length; x++) { var C = arguments[x] != null ? arguments[x] : {}; x % 2 ? c(Object(C), !0).forEach(function (w) { $(_, w, C[w]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(C)) : c(Object(C)).forEach(function (w) { Object.defineProperty(_, w, Object.getOwnPropertyDescriptor(C, w)) }) } return _ } function h(_, x) { return p(_) || y(_, x) || g(_, x) || f() } function f() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function g(_, x) { if (_) { if (typeof _ == "string") return m(_, x); var C = Object.prototype.toString.call(_).slice(8, -1); if (C === "Object" && _.constructor && (C = _.constructor.name), C === "Map" || C === "Set") return Array.from(C); if (C === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(C)) return m(_, x) } } function m(_, x) { (x == null || x > _.length) && (x = _.length); for (var C = 0, w = new Array(x); C < x; C++)w[C] = _[C]; return w } function y(_, x) { if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(_)))) { var C = [], w = !0, O = !1, D = void 0; try { for (var F = _[Symbol.iterator](), z; !(w = (z = F.next()).done) && (C.push(z.value), !(x && C.length === x)); w = !0); } catch (W) { O = !0, D = W } finally { try { !w && F.return != null && F.return() } finally { if (O) throw D } } return C } } function p(_) { if (Array.isArray(_)) return _ } function v(_) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? v = function (C) { return typeof C } : v = function (C) { return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C }, v(_) } function b(_, x) { if (!(_ instanceof x)) throw new TypeError("Cannot call a class as a function") } function S(_, x) { for (var C = 0; C < x.length; C++) { var w = x[C]; w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(_, w.key, w) } } function P(_, x, C) { return x && S(_.prototype, x), _ } function I(_) { return function () { var x = M(_), C; if (E()) { var w = M(this).constructor; C = Reflect.construct(x, arguments, w) } else C = x.apply(this, arguments); return T(this, C) } } function T(_, x) { return x && (v(x) === "object" || typeof x == "function") ? x : k(_) } function k(_) { if (_ === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return _ } function E() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch { return !1 } } function M(_) { return M = Object.setPrototypeOf ? Object.getPrototypeOf : function (C) { return C.__proto__ || Object.getPrototypeOf(C) }, M(_) } function L(_, x) { if (typeof x != "function" && x !== null) throw new TypeError("Super expression must either be null or a function"); _.prototype = Object.create(x && x.prototype, { constructor: { value: _, writable: !0, configurable: !0 } }), x && N(_, x) } function N(_, x) { return N = Object.setPrototypeOf || function (w, O) { return w.__proto__ = O, w }, N(_, x) } function $(_, x, C) { return x in _ ? Object.defineProperty(_, x, { value: C, enumerable: !0, configurable: !0, writable: !0 }) : _[x] = C, _ } var B = {}, H = function (x) { return e.default.createElement("input", x) }, V = function (x) { var C = x.containerProps, w = x.children; return e.default.createElement("div", C, w) }, q = { container: "react-autowhatever__container", containerOpen: "react-autowhatever__container--open", input: "react-autowhatever__input", inputOpen: "react-autowhatever__input--open", inputFocused: "react-autowhatever__input--focused", itemsContainer: "react-autowhatever__items-container", itemsContainerOpen: "react-autowhatever__items-container--open", itemsList: "react-autowhatever__items-list", item: "react-autowhatever__item", itemFirst: "react-autowhatever__item--first", itemHighlighted: "react-autowhatever__item--highlighted", sectionContainer: "react-autowhatever__section-container", sectionContainerFirst: "react-autowhatever__section-container--first", sectionTitle: "react-autowhatever__section-title" }, j = function (_) { L(C, _); var x = I(C); function C(w) { var O; return b(this, C), O = x.call(this, w), $(k(O), "storeInputReference", function (D) { D !== null && (O.input = D); var F = O.props.inputProps.ref; F && (typeof F == "function" ? F(D) : v(F) === "object" && Object.prototype.hasOwnProperty.call(F, "current") && (F.current = D)) }), $(k(O), "storeItemsContainerReference", function (D) { D !== null && (O.itemsContainer = D) }), $(k(O), "onHighlightedItemChange", function (D) { O.highlightedItem = D }), $(k(O), "getItemId", function (D, F) { if (F === null) return null; var z = O.props.id, W = D === null ? "" : "section-".concat(D); return "react-autowhatever-".concat(z, "-").concat(W, "-item-").concat(F) }), $(k(O), "onFocus", function (D) { var F = O.props.inputProps; O.setState({ isInputFocused: !0 }), F.onFocus && F.onFocus(D) }), $(k(O), "onBlur", function (D) { var F = O.props.inputProps; O.setState({ isInputFocused: !1 }), F.onBlur && F.onBlur(D) }), $(k(O), "onKeyDown", function (D) { var F = O.props, z = F.inputProps, W = F.highlightedSectionIndex, K = F.highlightedItemIndex, Z = D.keyCode; switch (Z) { case 40: case 38: { var ae = Z === 40 ? "next" : "prev", ue = O.sectionIterator[ae]([W, K]), tt = h(ue, 2), ot = tt[0], Yt = tt[1]; z.onKeyDown(D, { newHighlightedSectionIndex: ot, newHighlightedItemIndex: Yt }); break } default: z.onKeyDown(D, { highlightedSectionIndex: W, highlightedItemIndex: K }) } }), O.highlightedItem = null, O.state = { isInputFocused: !1 }, O.setSectionsItems(w), O.setSectionIterator(w), O.setTheme(w), O } return P(C, [{ key: "componentDidMount", value: function () { this.ensureHighlightedItemIsVisible() } }, { key: "UNSAFE_componentWillReceiveProps", value: function (O) { O.items !== this.props.items && this.setSectionsItems(O), (O.items !== this.props.items || O.multiSection !== this.props.multiSection) && this.setSectionIterator(O), O.theme !== this.props.theme && this.setTheme(O) } }, { key: "componentDidUpdate", value: function () { this.ensureHighlightedItemIsVisible() } }, { key: "setSectionsItems", value: function (O) { O.multiSection && (this.sectionsItems = O.items.map(function (D) { return O.getSectionItems(D) }), this.sectionsLengths = this.sectionsItems.map(function (D) { return D.length }), this.allSectionsAreEmpty = this.sectionsLengths.every(function (D) { return D === 0 })) } }, { key: "setSectionIterator", value: function (O) { this.sectionIterator = (0, r.default)({ multiSection: O.multiSection, data: O.multiSection ? this.sectionsLengths : O.items.length }) } }, { key: "setTheme", value: function (O) { this.theme = (0, i.default)(O.theme) } }, { key: "renderSections", value: function () { var O = this; if (this.allSectionsAreEmpty) return null; var D = this.theme, F = this.props, z = F.id, W = F.items, K = F.renderItem, Z = F.renderItemData, ae = F.renderSectionTitle, ue = F.highlightedSectionIndex, tt = F.highlightedItemIndex, ot = F.itemProps; return W.map(function (Yt, qe) { var Ur = "react-autowhatever-".concat(z, "-"), Hr = "".concat(Ur, "section-").concat(qe, "-"), un = qe === 0; return e.default.createElement("div", D("".concat(Hr, "container"), "sectionContainer", un && "sectionContainerFirst"), e.default.createElement(s.default, { section: Yt, renderSectionTitle: ae, theme: D, sectionKeyPrefix: Hr }), e.default.createElement(o.default, { items: O.sectionsItems[qe], itemProps: ot, renderItem: K, renderItemData: Z, sectionIndex: qe, highlightedItemIndex: ue === qe ? tt : null, onHighlightedItemChange: O.onHighlightedItemChange, getItemId: O.getItemId, theme: D, keyPrefix: Ur, ref: O.storeItemsListReference })) }) } }, { key: "renderItems", value: function () { var O = this.props.items; if (O.length === 0) return null; var D = this.theme, F = this.props, z = F.id, W = F.renderItem, K = F.renderItemData, Z = F.highlightedSectionIndex, ae = F.highlightedItemIndex, ue = F.itemProps; return e.default.createElement(o.default, { items: O, itemProps: ue, renderItem: W, renderItemData: K, highlightedItemIndex: Z === null ? ae : null, onHighlightedItemChange: this.onHighlightedItemChange, getItemId: this.getItemId, theme: D, keyPrefix: "react-autowhatever-".concat(z, "-") }) } }, { key: "ensureHighlightedItemIsVisible", value: function () { var O = this.highlightedItem; if (O) { var D = this.itemsContainer, F = O.offsetParent === D ? O.offsetTop : O.offsetTop - D.offsetTop, z = D.scrollTop; F < z ? z = F : F + O.offsetHeight > z + D.offsetHeight && (z = F + O.offsetHeight - D.offsetHeight), z !== D.scrollTop && (D.scrollTop = z) } } }, { key: "render", value: function () { var O = this.theme, D = this.props, F = D.id, z = D.multiSection, W = D.renderInputComponent, K = D.renderItemsContainer, Z = D.highlightedSectionIndex, ae = D.highlightedItemIndex, ue = this.state.isInputFocused, tt = z ? this.renderSections() : this.renderItems(), ot = tt !== null, Yt = this.getItemId(Z, ae), qe = "react-autowhatever-".concat(F), Ur = d({ role: "combobox", "aria-haspopup": "listbox", "aria-owns": qe, "aria-expanded": ot }, O("react-autowhatever-".concat(F, "-container"), "container", ot && "containerOpen"), {}, this.props.containerProps), Hr = W(d({ type: "text", value: "", autoComplete: "off", "aria-autocomplete": "list", "aria-controls": qe, "aria-activedescendant": Yt }, O("react-autowhatever-".concat(F, "-input"), "input", ot && "inputOpen", ue && "inputFocused"), {}, this.props.inputProps, { onFocus: this.onFocus, onBlur: this.onBlur, onKeyDown: this.props.inputProps.onKeyDown && this.onKeyDown, ref: this.storeInputReference })), un = K({ containerProps: d({ id: qe, role: "listbox" }, O("react-autowhatever-".concat(F, "-items-container"), "itemsContainer", ot && "itemsContainerOpen"), { ref: this.storeItemsContainerReference }), children: tt }); return e.default.createElement("div", Ur, Hr, un) } }]), C }(e.Component); t.default = j, $(j, "propTypes", { id: n.default.string, multiSection: n.default.bool, renderInputComponent: n.default.func, renderItemsContainer: n.default.func, items: n.default.array.isRequired, renderItem: n.default.func, renderItemData: n.default.object, renderSectionTitle: n.default.func, getSectionItems: n.default.func, containerProps: n.default.object, inputProps: n.default.object, itemProps: n.default.oneOfType([n.default.object, n.default.func]), highlightedSectionIndex: n.default.number, highlightedItemIndex: n.default.number, theme: n.default.oneOfType([n.default.object, n.default.array]) }), $(j, "defaultProps", { id: "1", multiSection: !1, renderInputComponent: H, renderItemsContainer: V, renderItem: function () { throw new Error("`renderItem` must be provided") }, renderItemData: B, renderSectionTitle: function () { throw new Error("`renderSectionTitle` must be provided") }, getSectionItems: function () { throw new Error("`getSectionItems` must be provided") }, containerProps: B, inputProps: B, itemProps: B, highlightedSectionIndex: null, highlightedItemIndex: null, theme: q })
})(pb); var Ri = {}; Object.defineProperty(Ri, "__esModule", { value: !0 }); Ri.mapToAutowhateverTheme = Ri.defaultTheme = void 0; var yP = { container: "react-autosuggest__container", containerOpen: "react-autosuggest__container--open", input: "react-autosuggest__input", inputOpen: "react-autosuggest__input--open", inputFocused: "react-autosuggest__input--focused", suggestionsContainer: "react-autosuggest__suggestions-container", suggestionsContainerOpen: "react-autosuggest__suggestions-container--open", suggestionsList: "react-autosuggest__suggestions-list", suggestion: "react-autosuggest__suggestion", suggestionFirst: "react-autosuggest__suggestion--first", suggestionHighlighted: "react-autosuggest__suggestion--highlighted", sectionContainer: "react-autosuggest__section-container", sectionContainerFirst: "react-autosuggest__section-container--first", sectionTitle: "react-autosuggest__section-title" }; Ri.defaultTheme = yP; var bP = function (e) { var n = {}; for (var r in e) switch (r) { case "suggestionsContainer": n.itemsContainer = e[r]; break; case "suggestionsContainerOpen": n.itemsContainerOpen = e[r]; break; case "suggestion": n.item = e[r]; break; case "suggestionFirst": n.itemFirst = e[r]; break; case "suggestionHighlighted": n.itemHighlighted = e[r]; break; case "suggestionsList": n.itemsList = e[r]; break; default: n[r] = e[r] }return n }; Ri.mapToAutowhateverTheme = bP; (function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var e = l(R), n = o(yo), r = o(dP), i = o(pb), s = Ri; function o(j) { return j && j.__esModule ? j : { default: j } } function a() { if (typeof WeakMap != "function") return null; var j = new WeakMap; return a = function () { return j }, j } function l(j) { if (j && j.__esModule) return j; if (j === null || u(j) !== "object" && typeof j != "function") return { default: j }; var _ = a(); if (_ && _.has(j)) return _.get(j); var x = {}, C = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var w in j) if (Object.prototype.hasOwnProperty.call(j, w)) { var O = C ? Object.getOwnPropertyDescriptor(j, w) : null; O && (O.get || O.set) ? Object.defineProperty(x, w, O) : x[w] = j[w] } return x.default = j, _ && _.set(j, x), x } function u(j) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? u = function (x) { return typeof x } : u = function (x) { return x && typeof Symbol == "function" && x.constructor === Symbol && x !== Symbol.prototype ? "symbol" : typeof x }, u(j) } function c(j, _) { var x = Object.keys(j); if (Object.getOwnPropertySymbols) { var C = Object.getOwnPropertySymbols(j); _ && (C = C.filter(function (w) { return Object.getOwnPropertyDescriptor(j, w).enumerable })), x.push.apply(x, C) } return x } function d(j) { for (var _ = 1; _ < arguments.length; _++) { var x = arguments[_] != null ? arguments[_] : {}; _ % 2 ? c(Object(x), !0).forEach(function (C) { I(j, C, x[C]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(j, Object.getOwnPropertyDescriptors(x)) : c(Object(x)).forEach(function (C) { Object.defineProperty(j, C, Object.getOwnPropertyDescriptor(x, C)) }) } return j } function h(j, _) { if (!(j instanceof _)) throw new TypeError("Cannot call a class as a function") } function f(j, _) { for (var x = 0; x < _.length; x++) { var C = _[x]; C.enumerable = C.enumerable || !1, C.configurable = !0, "value" in C && (C.writable = !0), Object.defineProperty(j, C.key, C) } } function g(j, _, x) { return _ && f(j.prototype, _), j } function m(j) { return function () { var _ = b(j), x; if (v()) { var C = b(this).constructor; x = Reflect.construct(_, arguments, C) } else x = _.apply(this, arguments); return y(this, x) } } function y(j, _) { return _ && (u(_) === "object" || typeof _ == "function") ? _ : p(j) } function p(j) { if (j === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return j } function v() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch { return !1 } } function b(j) { return b = Object.setPrototypeOf ? Object.getPrototypeOf : function (x) { return x.__proto__ || Object.getPrototypeOf(x) }, b(j) } function S(j, _) { if (typeof _ != "function" && _ !== null) throw new TypeError("Super expression must either be null or a function"); j.prototype = Object.create(_ && _.prototype, { constructor: { value: j, writable: !0, configurable: !0 } }), _ && P(j, _) } function P(j, _) { return P = Object.setPrototypeOf || function (C, w) { return C.__proto__ = w, C }, P(j, _) } function I(j, _, x) { return _ in j ? Object.defineProperty(j, _, { value: x, enumerable: !0, configurable: !0, writable: !0 }) : j[_] = x, j } var T = function () { return !0 }, k = function (_) { return _.trim().length > 0 }, E = function (_) { var x = _.containerProps, C = _.children; return e.default.createElement("div", x, C) }, M = "suggestions-revealed", L = "suggestions-updated", N = "suggestion-selected", $ = "input-focused", B = "input-changed", H = "input-blurred", V = "escape-pressed", q = function (j) { S(x, j); var _ = m(x); function x(C) { var w, O = C.alwaysRenderSuggestions; return h(this, x), w = _.call(this), I(p(w), "onDocumentMouseDown", function (D) { w.justClickedOnSuggestionsContainer = !1; for (var F = D.detail && D.detail.target || D.target; F !== null && F !== document;) { if (F.getAttribute && F.getAttribute("data-suggestion-index") !== null) return; if (F === w.suggestionsContainer) { w.justClickedOnSuggestionsContainer = !0; return } F = F.parentNode } }), I(p(w), "storeAutowhateverRef", function (D) { D !== null && (w.autowhatever = D) }), I(p(w), "onSuggestionMouseEnter", function (D, F) { var z = F.sectionIndex, W = F.itemIndex; w.updateHighlightedSuggestion(z, W), D.target === w.pressedSuggestion && (w.justSelectedSuggestion = !0), w.justMouseEntered = !0, setTimeout(function () { w.justMouseEntered = !1 }) }), I(p(w), "highlightFirstSuggestion", function () { w.updateHighlightedSuggestion(w.props.multiSection ? 0 : null, 0) }), I(p(w), "onDocumentMouseUp", function () { w.pressedSuggestion && !w.justSelectedSuggestion && w.input.focus(), w.pressedSuggestion = null }), I(p(w), "onSuggestionMouseDown", function (D) { w.justSelectedSuggestion || (w.justSelectedSuggestion = !0, w.pressedSuggestion = D.target) }), I(p(w), "onSuggestionsClearRequested", function () { var D = w.props.onSuggestionsClearRequested; D && D() }), I(p(w), "onSuggestionSelected", function (D, F) { var z = w.props, W = z.alwaysRenderSuggestions, K = z.onSuggestionSelected, Z = z.onSuggestionsFetchRequested; K && K(D, F); var ae = w.props.shouldKeepSuggestionsOnSelect(F.suggestion); W || ae ? Z({ value: F.suggestionValue, reason: N }) : w.onSuggestionsClearRequested(), w.resetHighlightedSuggestion() }), I(p(w), "onSuggestionClick", function (D) { var F = w.props, z = F.alwaysRenderSuggestions, W = F.focusInputOnSuggestionClick, K = w.getSuggestionIndices(w.findSuggestionElement(D.target)), Z = K.sectionIndex, ae = K.suggestionIndex, ue = w.getSuggestion(Z, ae), tt = w.props.getSuggestionValue(ue); w.maybeCallOnChange(D, tt, "click"), w.onSuggestionSelected(D, { suggestion: ue, suggestionValue: tt, suggestionIndex: ae, sectionIndex: Z, method: "click" }); var ot = w.props.shouldKeepSuggestionsOnSelect(ue); z || ot || w.closeSuggestions(), W === !0 ? w.input.focus() : w.onBlur(), setTimeout(function () { w.justSelectedSuggestion = !1 }) }), I(p(w), "onBlur", function () { var D = w.props, F = D.inputProps, z = D.shouldRenderSuggestions, W = F.value, K = F.onBlur, Z = w.getHighlightedSuggestion(), ae = z(W, H); w.setState({ isFocused: !1, highlightedSectionIndex: null, highlightedSuggestionIndex: null, highlightedSuggestion: null, valueBeforeUpDown: null, isCollapsed: !ae }), K && K(w.blurEvent, { highlightedSuggestion: Z }) }), I(p(w), "onSuggestionMouseLeave", function (D) { w.resetHighlightedSuggestion(!1), w.justSelectedSuggestion && D.target === w.pressedSuggestion && (w.justSelectedSuggestion = !1) }), I(p(w), "onSuggestionTouchStart", function () { w.justSelectedSuggestion = !0 }), I(p(w), "onSuggestionTouchMove", function () { w.justSelectedSuggestion = !1, w.pressedSuggestion = null, w.input.focus() }), I(p(w), "itemProps", function (D) { var F = D.sectionIndex, z = D.itemIndex; return { "data-section-index": F, "data-suggestion-index": z, onMouseEnter: w.onSuggestionMouseEnter, onMouseLeave: w.onSuggestionMouseLeave, onMouseDown: w.onSuggestionMouseDown, onTouchStart: w.onSuggestionTouchStart, onTouchMove: w.onSuggestionTouchMove, onClick: w.onSuggestionClick } }), I(p(w), "renderSuggestionsContainer", function (D) { var F = D.containerProps, z = D.children, W = w.props.renderSuggestionsContainer; return W({ containerProps: F, children: z, query: w.getQuery() }) }), w.state = { isFocused: !1, isCollapsed: !O, highlightedSectionIndex: null, highlightedSuggestionIndex: null, highlightedSuggestion: null, valueBeforeUpDown: null }, w.justPressedUpDown = !1, w.justMouseEntered = !1, w.pressedSuggestion = null, w } return g(x, [{ key: "componentDidMount", value: function () { document.addEventListener("mousedown", this.onDocumentMouseDown), document.addEventListener("mouseup", this.onDocumentMouseUp), this.input = this.autowhatever.input, this.suggestionsContainer = this.autowhatever.itemsContainer } }, { key: "UNSAFE_componentWillReceiveProps", value: function (w) { var O = this.state.highlightedSuggestionIndex === 0 && this.props.highlightFirstSuggestion && !w.highlightFirstSuggestion; (0, r.default)(w.suggestions, this.props.suggestions) ? w.highlightFirstSuggestion && w.suggestions.length > 0 && this.justPressedUpDown === !1 && this.justMouseEntered === !1 ? this.highlightFirstSuggestion() : O && this.resetHighlightedSuggestion() : this.willRenderSuggestions(w, L) ? (this.state.isCollapsed && !this.justSelectedSuggestion && this.revealSuggestions(), O && this.resetHighlightedSuggestion()) : this.resetHighlightedSuggestion() } }, { key: "componentDidUpdate", value: function (w, O) { var D = this.props, F = D.suggestions, z = D.onSuggestionHighlighted, W = D.highlightFirstSuggestion; if (!(0, r.default)(F, w.suggestions) && F.length > 0 && W) { this.highlightFirstSuggestion(); return } if (z) { var K = this.getHighlightedSuggestion(), Z = O.highlightedSuggestion; K != Z && z({ suggestion: K }) } } }, { key: "componentWillUnmount", value: function () { document.removeEventListener("mousedown", this.onDocumentMouseDown), document.removeEventListener("mouseup", this.onDocumentMouseUp) } }, { key: "updateHighlightedSuggestion", value: function (w, O, D) { var F = this; this.setState(function (z) { var W = z.valueBeforeUpDown; return O === null ? W = null : W === null && typeof D < "u" && (W = D), { highlightedSectionIndex: w, highlightedSuggestionIndex: O, highlightedSuggestion: O === null ? null : F.getSuggestion(w, O), valueBeforeUpDown: W } }) } }, { key: "resetHighlightedSuggestion", value: function () { var w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0; this.setState(function (O) { var D = O.valueBeforeUpDown; return { highlightedSectionIndex: null, highlightedSuggestionIndex: null, highlightedSuggestion: null, valueBeforeUpDown: w ? null : D } }) } }, { key: "revealSuggestions", value: function () { this.setState({ isCollapsed: !1 }) } }, { key: "closeSuggestions", value: function () { this.setState({ highlightedSectionIndex: null, highlightedSuggestionIndex: null, highlightedSuggestion: null, valueBeforeUpDown: null, isCollapsed: !0 }) } }, { key: "getSuggestion", value: function (w, O) { var D = this.props, F = D.suggestions, z = D.multiSection, W = D.getSectionSuggestions; return z ? W(F[w])[O] : F[O] } }, { key: "getHighlightedSuggestion", value: function () { var w = this.state, O = w.highlightedSectionIndex, D = w.highlightedSuggestionIndex; return D === null ? null : this.getSuggestion(O, D) } }, { key: "getSuggestionValueByIndex", value: function (w, O) { var D = this.props.getSuggestionValue; return D(this.getSuggestion(w, O)) } }, { key: "getSuggestionIndices", value: function (w) { var O = w.getAttribute("data-section-index"), D = w.getAttribute("data-suggestion-index"); return { sectionIndex: typeof O == "string" ? parseInt(O, 10) : null, suggestionIndex: parseInt(D, 10) } } }, { key: "findSuggestionElement", value: function (w) { var O = w; do { if (O.getAttribute && O.getAttribute("data-suggestion-index") !== null) return O; O = O.parentNode } while (O !== null); throw console.error("Clicked element:", w), new Error("Couldn't find suggestion element") } }, { key: "maybeCallOnChange", value: function (w, O, D) { var F = this.props.inputProps, z = F.value, W = F.onChange; O !== z && W(w, { newValue: O, method: D }) } }, { key: "willRenderSuggestions", value: function (w, O) { var D = w.suggestions, F = w.inputProps, z = w.shouldRenderSuggestions, W = F.value; return D.length > 0 && z(W, O) } }, { key: "getQuery", value: function () { var w = this.props.inputProps, O = w.value, D = this.state.valueBeforeUpDown; return (D === null ? O : D).trim() } }, { key: "render", value: function () { var w = this, O = this.props, D = O.suggestions, F = O.renderInputComponent, z = O.onSuggestionsFetchRequested, W = O.renderSuggestion, K = O.inputProps, Z = O.multiSection, ae = O.renderSectionTitle, ue = O.id, tt = O.getSectionSuggestions, ot = O.theme, Yt = O.getSuggestionValue, qe = O.alwaysRenderSuggestions, Ur = O.highlightFirstSuggestion, Hr = O.containerProps, un = this.state, ew = un.isFocused, Cf = un.isCollapsed, Of = un.highlightedSectionIndex, Pf = un.highlightedSuggestionIndex, So = un.valueBeforeUpDown, xo = qe ? T : this.props.shouldRenderSuggestions, Wr = K.value, Ef = K.onFocus, Tf = K.onKeyDown, tw = this.willRenderSuggestions(this.props, "render"), ko = qe || ew && !Cf && tw, nw = ko ? D : [], rw = d({}, K, { onFocus: function (Re) { if (!w.justSelectedSuggestion && !w.justClickedOnSuggestionsContainer) { var cn = xo(Wr, $); w.setState({ isFocused: !0, isCollapsed: !cn }), Ef && Ef(Re), cn && z({ value: Wr, reason: $ }) } }, onBlur: function (Re) { if (w.justClickedOnSuggestionsContainer) { w.input.focus(); return } w.blurEvent = Re, w.justSelectedSuggestion || (w.onBlur(), w.onSuggestionsClearRequested()) }, onChange: function (Re) { var cn = Re.target.value, Wi = xo(cn, B); w.maybeCallOnChange(Re, cn, "type"), w.suggestionsContainer && (w.suggestionsContainer.scrollTop = 0), w.setState(d({}, Ur ? {} : { highlightedSectionIndex: null, highlightedSuggestionIndex: null, highlightedSuggestion: null }, { valueBeforeUpDown: null, isCollapsed: !Wi })), Wi ? z({ value: cn, reason: B }) : w.onSuggestionsClearRequested() }, onKeyDown: function (Re, cn) { var Wi = Re.keyCode; switch (Wi) { case 40: case 38: if (Cf) xo(Wr, M) && (z({ value: Wr, reason: M }), w.revealSuggestions(), Re.preventDefault()); else if (D.length > 0) { var If = cn.newHighlightedSectionIndex, vu = cn.newHighlightedItemIndex, yu; vu === null ? yu = So === null ? Wr : So : yu = w.getSuggestionValueByIndex(If, vu), w.updateHighlightedSuggestion(If, vu, Wr), w.maybeCallOnChange(Re, yu, Wi === 40 ? "down" : "up"), Re.preventDefault() } w.justPressedUpDown = !0, setTimeout(function () { w.justPressedUpDown = !1 }); break; case 13: { if (Re.keyCode === 229) break; var bu = w.getHighlightedSuggestion(); if (ko && !qe && w.closeSuggestions(), bu != null) { Re.preventDefault(); var Rf = Yt(bu); w.maybeCallOnChange(Re, Rf, "enter"), w.onSuggestionSelected(Re, { suggestion: bu, suggestionValue: Rf, suggestionIndex: Pf, sectionIndex: Of, method: "enter" }), w.justSelectedSuggestion = !0, setTimeout(function () { w.justSelectedSuggestion = !1 }) } break } case 27: { ko && Re.preventDefault(); var Mf = ko && !qe; if (So === null) { if (!Mf) { var _u = ""; w.maybeCallOnChange(Re, _u, "escape"), xo(_u, V) ? z({ value: _u, reason: V }) : w.onSuggestionsClearRequested() } } else w.maybeCallOnChange(Re, So, "escape"); Mf ? (w.onSuggestionsClearRequested(), w.closeSuggestions()) : w.resetHighlightedSuggestion(); break } }Tf && Tf(Re) } }), iw = { query: this.getQuery() }; return e.default.createElement(i.default, { multiSection: Z, items: nw, renderInputComponent: F, renderItemsContainer: this.renderSuggestionsContainer, renderItem: W, renderItemData: iw, renderSectionTitle: ae, getSectionItems: tt, highlightedSectionIndex: Of, highlightedItemIndex: Pf, containerProps: Hr, inputProps: rw, itemProps: this.itemProps, theme: (0, s.mapToAutowhateverTheme)(ot), id: ue, ref: this.storeAutowhateverRef }) } }]), x }(e.Component); t.default = q, I(q, "propTypes", { suggestions: n.default.array.isRequired, onSuggestionsFetchRequested: function (_, x) { var C = _[x]; if (typeof C != "function") throw new Error("'onSuggestionsFetchRequested' must be implemented. See: https://github.com/moroshko/react-autosuggest#onSuggestionsFetchRequestedProp") }, onSuggestionsClearRequested: function (_, x) { var C = _[x]; if (_.alwaysRenderSuggestions === !1 && typeof C != "function") throw new Error("'onSuggestionsClearRequested' must be implemented. See: https://github.com/moroshko/react-autosuggest#onSuggestionsClearRequestedProp") }, shouldKeepSuggestionsOnSelect: n.default.func, onSuggestionSelected: n.default.func, onSuggestionHighlighted: n.default.func, renderInputComponent: n.default.func, renderSuggestionsContainer: n.default.func, getSuggestionValue: n.default.func.isRequired, renderSuggestion: n.default.func.isRequired, inputProps: function (_, x) { var C = _[x]; if (!C) throw new Error("'inputProps' must be passed."); if (!Object.prototype.hasOwnProperty.call(C, "value")) throw new Error("'inputProps' must have 'value'."); if (!Object.prototype.hasOwnProperty.call(C, "onChange")) throw new Error("'inputProps' must have 'onChange'.") }, shouldRenderSuggestions: n.default.func, alwaysRenderSuggestions: n.default.bool, multiSection: n.default.bool, renderSectionTitle: function (_, x) { var C = _[x]; if (_.multiSection === !0 && typeof C != "function") throw new Error("'renderSectionTitle' must be implemented. See: https://github.com/moroshko/react-autosuggest#renderSectionTitleProp") }, getSectionSuggestions: function (_, x) { var C = _[x]; if (_.multiSection === !0 && typeof C != "function") throw new Error("'getSectionSuggestions' must be implemented. See: https://github.com/moroshko/react-autosuggest#getSectionSuggestionsProp") }, focusInputOnSuggestionClick: n.default.bool, highlightFirstSuggestion: n.default.bool, theme: n.default.object, id: n.default.string, containerProps: n.default.object }), I(q, "defaultProps", { renderSuggestionsContainer: E, shouldRenderSuggestions: k, alwaysRenderSuggestions: !1, multiSection: !1, shouldKeepSuggestionsOnSelect: function () { return !1 }, focusInputOnSuggestionClick: !0, highlightFirstSuggestion: !1, theme: s.defaultTheme, id: "1", containerProps: {} }) })(cb); var _P = cb.default; const wP = Vd(_P), SP = ({ addAccount: t, accounts: e, livrets: n }) => { const [r, i] = R.useState(""), [s, o] = R.useState(""), [a, l] = R.useState(""), [u, c] = R.useState([]), [d, h] = R.useState(""), [f, g] = R.useState({}), [m, y] = R.useState("Oui"), [p, v] = R.useState(!1), [b, S] = R.useState(!1), [P, I] = R.useState(null), [T, k] = R.useState(!1); R.useEffect(() => { (async () => { const { data: { user: w } } = await je.auth.getUser(); I(w) })() }, []); const E = C => { h(C.target.value) }, M = C => { const { name: w, value: O } = C.target; g(D => ({ ...D, [w]: O })) }, L = async C => { var O; const w = (O = C.target.files) == null ? void 0 : O[0]; if (w) { v(!0); const { data: { text: D } } = await ZO.recognize(w, "fra"), F = eP(D); i(F.Date), o(F.NomDeLaDepense), h(F.selectedOption), g(z => ({ ...z, [F.selectedOption]: F.DepenseCarteBleue })) } }, N = async C => { try { const w = C.trim(), { error: O } = await je.rpc("check_and_add_column", { p_table_name: "accounts", p_column_name: w, p_column_type: "text" }); if (O) throw O; const { data: D, error: F } = await je.from("accounts").select(w).limit(1); if (F) throw F } catch (w) { console.error(`Erreur lors de la vérification/ajout de la colonne ${C} :`, w) } }, $ = async C => { if (k(!0), C.preventDefault(), b) return; if ((!r || !s || !a || !d) && !p) { alert("Veuillez remplir au minimum la date, le nom de la dépense, la catégorie et sélectionner un type de dépense, ou télécharger une image."); return } S(!0); const [w, O, D] = r.split("-"), F = `${D}/${O}/${w}`; let z = { id: ub(), date: F, NomDeLaDepense: s, Categorie: a, DepenseCarteBleue: "", ObtenuCarteBleue: "", DeplaceCarteBleueVersLivretA: "", DeplaceLivretAVersCarteBleue: "", ObtenuLivretA: "", ObtenuMozaïque: "", ARevoir: m, ...f }; try { await N("date"), await N("NomDeLaDepense"), await N("Categorie"), await N("DepenseCarteBleue"), await N("ObtenuCarteBleue"), await N("DeplaceCarteBleueVersLivretA"), await N("DeplaceLivretAVersCarteBleue"), await N("ObtenuLivretA"), await N("ObtenuMozaïque"), await N("ARevoir"); for (const Z in f) f.hasOwnProperty(Z) && await N(Z); if (!P || !P.id) { console.error("Erreur: Utilisateur non défini ou non connecté."), S(!1); return } const { data: W, error: K } = await je.from("accounts").insert([{ ...z, user_id: P.id }]); if (K) { console.error("Erreur lors de l'ajout du compte :", K), S(!1); return } } catch (W) { console.error("Erreur lors de l'ajout du compte :", W) } i(""), o(""), l(""), h(""), g({}), y("Oui"), v(!1), S(!1), k(!1), window.location.reload() }, B = C => { const w = C.trim().toLowerCase(); return w.length === 0 ? [] : e.map(D => D.Categorie).filter((D, F, z) => D.toLowerCase().includes(w) && z.indexOf(D) === F) }, H = ({ value: C }) => { c(B(C)) }, V = () => { c([]) }, q = (C, { suggestion: w }) => { l(w) }, j = C => C, _ = C => A.jsx("div", { children: C }), x = { placeholder: "Catégorie", value: a, onChange: (C, { newValue: w }) => { l(w) } }; return A.jsxs("form", { onSubmit: $, className: "p-4", children: [A.jsxs("div", { className: "flex flex-row gap-5", children: [A.jsxs("div", { className: "w-3/4 my-auto", children: [A.jsxs("div", { className: "flex gap-5", children: [A.jsxs("div", { className: "w-1/3 p-2", children: [A.jsx("label", { className: "block", children: "Date" }), A.jsx("input", { type: "date", value: r, onChange: C => i(C.target.value), className: "border p-2 w-full" })] }), A.jsxs("div", { className: "w-1/3 p-2", children: [A.jsx("label", { className: "block", children: "Nom de la dépense" }), A.jsx("input", { type: "text", value: s, onChange: C => o(C.target.value), className: "border p-2 w-full" })] }), A.jsxs("div", { className: "w-1/3 p-2", children: [A.jsx("label", { className: "block", children: "Catégorie" }), A.jsx(wP, { suggestions: u, onSuggestionsFetchRequested: H, onSuggestionsClearRequested: V, onSuggestionSelected: q, getSuggestionValue: j, renderSuggestion: _, inputProps: x })] })] }), A.jsxs("div", { className: "flex gap-5", children: [A.jsxs("div", { className: "w-1/2 p-2", children: [A.jsx("label", { className: "block", children: "Type de dépense" }), A.jsxs("select", { value: d, onChange: E, className: "border p-2 w-full", children: [A.jsx("option", { value: "", children: "Sélectionner le type de dépense" }), A.jsx("option", { value: "DepenseCarteBleue", children: "Dépense Carte Bleue" }), A.jsx("option", { value: "ObtenuCarteBleue", children: "Obtenu Carte Bleue" }), n.map(C => { var w; return A.jsxs(_t.Fragment, { children: [C.expense && A.jsxs("option", { value: `Depense${C.name}`, children: ["Dépense ", C.name] }), C.obtained && A.jsxs("option", { value: `Obtenu${C.name}`, children: ["Obtenu ", C.name] }), C.move && ((w = C.moveTo) == null ? void 0 : w.map(O => A.jsxs("option", { value: `Deplace${C.name}Vers${O}`, children: ["Déplacé ", C.name, " vers ", O] }, `Deplace${C.name}Vers${O}`)))] }, C.name) })] })] }), A.jsxs("div", { className: "w-1/2 p-2", children: [A.jsx("label", { className: "block", children: "Montant" }), A.jsx("input", { type: "number", name: d, value: f[d] || "", onChange: M, className: "border p-2 w-full" })] })] }), A.jsx("div", { children: A.jsxs("label", { className: "block", children: ["A revoir", A.jsx("input", { type: "checkbox", checked: m === "Oui", onChange: C => y(C.target.checked ? "Oui" : ""), className: "ml-2" })] }) }), A.jsx("button", { type: "submit", className: "bg-green-500 text-white p-2 mt-2", children: "Ajouter" }), T && A.jsx("div", { className: "text-blue-500 mb-4", children: "En cours de chargement..." })] }), A.jsxs("div", { className: "w-1/4", children: [A.jsx("input", { type: "file", id: "imageUpload", onChange: L, style: { display: "none" } }), A.jsxs("label", { htmlFor: "imageUpload", children: [A.jsx("span", { className: "block bg-slate-500", children: "Clicker sur l'image pour insérer depuis une image" }), A.jsx("span", { className: "block bg-slate-500 text-center", children: "  ↓  ↓  ↓  " }), A.jsx("img", { src: ol, alt: "Logo", className: "preview-image rounded-full", style: { cursor: "pointer" } })] })] })] }), A.jsx(lb, { accounts: e })] }) }, xP = ({ accounts: t, deleteAccount: e, updateAccount: n, livrets: r }) => { const [i, s] = R.useState("date"), [o, a] = R.useState("asc"), [l, u] = R.useState([]), [c, d] = R.useState(!1), [h, f] = R.useState(!1), [g, m] = R.useState([]), [y, p] = R.useState(!1), [v, b] = R.useState(["date", "NomDeLaDepense", "Categorie", "ARevoir"]), S = R.useRef(null), P = R.useRef(null); R.useEffect(() => { (async () => { var x; const { data: q, error: j } = await je.auth.getUser(); if (j) { console.error("Erreur lors de la récupération de l’ordre des colonnes :", j); return } const _ = q.user; b(((x = _ == null ? void 0 : _.user_metadata) == null ? void 0 : x.columnOrder) || ["date", "NomDeLaDepense", "Categorie", "ARevoir"]) })() }, []), R.useEffect(() => { const V = S.current, q = P.current; if (V && q) { const j = () => { q.scrollLeft = V.scrollLeft }; return V.addEventListener("scroll", j), () => V.removeEventListener("scroll", j) } }, []); const I = V => { i === V ? a(o === "asc" ? "desc" : "asc") : (s(V), a("asc")) }, T = V => { const [q, j, _] = V.split("/").map(Number); return new Date(_, j - 1, q) }, k = [...t].sort((V, q) => { const j = o === "asc" ? 1 : -1, _ = !V[i] && V[i] !== 0, x = !q[i] && q[i] !== 0; if (_ && x) return 0; if (_) return 1; if (x) return -1; if (i === "date") { const C = T(V.date), w = T(q.date); return (C.getTime() - w.getTime()) * j } else return !isNaN(Number(V[i])) && !isNaN(Number(q[i])) ? (Number(V[i]) - Number(q[i])) * j : V[i].localeCompare(q[i]) * j }), E = () => { u(c ? [] : t.map(V => V.id)), d(!c) }, M = V => { l.includes(V) ? u(l.filter(q => q !== V)) : u([...l, V]) }, L = async () => { f(!1), p(!0), await Promise.all(l.map(V => e(V))), u([]), d(!1), p(!1) }, N = () => { f(!0), m(t) }, $ = async () => { f(!1), p(!0), await Promise.all(g.map(V => { const { id: q, ...j } = V; return n(q, j) })), p(!1), window.location.reload() }, B = (V, q) => { const { name: j, value: _ } = q.target; m(g.map(x => x.id === V ? { ...x, [j]: _ } : x)) }, H = V => V.replace(/([A-Z])/g, " $1").trim(); return A.jsxs("div", { className: "flex flex-col pr-4", children: [A.jsx(lb, { accounts: t }), A.jsx("h2", { className: "text-xl mb-2", children: "Liste des comptes" }), A.jsxs("div", { className: "flex flex-wrap justify-evenly mb-4", children: [A.jsx("button", { className: "bg-blue-500 text-white px-4 py-2 mr-2 rounded", onClick: N, disabled: h, children: "Éditer" }), A.jsx("button", { className: "bg-red-500 text-white px-4 py-2 mr-2 rounded", onClick: L, disabled: l.length === 0, children: "Supprimer Sélectionnés" }), A.jsx("button", { className: "bg-green-500 text-white px-4 py-2 rounded", onClick: $, disabled: !h, children: "Enregistrer" })] }), y && A.jsx("div", { className: "text-blue-500 mb-4", children: "En cours de chargement..." }), A.jsx("div", { className: "relative flex-1 p-2 mx-auto", children: A.jsx("div", { ref: S, className: "overflow-auto h-full", children: A.jsxs("table", { className: "min-w-full bg-white text-black border-collapse border text-center", children: [A.jsx("thead", { children: A.jsxs("tr", { children: [A.jsx("th", { className: "py-2", children: A.jsx("input", { type: "checkbox", checked: c, onChange: E }) }), v.map(V => A.jsx("th", { className: "py-2", children: A.jsxs("button", { className: "focus:outline-none flex bg-transparent mx-auto", onClick: () => I(V), children: [H(V), " ", i === V && (o === "asc" ? "↑" : "↓")] }) }, V))] }) }), A.jsx("tbody", { children: k.map((V, q) => A.jsxs("tr", { className: "border-b border-gray-200", children: [A.jsx("td", { className: "py-2 border border-gray-200", children: A.jsx("input", { type: "checkbox", checked: l.includes(V.id), onChange: () => M(V.id) }) }), h ? A.jsx(A.Fragment, { children: v.map(j => { var _; return A.jsx("td", { className: "py-2 border border-gray-200 bg-gray-100", children: A.jsx("input", { type: "text", name: j, value: ((_ = g.find(x => x.id === V.id)) == null ? void 0 : _[j]) || "", onChange: x => B(V.id, x), className: "border p-1 w-full text-center bg-gray-200" }) }, j) }) }) : A.jsx(A.Fragment, { children: v.map(j => A.jsx("td", { className: "py-2 border border-gray-200", children: V[j] }, j)) })] }, q)) })] }) }) })] }) };/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */function bo(t) { return t + .5 | 0 } const Vn = (t, e, n) => Math.max(Math.min(t, n), e); function ps(t) { return Vn(bo(t * 2.55), 0, 255) } function er(t) { return Vn(bo(t * 255), 0, 255) } function vn(t) { return Vn(bo(t / 2.55) / 100, 0, 1) } function _g(t) { return Vn(bo(t * 100), 0, 100) } const Et = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Cd = [..."0123456789ABCDEF"], kP = t => Cd[t & 15], CP = t => Cd[(t & 240) >> 4] + Cd[t & 15], Ko = t => (t & 240) >> 4 === (t & 15), OP = t => Ko(t.r) && Ko(t.g) && Ko(t.b) && Ko(t.a); function PP(t) { var e = t.length, n; return t[0] === "#" && (e === 4 || e === 5 ? n = { r: 255 & Et[t[1]] * 17, g: 255 & Et[t[2]] * 17, b: 255 & Et[t[3]] * 17, a: e === 5 ? Et[t[4]] * 17 : 255 } : (e === 7 || e === 9) && (n = { r: Et[t[1]] << 4 | Et[t[2]], g: Et[t[3]] << 4 | Et[t[4]], b: Et[t[5]] << 4 | Et[t[6]], a: e === 9 ? Et[t[7]] << 4 | Et[t[8]] : 255 })), n } const EP = (t, e) => t < 255 ? e(t) : ""; function TP(t) { var e = OP(t) ? kP : CP; return t ? "#" + e(t.r) + e(t.g) + e(t.b) + EP(t.a, e) : void 0 } const IP = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function yb(t, e, n) { const r = e * Math.min(n, 1 - n), i = (s, o = (s + t / 30) % 12) => n - r * Math.max(Math.min(o - 3, 9 - o, 1), -1); return [i(0), i(8), i(4)] } function RP(t, e, n) { const r = (i, s = (i + t / 60) % 6) => n - n * e * Math.max(Math.min(s, 4 - s, 1), 0); return [r(5), r(3), r(1)] } function MP(t, e, n) { const r = yb(t, 1, .5); let i; for (e + n > 1 && (i = 1 / (e + n), e *= i, n *= i), i = 0; i < 3; i++)r[i] *= 1 - e - n, r[i] += e; return r } function LP(t, e, n, r, i) { return t === i ? (e - n) / r + (e < n ? 6 : 0) : e === i ? (n - t) / r + 2 : (t - e) / r + 4 } function Gh(t) { const n = t.r / 255, r = t.g / 255, i = t.b / 255, s = Math.max(n, r, i), o = Math.min(n, r, i), a = (s + o) / 2; let l, u, c; return s !== o && (c = s - o, u = a > .5 ? c / (2 - s - o) : c / (s + o), l = LP(n, r, i, c, s), l = l * 60 + .5), [l | 0, u || 0, a] } function Yh(t, e, n, r) { return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, n, r)).map(er) } function Qh(t, e, n) { return Yh(yb, t, e, n) } function DP(t, e, n) { return Yh(MP, t, e, n) } function AP(t, e, n) { return Yh(RP, t, e, n) } function bb(t) { return (t % 360 + 360) % 360 } function jP(t) { const e = IP.exec(t); let n = 255, r; if (!e) return; e[5] !== r && (n = e[6] ? ps(+e[5]) : er(+e[5])); const i = bb(+e[2]), s = +e[3] / 100, o = +e[4] / 100; return e[1] === "hwb" ? r = DP(i, s, o) : e[1] === "hsv" ? r = AP(i, s, o) : r = Qh(i, s, o), { r: r[0], g: r[1], b: r[2], a: n } } function NP(t, e) { var n = Gh(t); n[0] = bb(n[0] + e), n = Qh(n), t.r = n[0], t.g = n[1], t.b = n[2] } function FP(t) { if (!t) return; const e = Gh(t), n = e[0], r = _g(e[1]), i = _g(e[2]); return t.a < 255 ? `hsla(${n}, ${r}%, ${i}%, ${vn(t.a)})` : `hsl(${n}, ${r}%, ${i}%)` } const wg = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, Sg = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" }; function $P() { const t = {}, e = Object.keys(Sg), n = Object.keys(wg); let r, i, s, o, a; for (r = 0; r < e.length; r++) { for (o = a = e[r], i = 0; i < n.length; i++)s = n[i], a = a.replace(s, wg[s]); s = parseInt(Sg[o], 16), t[a] = [s >> 16 & 255, s >> 8 & 255, s & 255] } return t } let Go; function zP(t) { Go || (Go = $P(), Go.transparent = [0, 0, 0, 0]); const e = Go[t.toLowerCase()]; return e && { r: e[0], g: e[1], b: e[2], a: e.length === 4 ? e[3] : 255 } } const VP = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/; function BP(t) { const e = VP.exec(t); let n = 255, r, i, s; if (e) { if (e[7] !== r) { const o = +e[7]; n = e[8] ? ps(o) : Vn(o * 255, 0, 255) } return r = +e[1], i = +e[3], s = +e[5], r = 255 & (e[2] ? ps(r) : Vn(r, 0, 255)), i = 255 & (e[4] ? ps(i) : Vn(i, 0, 255)), s = 255 & (e[6] ? ps(s) : Vn(s, 0, 255)), { r, g: i, b: s, a: n } } } function UP(t) { return t && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${vn(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) } const nc = t => t <= .0031308 ? t * 12.92 : Math.pow(t, 1 / 2.4) * 1.055 - .055, Qr = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4); function HP(t, e, n) { const r = Qr(vn(t.r)), i = Qr(vn(t.g)), s = Qr(vn(t.b)); return { r: er(nc(r + n * (Qr(vn(e.r)) - r))), g: er(nc(i + n * (Qr(vn(e.g)) - i))), b: er(nc(s + n * (Qr(vn(e.b)) - s))), a: t.a + n * (e.a - t.a) } } function Yo(t, e, n) { if (t) { let r = Gh(t); r[e] = Math.max(0, Math.min(r[e] + r[e] * n, e === 0 ? 360 : 1)), r = Qh(r), t.r = r[0], t.g = r[1], t.b = r[2] } } function _b(t, e) { return t && Object.assign(e || {}, t) } function xg(t) { var e = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = er(t[3]))) : (e = _b(t, { r: 0, g: 0, b: 0, a: 1 }), e.a = er(e.a)), e } function WP(t) { return t.charAt(0) === "r" ? BP(t) : jP(t) } class Zs { constructor(e) { if (e instanceof Zs) return e; const n = typeof e; let r; n === "object" ? r = xg(e) : n === "string" && (r = PP(e) || zP(e) || WP(e)), this._rgb = r, this._valid = !!r } get valid() { return this._valid } get rgb() { var e = _b(this._rgb); return e && (e.a = vn(e.a)), e } set rgb(e) { this._rgb = xg(e) } rgbString() { return this._valid ? UP(this._rgb) : void 0 } hexString() { return this._valid ? TP(this._rgb) : void 0 } hslString() { return this._valid ? FP(this._rgb) : void 0 } mix(e, n) { if (e) { const r = this.rgb, i = e.rgb; let s; const o = n === s ? .5 : n, a = 2 * o - 1, l = r.a - i.a, u = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2; s = 1 - u, r.r = 255 & u * r.r + s * i.r + .5, r.g = 255 & u * r.g + s * i.g + .5, r.b = 255 & u * r.b + s * i.b + .5, r.a = o * r.a + (1 - o) * i.a, this.rgb = r } return this } interpolate(e, n) { return e && (this._rgb = HP(this._rgb, e._rgb, n)), this } clone() { return new Zs(this.rgb) } alpha(e) { return this._rgb.a = er(e), this } clearer(e) { const n = this._rgb; return n.a *= 1 - e, this } greyscale() { const e = this._rgb, n = bo(e.r * .3 + e.g * .59 + e.b * .11); return e.r = e.g = e.b = n, this } opaquer(e) { const n = this._rgb; return n.a *= 1 + e, this } negate() { const e = this._rgb; return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this } lighten(e) { return Yo(this._rgb, 2, e), this } darken(e) { return Yo(this._rgb, 2, -e), this } saturate(e) { return Yo(this._rgb, 1, e), this } desaturate(e) { return Yo(this._rgb, 1, -e), this } rotate(e) { return NP(this._rgb, e), this } }/*!
 * Chart.js v4.4.3
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */function dn() { } const qP = (() => { let t = 0; return () => t++ })(); function fe(t) { return t === null || typeof t > "u" } function we(t) { if (Array.isArray && Array.isArray(t)) return !0; const e = Object.prototype.toString.call(t); return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]" } function ie(t) { return t !== null && Object.prototype.toString.call(t) === "[object Object]" } function Ne(t) { return (typeof t == "number" || t instanceof Number) && isFinite(+t) } function mt(t, e) { return Ne(t) ? t : e } function le(t, e) { return typeof t > "u" ? e : t } const KP = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 * e : +t; function ge(t, e, n) { if (t && typeof t.call == "function") return t.apply(n, e) } function ce(t, e, n, r) { let i, s, o; if (we(t)) for (s = t.length, i = 0; i < s; i++)e.call(n, t[i], i); else if (ie(t)) for (o = Object.keys(t), s = o.length, i = 0; i < s; i++)e.call(n, t[o[i]], o[i]) } function al(t, e) { let n, r, i, s; if (!t || !e || t.length !== e.length) return !1; for (n = 0, r = t.length; n < r; ++n)if (i = t[n], s = e[n], i.datasetIndex !== s.datasetIndex || i.index !== s.index) return !1; return !0 } function ll(t) { if (we(t)) return t.map(ll); if (ie(t)) { const e = Object.create(null), n = Object.keys(t), r = n.length; let i = 0; for (; i < r; ++i)e[n[i]] = ll(t[n[i]]); return e } return t } function wb(t) { return ["__proto__", "prototype", "constructor"].indexOf(t) === -1 } function GP(t, e, n, r) { if (!wb(t)) return; const i = e[t], s = n[t]; ie(i) && ie(s) ? eo(i, s, r) : e[t] = ll(s) } function eo(t, e, n) { const r = we(e) ? e : [e], i = r.length; if (!ie(t)) return t; n = n || {}; const s = n.merger || GP; let o; for (let a = 0; a < i; ++a) { if (o = r[a], !ie(o)) continue; const l = Object.keys(o); for (let u = 0, c = l.length; u < c; ++u)s(l[u], t, o, n) } return t } function Ts(t, e) { return eo(t, e, { merger: YP }) } function YP(t, e, n) { if (!wb(t)) return; const r = e[t], i = n[t]; ie(r) && ie(i) ? Ts(r, i) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = ll(i)) } const kg = { "": t => t, x: t => t.x, y: t => t.y }; function QP(t) { const e = t.split("."), n = []; let r = ""; for (const i of e) r += i, r.endsWith("\\") ? r = r.slice(0, -1) + "." : (n.push(r), r = ""); return n } function XP(t) { const e = QP(t); return n => { for (const r of e) { if (r === "") break; n = n && n[r] } return n } } function Mi(t, e) { return (kg[e] || (kg[e] = XP(e)))(t) } function Xh(t) { return t.charAt(0).toUpperCase() + t.slice(1) } const to = t => typeof t < "u", ir = t => typeof t == "function", Cg = (t, e) => { if (t.size !== e.size) return !1; for (const n of t) if (!e.has(n)) return !1; return !0 }; function JP(t) { return t.type === "mouseup" || t.type === "click" || t.type === "contextmenu" } const $e = Math.PI, an = 2 * $e, ul = Number.POSITIVE_INFINITY, ZP = $e / 180, bt = $e / 2, pr = $e / 4, Og = $e * 2 / 3, Bn = Math.log10, tr = Math.sign; function Ca(t, e, n) { return Math.abs(t - e) < n } function Pg(t) { const e = Math.round(t); t = Ca(t, e, t / 1e3) ? e : t; const n = Math.pow(10, Math.floor(Bn(t))), r = t / n; return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n } function eE(t) { const e = [], n = Math.sqrt(t); let r; for (r = 1; r < n; r++)t % r === 0 && (e.push(r), e.push(t / r)); return n === (n | 0) && e.push(n), e.sort((i, s) => i - s).pop(), e } function cl(t) { return !isNaN(parseFloat(t)) && isFinite(t) } function tE(t, e) { const n = Math.round(t); return n - e <= t && n + e >= t } function Sb(t, e, n) { let r, i, s; for (r = 0, i = t.length; r < i; r++)s = t[r][n], isNaN(s) || (e.min = Math.min(e.min, s), e.max = Math.max(e.max, s)) } function Un(t) { return t * ($e / 180) } function Jh(t) { return t * (180 / $e) } function Eg(t) { if (!Ne(t)) return; let e = 1, n = 0; for (; Math.round(t * e) / e !== t;)e *= 10, n++; return n } function nE(t, e) { const n = e.x - t.x, r = e.y - t.y, i = Math.sqrt(n * n + r * r); let s = Math.atan2(r, n); return s < -.5 * $e && (s += an), { angle: s, distance: i } } function rE(t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) } function en(t) { return (t % an + an) % an } function iE(t, e, n, r) { const i = en(t), s = en(e), o = en(n), a = en(s - i), l = en(o - i), u = en(i - s), c = en(i - o); return i === s || i === o || r && s === o || a > l && u < c } function Wt(t, e, n) { return Math.max(e, Math.min(n, t)) } function sE(t) { return Wt(t, -32768, 32767) } function di(t, e, n, r = 1e-6) { return t >= Math.min(e, n) - r && t <= Math.max(e, n) + r } function Zh(t, e, n) { n = n || (o => t[o] < e); let r = t.length - 1, i = 0, s; for (; r - i > 1;)s = i + r >> 1, n(s) ? i = s : r = s; return { lo: i, hi: r } } const Od = (t, e, n, r) => Zh(t, n, r ? i => { const s = t[i][e]; return s < n || s === n && t[i + 1][e] === n } : i => t[i][e] < n), oE = (t, e, n) => Zh(t, n, r => t[r][e] >= n); function aE(t, e, n) { let r = 0, i = t.length; for (; r < i && t[r] < e;)r++; for (; i > r && t[i - 1] > n;)i--; return r > 0 || i < t.length ? t.slice(r, i) : t } const xb = ["push", "pop", "shift", "splice", "unshift"]; function lE(t, e) { if (t._chartjs) { t._chartjs.listeners.push(e); return } Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [e] } }), xb.forEach(n => { const r = "_onData" + Xh(n), i = t[n]; Object.defineProperty(t, n, { configurable: !0, enumerable: !1, value(...s) { const o = i.apply(this, s); return t._chartjs.listeners.forEach(a => { typeof a[r] == "function" && a[r](...s) }), o } }) }) } function Tg(t, e) { const n = t._chartjs; if (!n) return; const r = n.listeners, i = r.indexOf(e); i !== -1 && r.splice(i, 1), !(r.length > 0) && (xb.forEach(s => { delete t[s] }), delete t._chartjs) } function kb(t) { const e = new Set(t); return e.size === t.length ? t : Array.from(e) } const Cb = function () { return typeof window > "u" ? function (t) { return t() } : window.requestAnimationFrame }(); function Ob(t, e) { let n = [], r = !1; return function (...i) { n = i, r || (r = !0, Cb.call(window, () => { r = !1, t.apply(e, n) })) } } function uE(t, e) { let n; return function (...r) { return e ? (clearTimeout(n), n = setTimeout(t, e, r)) : t.apply(this, r), e } } const ef = t => t === "start" ? "left" : t === "end" ? "right" : "center", Qe = (t, e, n) => t === "start" ? e : t === "end" ? n : (e + n) / 2, cE = (t, e, n, r) => t === (r ? "left" : "right") ? n : t === "center" ? (e + n) / 2 : e, Qo = t => t === 0 || t === 1, Ig = (t, e, n) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * an / n)), Rg = (t, e, n) => Math.pow(2, -10 * t) * Math.sin((t - e) * an / n) + 1, Is = { linear: t => t, easeInQuad: t => t * t, easeOutQuad: t => -t * (t - 2), easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1), easeInCubic: t => t * t * t, easeOutCubic: t => (t -= 1) * t * t + 1, easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2), easeInQuart: t => t * t * t * t, easeOutQuart: t => -((t -= 1) * t * t * t - 1), easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2), easeInQuint: t => t * t * t * t * t, easeOutQuint: t => (t -= 1) * t * t * t * t + 1, easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2), easeInSine: t => -Math.cos(t * bt) + 1, easeOutSine: t => Math.sin(t * bt), easeInOutSine: t => -.5 * (Math.cos($e * t) - 1), easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)), easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1, easeInOutExpo: t => Qo(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (t * 2 - 1)) : .5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2), easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1), easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t), easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1), easeInElastic: t => Qo(t) ? t : Ig(t, .075, .3), easeOutElastic: t => Qo(t) ? t : Rg(t, .075, .3), easeInOutElastic(t) { return Qo(t) ? t : t < .5 ? .5 * Ig(t * 2, .1125, .45) : .5 + .5 * Rg(t * 2 - 1, .1125, .45) }, easeInBack(t) { return t * t * ((1.70158 + 1) * t - 1.70158) }, easeOutBack(t) { return (t -= 1) * t * ((1.70158 + 1) * t + 1.70158) + 1 }, easeInOutBack(t) { let e = 1.70158; return (t /= .5) < 1 ? .5 * (t * t * (((e *= 1.525) + 1) * t - e)) : .5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2) }, easeInBounce: t => 1 - Is.easeOutBounce(1 - t), easeOutBounce(t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, easeInOutBounce: t => t < .5 ? Is.easeInBounce(t * 2) * .5 : Is.easeOutBounce(t * 2 - 1) * .5 + .5 }; function Pb(t) { if (t && typeof t == "object") { const e = t.toString(); return e === "[object CanvasPattern]" || e === "[object CanvasGradient]" } return !1 } function Mg(t) { return Pb(t) ? t : new Zs(t) } function rc(t) { return Pb(t) ? t : new Zs(t).saturate(.5).darken(.1).hexString() } const dE = ["x", "y", "borderWidth", "radius", "tension"], hE = ["color", "borderColor", "backgroundColor"]; function fE(t) { t.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }), t.describe("animation", { _fallback: !1, _indexable: !1, _scriptable: e => e !== "onProgress" && e !== "onComplete" && e !== "fn" }), t.set("animations", { colors: { type: "color", properties: hE }, numbers: { type: "number", properties: dE } }), t.describe("animations", { _fallback: "animation" }), t.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: e => e | 0 } } } }) } function pE(t) { t.set("layout", { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } }) } const Lg = new Map; function gE(t, e) { e = e || {}; const n = t + JSON.stringify(e); let r = Lg.get(n); return r || (r = new Intl.NumberFormat(t, e), Lg.set(n, r)), r } function tf(t, e, n) { return gE(e, n).format(t) } const Eb = { values(t) { return we(t) ? t : "" + t }, numeric(t, e, n) { if (t === 0) return "0"; const r = this.chart.options.locale; let i, s = t; if (n.length > 1) { const u = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value)); (u < 1e-4 || u > 1e15) && (i = "scientific"), s = mE(t, n) } const o = Bn(Math.abs(s)), a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = { notation: i, minimumFractionDigits: a, maximumFractionDigits: a }; return Object.assign(l, this.options.ticks.format), tf(t, r, l) }, logarithmic(t, e, n) { if (t === 0) return "0"; const r = n[e].significand || t / Math.pow(10, Math.floor(Bn(t))); return [1, 2, 3, 5, 10, 15].includes(r) || e > .8 * n.length ? Eb.numeric.call(this, t, e, n) : "" } }; function mE(t, e) { let n = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value; return Math.abs(n) >= 1 && t !== Math.floor(t) && (n = t - Math.floor(t)), n } var Jl = { formatters: Eb }; function vE(t) { t.set("scale", { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: "ticks", clip: !0, grace: 0, grid: { display: !0, lineWidth: 1, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: (e, n) => n.lineWidth, tickColor: (e, n) => n.color, offset: !1 }, border: { display: !0, dash: [], dashOffset: 0, width: 1 }, title: { display: !1, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: Jl.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: !1, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", { _fallback: !1, _scriptable: e => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser", _indexable: e => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash" }), t.describe("scales", { _fallback: "scale" }), t.describe("scale.ticks", { _scriptable: e => e !== "backdropPadding" && e !== "callback", _indexable: e => e !== "backdropPadding" }) } const Ar = Object.create(null), Pd = Object.create(null); function Rs(t, e) { if (!e) return t; const n = e.split("."); for (let r = 0, i = n.length; r < i; ++r) { const s = n[r]; t = t[s] || (t[s] = Object.create(null)) } return t } function ic(t, e, n) { return typeof e == "string" ? eo(Rs(t, e), n) : eo(Rs(t, ""), e) } class yE { constructor(e, n) { this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = r => r.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (r, i) => rc(i.backgroundColor), this.hoverBorderColor = (r, i) => rc(i.borderColor), this.hoverColor = (r, i) => rc(i.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: !0, includeInvisible: !1 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(n) } set(e, n) { return ic(this, e, n) } get(e) { return Rs(this, e) } describe(e, n) { return ic(Pd, e, n) } override(e, n) { return ic(Ar, e, n) } route(e, n, r, i) { const s = Rs(this, e), o = Rs(this, r), a = "_" + n; Object.defineProperties(s, { [a]: { value: s[n], writable: !0 }, [n]: { enumerable: !0, get() { const l = this[a], u = o[i]; return ie(l) ? Object.assign({}, u, l) : le(l, u) }, set(l) { this[a] = l } } }) } apply(e) { e.forEach(n => n(this)) } } var Ce = new yE({ _scriptable: t => !t.startsWith("on"), _indexable: t => t !== "events", hover: { _fallback: "interaction" }, interaction: { _scriptable: !1, _indexable: !1 } }, [fE, pE, vE]); function bE(t) { return !t || fe(t.size) || fe(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family } function dl(t, e, n, r, i) { let s = e[i]; return s || (s = e[i] = t.measureText(i).width, n.push(i)), s > r && (r = s), r } function _E(t, e, n, r) { r = r || {}; let i = r.data = r.data || {}, s = r.garbageCollect = r.garbageCollect || []; r.font !== e && (i = r.data = {}, s = r.garbageCollect = [], r.font = e), t.save(), t.font = e; let o = 0; const a = n.length; let l, u, c, d, h; for (l = 0; l < a; l++)if (d = n[l], d != null && !we(d)) o = dl(t, i, s, o, d); else if (we(d)) for (u = 0, c = d.length; u < c; u++)h = d[u], h != null && !we(h) && (o = dl(t, i, s, o, h)); t.restore(); const f = s.length / 2; if (f > n.length) { for (l = 0; l < f; l++)delete i[s[l]]; s.splice(0, f) } return o } function gr(t, e, n) { const r = t.currentDevicePixelRatio, i = n !== 0 ? Math.max(n / 2, .5) : 0; return Math.round((e - i) * r) / r + i } function Dg(t, e) { !e && !t || (e = e || t.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore()) } function Ag(t, e, n, r) { Tb(t, e, n, r, null) } function Tb(t, e, n, r, i) { let s, o, a, l, u, c, d, h; const f = e.pointStyle, g = e.rotation, m = e.radius; let y = (g || 0) * ZP; if (f && typeof f == "object" && (s = f.toString(), s === "[object HTMLImageElement]" || s === "[object HTMLCanvasElement]")) { t.save(), t.translate(n, r), t.rotate(y), t.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), t.restore(); return } if (!(isNaN(m) || m <= 0)) { switch (t.beginPath(), f) { default: i ? t.ellipse(n, r, i / 2, m, 0, 0, an) : t.arc(n, r, m, 0, an), t.closePath(); break; case "triangle": c = i ? i / 2 : m, t.moveTo(n + Math.sin(y) * c, r - Math.cos(y) * m), y += Og, t.lineTo(n + Math.sin(y) * c, r - Math.cos(y) * m), y += Og, t.lineTo(n + Math.sin(y) * c, r - Math.cos(y) * m), t.closePath(); break; case "rectRounded": u = m * .516, l = m - u, o = Math.cos(y + pr) * l, d = Math.cos(y + pr) * (i ? i / 2 - u : l), a = Math.sin(y + pr) * l, h = Math.sin(y + pr) * (i ? i / 2 - u : l), t.arc(n - d, r - a, u, y - $e, y - bt), t.arc(n + h, r - o, u, y - bt, y), t.arc(n + d, r + a, u, y, y + bt), t.arc(n - h, r + o, u, y + bt, y + $e), t.closePath(); break; case "rect": if (!g) { l = Math.SQRT1_2 * m, c = i ? i / 2 : l, t.rect(n - c, r - l, 2 * c, 2 * l); break } y += pr; case "rectRot": d = Math.cos(y) * (i ? i / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, h = Math.sin(y) * (i ? i / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + h, r - o), t.lineTo(n + d, r + a), t.lineTo(n - h, r + o), t.closePath(); break; case "crossRot": y += pr; case "cross": d = Math.cos(y) * (i ? i / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, h = Math.sin(y) * (i ? i / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + d, r + a), t.moveTo(n + h, r - o), t.lineTo(n - h, r + o); break; case "star": d = Math.cos(y) * (i ? i / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, h = Math.sin(y) * (i ? i / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + d, r + a), t.moveTo(n + h, r - o), t.lineTo(n - h, r + o), y += pr, d = Math.cos(y) * (i ? i / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, h = Math.sin(y) * (i ? i / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + d, r + a), t.moveTo(n + h, r - o), t.lineTo(n - h, r + o); break; case "line": o = i ? i / 2 : Math.cos(y) * m, a = Math.sin(y) * m, t.moveTo(n - o, r - a), t.lineTo(n + o, r + a); break; case "dash": t.moveTo(n, r), t.lineTo(n + Math.cos(y) * (i ? i / 2 : m), r + Math.sin(y) * m); break; case !1: t.closePath(); break }t.fill(), e.borderWidth > 0 && t.stroke() } } function hi(t, e, n) { return n = n || .5, !e || t && t.x > e.left - n && t.x < e.right + n && t.y > e.top - n && t.y < e.bottom + n } function nf(t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() } function rf(t) { t.restore() } function wE(t, e) { e.translation && t.translate(e.translation[0], e.translation[1]), fe(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline) } function SE(t, e, n, r, i) { if (i.strikethrough || i.underline) { const s = t.measureText(r), o = e - s.actualBoundingBoxLeft, a = e + s.actualBoundingBoxRight, l = n - s.actualBoundingBoxAscent, u = n + s.actualBoundingBoxDescent, c = i.strikethrough ? (l + u) / 2 : u; t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = i.decorationWidth || 2, t.moveTo(o, c), t.lineTo(a, c), t.stroke() } } function xE(t, e) { const n = t.fillStyle; t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = n } function jr(t, e, n, r, i, s = {}) { const o = we(e) ? e : [e], a = s.strokeWidth > 0 && s.strokeColor !== ""; let l, u; for (t.save(), t.font = i.string, wE(t, s), l = 0; l < o.length; ++l)u = o[l], s.backdrop && xE(t, s.backdrop), a && (s.strokeColor && (t.strokeStyle = s.strokeColor), fe(s.strokeWidth) || (t.lineWidth = s.strokeWidth), t.strokeText(u, n, r, s.maxWidth)), t.fillText(u, n, r, s.maxWidth), SE(t, n, r, u, s), r += Number(i.lineHeight); t.restore() } function no(t, e) { const { x: n, y: r, w: i, h: s, radius: o } = e; t.arc(n + o.topLeft, r + o.topLeft, o.topLeft, 1.5 * $e, $e, !0), t.lineTo(n, r + s - o.bottomLeft), t.arc(n + o.bottomLeft, r + s - o.bottomLeft, o.bottomLeft, $e, bt, !0), t.lineTo(n + i - o.bottomRight, r + s), t.arc(n + i - o.bottomRight, r + s - o.bottomRight, o.bottomRight, bt, 0, !0), t.lineTo(n + i, r + o.topRight), t.arc(n + i - o.topRight, r + o.topRight, o.topRight, 0, -bt, !0), t.lineTo(n + o.topLeft, r) } const kE = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, CE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/; function OE(t, e) { const n = ("" + t).match(kE); if (!n || n[1] === "normal") return e * 1.2; switch (t = +n[2], n[3]) { case "px": return t; case "%": t /= 100; break }return e * t } const PE = t => +t || 0; function Ib(t, e) { const n = {}, r = ie(e), i = r ? Object.keys(e) : e, s = ie(t) ? r ? o => le(t[o], t[e[o]]) : o => t[o] : () => t; for (const o of i) n[o] = PE(s(o)); return n } function Rb(t) { return Ib(t, { top: "y", right: "x", bottom: "y", left: "x" }) } function Er(t) { return Ib(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"]) } function et(t) { const e = Rb(t); return e.width = e.left + e.right, e.height = e.top + e.bottom, e } function De(t, e) { t = t || {}, e = e || Ce.font; let n = le(t.size, e.size); typeof n == "string" && (n = parseInt(n, 10)); let r = le(t.style, e.style); r && !("" + r).match(CE) && (console.warn('Invalid font style specified: "' + r + '"'), r = void 0); const i = { family: le(t.family, e.family), lineHeight: OE(le(t.lineHeight, e.lineHeight), n), size: n, style: r, weight: le(t.weight, e.weight), string: "" }; return i.string = bE(i), i } function Xo(t, e, n, r) { let i, s, o; for (i = 0, s = t.length; i < s; ++i)if (o = t[i], o !== void 0 && o !== void 0) return o } function EE(t, e, n) { const { min: r, max: i } = t, s = KP(e, (i - r) / 2), o = (a, l) => n && a === 0 ? 0 : a + l; return { min: o(r, -Math.abs(s)), max: o(i, s) } } function Vr(t, e) { return Object.assign(Object.create(t), e) } function sf(t, e = [""], n, r, i = () => t[0]) { const s = n || t; typeof r > "u" && (r = Ab("_fallback", t)); const o = { [Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: t, _rootScopes: s, _fallback: r, _getTarget: i, override: a => sf([a, ...t], e, s, r) }; return new Proxy(o, { deleteProperty(a, l) { return delete a[l], delete a._keys, delete t[0][l], !0 }, get(a, l) { return Lb(a, l, () => jE(l, e, t, a)) }, getOwnPropertyDescriptor(a, l) { return Reflect.getOwnPropertyDescriptor(a._scopes[0], l) }, getPrototypeOf() { return Reflect.getPrototypeOf(t[0]) }, has(a, l) { return Ng(a).includes(l) }, ownKeys(a) { return Ng(a) }, set(a, l, u) { const c = a._storage || (a._storage = i()); return a[l] = c[l] = u, delete a._keys, !0 } }) } function Li(t, e, n, r) { const i = { _cacheable: !1, _proxy: t, _context: e, _subProxy: n, _stack: new Set, _descriptors: Mb(t, r), setContext: s => Li(t, s, n, r), override: s => Li(t.override(s), e, n, r) }; return new Proxy(i, { deleteProperty(s, o) { return delete s[o], delete t[o], !0 }, get(s, o, a) { return Lb(s, o, () => IE(s, o, a)) }, getOwnPropertyDescriptor(s, o) { return s._descriptors.allKeys ? Reflect.has(t, o) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(t, o) }, getPrototypeOf() { return Reflect.getPrototypeOf(t) }, has(s, o) { return Reflect.has(t, o) }, ownKeys() { return Reflect.ownKeys(t) }, set(s, o, a) { return t[o] = a, delete s[o], !0 } }) } function Mb(t, e = { scriptable: !0, indexable: !0 }) { const { _scriptable: n = e.scriptable, _indexable: r = e.indexable, _allKeys: i = e.allKeys } = t; return { allKeys: i, scriptable: n, indexable: r, isScriptable: ir(n) ? n : () => n, isIndexable: ir(r) ? r : () => r } } const TE = (t, e) => t ? t + Xh(e) : e, of = (t, e) => ie(e) && t !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object); function Lb(t, e, n) { if (Object.prototype.hasOwnProperty.call(t, e) || e === "constructor") return t[e]; const r = n(); return t[e] = r, r } function IE(t, e, n) { const { _proxy: r, _context: i, _subProxy: s, _descriptors: o } = t; let a = r[e]; return ir(a) && o.isScriptable(e) && (a = RE(e, a, t, n)), we(a) && a.length && (a = ME(e, a, t, o.isIndexable)), of(e, a) && (a = Li(a, i, s && s[e], o)), a } function RE(t, e, n, r) { const { _proxy: i, _context: s, _subProxy: o, _stack: a } = n; if (a.has(t)) throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + t); a.add(t); let l = e(s, o || r); return a.delete(t), of(t, l) && (l = af(i._scopes, i, t, l)), l } function ME(t, e, n, r) { const { _proxy: i, _context: s, _subProxy: o, _descriptors: a } = n; if (typeof s.index < "u" && r(t)) return e[s.index % e.length]; if (ie(e[0])) { const l = e, u = i._scopes.filter(c => c !== l); e = []; for (const c of l) { const d = af(u, i, t, c); e.push(Li(d, s, o && o[t], a)) } } return e } function Db(t, e, n) { return ir(t) ? t(e, n) : t } const LE = (t, e) => t === !0 ? e : typeof t == "string" ? Mi(e, t) : void 0; function DE(t, e, n, r, i) { for (const s of e) { const o = LE(n, s); if (o) { t.add(o); const a = Db(o._fallback, n, i); if (typeof a < "u" && a !== n && a !== r) return a } else if (o === !1 && typeof r < "u" && n !== r) return null } return !1 } function af(t, e, n, r) { const i = e._rootScopes, s = Db(e._fallback, n, r), o = [...t, ...i], a = new Set; a.add(r); let l = jg(a, o, n, s || n, r); return l === null || typeof s < "u" && s !== n && (l = jg(a, o, s, l, r), l === null) ? !1 : sf(Array.from(a), [""], i, s, () => AE(e, n, r)) } function jg(t, e, n, r, i) { for (; n;)n = DE(t, e, n, r, i); return n } function AE(t, e, n) { const r = t._getTarget(); e in r || (r[e] = {}); const i = r[e]; return we(i) && ie(n) ? n : i || {} } function jE(t, e, n, r) { let i; for (const s of e) if (i = Ab(TE(s, t), n), typeof i < "u") return of(t, i) ? af(n, r, t, i) : i } function Ab(t, e) { for (const n of e) { if (!n) continue; const r = n[t]; if (typeof r < "u") return r } } function Ng(t) { let e = t._keys; return e || (e = t._keys = NE(t._scopes)), e } function NE(t) { const e = new Set; for (const n of t) for (const r of Object.keys(n).filter(i => !i.startsWith("_"))) e.add(r); return Array.from(e) } function lf() { return typeof window < "u" && typeof document < "u" } function uf(t) { let e = t.parentNode; return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e } function hl(t, e, n) { let r; return typeof t == "string" ? (r = parseInt(t, 10), t.indexOf("%") !== -1 && (r = r / 100 * e.parentNode[n])) : r = t, r } const Zl = t => t.ownerDocument.defaultView.getComputedStyle(t, null); function FE(t, e) { return Zl(t).getPropertyValue(e) } const $E = ["top", "right", "bottom", "left"]; function Tr(t, e, n) { const r = {}; n = n ? "-" + n : ""; for (let i = 0; i < 4; i++) { const s = $E[i]; r[s] = parseFloat(t[e + "-" + s + n]) || 0 } return r.width = r.left + r.right, r.height = r.top + r.bottom, r } const zE = (t, e, n) => (t > 0 || e > 0) && (!n || !n.shadowRoot); function VE(t, e) { const n = t.touches, r = n && n.length ? n[0] : t, { offsetX: i, offsetY: s } = r; let o = !1, a, l; if (zE(i, s, t.target)) a = i, l = s; else { const u = e.getBoundingClientRect(); a = r.clientX - u.left, l = r.clientY - u.top, o = !0 } return { x: a, y: l, box: o } } function wr(t, e) { if ("native" in t) return t; const { canvas: n, currentDevicePixelRatio: r } = e, i = Zl(n), s = i.boxSizing === "border-box", o = Tr(i, "padding"), a = Tr(i, "border", "width"), { x: l, y: u, box: c } = VE(t, n), d = o.left + (c && a.left), h = o.top + (c && a.top); let { width: f, height: g } = e; return s && (f -= o.width + a.width, g -= o.height + a.height), { x: Math.round((l - d) / f * n.width / r), y: Math.round((u - h) / g * n.height / r) } } function BE(t, e, n) { let r, i; if (e === void 0 || n === void 0) { const s = t && uf(t); if (!s) e = t.clientWidth, n = t.clientHeight; else { const o = s.getBoundingClientRect(), a = Zl(s), l = Tr(a, "border", "width"), u = Tr(a, "padding"); e = o.width - u.width - l.width, n = o.height - u.height - l.height, r = hl(a.maxWidth, s, "clientWidth"), i = hl(a.maxHeight, s, "clientHeight") } } return { width: e, height: n, maxWidth: r || ul, maxHeight: i || ul } } const Jo = t => Math.round(t * 10) / 10; function UE(t, e, n, r) { const i = Zl(t), s = Tr(i, "margin"), o = hl(i.maxWidth, t, "clientWidth") || ul, a = hl(i.maxHeight, t, "clientHeight") || ul, l = BE(t, e, n); let { width: u, height: c } = l; if (i.boxSizing === "content-box") { const h = Tr(i, "border", "width"), f = Tr(i, "padding"); u -= f.width + h.width, c -= f.height + h.height } return u = Math.max(0, u - s.width), c = Math.max(0, r ? u / r : c - s.height), u = Jo(Math.min(u, o, l.maxWidth)), c = Jo(Math.min(c, a, l.maxHeight)), u && !c && (c = Jo(u / 2)), (e !== void 0 || n !== void 0) && r && l.height && c > l.height && (c = l.height, u = Jo(Math.floor(c * r))), { width: u, height: c } } function Fg(t, e, n) { const r = e || 1, i = Math.floor(t.height * r), s = Math.floor(t.width * r); t.height = Math.floor(t.height), t.width = Math.floor(t.width); const o = t.canvas; return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = `${t.height}px`, o.style.width = `${t.width}px`), t.currentDevicePixelRatio !== r || o.height !== i || o.width !== s ? (t.currentDevicePixelRatio = r, o.height = i, o.width = s, t.ctx.setTransform(r, 0, 0, r, 0, 0), !0) : !1 } const HE = function () { let t = !1; try { const e = { get passive() { return t = !0, !1 } }; lf() && (window.addEventListener("test", null, e), window.removeEventListener("test", null, e)) } catch { } return t }(); function $g(t, e) { const n = FE(t, e), r = n && n.match(/^(\d+)(\.\d+)?px$/); return r ? +r[1] : void 0 } const WE = function (t, e) { return { x(n) { return t + t + e - n }, setWidth(n) { e = n }, textAlign(n) { return n === "center" ? n : n === "right" ? "left" : "right" }, xPlus(n, r) { return n - r }, leftForLtr(n, r) { return n - r } } }, qE = function () { return { x(t) { return t }, setWidth(t) { }, textAlign(t) { return t }, xPlus(t, e) { return t + e }, leftForLtr(t, e) { return t } } }; function _i(t, e, n) { return t ? WE(e, n) : qE() } function jb(t, e) { let n, r; (e === "ltr" || e === "rtl") && (n = t.canvas.style, r = [n.getPropertyValue("direction"), n.getPropertyPriority("direction")], n.setProperty("direction", e, "important"), t.prevTextDirection = r) } function Nb(t, e) { e !== void 0 && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1])) }/*!
 * Chart.js v4.4.3
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */class KE { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify(e, n, r, i) { const s = n.listeners[i], o = n.duration; s.forEach(a => a({ chart: e, initial: n.initial, numSteps: o, currentStep: Math.min(r - n.start, o) })) } _refresh() { this._request || (this._running = !0, this._request = Cb.call(window, () => { this._update(), this._request = null, this._running && this._refresh() })) } _update(e = Date.now()) { let n = 0; this._charts.forEach((r, i) => { if (!r.running || !r.items.length) return; const s = r.items; let o = s.length - 1, a = !1, l; for (; o >= 0; --o)l = s[o], l._active ? (l._total > r.duration && (r.duration = l._total), l.tick(e), a = !0) : (s[o] = s[s.length - 1], s.pop()); a && (i.draw(), this._notify(i, r, e, "progress")), s.length || (r.running = !1, this._notify(i, r, e, "complete"), r.initial = !1), n += s.length }), this._lastDate = e, n === 0 && (this._running = !1) } _getAnims(e) { const n = this._charts; let r = n.get(e); return r || (r = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, n.set(e, r)), r } listen(e, n, r) { this._getAnims(e).listeners[n].push(r) } add(e, n) { !n || !n.length || this._getAnims(e).items.push(...n) } has(e) { return this._getAnims(e).items.length > 0 } start(e) { const n = this._charts.get(e); n && (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((r, i) => Math.max(r, i._duration), 0), this._refresh()) } running(e) { if (!this._running) return !1; const n = this._charts.get(e); return !(!n || !n.running || !n.items.length) } stop(e) { const n = this._charts.get(e); if (!n || !n.items.length) return; const r = n.items; let i = r.length - 1; for (; i >= 0; --i)r[i].cancel(); n.items = [], this._notify(e, n, Date.now(), "complete") } remove(e) { return this._charts.delete(e) } } var fn = new KE; const zg = "transparent", GE = { boolean(t, e, n) { return n > .5 ? e : t }, color(t, e, n) { const r = Mg(t || zg), i = r.valid && Mg(e || zg); return i && i.valid ? i.mix(r, n).hexString() : e }, number(t, e, n) { return t + (e - t) * n } }; class YE { constructor(e, n, r, i) { const s = n[r]; i = Xo([e.to, i, s, e.from]); const o = Xo([e.from, s, i]); this._active = !0, this._fn = e.fn || GE[e.type || typeof o], this._easing = Is[e.easing] || Is.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = n, this._prop = r, this._from = o, this._to = i, this._promises = void 0 } active() { return this._active } update(e, n, r) { if (this._active) { this._notify(!1); const i = this._target[this._prop], s = r - this._start, o = this._duration - s; this._start = r, this._duration = Math.floor(Math.max(o, e.duration)), this._total += s, this._loop = !!e.loop, this._to = Xo([e.to, n, i, e.from]), this._from = Xo([e.from, i, n]) } } cancel() { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } tick(e) { const n = e - this._start, r = this._duration, i = this._prop, s = this._from, o = this._loop, a = this._to; let l; if (this._active = s !== a && (o || n < r), !this._active) { this._target[i] = a, this._notify(!0); return } if (n < 0) { this._target[i] = s; return } l = n / r % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[i] = this._fn(s, a, l) } wait() { const e = this._promises || (this._promises = []); return new Promise((n, r) => { e.push({ res: n, rej: r }) }) } _notify(e) { const n = e ? "res" : "rej", r = this._promises || []; for (let i = 0; i < r.length; i++)r[i][n]() } } class Fb { constructor(e, n) { this._chart = e, this._properties = new Map, this.configure(n) } configure(e) { if (!ie(e)) return; const n = Object.keys(Ce.animation), r = this._properties; Object.getOwnPropertyNames(e).forEach(i => { const s = e[i]; if (!ie(s)) return; const o = {}; for (const a of n) o[a] = s[a]; (we(s.properties) && s.properties || [i]).forEach(a => { (a === i || !r.has(a)) && r.set(a, o) }) }) } _animateOptions(e, n) { const r = n.options, i = XE(e, r); if (!i) return []; const s = this._createAnimations(i, r); return r.$shared && QE(e.options.$animations, r).then(() => { e.options = r }, () => { }), s } _createAnimations(e, n) { const r = this._properties, i = [], s = e.$animations || (e.$animations = {}), o = Object.keys(n), a = Date.now(); let l; for (l = o.length - 1; l >= 0; --l) { const u = o[l]; if (u.charAt(0) === "$") continue; if (u === "options") { i.push(...this._animateOptions(e, n)); continue } const c = n[u]; let d = s[u]; const h = r.get(u); if (d) if (h && d.active()) { d.update(h, c, a); continue } else d.cancel(); if (!h || !h.duration) { e[u] = c; continue } s[u] = d = new YE(h, e, u, c), i.push(d) } return i } update(e, n) { if (this._properties.size === 0) { Object.assign(e, n); return } const r = this._createAnimations(e, n); if (r.length) return fn.add(this._chart, r), !0 } } function QE(t, e) { const n = [], r = Object.keys(e); for (let i = 0; i < r.length; i++) { const s = t[r[i]]; s && s.active() && n.push(s.wait()) } return Promise.all(n) } function XE(t, e) { if (!e) return; let n = t.options; if (!n) { t.options = e; return } return n.$shared && (t.options = n = Object.assign({}, n, { $shared: !1, $animations: {} })), n } function Vg(t, e) { const n = t && t.options || {}, r = n.reverse, i = n.min === void 0 ? e : 0, s = n.max === void 0 ? e : 0; return { start: r ? s : i, end: r ? i : s } } function JE(t, e, n) { if (n === !1) return !1; const r = Vg(t, n), i = Vg(e, n); return { top: i.end, right: r.end, bottom: i.start, left: r.start } } function ZE(t) { let e, n, r, i; return ie(t) ? (e = t.top, n = t.right, r = t.bottom, i = t.left) : e = n = r = i = t, { top: e, right: n, bottom: r, left: i, disabled: t === !1 } } function $b(t, e) { const n = [], r = t._getSortedDatasetMetas(e); let i, s; for (i = 0, s = r.length; i < s; ++i)n.push(r[i].index); return n } function Bg(t, e, n, r = {}) { const i = t.keys, s = r.mode === "single"; let o, a, l, u; if (e !== null) { for (o = 0, a = i.length; o < a; ++o) { if (l = +i[o], l === n) { if (r.all) continue; break } u = t.values[l], Ne(u) && (s || e === 0 || tr(e) === tr(u)) && (e += u) } return e } } function eT(t, e) { const { iScale: n, vScale: r } = e, i = n.axis === "x" ? "x" : "y", s = r.axis === "x" ? "x" : "y", o = Object.keys(t), a = new Array(o.length); let l, u, c; for (l = 0, u = o.length; l < u; ++l)c = o[l], a[l] = { [i]: c, [s]: t[c] }; return a } function Ug(t, e) { const n = t && t.options.stacked; return n || n === void 0 && e.stack !== void 0 } function tT(t, e, n) { return `${t.id}.${e.id}.${n.stack || n.type}` } function nT(t) { const { min: e, max: n, minDefined: r, maxDefined: i } = t.getUserBounds(); return { min: r ? e : Number.NEGATIVE_INFINITY, max: i ? n : Number.POSITIVE_INFINITY } } function rT(t, e, n) { const r = t[e] || (t[e] = {}); return r[n] || (r[n] = {}) } function Hg(t, e, n, r) { for (const i of e.getMatchingVisibleMetas(r).reverse()) { const s = t[i.index]; if (n && s > 0 || !n && s < 0) return i.index } return null } function Wg(t, e) { const { chart: n, _cachedMeta: r } = t, i = n._stacks || (n._stacks = {}), { iScale: s, vScale: o, index: a } = r, l = s.axis, u = o.axis, c = tT(s, o, r), d = e.length; let h; for (let f = 0; f < d; ++f) { const g = e[f], { [l]: m, [u]: y } = g, p = g._stacks || (g._stacks = {}); h = p[u] = rT(i, c, m), h[a] = y, h._top = Hg(h, o, !0, r.type), h._bottom = Hg(h, o, !1, r.type); const v = h._visualValues || (h._visualValues = {}); v[a] = y } } function sc(t, e) { const n = t.scales; return Object.keys(n).filter(r => n[r].axis === e).shift() } function iT(t, e) { return Vr(t, { active: !1, dataset: void 0, datasetIndex: e, index: e, mode: "default", type: "dataset" }) } function sT(t, e, n) { return Vr(t, { active: !1, dataIndex: e, parsed: void 0, raw: void 0, element: n, index: e, mode: "default", type: "data" }) } function ns(t, e) { const n = t.controller.index, r = t.vScale && t.vScale.axis; if (r) { e = e || t._parsed; for (const i of e) { const s = i._stacks; if (!s || s[r] === void 0 || s[r][n] === void 0) return; delete s[r][n], s[r]._visualValues !== void 0 && s[r]._visualValues[n] !== void 0 && delete s[r]._visualValues[n] } } } const oc = t => t === "reset" || t === "none", qg = (t, e) => e ? t : Object.assign({}, t), oT = (t, e, n) => t && !e.hidden && e._stacked && { keys: $b(n, !0), values: null }; class Ms { constructor(e, n) { this.chart = e, this._ctx = e.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize() } initialize() { const e = this._cachedMeta; this.configure(), this.linkScales(), e._stacked = Ug(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options") } updateIndex(e) { this.index !== e && ns(this._cachedMeta), this.index = e } linkScales() { const e = this.chart, n = this._cachedMeta, r = this.getDataset(), i = (d, h, f, g) => d === "x" ? h : d === "r" ? g : f, s = n.xAxisID = le(r.xAxisID, sc(e, "x")), o = n.yAxisID = le(r.yAxisID, sc(e, "y")), a = n.rAxisID = le(r.rAxisID, sc(e, "r")), l = n.indexAxis, u = n.iAxisID = i(l, s, o, a), c = n.vAxisID = i(l, o, s, a); n.xScale = this.getScaleForId(s), n.yScale = this.getScaleForId(o), n.rScale = this.getScaleForId(a), n.iScale = this.getScaleForId(u), n.vScale = this.getScaleForId(c) } getDataset() { return this.chart.data.datasets[this.index] } getMeta() { return this.chart.getDatasetMeta(this.index) } getScaleForId(e) { return this.chart.scales[e] } _getOtherScale(e) { const n = this._cachedMeta; return e === n.iScale ? n.vScale : n.iScale } reset() { this._update("reset") } _destroy() { const e = this._cachedMeta; this._data && Tg(this._data, this), e._stacked && ns(e) } _dataCheck() { const e = this.getDataset(), n = e.data || (e.data = []), r = this._data; if (ie(n)) { const i = this._cachedMeta; this._data = eT(n, i) } else if (r !== n) { if (r) { Tg(r, this); const i = this._cachedMeta; ns(i), i._parsed = [] } n && Object.isExtensible(n) && lE(n, this), this._syncList = [], this._data = n } } addElements() { const e = this._cachedMeta; this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType) } buildOrUpdateElements(e) { const n = this._cachedMeta, r = this.getDataset(); let i = !1; this._dataCheck(); const s = n._stacked; n._stacked = Ug(n.vScale, n), n.stack !== r.stack && (i = !0, ns(n), n.stack = r.stack), this._resyncElements(e), (i || s !== n._stacked) && Wg(this, n._parsed) } configure() { const e = this.chart.config, n = e.datasetScopeKeys(this._type), r = e.getOptionScopes(this.getDataset(), n, !0); this.options = e.createResolver(r, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } parse(e, n) { const { _cachedMeta: r, _data: i } = this, { iScale: s, _stacked: o } = r, a = s.axis; let l = e === 0 && n === i.length ? !0 : r._sorted, u = e > 0 && r._parsed[e - 1], c, d, h; if (this._parsing === !1) r._parsed = i, r._sorted = !0, h = i; else { we(i[e]) ? h = this.parseArrayData(r, i, e, n) : ie(i[e]) ? h = this.parseObjectData(r, i, e, n) : h = this.parsePrimitiveData(r, i, e, n); const f = () => d[a] === null || u && d[a] < u[a]; for (c = 0; c < n; ++c)r._parsed[c + e] = d = h[c], l && (f() && (l = !1), u = d); r._sorted = l } o && Wg(this, h) } parsePrimitiveData(e, n, r, i) { const { iScale: s, vScale: o } = e, a = s.axis, l = o.axis, u = s.getLabels(), c = s === o, d = new Array(i); let h, f, g; for (h = 0, f = i; h < f; ++h)g = h + r, d[h] = { [a]: c || s.parse(u[g], g), [l]: o.parse(n[g], g) }; return d } parseArrayData(e, n, r, i) { const { xScale: s, yScale: o } = e, a = new Array(i); let l, u, c, d; for (l = 0, u = i; l < u; ++l)c = l + r, d = n[c], a[l] = { x: s.parse(d[0], c), y: o.parse(d[1], c) }; return a } parseObjectData(e, n, r, i) { const { xScale: s, yScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, u = new Array(i); let c, d, h, f; for (c = 0, d = i; c < d; ++c)h = c + r, f = n[h], u[c] = { x: s.parse(Mi(f, a), h), y: o.parse(Mi(f, l), h) }; return u } getParsed(e) { return this._cachedMeta._parsed[e] } getDataElement(e) { return this._cachedMeta.data[e] } applyStack(e, n, r) { const i = this.chart, s = this._cachedMeta, o = n[e.axis], a = { keys: $b(i, !0), values: n._stacks[e.axis]._visualValues }; return Bg(a, o, s.index, { mode: r }) } updateRangeFromParsed(e, n, r, i) { const s = r[n.axis]; let o = s === null ? NaN : s; const a = i && r._stacks[n.axis]; i && a && (i.values = a, o = Bg(i, s, this._cachedMeta.index)), e.min = Math.min(e.min, o), e.max = Math.max(e.max, o) } getMinMax(e, n) { const r = this._cachedMeta, i = r._parsed, s = r._sorted && e === r.iScale, o = i.length, a = this._getOtherScale(e), l = oT(n, r, this.chart), u = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: c, max: d } = nT(a); let h, f; function g() { f = i[h]; const m = f[a.axis]; return !Ne(f[e.axis]) || c > m || d < m } for (h = 0; h < o && !(!g() && (this.updateRangeFromParsed(u, e, f, l), s)); ++h); if (s) { for (h = o - 1; h >= 0; --h)if (!g()) { this.updateRangeFromParsed(u, e, f, l); break } } return u } getAllParsedValues(e) { const n = this._cachedMeta._parsed, r = []; let i, s, o; for (i = 0, s = n.length; i < s; ++i)o = n[i][e.axis], Ne(o) && r.push(o); return r } getMaxOverflow() { return !1 } getLabelAndValue(e) { const n = this._cachedMeta, r = n.iScale, i = n.vScale, s = this.getParsed(e); return { label: r ? "" + r.getLabelForValue(s[r.axis]) : "", value: i ? "" + i.getLabelForValue(s[i.axis]) : "" } } _update(e) { const n = this._cachedMeta; this.update(e || "default"), n._clip = ZE(le(this.options.clip, JE(n.xScale, n.yScale, this.getMaxOverflow()))) } update(e) { } draw() { const e = this._ctx, n = this.chart, r = this._cachedMeta, i = r.data || [], s = n.chartArea, o = [], a = this._drawStart || 0, l = this._drawCount || i.length - a, u = this.options.drawActiveElementsOnTop; let c; for (r.dataset && r.dataset.draw(e, s, a, l), c = a; c < a + l; ++c) { const d = i[c]; d.hidden || (d.active && u ? o.push(d) : d.draw(e, s)) } for (c = 0; c < o.length; ++c)o[c].draw(e, s) } getStyle(e, n) { const r = n ? "active" : "default"; return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(r) : this.resolveDataElementOptions(e || 0, r) } getContext(e, n, r) { const i = this.getDataset(); let s; if (e >= 0 && e < this._cachedMeta.data.length) { const o = this._cachedMeta.data[e]; s = o.$context || (o.$context = sT(this.getContext(), e, o)), s.parsed = this.getParsed(e), s.raw = i.data[e], s.index = s.dataIndex = e } else s = this.$context || (this.$context = iT(this.chart.getContext(), this.index)), s.dataset = i, s.index = s.datasetIndex = this.index; return s.active = !!n, s.mode = r, s } resolveDatasetElementOptions(e) { return this._resolveElementOptions(this.datasetElementType.id, e) } resolveDataElementOptions(e, n) { return this._resolveElementOptions(this.dataElementType.id, n, e) } _resolveElementOptions(e, n = "default", r) { const i = n === "active", s = this._cachedDataOpts, o = e + "-" + n, a = s[o], l = this.enableOptionSharing && to(r); if (a) return qg(a, l); const u = this.chart.config, c = u.datasetElementScopeKeys(this._type, e), d = i ? [`${e}Hover`, "hover", e, ""] : [e, ""], h = u.getOptionScopes(this.getDataset(), c), f = Object.keys(Ce.elements[e]), g = () => this.getContext(r, i, n), m = u.resolveNamedOptions(h, f, g, d); return m.$shared && (m.$shared = l, s[o] = Object.freeze(qg(m, l))), m } _resolveAnimations(e, n, r) { const i = this.chart, s = this._cachedDataOpts, o = `animation-${n}`, a = s[o]; if (a) return a; let l; if (i.options.animation !== !1) { const c = this.chart.config, d = c.datasetAnimationScopeKeys(this._type, n), h = c.getOptionScopes(this.getDataset(), d); l = c.createResolver(h, this.getContext(e, r, n)) } const u = new Fb(i, l && l.animations); return l && l._cacheable && (s[o] = Object.freeze(u)), u } getSharedOptions(e) { if (e.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, e)) } includeOptions(e, n) { return !n || oc(e) || this.chart._animationsDisabled } _getSharedOptions(e, n) { const r = this.resolveDataElementOptions(e, n), i = this._sharedOptions, s = this.getSharedOptions(r), o = this.includeOptions(n, s) || s !== i; return this.updateSharedOptions(s, n, r), { sharedOptions: s, includeOptions: o } } updateElement(e, n, r, i) { oc(i) ? Object.assign(e, r) : this._resolveAnimations(n, i).update(e, r) } updateSharedOptions(e, n, r) { e && !oc(n) && this._resolveAnimations(void 0, n).update(e, r) } _setStyle(e, n, r, i) { e.active = i; const s = this.getStyle(n, i); this._resolveAnimations(n, r, i).update(e, { options: !i && this.getSharedOptions(s) || s }) } removeHoverStyle(e, n, r) { this._setStyle(e, r, "active", !1) } setHoverStyle(e, n, r) { this._setStyle(e, r, "active", !0) } _removeDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !1) } _setDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !0) } _resyncElements(e) { const n = this._data, r = this._cachedMeta.data; for (const [a, l, u] of this._syncList) this[a](l, u); this._syncList = []; const i = r.length, s = n.length, o = Math.min(s, i); o && this.parse(0, o), s > i ? this._insertElements(i, s - i, e) : s < i && this._removeElements(s, i - s) } _insertElements(e, n, r = !0) { const i = this._cachedMeta, s = i.data, o = e + n; let a; const l = u => { for (u.length += n, a = u.length - 1; a >= o; a--)u[a] = u[a - n] }; for (l(s), a = e; a < o; ++a)s[a] = new this.dataElementType; this._parsing && l(i._parsed), this.parse(e, n), r && this.updateElements(s, e, n, "reset") } updateElements(e, n, r, i) { } _removeElements(e, n) { const r = this._cachedMeta; if (this._parsing) { const i = r._parsed.splice(e, n); r._stacked && ns(r, i) } r.data.splice(e, n) } _sync(e) { if (this._parsing) this._syncList.push(e); else { const [n, r, i] = e; this[n](r, i) } this.chart._dataChanges.push([this.index, ...e]) } _onDataPush() { const e = arguments.length; this._sync(["_insertElements", this.getDataset().data.length - e, e]) } _onDataPop() { this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift() { this._sync(["_removeElements", 0, 1]) } _onDataSplice(e, n) { n && this._sync(["_removeElements", e, n]); const r = arguments.length - 2; r && this._sync(["_insertElements", e, r]) } _onDataUnshift() { this._sync(["_insertElements", 0, arguments.length]) } } J(Ms, "defaults", {}), J(Ms, "datasetElementType", null), J(Ms, "dataElementType", null); function aT(t, e) { if (!t._cache.$bar) { const n = t.getMatchingVisibleMetas(e); let r = []; for (let i = 0, s = n.length; i < s; i++)r = r.concat(n[i].controller.getAllParsedValues(t)); t._cache.$bar = kb(r.sort((i, s) => i - s)) } return t._cache.$bar } function lT(t) { const e = t.iScale, n = aT(e, t.type); let r = e._length, i, s, o, a; const l = () => { o === 32767 || o === -32768 || (to(a) && (r = Math.min(r, Math.abs(o - a) || r)), a = o) }; for (i = 0, s = n.length; i < s; ++i)o = e.getPixelForValue(n[i]), l(); for (a = void 0, i = 0, s = e.ticks.length; i < s; ++i)o = e.getPixelForTick(i), l(); return r } function uT(t, e, n, r) { const i = n.barThickness; let s, o; return fe(i) ? (s = e.min * n.categoryPercentage, o = n.barPercentage) : (s = i * r, o = 1), { chunk: s / r, ratio: o, start: e.pixels[t] - s / 2 } } function cT(t, e, n, r) { const i = e.pixels, s = i[t]; let o = t > 0 ? i[t - 1] : null, a = t < i.length - 1 ? i[t + 1] : null; const l = n.categoryPercentage; o === null && (o = s - (a === null ? e.end - e.start : a - s)), a === null && (a = s + s - o); const u = s - (s - Math.min(o, a)) / 2 * l; return { chunk: Math.abs(a - o) / 2 * l / r, ratio: n.barPercentage, start: u } } function dT(t, e, n, r) { const i = n.parse(t[0], r), s = n.parse(t[1], r), o = Math.min(i, s), a = Math.max(i, s); let l = o, u = a; Math.abs(o) > Math.abs(a) && (l = a, u = o), e[n.axis] = u, e._custom = { barStart: l, barEnd: u, start: i, end: s, min: o, max: a } } function zb(t, e, n, r) { return we(t) ? dT(t, e, n, r) : e[n.axis] = n.parse(t, r), e } function Kg(t, e, n, r) { const i = t.iScale, s = t.vScale, o = i.getLabels(), a = i === s, l = []; let u, c, d, h; for (u = n, c = n + r; u < c; ++u)h = e[u], d = {}, d[i.axis] = a || i.parse(o[u], u), l.push(zb(h, d, s, u)); return l } function ac(t) { return t && t.barStart !== void 0 && t.barEnd !== void 0 } function hT(t, e, n) { return t !== 0 ? tr(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= n ? 1 : -1) } function fT(t) { let e, n, r, i, s; return t.horizontal ? (e = t.base > t.x, n = "left", r = "right") : (e = t.base < t.y, n = "bottom", r = "top"), e ? (i = "end", s = "start") : (i = "start", s = "end"), { start: n, end: r, reverse: e, top: i, bottom: s } } function pT(t, e, n, r) { let i = e.borderSkipped; const s = {}; if (!i) { t.borderSkipped = s; return } if (i === !0) { t.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 }; return } const { start: o, end: a, reverse: l, top: u, bottom: c } = fT(t); i === "middle" && n && (t.enableBorderRadius = !0, (n._top || 0) === r ? i = u : (n._bottom || 0) === r ? i = c : (s[Gg(c, o, a, l)] = !0, i = u)), s[Gg(i, o, a, l)] = !0, t.borderSkipped = s } function Gg(t, e, n, r) { return r ? (t = gT(t, e, n), t = Yg(t, n, e)) : t = Yg(t, e, n), t } function gT(t, e, n) { return t === e ? n : t === n ? e : t } function Yg(t, e, n) { return t === "start" ? e : t === "end" ? n : t } function mT(t, { inflateAmount: e }, n) { t.inflateAmount = e === "auto" ? n === 1 ? .33 : 0 : e } class Oa extends Ms { parsePrimitiveData(e, n, r, i) { return Kg(e, n, r, i) } parseArrayData(e, n, r, i) { return Kg(e, n, r, i) } parseObjectData(e, n, r, i) { const { iScale: s, vScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, u = s.axis === "x" ? a : l, c = o.axis === "x" ? a : l, d = []; let h, f, g, m; for (h = r, f = r + i; h < f; ++h)m = n[h], g = {}, g[s.axis] = s.parse(Mi(m, u), h), d.push(zb(Mi(m, c), g, o, h)); return d } updateRangeFromParsed(e, n, r, i) { super.updateRangeFromParsed(e, n, r, i); const s = r._custom; s && n === this._cachedMeta.vScale && (e.min = Math.min(e.min, s.min), e.max = Math.max(e.max, s.max)) } getMaxOverflow() { return 0 } getLabelAndValue(e) { const n = this._cachedMeta, { iScale: r, vScale: i } = n, s = this.getParsed(e), o = s._custom, a = ac(o) ? "[" + o.start + ", " + o.end + "]" : "" + i.getLabelForValue(s[i.axis]); return { label: "" + r.getLabelForValue(s[r.axis]), value: a } } initialize() { this.enableOptionSharing = !0, super.initialize(); const e = this._cachedMeta; e.stack = this.getDataset().stack } update(e) { const n = this._cachedMeta; this.updateElements(n.data, 0, n.data.length, e) } updateElements(e, n, r, i) { const s = i === "reset", { index: o, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), u = a.isHorizontal(), c = this._getRuler(), { sharedOptions: d, includeOptions: h } = this._getSharedOptions(n, i); for (let f = n; f < n + r; f++) { const g = this.getParsed(f), m = s || fe(g[a.axis]) ? { base: l, head: l } : this._calculateBarValuePixels(f), y = this._calculateBarIndexPixels(f, c), p = (g._stacks || {})[a.axis], v = { horizontal: u, base: m.base, enableBorderRadius: !p || ac(g._custom) || o === p._top || o === p._bottom, x: u ? m.head : y.center, y: u ? y.center : m.head, height: u ? y.size : Math.abs(m.size), width: u ? Math.abs(m.size) : y.size }; h && (v.options = d || this.resolveDataElementOptions(f, e[f].active ? "active" : i)); const b = v.options || e[f].options; pT(v, b, p, o), mT(v, b, c.ratio), this.updateElement(e[f], f, v, i) } } _getStacks(e, n) { const { iScale: r } = this._cachedMeta, i = r.getMatchingVisibleMetas(this._type).filter(l => l.controller.options.grouped), s = r.options.stacked, o = [], a = l => { const u = l.controller.getParsed(n), c = u && u[l.vScale.axis]; if (fe(c) || isNaN(c)) return !0 }; for (const l of i) if (!(n !== void 0 && a(l)) && ((s === !1 || o.indexOf(l.stack) === -1 || s === void 0 && l.stack === void 0) && o.push(l.stack), l.index === e)) break; return o.length || o.push(void 0), o } _getStackCount(e) { return this._getStacks(void 0, e).length } _getStackIndex(e, n, r) { const i = this._getStacks(e, r), s = n !== void 0 ? i.indexOf(n) : -1; return s === -1 ? i.length - 1 : s } _getRuler() { const e = this.options, n = this._cachedMeta, r = n.iScale, i = []; let s, o; for (s = 0, o = n.data.length; s < o; ++s)i.push(r.getPixelForValue(this.getParsed(s)[r.axis], s)); const a = e.barThickness; return { min: a || lT(n), pixels: i, start: r._startPixel, end: r._endPixel, stackCount: this._getStackCount(), scale: r, grouped: e.grouped, ratio: a ? 1 : e.categoryPercentage * e.barPercentage } } _calculateBarValuePixels(e) { const { _cachedMeta: { vScale: n, _stacked: r, index: i }, options: { base: s, minBarLength: o } } = this, a = s || 0, l = this.getParsed(e), u = l._custom, c = ac(u); let d = l[n.axis], h = 0, f = r ? this.applyStack(n, l, r) : d, g, m; f !== d && (h = f - d, f = d), c && (d = u.barStart, f = u.barEnd - u.barStart, d !== 0 && tr(d) !== tr(u.barEnd) && (h = 0), h += d); const y = !fe(s) && !c ? s : h; let p = n.getPixelForValue(y); if (this.chart.getDataVisibility(e) ? g = n.getPixelForValue(h + f) : g = p, m = g - p, Math.abs(m) < o) { m = hT(m, n, a) * o, d === a && (p -= m / 2); const v = n.getPixelForDecimal(0), b = n.getPixelForDecimal(1), S = Math.min(v, b), P = Math.max(v, b); p = Math.max(Math.min(p, P), S), g = p + m, r && !c && (l._stacks[n.axis]._visualValues[i] = n.getValueForPixel(g) - n.getValueForPixel(p)) } if (p === n.getPixelForValue(a)) { const v = tr(m) * n.getLineWidthForValue(a) / 2; p += v, m -= v } return { size: m, base: p, head: g, center: g + m / 2 } } _calculateBarIndexPixels(e, n) { const r = n.scale, i = this.options, s = i.skipNull, o = le(i.maxBarThickness, 1 / 0); let a, l; if (n.grouped) { const u = s ? this._getStackCount(e) : n.stackCount, c = i.barThickness === "flex" ? cT(e, n, i, u) : uT(e, n, i, u), d = this._getStackIndex(this.index, this._cachedMeta.stack, s ? e : void 0); a = c.start + c.chunk * d + c.chunk / 2, l = Math.min(o, c.chunk * c.ratio) } else a = r.getPixelForValue(this.getParsed(e)[r.axis], e), l = Math.min(o, n.min * n.ratio); return { base: a - l / 2, head: a + l / 2, center: a, size: l } } draw() { const e = this._cachedMeta, n = e.vScale, r = e.data, i = r.length; let s = 0; for (; s < i; ++s)this.getParsed(s)[n.axis] !== null && !r[s].hidden && r[s].draw(this._ctx) } } J(Oa, "id", "bar"), J(Oa, "defaults", { datasetElementType: !1, dataElementType: "bar", categoryPercentage: .8, barPercentage: .9, grouped: !0, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }), J(Oa, "overrides", { scales: { _index_: { type: "category", offset: !0, grid: { offset: !0 } }, _value_: { type: "linear", beginAtZero: !0 } } }); function mr() { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } class cf { constructor(e) { J(this, "options"); this.options = e || {} } static override(e) { Object.assign(cf.prototype, e) } init() { } formats() { return mr() } parse() { return mr() } format() { return mr() } add() { return mr() } diff() { return mr() } startOf() { return mr() } endOf() { return mr() } } var vT = { _date: cf }; function yT(t, e, n, r) { const { controller: i, data: s, _sorted: o } = t, a = i._cachedMeta.iScale; if (a && e === a.axis && e !== "r" && o && s.length) { const l = a._reversePixels ? oE : Od; if (r) { if (i._sharedOptions) { const u = s[0], c = typeof u.getRange == "function" && u.getRange(e); if (c) { const d = l(s, e, n - c), h = l(s, e, n + c); return { lo: d.lo, hi: h.hi } } } } else return l(s, e, n) } return { lo: 0, hi: s.length - 1 } } function _o(t, e, n, r, i) { const s = t.getSortedVisibleDatasetMetas(), o = n[e]; for (let a = 0, l = s.length; a < l; ++a) { const { index: u, data: c } = s[a], { lo: d, hi: h } = yT(s[a], e, o, i); for (let f = d; f <= h; ++f) { const g = c[f]; g.skip || r(g, u, f) } } } function bT(t) { const e = t.indexOf("x") !== -1, n = t.indexOf("y") !== -1; return function (r, i) { const s = e ? Math.abs(r.x - i.x) : 0, o = n ? Math.abs(r.y - i.y) : 0; return Math.sqrt(Math.pow(s, 2) + Math.pow(o, 2)) } } function lc(t, e, n, r, i) { const s = []; return !i && !t.isPointInArea(e) || _o(t, n, e, function (a, l, u) { !i && !hi(a, t.chartArea, 0) || a.inRange(e.x, e.y, r) && s.push({ element: a, datasetIndex: l, index: u }) }, !0), s } function _T(t, e, n, r) { let i = []; function s(o, a, l) { const { startAngle: u, endAngle: c } = o.getProps(["startAngle", "endAngle"], r), { angle: d } = nE(o, { x: e.x, y: e.y }); iE(d, u, c) && i.push({ element: o, datasetIndex: a, index: l }) } return _o(t, n, e, s), i } function wT(t, e, n, r, i, s) { let o = []; const a = bT(n); let l = Number.POSITIVE_INFINITY; function u(c, d, h) { const f = c.inRange(e.x, e.y, i); if (r && !f) return; const g = c.getCenterPoint(i); if (!(!!s || t.isPointInArea(g)) && !f) return; const y = a(e, g); y < l ? (o = [{ element: c, datasetIndex: d, index: h }], l = y) : y === l && o.push({ element: c, datasetIndex: d, index: h }) } return _o(t, n, e, u), o } function uc(t, e, n, r, i, s) { return !s && !t.isPointInArea(e) ? [] : n === "r" && !r ? _T(t, e, n, i) : wT(t, e, n, r, i, s) } function Qg(t, e, n, r, i) { const s = [], o = n === "x" ? "inXRange" : "inYRange"; let a = !1; return _o(t, n, e, (l, u, c) => { l[o](e[n], i) && (s.push({ element: l, datasetIndex: u, index: c }), a = a || l.inRange(e.x, e.y, i)) }), r && !a ? [] : s } var ST = { evaluateInteractionItems: _o, modes: { index(t, e, n, r) { const i = wr(e, t), s = n.axis || "x", o = n.includeInvisible || !1, a = n.intersect ? lc(t, i, s, r, o) : uc(t, i, s, !1, r, o), l = []; return a.length ? (t.getSortedVisibleDatasetMetas().forEach(u => { const c = a[0].index, d = u.data[c]; d && !d.skip && l.push({ element: d, datasetIndex: u.index, index: c }) }), l) : [] }, dataset(t, e, n, r) { const i = wr(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; let a = n.intersect ? lc(t, i, s, r, o) : uc(t, i, s, !1, r, o); if (a.length > 0) { const l = a[0].datasetIndex, u = t.getDatasetMeta(l).data; a = []; for (let c = 0; c < u.length; ++c)a.push({ element: u[c], datasetIndex: l, index: c }) } return a }, point(t, e, n, r) { const i = wr(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; return lc(t, i, s, r, o) }, nearest(t, e, n, r) { const i = wr(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; return uc(t, i, s, n.intersect, r, o) }, x(t, e, n, r) { const i = wr(e, t); return Qg(t, i, "x", n.intersect, r) }, y(t, e, n, r) { const i = wr(e, t); return Qg(t, i, "y", n.intersect, r) } } }; const Vb = ["left", "top", "right", "bottom"]; function rs(t, e) { return t.filter(n => n.pos === e) } function Xg(t, e) { return t.filter(n => Vb.indexOf(n.pos) === -1 && n.box.axis === e) } function is(t, e) { return t.sort((n, r) => { const i = e ? r : n, s = e ? n : r; return i.weight === s.weight ? i.index - s.index : i.weight - s.weight }) } function xT(t) { const e = []; let n, r, i, s, o, a; for (n = 0, r = (t || []).length; n < r; ++n)i = t[n], { position: s, options: { stack: o, stackWeight: a = 1 } } = i, e.push({ index: n, box: i, pos: s, horizontal: i.isHorizontal(), weight: i.weight, stack: o && s + o, stackWeight: a }); return e } function kT(t) { const e = {}; for (const n of t) { const { stack: r, pos: i, stackWeight: s } = n; if (!r || !Vb.includes(i)) continue; const o = e[r] || (e[r] = { count: 0, placed: 0, weight: 0, size: 0 }); o.count++, o.weight += s } return e } function CT(t, e) { const n = kT(t), { vBoxMaxWidth: r, hBoxMaxHeight: i } = e; let s, o, a; for (s = 0, o = t.length; s < o; ++s) { a = t[s]; const { fullSize: l } = a.box, u = n[a.stack], c = u && a.stackWeight / u.weight; a.horizontal ? (a.width = c ? c * r : l && e.availableWidth, a.height = i) : (a.width = r, a.height = c ? c * i : l && e.availableHeight) } return n } function OT(t) { const e = xT(t), n = is(e.filter(u => u.box.fullSize), !0), r = is(rs(e, "left"), !0), i = is(rs(e, "right")), s = is(rs(e, "top"), !0), o = is(rs(e, "bottom")), a = Xg(e, "x"), l = Xg(e, "y"); return { fullSize: n, leftAndTop: r.concat(s), rightAndBottom: i.concat(l).concat(o).concat(a), chartArea: rs(e, "chartArea"), vertical: r.concat(i).concat(l), horizontal: s.concat(o).concat(a) } } function Jg(t, e, n, r) { return Math.max(t[n], e[n]) + Math.max(t[r], e[r]) } function Bb(t, e) { t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right) } function PT(t, e, n, r) { const { pos: i, box: s } = n, o = t.maxPadding; if (!ie(i)) { n.size && (t[i] -= n.size); const d = r[n.stack] || { size: 0, count: 1 }; d.size = Math.max(d.size, n.horizontal ? s.height : s.width), n.size = d.size / d.count, t[i] += n.size } s.getPadding && Bb(o, s.getPadding()); const a = Math.max(0, e.outerWidth - Jg(o, t, "left", "right")), l = Math.max(0, e.outerHeight - Jg(o, t, "top", "bottom")), u = a !== t.w, c = l !== t.h; return t.w = a, t.h = l, n.horizontal ? { same: u, other: c } : { same: c, other: u } } function ET(t) { const e = t.maxPadding; function n(r) { const i = Math.max(e[r] - t[r], 0); return t[r] += i, i } t.y += n("top"), t.x += n("left"), n("right"), n("bottom") } function TT(t, e) { const n = e.maxPadding; function r(i) { const s = { left: 0, top: 0, right: 0, bottom: 0 }; return i.forEach(o => { s[o] = Math.max(e[o], n[o]) }), s } return r(t ? ["left", "right"] : ["top", "bottom"]) } function gs(t, e, n, r) { const i = []; let s, o, a, l, u, c; for (s = 0, o = t.length, u = 0; s < o; ++s) { a = t[s], l = a.box, l.update(a.width || e.w, a.height || e.h, TT(a.horizontal, e)); const { same: d, other: h } = PT(e, n, a, r); u |= d && i.length, c = c || h, l.fullSize || i.push(a) } return u && gs(i, e, n, r) || c } function Zo(t, e, n, r, i) { t.top = n, t.left = e, t.right = e + r, t.bottom = n + i, t.width = r, t.height = i } function Zg(t, e, n, r) { const i = n.padding; let { x: s, y: o } = e; for (const a of t) { const l = a.box, u = r[a.stack] || { count: 1, placed: 0, weight: 1 }, c = a.stackWeight / u.weight || 1; if (a.horizontal) { const d = e.w * c, h = u.size || l.height; to(u.start) && (o = u.start), l.fullSize ? Zo(l, i.left, o, n.outerWidth - i.right - i.left, h) : Zo(l, e.left + u.placed, o, d, h), u.start = o, u.placed += d, o = l.bottom } else { const d = e.h * c, h = u.size || l.width; to(u.start) && (s = u.start), l.fullSize ? Zo(l, s, i.top, h, n.outerHeight - i.bottom - i.top) : Zo(l, s, e.top + u.placed, h, d), u.start = s, u.placed += d, s = l.right } } e.x = s, e.y = o } var Lt = { addBox(t, e) { t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () { return [{ z: 0, draw(n) { e.draw(n) } }] }, t.boxes.push(e) }, removeBox(t, e) { const n = t.boxes ? t.boxes.indexOf(e) : -1; n !== -1 && t.boxes.splice(n, 1) }, configure(t, e, n) { e.fullSize = n.fullSize, e.position = n.position, e.weight = n.weight }, update(t, e, n, r) { if (!t) return; const i = et(t.options.layout.padding), s = Math.max(e - i.width, 0), o = Math.max(n - i.height, 0), a = OT(t.boxes), l = a.vertical, u = a.horizontal; ce(t.boxes, m => { typeof m.beforeLayout == "function" && m.beforeLayout() }); const c = l.reduce((m, y) => y.box.options && y.box.options.display === !1 ? m : m + 1, 0) || 1, d = Object.freeze({ outerWidth: e, outerHeight: n, padding: i, availableWidth: s, availableHeight: o, vBoxMaxWidth: s / 2 / c, hBoxMaxHeight: o / 2 }), h = Object.assign({}, i); Bb(h, et(r)); const f = Object.assign({ maxPadding: h, w: s, h: o, x: i.left, y: i.top }, i), g = CT(l.concat(u), d); gs(a.fullSize, f, d, g), gs(l, f, d, g), gs(u, f, d, g) && gs(l, f, d, g), ET(f), Zg(a.leftAndTop, f, d, g), f.x += f.w, f.y += f.h, Zg(a.rightAndBottom, f, d, g), t.chartArea = { left: f.left, top: f.top, right: f.left + f.w, bottom: f.top + f.h, height: f.h, width: f.w }, ce(a.chartArea, m => { const y = m.box; Object.assign(y, t.chartArea), y.update(f.w, f.h, { left: 0, top: 0, right: 0, bottom: 0 }) }) } }; class Ub { acquireContext(e, n) { } releaseContext(e) { return !1 } addEventListener(e, n, r) { } removeEventListener(e, n, r) { } getDevicePixelRatio() { return 1 } getMaximumSize(e, n, r, i) { return n = Math.max(0, n || e.width), r = r || e.height, { width: n, height: Math.max(0, i ? Math.floor(n / i) : r) } } isAttached(e) { return !0 } updateConfig(e) { } } class IT extends Ub { acquireContext(e) { return e && e.getContext && e.getContext("2d") || null } updateConfig(e) { e.options.animation = !1 } } const Pa = "$chartjs", RT = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, em = t => t === null || t === ""; function MT(t, e) { const n = t.style, r = t.getAttribute("height"), i = t.getAttribute("width"); if (t[Pa] = { initial: { height: r, width: i, style: { display: n.display, height: n.height, width: n.width } } }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", em(i)) { const s = $g(t, "width"); s !== void 0 && (t.width = s) } if (em(r)) if (t.style.height === "") t.height = t.width / (e || 2); else { const s = $g(t, "height"); s !== void 0 && (t.height = s) } return t } const Hb = HE ? { passive: !0 } : !1; function LT(t, e, n) { t && t.addEventListener(e, n, Hb) } function DT(t, e, n) { t && t.canvas && t.canvas.removeEventListener(e, n, Hb) } function AT(t, e) { const n = RT[t.type] || t.type, { x: r, y: i } = wr(t, e); return { type: n, chart: e, native: t, x: r !== void 0 ? r : null, y: i !== void 0 ? i : null } } function fl(t, e) { for (const n of t) if (n === e || n.contains(e)) return !0 } function jT(t, e, n) { const r = t.canvas, i = new MutationObserver(s => { let o = !1; for (const a of s) o = o || fl(a.addedNodes, r), o = o && !fl(a.removedNodes, r); o && n() }); return i.observe(document, { childList: !0, subtree: !0 }), i } function NT(t, e, n) { const r = t.canvas, i = new MutationObserver(s => { let o = !1; for (const a of s) o = o || fl(a.removedNodes, r), o = o && !fl(a.addedNodes, r); o && n() }); return i.observe(document, { childList: !0, subtree: !0 }), i } const ro = new Map; let tm = 0; function Wb() { const t = window.devicePixelRatio; t !== tm && (tm = t, ro.forEach((e, n) => { n.currentDevicePixelRatio !== t && e() })) } function FT(t, e) { ro.size || window.addEventListener("resize", Wb), ro.set(t, e) } function $T(t) { ro.delete(t), ro.size || window.removeEventListener("resize", Wb) } function zT(t, e, n) { const r = t.canvas, i = r && uf(r); if (!i) return; const s = Ob((a, l) => { const u = i.clientWidth; n(a, l), u < i.clientWidth && n() }, window), o = new ResizeObserver(a => { const l = a[0], u = l.contentRect.width, c = l.contentRect.height; u === 0 && c === 0 || s(u, c) }); return o.observe(i), FT(t, s), o } function cc(t, e, n) { n && n.disconnect(), e === "resize" && $T(t) } function VT(t, e, n) { const r = t.canvas, i = Ob(s => { t.ctx !== null && n(AT(s, t)) }, t); return LT(r, e, i), i } class BT extends Ub { acquireContext(e, n) { const r = e && e.getContext && e.getContext("2d"); return r && r.canvas === e ? (MT(e, n), r) : null } releaseContext(e) { const n = e.canvas; if (!n[Pa]) return !1; const r = n[Pa].initial;["height", "width"].forEach(s => { const o = r[s]; fe(o) ? n.removeAttribute(s) : n.setAttribute(s, o) }); const i = r.style || {}; return Object.keys(i).forEach(s => { n.style[s] = i[s] }), n.width = n.width, delete n[Pa], !0 } addEventListener(e, n, r) { this.removeEventListener(e, n); const i = e.$proxies || (e.$proxies = {}), o = { attach: jT, detach: NT, resize: zT }[n] || VT; i[n] = o(e, n, r) } removeEventListener(e, n) { const r = e.$proxies || (e.$proxies = {}), i = r[n]; if (!i) return; ({ attach: cc, detach: cc, resize: cc }[n] || DT)(e, n, i), r[n] = void 0 } getDevicePixelRatio() { return window.devicePixelRatio } getMaximumSize(e, n, r, i) { return UE(e, n, r, i) } isAttached(e) { const n = e && uf(e); return !!(n && n.isConnected) } } function UT(t) { return !lf() || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas ? IT : BT } var ha; let Ui = (ha = class { constructor() { J(this, "x"); J(this, "y"); J(this, "active", !1); J(this, "options"); J(this, "$animations") } tooltipPosition(e) { const { x: n, y: r } = this.getProps(["x", "y"], e); return { x: n, y: r } } hasValue() { return cl(this.x) && cl(this.y) } getProps(e, n) { const r = this.$animations; if (!n || !r) return this; const i = {}; return e.forEach(s => { i[s] = r[s] && r[s].active() ? r[s]._to : this[s] }), i } }, J(ha, "defaults", {}), J(ha, "defaultRoutes"), ha); function HT(t, e) { const n = t.options.ticks, r = WT(t), i = Math.min(n.maxTicksLimit || r, r), s = n.major.enabled ? KT(e) : [], o = s.length, a = s[0], l = s[o - 1], u = []; if (o > i) return GT(e, u, s, o / i), u; const c = qT(s, e, i); if (o > 0) { let d, h; const f = o > 1 ? Math.round((l - a) / (o - 1)) : null; for (ea(e, u, c, fe(f) ? 0 : a - f, a), d = 0, h = o - 1; d < h; d++)ea(e, u, c, s[d], s[d + 1]); return ea(e, u, c, l, fe(f) ? e.length : l + f), u } return ea(e, u, c), u } function WT(t) { const e = t.options.offset, n = t._tickSize(), r = t._length / n + (e ? 0 : 1), i = t._maxLength / n; return Math.floor(Math.min(r, i)) } function qT(t, e, n) { const r = YT(t), i = e.length / n; if (!r) return Math.max(i, 1); const s = eE(r); for (let o = 0, a = s.length - 1; o < a; o++) { const l = s[o]; if (l > i) return l } return Math.max(i, 1) } function KT(t) { const e = []; let n, r; for (n = 0, r = t.length; n < r; n++)t[n].major && e.push(n); return e } function GT(t, e, n, r) { let i = 0, s = n[0], o; for (r = Math.ceil(r), o = 0; o < t.length; o++)o === s && (e.push(t[o]), i++, s = n[i * r]) } function ea(t, e, n, r, i) { const s = le(r, 0), o = Math.min(le(i, t.length), t.length); let a = 0, l, u, c; for (n = Math.ceil(n), i && (l = i - r, n = l / Math.floor(l / n)), c = s; c < 0;)a++, c = Math.round(s + a * n); for (u = Math.max(s, 0); u < o; u++)u === c && (e.push(t[u]), a++, c = Math.round(s + a * n)) } function YT(t) { const e = t.length; let n, r; if (e < 2) return !1; for (r = t[0], n = 1; n < e; ++n)if (t[n] - t[n - 1] !== r) return !1; return r } const QT = t => t === "left" ? "right" : t === "right" ? "left" : t, nm = (t, e, n) => e === "top" || e === "left" ? t[e] + n : t[e] - n, rm = (t, e) => Math.min(e || t, t); function im(t, e) { const n = [], r = t.length / e, i = t.length; let s = 0; for (; s < i; s += r)n.push(t[Math.floor(s)]); return n } function XT(t, e, n) { const r = t.ticks.length, i = Math.min(e, r - 1), s = t._startPixel, o = t._endPixel, a = 1e-6; let l = t.getPixelForTick(i), u; if (!(n && (r === 1 ? u = Math.max(l - s, o - l) : e === 0 ? u = (t.getPixelForTick(1) - l) / 2 : u = (l - t.getPixelForTick(i - 1)) / 2, l += i < e ? u : -u, l < s - a || l > o + a))) return l } function JT(t, e) { ce(t, n => { const r = n.gc, i = r.length / 2; let s; if (i > e) { for (s = 0; s < i; ++s)delete n.data[r[s]]; r.splice(0, i) } }) } function ss(t) { return t.drawTicks ? t.tickLength : 0 } function sm(t, e) { if (!t.display) return 0; const n = De(t.font, e), r = et(t.padding); return (we(t.text) ? t.text.length : 1) * n.lineHeight + r.height } function ZT(t, e) { return Vr(t, { scale: e, type: "scale" }) } function eI(t, e, n) { return Vr(t, { tick: n, index: e, type: "tick" }) } function tI(t, e, n) { let r = ef(t); return (n && e !== "right" || !n && e === "right") && (r = QT(r)), r } function nI(t, e, n, r) { const { top: i, left: s, bottom: o, right: a, chart: l } = t, { chartArea: u, scales: c } = l; let d = 0, h, f, g; const m = o - i, y = a - s; if (t.isHorizontal()) { if (f = Qe(r, s, a), ie(n)) { const p = Object.keys(n)[0], v = n[p]; g = c[p].getPixelForValue(v) + m - e } else n === "center" ? g = (u.bottom + u.top) / 2 + m - e : g = nm(t, n, e); h = a - s } else { if (ie(n)) { const p = Object.keys(n)[0], v = n[p]; f = c[p].getPixelForValue(v) - y + e } else n === "center" ? f = (u.left + u.right) / 2 - y + e : f = nm(t, n, e); g = Qe(r, o, i), d = n === "left" ? -bt : bt } return { titleX: f, titleY: g, maxWidth: h, rotation: d } } class Br extends Ui { constructor(e) { super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init(e) { this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax) } parse(e, n) { return e } getUserBounds() { let { _userMin: e, _userMax: n, _suggestedMin: r, _suggestedMax: i } = this; return e = mt(e, Number.POSITIVE_INFINITY), n = mt(n, Number.NEGATIVE_INFINITY), r = mt(r, Number.POSITIVE_INFINITY), i = mt(i, Number.NEGATIVE_INFINITY), { min: mt(e, r), max: mt(n, i), minDefined: Ne(e), maxDefined: Ne(n) } } getMinMax(e) { let { min: n, max: r, minDefined: i, maxDefined: s } = this.getUserBounds(), o; if (i && s) return { min: n, max: r }; const a = this.getMatchingVisibleMetas(); for (let l = 0, u = a.length; l < u; ++l)o = a[l].controller.getMinMax(this, e), i || (n = Math.min(n, o.min)), s || (r = Math.max(r, o.max)); return n = s && n > r ? r : n, r = i && n > r ? n : r, { min: mt(n, mt(r, n)), max: mt(r, mt(n, r)) } } getPadding() { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } getTicks() { return this.ticks } getLabels() { const e = this.chart.data; return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [] } getLabelItems(e = this.chart.chartArea) { return this._labelItems || (this._labelItems = this._computeLabelItems(e)) } beforeLayout() { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate() { ge(this.options.beforeUpdate, [this]) } update(e, n, r) { const { beginAtZero: i, grace: s, ticks: o } = this.options, a = o.sampleSize; this.beforeUpdate(), this.maxWidth = e, this.maxHeight = n, this._margins = r = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, r), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + r.left + r.right : this.height + r.top + r.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = EE(this, s, i), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const l = a < this.ticks.length; this._convertTicksToLabels(l ? im(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = HT(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } configure() { let e = this.options.reverse, n, r; this.isHorizontal() ? (n = this.left, r = this.right) : (n = this.top, r = this.bottom, e = !e), this._startPixel = n, this._endPixel = r, this._reversePixels = e, this._length = r - n, this._alignToPixels = this.options.alignToPixels } afterUpdate() { ge(this.options.afterUpdate, [this]) } beforeSetDimensions() { ge(this.options.beforeSetDimensions, [this]) } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } afterSetDimensions() { ge(this.options.afterSetDimensions, [this]) } _callHooks(e) { this.chart.notifyPlugins(e, this.getContext()), ge(this.options[e], [this]) } beforeDataLimits() { this._callHooks("beforeDataLimits") } determineDataLimits() { } afterDataLimits() { this._callHooks("afterDataLimits") } beforeBuildTicks() { this._callHooks("beforeBuildTicks") } buildTicks() { return [] } afterBuildTicks() { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion() { ge(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels(e) { const n = this.options.ticks; let r, i, s; for (r = 0, i = e.length; r < i; r++)s = e[r], s.label = ge(n.callback, [s.value, r, e], this) } afterTickToLabelConversion() { ge(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation() { ge(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation() { const e = this.options, n = e.ticks, r = rm(this.ticks.length, e.ticks.maxTicksLimit), i = n.minRotation || 0, s = n.maxRotation; let o = i, a, l, u; if (!this._isVisible() || !n.display || i >= s || r <= 1 || !this.isHorizontal()) { this.labelRotation = i; return } const c = this._getLabelSizes(), d = c.widest.width, h = c.highest.height, f = Wt(this.chart.width - d, 0, this.maxWidth); a = e.offset ? this.maxWidth / r : f / (r - 1), d + 6 > a && (a = f / (r - (e.offset ? .5 : 1)), l = this.maxHeight - ss(e.grid) - n.padding - sm(e.title, this.chart.options.font), u = Math.sqrt(d * d + h * h), o = Jh(Math.min(Math.asin(Wt((c.highest.height + 6) / a, -1, 1)), Math.asin(Wt(l / u, -1, 1)) - Math.asin(Wt(h / u, -1, 1)))), o = Math.max(i, Math.min(s, o))), this.labelRotation = o } afterCalculateLabelRotation() { ge(this.options.afterCalculateLabelRotation, [this]) } afterAutoSkip() { } beforeFit() { ge(this.options.beforeFit, [this]) } fit() { const e = { width: 0, height: 0 }, { chart: n, options: { ticks: r, title: i, grid: s } } = this, o = this._isVisible(), a = this.isHorizontal(); if (o) { const l = sm(i, n.options.font); if (a ? (e.width = this.maxWidth, e.height = ss(s) + l) : (e.height = this.maxHeight, e.width = ss(s) + l), r.display && this.ticks.length) { const { first: u, last: c, widest: d, highest: h } = this._getLabelSizes(), f = r.padding * 2, g = Un(this.labelRotation), m = Math.cos(g), y = Math.sin(g); if (a) { const p = r.mirror ? 0 : y * d.width + m * h.height; e.height = Math.min(this.maxHeight, e.height + p + f) } else { const p = r.mirror ? 0 : m * d.width + y * h.height; e.width = Math.min(this.maxWidth, e.width + p + f) } this._calculatePadding(u, c, y, m) } } this._handleMargins(), a ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom) } _calculatePadding(e, n, r, i) { const { ticks: { align: s, padding: o }, position: a } = this.options, l = this.labelRotation !== 0, u = a !== "top" && this.axis === "x"; if (this.isHorizontal()) { const c = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1); let h = 0, f = 0; l ? u ? (h = i * e.width, f = r * n.height) : (h = r * e.height, f = i * n.width) : s === "start" ? f = n.width : s === "end" ? h = e.width : s !== "inner" && (h = e.width / 2, f = n.width / 2), this.paddingLeft = Math.max((h - c + o) * this.width / (this.width - c), 0), this.paddingRight = Math.max((f - d + o) * this.width / (this.width - d), 0) } else { let c = n.height / 2, d = e.height / 2; s === "start" ? (c = 0, d = e.height) : s === "end" && (c = n.height, d = 0), this.paddingTop = c + o, this.paddingBottom = d + o } } _handleMargins() { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } afterFit() { ge(this.options.afterFit, [this]) } isHorizontal() { const { axis: e, position: n } = this.options; return n === "top" || n === "bottom" || e === "x" } isFullSize() { return this.options.fullSize } _convertTicksToLabels(e) { this.beforeTickToLabelConversion(), this.generateTickLabels(e); let n, r; for (n = 0, r = e.length; n < r; n++)fe(e[n].label) && (e.splice(n, 1), r--, n--); this.afterTickToLabelConversion() } _getLabelSizes() { let e = this._labelSizes; if (!e) { const n = this.options.ticks.sampleSize; let r = this.ticks; n < r.length && (r = im(r, n)), this._labelSizes = e = this._computeLabelSizes(r, r.length, this.options.ticks.maxTicksLimit) } return e } _computeLabelSizes(e, n, r) { const { ctx: i, _longestTextCache: s } = this, o = [], a = [], l = Math.floor(n / rm(n, r)); let u = 0, c = 0, d, h, f, g, m, y, p, v, b, S, P; for (d = 0; d < n; d += l) { if (g = e[d].label, m = this._resolveTickFontOptions(d), i.font = y = m.string, p = s[y] = s[y] || { data: {}, gc: [] }, v = m.lineHeight, b = S = 0, !fe(g) && !we(g)) b = dl(i, p.data, p.gc, b, g), S = v; else if (we(g)) for (h = 0, f = g.length; h < f; ++h)P = g[h], !fe(P) && !we(P) && (b = dl(i, p.data, p.gc, b, P), S += v); o.push(b), a.push(S), u = Math.max(b, u), c = Math.max(S, c) } JT(s, n); const I = o.indexOf(u), T = a.indexOf(c), k = E => ({ width: o[E] || 0, height: a[E] || 0 }); return { first: k(0), last: k(n - 1), widest: k(I), highest: k(T), widths: o, heights: a } } getLabelForValue(e) { return e } getPixelForValue(e, n) { return NaN } getValueForPixel(e) { } getPixelForTick(e) { const n = this.ticks; return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value) } getPixelForDecimal(e) { this._reversePixels && (e = 1 - e); const n = this._startPixel + e * this._length; return sE(this._alignToPixels ? gr(this.chart, n, 0) : n) } getDecimalForPixel(e) { const n = (e - this._startPixel) / this._length; return this._reversePixels ? 1 - n : n } getBasePixel() { return this.getPixelForValue(this.getBaseValue()) } getBaseValue() { const { min: e, max: n } = this; return e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0 } getContext(e) { const n = this.ticks || []; if (e >= 0 && e < n.length) { const r = n[e]; return r.$context || (r.$context = eI(this.getContext(), e, r)) } return this.$context || (this.$context = ZT(this.chart.getContext(), this)) } _tickSize() { const e = this.options.ticks, n = Un(this.labelRotation), r = Math.abs(Math.cos(n)), i = Math.abs(Math.sin(n)), s = this._getLabelSizes(), o = e.autoSkipPadding || 0, a = s ? s.widest.width + o : 0, l = s ? s.highest.height + o : 0; return this.isHorizontal() ? l * r > a * i ? a / r : l / i : l * i < a * r ? l / r : a / i } _isVisible() { const e = this.options.display; return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems(e) { const n = this.axis, r = this.chart, i = this.options, { grid: s, position: o, border: a } = i, l = s.offset, u = this.isHorizontal(), d = this.ticks.length + (l ? 1 : 0), h = ss(s), f = [], g = a.setContext(this.getContext()), m = g.display ? g.width : 0, y = m / 2, p = function (V) { return gr(r, V, m) }; let v, b, S, P, I, T, k, E, M, L, N, $; if (o === "top") v = p(this.bottom), T = this.bottom - h, E = v - y, L = p(e.top) + y, $ = e.bottom; else if (o === "bottom") v = p(this.top), L = e.top, $ = p(e.bottom) - y, T = v + y, E = this.top + h; else if (o === "left") v = p(this.right), I = this.right - h, k = v - y, M = p(e.left) + y, N = e.right; else if (o === "right") v = p(this.left), M = e.left, N = p(e.right) - y, I = v + y, k = this.left + h; else if (n === "x") { if (o === "center") v = p((e.top + e.bottom) / 2 + .5); else if (ie(o)) { const V = Object.keys(o)[0], q = o[V]; v = p(this.chart.scales[V].getPixelForValue(q)) } L = e.top, $ = e.bottom, T = v + y, E = T + h } else if (n === "y") { if (o === "center") v = p((e.left + e.right) / 2); else if (ie(o)) { const V = Object.keys(o)[0], q = o[V]; v = p(this.chart.scales[V].getPixelForValue(q)) } I = v - y, k = I - h, M = e.left, N = e.right } const B = le(i.ticks.maxTicksLimit, d), H = Math.max(1, Math.ceil(d / B)); for (b = 0; b < d; b += H) { const V = this.getContext(b), q = s.setContext(V), j = a.setContext(V), _ = q.lineWidth, x = q.color, C = j.dash || [], w = j.dashOffset, O = q.tickWidth, D = q.tickColor, F = q.tickBorderDash || [], z = q.tickBorderDashOffset; S = XT(this, b, l), S !== void 0 && (P = gr(r, S, _), u ? I = k = M = N = P : T = E = L = $ = P, f.push({ tx1: I, ty1: T, tx2: k, ty2: E, x1: M, y1: L, x2: N, y2: $, width: _, color: x, borderDash: C, borderDashOffset: w, tickWidth: O, tickColor: D, tickBorderDash: F, tickBorderDashOffset: z })) } return this._ticksLength = d, this._borderValue = v, f } _computeLabelItems(e) { const n = this.axis, r = this.options, { position: i, ticks: s } = r, o = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: u, padding: c, mirror: d } = s, h = ss(r.grid), f = h + c, g = d ? -c : f, m = -Un(this.labelRotation), y = []; let p, v, b, S, P, I, T, k, E, M, L, N, $ = "middle"; if (i === "top") I = this.bottom - g, T = this._getXAxisLabelAlignment(); else if (i === "bottom") I = this.top + g, T = this._getXAxisLabelAlignment(); else if (i === "left") { const H = this._getYAxisLabelAlignment(h); T = H.textAlign, P = H.x } else if (i === "right") { const H = this._getYAxisLabelAlignment(h); T = H.textAlign, P = H.x } else if (n === "x") { if (i === "center") I = (e.top + e.bottom) / 2 + f; else if (ie(i)) { const H = Object.keys(i)[0], V = i[H]; I = this.chart.scales[H].getPixelForValue(V) + f } T = this._getXAxisLabelAlignment() } else if (n === "y") { if (i === "center") P = (e.left + e.right) / 2 - f; else if (ie(i)) { const H = Object.keys(i)[0], V = i[H]; P = this.chart.scales[H].getPixelForValue(V) } T = this._getYAxisLabelAlignment(h).textAlign } n === "y" && (l === "start" ? $ = "top" : l === "end" && ($ = "bottom")); const B = this._getLabelSizes(); for (p = 0, v = a.length; p < v; ++p) { b = a[p], S = b.label; const H = s.setContext(this.getContext(p)); k = this.getPixelForTick(p) + s.labelOffset, E = this._resolveTickFontOptions(p), M = E.lineHeight, L = we(S) ? S.length : 1; const V = L / 2, q = H.color, j = H.textStrokeColor, _ = H.textStrokeWidth; let x = T; o ? (P = k, T === "inner" && (p === v - 1 ? x = this.options.reverse ? "left" : "right" : p === 0 ? x = this.options.reverse ? "right" : "left" : x = "center"), i === "top" ? u === "near" || m !== 0 ? N = -L * M + M / 2 : u === "center" ? N = -B.highest.height / 2 - V * M + M : N = -B.highest.height + M / 2 : u === "near" || m !== 0 ? N = M / 2 : u === "center" ? N = B.highest.height / 2 - V * M : N = B.highest.height - L * M, d && (N *= -1), m !== 0 && !H.showLabelBackdrop && (P += M / 2 * Math.sin(m))) : (I = k, N = (1 - L) * M / 2); let C; if (H.showLabelBackdrop) { const w = et(H.backdropPadding), O = B.heights[p], D = B.widths[p]; let F = N - w.top, z = 0 - w.left; switch ($) { case "middle": F -= O / 2; break; case "bottom": F -= O; break }switch (T) { case "center": z -= D / 2; break; case "right": z -= D; break; case "inner": p === v - 1 ? z -= D : p > 0 && (z -= D / 2); break }C = { left: z, top: F, width: D + w.width, height: O + w.height, color: H.backdropColor } } y.push({ label: S, font: E, textOffset: N, options: { rotation: m, color: q, strokeColor: j, strokeWidth: _, textAlign: x, textBaseline: $, translation: [P, I], backdrop: C } }) } return y } _getXAxisLabelAlignment() { const { position: e, ticks: n } = this.options; if (-Un(this.labelRotation)) return e === "top" ? "left" : "right"; let i = "center"; return n.align === "start" ? i = "left" : n.align === "end" ? i = "right" : n.align === "inner" && (i = "inner"), i } _getYAxisLabelAlignment(e) { const { position: n, ticks: { crossAlign: r, mirror: i, padding: s } } = this.options, o = this._getLabelSizes(), a = e + s, l = o.widest.width; let u, c; return n === "left" ? i ? (c = this.right + s, r === "near" ? u = "left" : r === "center" ? (u = "center", c += l / 2) : (u = "right", c += l)) : (c = this.right - a, r === "near" ? u = "right" : r === "center" ? (u = "center", c -= l / 2) : (u = "left", c = this.left)) : n === "right" ? i ? (c = this.left + s, r === "near" ? u = "right" : r === "center" ? (u = "center", c -= l / 2) : (u = "left", c -= l)) : (c = this.left + a, r === "near" ? u = "left" : r === "center" ? (u = "center", c += l / 2) : (u = "right", c = this.right)) : u = "right", { textAlign: u, x: c } } _computeLabelArea() { if (this.options.ticks.mirror) return; const e = this.chart, n = this.options.position; if (n === "left" || n === "right") return { top: 0, left: this.left, bottom: e.height, right: this.right }; if (n === "top" || n === "bottom") return { top: this.top, left: 0, bottom: this.bottom, right: e.width } } drawBackground() { const { ctx: e, options: { backgroundColor: n }, left: r, top: i, width: s, height: o } = this; n && (e.save(), e.fillStyle = n, e.fillRect(r, i, s, o), e.restore()) } getLineWidthForValue(e) { const n = this.options.grid; if (!this._isVisible() || !n.display) return 0; const i = this.ticks.findIndex(s => s.value === e); return i >= 0 ? n.setContext(this.getContext(i)).lineWidth : 0 } drawGrid(e) { const n = this.options.grid, r = this.ctx, i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e)); let s, o; const a = (l, u, c) => { !c.width || !c.color || (r.save(), r.lineWidth = c.width, r.strokeStyle = c.color, r.setLineDash(c.borderDash || []), r.lineDashOffset = c.borderDashOffset, r.beginPath(), r.moveTo(l.x, l.y), r.lineTo(u.x, u.y), r.stroke(), r.restore()) }; if (n.display) for (s = 0, o = i.length; s < o; ++s) { const l = i[s]; n.drawOnChartArea && a({ x: l.x1, y: l.y1 }, { x: l.x2, y: l.y2 }, l), n.drawTicks && a({ x: l.tx1, y: l.ty1 }, { x: l.tx2, y: l.ty2 }, { color: l.tickColor, width: l.tickWidth, borderDash: l.tickBorderDash, borderDashOffset: l.tickBorderDashOffset }) } } drawBorder() { const { chart: e, ctx: n, options: { border: r, grid: i } } = this, s = r.setContext(this.getContext()), o = r.display ? s.width : 0; if (!o) return; const a = i.setContext(this.getContext(0)).lineWidth, l = this._borderValue; let u, c, d, h; this.isHorizontal() ? (u = gr(e, this.left, o) - o / 2, c = gr(e, this.right, a) + a / 2, d = h = l) : (d = gr(e, this.top, o) - o / 2, h = gr(e, this.bottom, a) + a / 2, u = c = l), n.save(), n.lineWidth = s.width, n.strokeStyle = s.color, n.beginPath(), n.moveTo(u, d), n.lineTo(c, h), n.stroke(), n.restore() } drawLabels(e) { if (!this.options.ticks.display) return; const r = this.ctx, i = this._computeLabelArea(); i && nf(r, i); const s = this.getLabelItems(e); for (const o of s) { const a = o.options, l = o.font, u = o.label, c = o.textOffset; jr(r, u, 0, c, l, a) } i && rf(r) } drawTitle() { const { ctx: e, options: { position: n, title: r, reverse: i } } = this; if (!r.display) return; const s = De(r.font), o = et(r.padding), a = r.align; let l = s.lineHeight / 2; n === "bottom" || n === "center" || ie(n) ? (l += o.bottom, we(r.text) && (l += s.lineHeight * (r.text.length - 1))) : l += o.top; const { titleX: u, titleY: c, maxWidth: d, rotation: h } = nI(this, l, n, a); jr(e, r.text, 0, 0, s, { color: r.color, maxWidth: d, rotation: h, textAlign: tI(a, n, i), textBaseline: "middle", translation: [u, c] }) } draw(e) { this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e)) } _layers() { const e = this.options, n = e.ticks && e.ticks.z || 0, r = le(e.grid && e.grid.z, -1), i = le(e.border && e.border.z, 0); return !this._isVisible() || this.draw !== Br.prototype.draw ? [{ z: n, draw: s => { this.draw(s) } }] : [{ z: r, draw: s => { this.drawBackground(), this.drawGrid(s), this.drawTitle() } }, { z: i, draw: () => { this.drawBorder() } }, { z: n, draw: s => { this.drawLabels(s) } }] } getMatchingVisibleMetas(e) { const n = this.chart.getSortedVisibleDatasetMetas(), r = this.axis + "AxisID", i = []; let s, o; for (s = 0, o = n.length; s < o; ++s) { const a = n[s]; a[r] === this.id && (!e || a.type === e) && i.push(a) } return i } _resolveTickFontOptions(e) { const n = this.options.ticks.setContext(this.getContext(e)); return De(n.font) } _maxDigits() { const e = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / e } } class ta { constructor(e, n, r) { this.type = e, this.scope = n, this.override = r, this.items = Object.create(null) } isForType(e) { return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype) } register(e) { const n = Object.getPrototypeOf(e); let r; sI(n) && (r = this.register(n)); const i = this.items, s = e.id, o = this.scope + "." + s; if (!s) throw new Error("class does not have id: " + e); return s in i || (i[s] = e, rI(e, o, r), this.override && Ce.override(e.id, e.overrides)), o } get(e) { return this.items[e] } unregister(e) { const n = this.items, r = e.id, i = this.scope; r in n && delete n[r], i && r in Ce[i] && (delete Ce[i][r], this.override && delete Ar[r]) } } function rI(t, e, n) { const r = eo(Object.create(null), [n ? Ce.get(n) : {}, Ce.get(e), t.defaults]); Ce.set(e, r), t.defaultRoutes && iI(e, t.defaultRoutes), t.descriptors && Ce.describe(e, t.descriptors) } function iI(t, e) { Object.keys(e).forEach(n => { const r = n.split("."), i = r.pop(), s = [t].concat(r).join("."), o = e[n].split("."), a = o.pop(), l = o.join("."); Ce.route(s, i, l, a) }) } function sI(t) { return "id" in t && "defaults" in t } class oI { constructor() { this.controllers = new ta(Ms, "datasets", !0), this.elements = new ta(Ui, "elements"), this.plugins = new ta(Object, "plugins"), this.scales = new ta(Br, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add(...e) { this._each("register", e) } remove(...e) { this._each("unregister", e) } addControllers(...e) { this._each("register", e, this.controllers) } addElements(...e) { this._each("register", e, this.elements) } addPlugins(...e) { this._each("register", e, this.plugins) } addScales(...e) { this._each("register", e, this.scales) } getController(e) { return this._get(e, this.controllers, "controller") } getElement(e) { return this._get(e, this.elements, "element") } getPlugin(e) { return this._get(e, this.plugins, "plugin") } getScale(e) { return this._get(e, this.scales, "scale") } removeControllers(...e) { this._each("unregister", e, this.controllers) } removeElements(...e) { this._each("unregister", e, this.elements) } removePlugins(...e) { this._each("unregister", e, this.plugins) } removeScales(...e) { this._each("unregister", e, this.scales) } _each(e, n, r) { [...n].forEach(i => { const s = r || this._getRegistryForType(i); r || s.isForType(i) || s === this.plugins && i.id ? this._exec(e, s, i) : ce(i, o => { const a = r || this._getRegistryForType(o); this._exec(e, a, o) }) }) } _exec(e, n, r) { const i = Xh(e); ge(r["before" + i], [], r), n[e](r), ge(r["after" + i], [], r) } _getRegistryForType(e) { for (let n = 0; n < this._typedRegistries.length; n++) { const r = this._typedRegistries[n]; if (r.isForType(e)) return r } return this.plugins } _get(e, n, r) { const i = n.get(e); if (i === void 0) throw new Error('"' + e + '" is not a registered ' + r + "."); return i } } var Zt = new oI; class aI { constructor() { this._init = [] } notify(e, n, r, i) { n === "beforeInit" && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install")); const s = i ? this._descriptors(e).filter(i) : this._descriptors(e), o = this._notify(s, e, n, r); return n === "afterDestroy" && (this._notify(s, e, "stop"), this._notify(this._init, e, "uninstall")), o } _notify(e, n, r, i) { i = i || {}; for (const s of e) { const o = s.plugin, a = o[r], l = [n, i, s.options]; if (ge(a, l, o) === !1 && i.cancelable) return !1 } return !0 } invalidate() { fe(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(e) { if (this._cache) return this._cache; const n = this._cache = this._createDescriptors(e); return this._notifyStateChanges(e), n } _createDescriptors(e, n) { const r = e && e.config, i = le(r.options && r.options.plugins, {}), s = lI(r); return i === !1 && !n ? [] : cI(e, s, i, n) } _notifyStateChanges(e) { const n = this._oldCache || [], r = this._cache, i = (s, o) => s.filter(a => !o.some(l => a.plugin.id === l.plugin.id)); this._notify(i(n, r), e, "stop"), this._notify(i(r, n), e, "start") } } function lI(t) { const e = {}, n = [], r = Object.keys(Zt.plugins.items); for (let s = 0; s < r.length; s++)n.push(Zt.getPlugin(r[s])); const i = t.plugins || []; for (let s = 0; s < i.length; s++) { const o = i[s]; n.indexOf(o) === -1 && (n.push(o), e[o.id] = !0) } return { plugins: n, localIds: e } } function uI(t, e) { return !e && t === !1 ? null : t === !0 ? {} : t } function cI(t, { plugins: e, localIds: n }, r, i) { const s = [], o = t.getContext(); for (const a of e) { const l = a.id, u = uI(r[l], i); u !== null && s.push({ plugin: a, options: dI(t.config, { plugin: a, local: n[l] }, u, o) }) } return s } function dI(t, { plugin: e, local: n }, r, i) { const s = t.pluginScopeKeys(e), o = t.getOptionScopes(r, s); return n && e.defaults && o.push(e.defaults), t.createResolver(o, i, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function Ed(t, e) { const n = Ce.datasets[t] || {}; return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || n.indexAxis || "x" } function hI(t, e) { let n = t; return t === "_index_" ? n = e : t === "_value_" && (n = e === "x" ? "y" : "x"), n } function fI(t, e) { return t === e ? "_index_" : "_value_" } function om(t) { if (t === "x" || t === "y" || t === "r") return t } function pI(t) { if (t === "top" || t === "bottom") return "x"; if (t === "left" || t === "right") return "y" } function Td(t, ...e) { if (om(t)) return t; for (const n of e) { const r = n.axis || pI(n.position) || t.length > 1 && om(t[0].toLowerCase()); if (r) return r } throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`) } function am(t, e, n) { if (n[e + "AxisID"] === t) return { axis: e } } function gI(t, e) { if (e.data && e.data.datasets) { const n = e.data.datasets.filter(r => r.xAxisID === t || r.yAxisID === t); if (n.length) return am(t, "x", n[0]) || am(t, "y", n[0]) } return {} } function mI(t, e) { const n = Ar[t.type] || { scales: {} }, r = e.scales || {}, i = Ed(t.type, e), s = Object.create(null); return Object.keys(r).forEach(o => { const a = r[o]; if (!ie(a)) return console.error(`Invalid scale configuration for scale: ${o}`); if (a._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${o}`); const l = Td(o, a, gI(o, t), Ce.scales[a.type]), u = fI(l, i), c = n.scales || {}; s[o] = Ts(Object.create(null), [{ axis: l }, a, c[l], c[u]]) }), t.data.datasets.forEach(o => { const a = o.type || t.type, l = o.indexAxis || Ed(a, e), c = (Ar[a] || {}).scales || {}; Object.keys(c).forEach(d => { const h = hI(d, l), f = o[h + "AxisID"] || h; s[f] = s[f] || Object.create(null), Ts(s[f], [{ axis: h }, r[f], c[d]]) }) }), Object.keys(s).forEach(o => { const a = s[o]; Ts(a, [Ce.scales[a.type], Ce.scale]) }), s } function qb(t) { const e = t.options || (t.options = {}); e.plugins = le(e.plugins, {}), e.scales = mI(t, e) } function Kb(t) { return t = t || {}, t.datasets = t.datasets || [], t.labels = t.labels || [], t } function vI(t) { return t = t || {}, t.data = Kb(t.data), qb(t), t } const lm = new Map, Gb = new Set; function na(t, e) { let n = lm.get(t); return n || (n = e(), lm.set(t, n), Gb.add(n)), n } const os = (t, e, n) => { const r = Mi(e, n); r !== void 0 && t.add(r) }; class yI { constructor(e) { this._config = vI(e), this._scopeCache = new Map, this._resolverCache = new Map } get platform() { return this._config.platform } get type() { return this._config.type } set type(e) { this._config.type = e } get data() { return this._config.data } set data(e) { this._config.data = Kb(e) } get options() { return this._config.options } set options(e) { this._config.options = e } get plugins() { return this._config.plugins } update() { const e = this._config; this.clearCache(), qb(e) } clearCache() { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(e) { return na(e, () => [[`datasets.${e}`, ""]]) } datasetAnimationScopeKeys(e, n) { return na(`${e}.transition.${n}`, () => [[`datasets.${e}.transitions.${n}`, `transitions.${n}`], [`datasets.${e}`, ""]]) } datasetElementScopeKeys(e, n) { return na(`${e}-${n}`, () => [[`datasets.${e}.elements.${n}`, `datasets.${e}`, `elements.${n}`, ""]]) } pluginScopeKeys(e) { const n = e.id, r = this.type; return na(`${r}-plugin-${n}`, () => [[`plugins.${n}`, ...e.additionalOptionScopes || []]]) } _cachedScopes(e, n) { const r = this._scopeCache; let i = r.get(e); return (!i || n) && (i = new Map, r.set(e, i)), i } getOptionScopes(e, n, r) { const { options: i, type: s } = this, o = this._cachedScopes(e, r), a = o.get(n); if (a) return a; const l = new Set; n.forEach(c => { e && (l.add(e), c.forEach(d => os(l, e, d))), c.forEach(d => os(l, i, d)), c.forEach(d => os(l, Ar[s] || {}, d)), c.forEach(d => os(l, Ce, d)), c.forEach(d => os(l, Pd, d)) }); const u = Array.from(l); return u.length === 0 && u.push(Object.create(null)), Gb.has(n) && o.set(n, u), u } chartOptionScopes() { const { options: e, type: n } = this; return [e, Ar[n] || {}, Ce.datasets[n] || {}, { type: n }, Ce, Pd] } resolveNamedOptions(e, n, r, i = [""]) { const s = { $shared: !0 }, { resolver: o, subPrefixes: a } = um(this._resolverCache, e, i); let l = o; if (_I(o, n)) { s.$shared = !1, r = ir(r) ? r() : r; const u = this.createResolver(e, r, a); l = Li(o, r, u) } for (const u of n) s[u] = l[u]; return s } createResolver(e, n, r = [""], i) { const { resolver: s } = um(this._resolverCache, e, r); return ie(n) ? Li(s, n, void 0, i) : s } } function um(t, e, n) { let r = t.get(e); r || (r = new Map, t.set(e, r)); const i = n.join(); let s = r.get(i); return s || (s = { resolver: sf(e, n), subPrefixes: n.filter(a => !a.toLowerCase().includes("hover")) }, r.set(i, s)), s } const bI = t => ie(t) && Object.getOwnPropertyNames(t).some(e => ir(t[e])); function _I(t, e) { const { isScriptable: n, isIndexable: r } = Mb(t); for (const i of e) { const s = n(i), o = r(i), a = (o || s) && t[i]; if (s && (ir(a) || bI(a)) || o && we(a)) return !0 } return !1 } var wI = "4.4.3"; const SI = ["top", "bottom", "left", "right", "chartArea"]; function cm(t, e) { return t === "top" || t === "bottom" || SI.indexOf(t) === -1 && e === "x" } function dm(t, e) { return function (n, r) { return n[t] === r[t] ? n[e] - r[e] : n[t] - r[t] } } function hm(t) { const e = t.chart, n = e.options.animation; e.notifyPlugins("afterRender"), ge(n && n.onComplete, [t], e) } function xI(t) { const e = t.chart, n = e.options.animation; ge(n && n.onProgress, [t], e) } function Yb(t) { return lf() && typeof t == "string" ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t } const Ea = {}, fm = t => { const e = Yb(t); return Object.values(Ea).filter(n => n.canvas === e).pop() }; function kI(t, e, n) { const r = Object.keys(t); for (const i of r) { const s = +i; if (s >= e) { const o = t[i]; delete t[i], (n > 0 || s > e) && (t[s + n] = o) } } } function CI(t, e, n, r) { return !n || t.type === "mouseout" ? null : r ? e : t } function ra(t, e, n) { return t.options.clip ? t[n] : e[n] } function OI(t, e) { const { xScale: n, yScale: r } = t; return n && r ? { left: ra(n, e, "left"), right: ra(n, e, "right"), top: ra(r, e, "top"), bottom: ra(r, e, "bottom") } : e } var In; let eu = (In = class { static register(...e) { Zt.add(...e), pm() } static unregister(...e) { Zt.remove(...e), pm() } constructor(e, n) { const r = this.config = new yI(n), i = Yb(e), s = fm(i); if (s) throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas with ID '" + s.canvas.id + "' can be reused."); const o = r.createResolver(r.chartOptionScopes(), this.getContext()); this.platform = new (r.platform || UT(i)), this.platform.updateConfig(r); const a = this.platform.acquireContext(i, o.aspectRatio), l = a && a.canvas, u = l && l.height, c = l && l.width; if (this.id = qP(), this.ctx = a, this.canvas = l, this.width = c, this.height = u, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new aI, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = uE(d => this.update(d), o.resizeDelay || 0), this._dataChanges = [], Ea[this.id] = this, !a || !l) { console.error("Failed to create chart: can't acquire context from the given item"); return } fn.listen(this, "complete", hm), fn.listen(this, "progress", xI), this._initialize(), this.attached && this.update() } get aspectRatio() { const { options: { aspectRatio: e, maintainAspectRatio: n }, width: r, height: i, _aspectRatio: s } = this; return fe(e) ? n && s ? s : i ? r / i : null : e } get data() { return this.config.data } set data(e) { this.config.data = e } get options() { return this._options } set options(e) { this.config.options = e } get registry() { return Zt } _initialize() { return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Fg(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear() { return Dg(this.canvas, this.ctx), this } stop() { return fn.stop(this), this } resize(e, n) { fn.running(this) ? this._resizeBeforeDraw = { width: e, height: n } : this._resize(e, n) } _resize(e, n) { const r = this.options, i = this.canvas, s = r.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(i, e, n, s), a = r.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach"; this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, Fg(this, a, !0) && (this.notifyPlugins("resize", { size: o }), ge(r.onResize, [this, o], this), this.attached && this._doResize(l) && this.render()) } ensureScalesHaveIDs() { const n = this.options.scales || {}; ce(n, (r, i) => { r.id = i }) } buildOrUpdateScales() { const e = this.options, n = e.scales, r = this.scales, i = Object.keys(r).reduce((o, a) => (o[a] = !1, o), {}); let s = []; n && (s = s.concat(Object.keys(n).map(o => { const a = n[o], l = Td(o, a), u = l === "r", c = l === "x"; return { options: a, dposition: u ? "chartArea" : c ? "bottom" : "left", dtype: u ? "radialLinear" : c ? "category" : "linear" } }))), ce(s, o => { const a = o.options, l = a.id, u = Td(l, a), c = le(a.type, o.dtype); (a.position === void 0 || cm(a.position, u) !== cm(o.dposition)) && (a.position = o.dposition), i[l] = !0; let d = null; if (l in r && r[l].type === c) d = r[l]; else { const h = Zt.getScale(c); d = new h({ id: l, type: c, ctx: this.ctx, chart: this }), r[d.id] = d } d.init(a, e) }), ce(i, (o, a) => { o || delete r[a] }), ce(r, o => { Lt.configure(this, o, o.options), Lt.addBox(this, o) }) } _updateMetasets() { const e = this._metasets, n = this.data.datasets.length, r = e.length; if (e.sort((i, s) => i.index - s.index), r > n) { for (let i = n; i < r; ++i)this._destroyDatasetMeta(i); e.splice(n, r - n) } this._sortedMetasets = e.slice(0).sort(dm("order", "index")) } _removeUnreferencedMetasets() { const { _metasets: e, data: { datasets: n } } = this; e.length > n.length && delete this._stacks, e.forEach((r, i) => { n.filter(s => s === r._dataset).length === 0 && this._destroyDatasetMeta(i) }) } buildOrUpdateControllers() { const e = [], n = this.data.datasets; let r, i; for (this._removeUnreferencedMetasets(), r = 0, i = n.length; r < i; r++) { const s = n[r]; let o = this.getDatasetMeta(r); const a = s.type || this.config.type; if (o.type && o.type !== a && (this._destroyDatasetMeta(r), o = this.getDatasetMeta(r)), o.type = a, o.indexAxis = s.indexAxis || Ed(a, this.options), o.order = s.order || 0, o.index = r, o.label = "" + s.label, o.visible = this.isDatasetVisible(r), o.controller) o.controller.updateIndex(r), o.controller.linkScales(); else { const l = Zt.getController(a), { datasetElementType: u, dataElementType: c } = Ce.datasets[a]; Object.assign(l, { dataElementType: Zt.getElement(c), datasetElementType: u && Zt.getElement(u) }), o.controller = new l(this, r), e.push(o.controller) } } return this._updateMetasets(), e } _resetElements() { ce(this.data.datasets, (e, n) => { this.getDatasetMeta(n).controller.reset() }, this) } reset() { this._resetElements(), this.notifyPlugins("reset") } update(e) { const n = this.config; n.update(); const r = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), i = this._animationsDisabled = !r.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", { mode: e, cancelable: !0 }) === !1) return; const s = this.buildOrUpdateControllers(); this.notifyPlugins("beforeElementsUpdate"); let o = 0; for (let u = 0, c = this.data.datasets.length; u < c; u++) { const { controller: d } = this.getDatasetMeta(u), h = !i && s.indexOf(d) === -1; d.buildOrUpdateElements(h), o = Math.max(+d.getMaxOverflow(), o) } o = this._minPadding = r.layout.autoPadding ? o : 0, this._updateLayout(o), i || ce(s, u => { u.reset() }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", { mode: e }), this._layers.sort(dm("z", "_idx")); const { _active: a, _lastEvent: l } = this; l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render() } _updateScales() { ce(this.scales, e => { Lt.removeBox(this, e) }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings() { const e = this.options, n = new Set(Object.keys(this._listeners)), r = new Set(e.events); (!Cg(n, r) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices() { const { _hiddenIndices: e } = this, n = this._getUniformDataChanges() || []; for (const { method: r, start: i, count: s } of n) { const o = r === "_removeElements" ? -s : s; kI(e, i, o) } } _getUniformDataChanges() { const e = this._dataChanges; if (!e || !e.length) return; this._dataChanges = []; const n = this.data.datasets.length, r = s => new Set(e.filter(o => o[0] === s).map((o, a) => a + "," + o.splice(1).join(","))), i = r(0); for (let s = 1; s < n; s++)if (!Cg(i, r(s))) return; return Array.from(i).map(s => s.split(",")).map(s => ({ method: s[1], start: +s[2], count: +s[3] })) } _updateLayout(e) { if (this.notifyPlugins("beforeLayout", { cancelable: !0 }) === !1) return; Lt.update(this, this.width, this.height, e); const n = this.chartArea, r = n.width <= 0 || n.height <= 0; this._layers = [], ce(this.boxes, i => { r && i.position === "chartArea" || (i.configure && i.configure(), this._layers.push(...i._layers())) }, this), this._layers.forEach((i, s) => { i._idx = s }), this.notifyPlugins("afterLayout") } _updateDatasets(e) { if (this.notifyPlugins("beforeDatasetsUpdate", { mode: e, cancelable: !0 }) !== !1) { for (let n = 0, r = this.data.datasets.length; n < r; ++n)this.getDatasetMeta(n).controller.configure(); for (let n = 0, r = this.data.datasets.length; n < r; ++n)this._updateDataset(n, ir(e) ? e({ datasetIndex: n }) : e); this.notifyPlugins("afterDatasetsUpdate", { mode: e }) } } _updateDataset(e, n) { const r = this.getDatasetMeta(e), i = { meta: r, index: e, mode: n, cancelable: !0 }; this.notifyPlugins("beforeDatasetUpdate", i) !== !1 && (r.controller._update(n), i.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", i)) } render() { this.notifyPlugins("beforeRender", { cancelable: !0 }) !== !1 && (fn.has(this) ? this.attached && !fn.running(this) && fn.start(this) : (this.draw(), hm({ chart: this }))) } draw() { let e; if (this._resizeBeforeDraw) { const { width: r, height: i } = this._resizeBeforeDraw; this._resize(r, i), this._resizeBeforeDraw = null } if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", { cancelable: !0 }) === !1) return; const n = this._layers; for (e = 0; e < n.length && n[e].z <= 0; ++e)n[e].draw(this.chartArea); for (this._drawDatasets(); e < n.length; ++e)n[e].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas(e) { const n = this._sortedMetasets, r = []; let i, s; for (i = 0, s = n.length; i < s; ++i) { const o = n[i]; (!e || o.visible) && r.push(o) } return r } getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0) } _drawDatasets() { if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 }) === !1) return; const e = this.getSortedVisibleDatasetMetas(); for (let n = e.length - 1; n >= 0; --n)this._drawDataset(e[n]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset(e) { const n = this.ctx, r = e._clip, i = !r.disabled, s = OI(e, this.chartArea), o = { meta: e, index: e.index, cancelable: !0 }; this.notifyPlugins("beforeDatasetDraw", o) !== !1 && (i && nf(n, { left: r.left === !1 ? 0 : s.left - r.left, right: r.right === !1 ? this.width : s.right + r.right, top: r.top === !1 ? 0 : s.top - r.top, bottom: r.bottom === !1 ? this.height : s.bottom + r.bottom }), e.controller.draw(), i && rf(n), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o)) } isPointInArea(e) { return hi(e, this.chartArea, this._minPadding) } getElementsAtEventForMode(e, n, r, i) { const s = ST.modes[n]; return typeof s == "function" ? s(this, e, r, i) : [] } getDatasetMeta(e) { const n = this.data.datasets[e], r = this._metasets; let i = r.filter(s => s && s._dataset === n).pop(); return i || (i = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: n && n.order || 0, index: e, _dataset: n, _parsed: [], _sorted: !1 }, r.push(i)), i } getContext() { return this.$context || (this.$context = Vr(null, { chart: this, type: "chart" })) } getVisibleDatasetCount() { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible(e) { const n = this.data.datasets[e]; if (!n) return !1; const r = this.getDatasetMeta(e); return typeof r.hidden == "boolean" ? !r.hidden : !n.hidden } setDatasetVisibility(e, n) { const r = this.getDatasetMeta(e); r.hidden = !n } toggleDataVisibility(e) { this._hiddenIndices[e] = !this._hiddenIndices[e] } getDataVisibility(e) { return !this._hiddenIndices[e] } _updateVisibility(e, n, r) { const i = r ? "show" : "hide", s = this.getDatasetMeta(e), o = s.controller._resolveAnimations(void 0, i); to(n) ? (s.data[n].hidden = !r, this.update()) : (this.setDatasetVisibility(e, r), o.update(s, { visible: r }), this.update(a => a.datasetIndex === e ? i : void 0)) } hide(e, n) { this._updateVisibility(e, n, !1) } show(e, n) { this._updateVisibility(e, n, !0) } _destroyDatasetMeta(e) { const n = this._metasets[e]; n && n.controller && n.controller._destroy(), delete this._metasets[e] } _stop() { let e, n; for (this.stop(), fn.remove(this), e = 0, n = this.data.datasets.length; e < n; ++e)this._destroyDatasetMeta(e) } destroy() { this.notifyPlugins("beforeDestroy"); const { canvas: e, ctx: n } = this; this._stop(), this.config.clearCache(), e && (this.unbindEvents(), Dg(e, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete Ea[this.id], this.notifyPlugins("afterDestroy") } toBase64Image(...e) { return this.canvas.toDataURL(...e) } bindEvents() { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents() { const e = this._listeners, n = this.platform, r = (s, o) => { n.addEventListener(this, s, o), e[s] = o }, i = (s, o, a) => { s.offsetX = o, s.offsetY = a, this._eventHandler(s) }; ce(this.options.events, s => r(s, i)) } bindResponsiveEvents() { this._responsiveListeners || (this._responsiveListeners = {}); const e = this._responsiveListeners, n = this.platform, r = (l, u) => { n.addEventListener(this, l, u), e[l] = u }, i = (l, u) => { e[l] && (n.removeEventListener(this, l, u), delete e[l]) }, s = (l, u) => { this.canvas && this.resize(l, u) }; let o; const a = () => { i("attach", a), this.attached = !0, this.resize(), r("resize", s), r("detach", o) }; o = () => { this.attached = !1, i("resize", s), this._stop(), this._resize(0, 0), r("attach", a) }, n.isAttached(this.canvas) ? a() : o() } unbindEvents() { ce(this._listeners, (e, n) => { this.platform.removeEventListener(this, n, e) }), this._listeners = {}, ce(this._responsiveListeners, (e, n) => { this.platform.removeEventListener(this, n, e) }), this._responsiveListeners = void 0 } updateHoverStyle(e, n, r) { const i = r ? "set" : "remove"; let s, o, a, l; for (n === "dataset" && (s = this.getDatasetMeta(e[0].datasetIndex), s.controller["_" + i + "DatasetHoverStyle"]()), a = 0, l = e.length; a < l; ++a) { o = e[a]; const u = o && this.getDatasetMeta(o.datasetIndex).controller; u && u[i + "HoverStyle"](o.element, o.datasetIndex, o.index) } } getActiveElements() { return this._active || [] } setActiveElements(e) { const n = this._active || [], r = e.map(({ datasetIndex: s, index: o }) => { const a = this.getDatasetMeta(s); if (!a) throw new Error("No dataset found at index " + s); return { datasetIndex: s, element: a.data[o], index: o } }); !al(r, n) && (this._active = r, this._lastEvent = null, this._updateHoverStyles(r, n)) } notifyPlugins(e, n, r) { return this._plugins.notify(this, e, n, r) } isPluginEnabled(e) { return this._plugins._cache.filter(n => n.plugin.id === e).length === 1 } _updateHoverStyles(e, n, r) { const i = this.options.hover, s = (l, u) => l.filter(c => !u.some(d => c.datasetIndex === d.datasetIndex && c.index === d.index)), o = s(n, e), a = r ? e : s(e, n); o.length && this.updateHoverStyle(o, i.mode, !1), a.length && i.mode && this.updateHoverStyle(a, i.mode, !0) } _eventHandler(e, n) { const r = { event: e, replay: n, cancelable: !0, inChartArea: this.isPointInArea(e) }, i = o => (o.options.events || this.options.events).includes(e.native.type); if (this.notifyPlugins("beforeEvent", r, i) === !1) return; const s = this._handleEvent(e, n, r.inChartArea); return r.cancelable = !1, this.notifyPlugins("afterEvent", r, i), (s || r.changed) && this.render(), this } _handleEvent(e, n, r) { const { _active: i = [], options: s } = this, o = n, a = this._getActiveElements(e, i, r, o), l = JP(e), u = CI(e, this._lastEvent, r, l); r && (this._lastEvent = null, ge(s.onHover, [e, a, this], this), l && ge(s.onClick, [e, a, this], this)); const c = !al(a, i); return (c || n) && (this._active = a, this._updateHoverStyles(a, i, n)), this._lastEvent = u, c } _getActiveElements(e, n, r, i) { if (e.type === "mouseout") return []; if (!r) return n; const s = this.options.hover; return this.getElementsAtEventForMode(e, s.mode, s, i) } }, J(In, "defaults", Ce), J(In, "instances", Ea), J(In, "overrides", Ar), J(In, "registry", Zt), J(In, "version", wI), J(In, "getChart", fm), In); function pm() { return ce(eu.instances, t => t._plugins.invalidate()) } function Qb(t, e) { const { x: n, y: r, base: i, width: s, height: o } = t.getProps(["x", "y", "base", "width", "height"], e); let a, l, u, c, d; return t.horizontal ? (d = o / 2, a = Math.min(n, i), l = Math.max(n, i), u = r - d, c = r + d) : (d = s / 2, a = n - d, l = n + d, u = Math.min(r, i), c = Math.max(r, i)), { left: a, top: u, right: l, bottom: c } } function Hn(t, e, n, r) { return t ? 0 : Wt(e, n, r) } function PI(t, e, n) { const r = t.options.borderWidth, i = t.borderSkipped, s = Rb(r); return { t: Hn(i.top, s.top, 0, n), r: Hn(i.right, s.right, 0, e), b: Hn(i.bottom, s.bottom, 0, n), l: Hn(i.left, s.left, 0, e) } } function EI(t, e, n) { const { enableBorderRadius: r } = t.getProps(["enableBorderRadius"]), i = t.options.borderRadius, s = Er(i), o = Math.min(e, n), a = t.borderSkipped, l = r || ie(i); return { topLeft: Hn(!l || a.top || a.left, s.topLeft, 0, o), topRight: Hn(!l || a.top || a.right, s.topRight, 0, o), bottomLeft: Hn(!l || a.bottom || a.left, s.bottomLeft, 0, o), bottomRight: Hn(!l || a.bottom || a.right, s.bottomRight, 0, o) } } function TI(t) { const e = Qb(t), n = e.right - e.left, r = e.bottom - e.top, i = PI(t, n / 2, r / 2), s = EI(t, n / 2, r / 2); return { outer: { x: e.left, y: e.top, w: n, h: r, radius: s }, inner: { x: e.left + i.l, y: e.top + i.t, w: n - i.l - i.r, h: r - i.t - i.b, radius: { topLeft: Math.max(0, s.topLeft - Math.max(i.t, i.l)), topRight: Math.max(0, s.topRight - Math.max(i.t, i.r)), bottomLeft: Math.max(0, s.bottomLeft - Math.max(i.b, i.l)), bottomRight: Math.max(0, s.bottomRight - Math.max(i.b, i.r)) } } } } function dc(t, e, n, r) { const i = e === null, s = n === null, a = t && !(i && s) && Qb(t, r); return a && (i || di(e, a.left, a.right)) && (s || di(n, a.top, a.bottom)) } function II(t) { return t.topLeft || t.topRight || t.bottomLeft || t.bottomRight } function RI(t, e) { t.rect(e.x, e.y, e.w, e.h) } function hc(t, e, n = {}) { const r = t.x !== n.x ? -e : 0, i = t.y !== n.y ? -e : 0, s = (t.x + t.w !== n.x + n.w ? e : 0) - r, o = (t.y + t.h !== n.y + n.h ? e : 0) - i; return { x: t.x + r, y: t.y + i, w: t.w + s, h: t.h + o, radius: t.radius } } class Ta extends Ui { constructor(e) { super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e) } draw(e) { const { inflateAmount: n, options: { borderColor: r, backgroundColor: i } } = this, { inner: s, outer: o } = TI(this), a = II(o.radius) ? no : RI; e.save(), (o.w !== s.w || o.h !== s.h) && (e.beginPath(), a(e, hc(o, n, s)), e.clip(), a(e, hc(s, -n, o)), e.fillStyle = r, e.fill("evenodd")), e.beginPath(), a(e, hc(s, n)), e.fillStyle = i, e.fill(), e.restore() } inRange(e, n, r) { return dc(this, e, n, r) } inXRange(e, n) { return dc(this, e, null, n) } inYRange(e, n) { return dc(this, null, e, n) } getCenterPoint(e) { const { x: n, y: r, base: i, horizontal: s } = this.getProps(["x", "y", "base", "horizontal"], e); return { x: s ? (n + i) / 2 : n, y: s ? r : (r + i) / 2 } } getRange(e) { return e === "x" ? this.width / 2 : this.height / 2 } } J(Ta, "id", "bar"), J(Ta, "defaults", { borderSkipped: "start", borderWidth: 0, borderRadius: 0, inflateAmount: "auto", pointStyle: void 0 }), J(Ta, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); const gm = (t, e) => { let { boxHeight: n = e, boxWidth: r = e } = t; return t.usePointStyle && (n = Math.min(n, e), r = t.pointStyleWidth || Math.min(r, e)), { boxWidth: r, boxHeight: n, itemHeight: Math.max(e, n) } }, MI = (t, e) => t !== null && e !== null && t.datasetIndex === e.datasetIndex && t.index === e.index; class mm extends Ui { constructor(e) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, n, r) { this.maxWidth = e, this.maxHeight = n, this._margins = r, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels() { const e = this.options.labels || {}; let n = ge(e.generateLabels, [this.chart], this) || []; e.filter && (n = n.filter(r => e.filter(r, this.chart.data))), e.sort && (n = n.sort((r, i) => e.sort(r, i, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n } fit() { const { options: e, ctx: n } = this; if (!e.display) { this.width = this.height = 0; return } const r = e.labels, i = De(r.font), s = i.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = gm(r, s); let u, c; n.font = i.string, this.isHorizontal() ? (u = this.maxWidth, c = this._fitRows(o, s, a, l) + 10) : (c = this.maxHeight, u = this._fitCols(o, i, a, l) + 10), this.width = Math.min(u, e.maxWidth || this.maxWidth), this.height = Math.min(c, e.maxHeight || this.maxHeight) } _fitRows(e, n, r, i) { const { ctx: s, maxWidth: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], u = this.lineWidths = [0], c = i + a; let d = e; s.textAlign = "left", s.textBaseline = "middle"; let h = -1, f = -c; return this.legendItems.forEach((g, m) => { const y = r + n / 2 + s.measureText(g.text).width; (m === 0 || u[u.length - 1] + y + 2 * a > o) && (d += c, u[u.length - (m > 0 ? 0 : 1)] = 0, f += c, h++), l[m] = { left: 0, top: f, row: h, width: y, height: i }, u[u.length - 1] += y + a }), d } _fitCols(e, n, r, i) { const { ctx: s, maxHeight: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], u = this.columnSizes = [], c = o - e; let d = a, h = 0, f = 0, g = 0, m = 0; return this.legendItems.forEach((y, p) => { const { itemWidth: v, itemHeight: b } = LI(r, n, s, y, i); p > 0 && f + b + 2 * a > c && (d += h + a, u.push({ width: h, height: f }), g += h + a, m++, h = f = 0), l[p] = { left: g, top: f, col: m, width: v, height: b }, h = Math.max(h, v), f += b + a }), d += h, u.push({ width: h, height: f }), d } adjustHitBoxes() { if (!this.options.display) return; const e = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: r, labels: { padding: i }, rtl: s } } = this, o = _i(s, this.left, this.width); if (this.isHorizontal()) { let a = 0, l = Qe(r, this.left + i, this.right - this.lineWidths[a]); for (const u of n) a !== u.row && (a = u.row, l = Qe(r, this.left + i, this.right - this.lineWidths[a])), u.top += this.top + e + i, u.left = o.leftForLtr(o.x(l), u.width), l += u.width + i } else { let a = 0, l = Qe(r, this.top + e + i, this.bottom - this.columnSizes[a].height); for (const u of n) u.col !== a && (a = u.col, l = Qe(r, this.top + e + i, this.bottom - this.columnSizes[a].height)), u.top = l, u.left += this.left + i, u.left = o.leftForLtr(o.x(u.left), u.width), l += u.height + i } } isHorizontal() { return this.options.position === "top" || this.options.position === "bottom" } draw() { if (this.options.display) { const e = this.ctx; nf(e, this), this._draw(), rf(e) } } _draw() { const { options: e, columnSizes: n, lineWidths: r, ctx: i } = this, { align: s, labels: o } = e, a = Ce.color, l = _i(e.rtl, this.left, this.width), u = De(o.font), { padding: c } = o, d = u.size, h = d / 2; let f; this.drawTitle(), i.textAlign = l.textAlign("left"), i.textBaseline = "middle", i.lineWidth = .5, i.font = u.string; const { boxWidth: g, boxHeight: m, itemHeight: y } = gm(o, d), p = function (I, T, k) { if (isNaN(g) || g <= 0 || isNaN(m) || m < 0) return; i.save(); const E = le(k.lineWidth, 1); if (i.fillStyle = le(k.fillStyle, a), i.lineCap = le(k.lineCap, "butt"), i.lineDashOffset = le(k.lineDashOffset, 0), i.lineJoin = le(k.lineJoin, "miter"), i.lineWidth = E, i.strokeStyle = le(k.strokeStyle, a), i.setLineDash(le(k.lineDash, [])), o.usePointStyle) { const M = { radius: m * Math.SQRT2 / 2, pointStyle: k.pointStyle, rotation: k.rotation, borderWidth: E }, L = l.xPlus(I, g / 2), N = T + h; Tb(i, M, L, N, o.pointStyleWidth && g) } else { const M = T + Math.max((d - m) / 2, 0), L = l.leftForLtr(I, g), N = Er(k.borderRadius); i.beginPath(), Object.values(N).some($ => $ !== 0) ? no(i, { x: L, y: M, w: g, h: m, radius: N }) : i.rect(L, M, g, m), i.fill(), E !== 0 && i.stroke() } i.restore() }, v = function (I, T, k) { jr(i, k.text, I, T + y / 2, u, { strikethrough: k.hidden, textAlign: l.textAlign(k.textAlign) }) }, b = this.isHorizontal(), S = this._computeTitleHeight(); b ? f = { x: Qe(s, this.left + c, this.right - r[0]), y: this.top + c + S, line: 0 } : f = { x: this.left + c, y: Qe(s, this.top + S + c, this.bottom - n[0].height), line: 0 }, jb(this.ctx, e.textDirection); const P = y + c; this.legendItems.forEach((I, T) => { i.strokeStyle = I.fontColor, i.fillStyle = I.fontColor; const k = i.measureText(I.text).width, E = l.textAlign(I.textAlign || (I.textAlign = o.textAlign)), M = g + h + k; let L = f.x, N = f.y; l.setWidth(this.width), b ? T > 0 && L + M + c > this.right && (N = f.y += P, f.line++, L = f.x = Qe(s, this.left + c, this.right - r[f.line])) : T > 0 && N + P > this.bottom && (L = f.x = L + n[f.line].width + c, f.line++, N = f.y = Qe(s, this.top + S + c, this.bottom - n[f.line].height)); const $ = l.x(L); if (p($, N, I), L = cE(E, L + g + h, b ? L + M : this.right, e.rtl), v(l.x(L), N, I), b) f.x += M + c; else if (typeof I.text != "string") { const B = u.lineHeight; f.y += Xb(I, B) + c } else f.y += P }), Nb(this.ctx, e.textDirection) } drawTitle() { const e = this.options, n = e.title, r = De(n.font), i = et(n.padding); if (!n.display) return; const s = _i(e.rtl, this.left, this.width), o = this.ctx, a = n.position, l = r.size / 2, u = i.top + l; let c, d = this.left, h = this.width; if (this.isHorizontal()) h = Math.max(...this.lineWidths), c = this.top + u, d = Qe(e.align, d, this.right - h); else { const g = this.columnSizes.reduce((m, y) => Math.max(m, y.height), 0); c = u + Qe(e.align, this.top, this.bottom - g - e.labels.padding - this._computeTitleHeight()) } const f = Qe(a, d, d + h); o.textAlign = s.textAlign(ef(a)), o.textBaseline = "middle", o.strokeStyle = n.color, o.fillStyle = n.color, o.font = r.string, jr(o, n.text, f, c, r) } _computeTitleHeight() { const e = this.options.title, n = De(e.font), r = et(e.padding); return e.display ? n.lineHeight + r.height : 0 } _getLegendItemAt(e, n) { let r, i, s; if (di(e, this.left, this.right) && di(n, this.top, this.bottom)) { for (s = this.legendHitBoxes, r = 0; r < s.length; ++r)if (i = s[r], di(e, i.left, i.left + i.width) && di(n, i.top, i.top + i.height)) return this.legendItems[r] } return null } handleEvent(e) { const n = this.options; if (!jI(e.type, n)) return; const r = this._getLegendItemAt(e.x, e.y); if (e.type === "mousemove" || e.type === "mouseout") { const i = this._hoveredItem, s = MI(i, r); i && !s && ge(n.onLeave, [e, i, this], this), this._hoveredItem = r, r && !s && ge(n.onHover, [e, r, this], this) } else r && ge(n.onClick, [e, r, this], this) } } function LI(t, e, n, r, i) { const s = DI(r, t, e, n), o = AI(i, r, e.lineHeight); return { itemWidth: s, itemHeight: o } } function DI(t, e, n, r) { let i = t.text; return i && typeof i != "string" && (i = i.reduce((s, o) => s.length > o.length ? s : o)), e + n.size / 2 + r.measureText(i).width } function AI(t, e, n) { let r = t; return typeof e.text != "string" && (r = Xb(e, n)), r } function Xb(t, e) { const n = t.text ? t.text.length : 0; return e * n } function jI(t, e) { return !!((t === "mousemove" || t === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t === "click" || t === "mouseup")) } var NI = { id: "legend", _element: mm, start(t, e, n) { const r = t.legend = new mm({ ctx: t.ctx, options: n, chart: t }); Lt.configure(t, r, n), Lt.addBox(t, r) }, stop(t) { Lt.removeBox(t, t.legend), delete t.legend }, beforeUpdate(t, e, n) { const r = t.legend; Lt.configure(t, r, n), r.options = n }, afterUpdate(t) { const e = t.legend; e.buildLabels(), e.adjustHitBoxes() }, afterEvent(t, e) { e.replay || t.legend.handleEvent(e.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(t, e, n) { const r = e.datasetIndex, i = n.chart; i.isDatasetVisible(r) ? (i.hide(r), e.hidden = !0) : (i.show(r), e.hidden = !1) }, onHover: null, onLeave: null, labels: { color: t => t.chart.options.color, boxWidth: 40, padding: 10, generateLabels(t) { const e = t.data.datasets, { labels: { usePointStyle: n, pointStyle: r, textAlign: i, color: s, useBorderRadius: o, borderRadius: a } } = t.legend.options; return t._getSortedDatasetMetas().map(l => { const u = l.controller.getStyle(n ? 0 : void 0), c = et(u.borderWidth); return { text: e[l.index].label, fillStyle: u.backgroundColor, fontColor: s, hidden: !l.visible, lineCap: u.borderCapStyle, lineDash: u.borderDash, lineDashOffset: u.borderDashOffset, lineJoin: u.borderJoinStyle, lineWidth: (c.width + c.height) / 4, strokeStyle: u.borderColor, pointStyle: r || u.pointStyle, rotation: u.rotation, textAlign: i || u.textAlign, borderRadius: o && (a || u.borderRadius), datasetIndex: l.index } }, this) } }, title: { color: t => t.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: t => !t.startsWith("on"), labels: { _scriptable: t => !["generateLabels", "filter", "sort"].includes(t) } } }; class Jb extends Ui { constructor(e) { super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, n) { const r = this.options; if (this.left = 0, this.top = 0, !r.display) { this.width = this.height = this.right = this.bottom = 0; return } this.width = this.right = e, this.height = this.bottom = n; const i = we(r.text) ? r.text.length : 1; this._padding = et(r.padding); const s = i * De(r.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = s : this.width = s } isHorizontal() { const e = this.options.position; return e === "top" || e === "bottom" } _drawArgs(e) { const { top: n, left: r, bottom: i, right: s, options: o } = this, a = o.align; let l = 0, u, c, d; return this.isHorizontal() ? (c = Qe(a, r, s), d = n + e, u = s - r) : (o.position === "left" ? (c = r + e, d = Qe(a, i, n), l = $e * -.5) : (c = s - e, d = Qe(a, n, i), l = $e * .5), u = i - n), { titleX: c, titleY: d, maxWidth: u, rotation: l } } draw() { const e = this.ctx, n = this.options; if (!n.display) return; const r = De(n.font), s = r.lineHeight / 2 + this._padding.top, { titleX: o, titleY: a, maxWidth: l, rotation: u } = this._drawArgs(s); jr(e, n.text, 0, 0, r, { color: n.color, maxWidth: l, rotation: u, textAlign: ef(n.align), textBaseline: "middle", translation: [o, a] }) } } function FI(t, e) { const n = new Jb({ ctx: t.ctx, options: e, chart: t }); Lt.configure(t, n, e), Lt.addBox(t, n), t.titleBlock = n } var $I = { id: "title", _element: Jb, start(t, e, n) { FI(t, n) }, stop(t) { const e = t.titleBlock; Lt.removeBox(t, e), delete t.titleBlock }, beforeUpdate(t, e, n) { const r = t.titleBlock; Lt.configure(t, r, n), r.options = n }, defaults: { align: "center", display: !1, font: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const ms = { average(t) { if (!t.length) return !1; let e, n, r = new Set, i = 0, s = 0; for (e = 0, n = t.length; e < n; ++e) { const a = t[e].element; if (a && a.hasValue()) { const l = a.tooltipPosition(); r.add(l.x), i += l.y, ++s } } return { x: [...r].reduce((a, l) => a + l) / r.size, y: i / s } }, nearest(t, e) { if (!t.length) return !1; let n = e.x, r = e.y, i = Number.POSITIVE_INFINITY, s, o, a; for (s = 0, o = t.length; s < o; ++s) { const l = t[s].element; if (l && l.hasValue()) { const u = l.getCenterPoint(), c = rE(e, u); c < i && (i = c, a = l) } } if (a) { const l = a.tooltipPosition(); n = l.x, r = l.y } return { x: n, y: r } } }; function Xt(t, e) { return e && (we(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function pn(t) {
  return (typeof t == "string" || t instanceof String) && t.indexOf(`
`) > -1 ? t.split(`
`) : t
} function zI(t, e) { const { element: n, datasetIndex: r, index: i } = e, s = t.getDatasetMeta(r).controller, { label: o, value: a } = s.getLabelAndValue(i); return { chart: t, label: o, parsed: s.getParsed(i), raw: t.data.datasets[r].data[i], formattedValue: a, dataset: s.getDataset(), dataIndex: i, datasetIndex: r, element: n } } function vm(t, e) { const n = t.chart.ctx, { body: r, footer: i, title: s } = t, { boxWidth: o, boxHeight: a } = e, l = De(e.bodyFont), u = De(e.titleFont), c = De(e.footerFont), d = s.length, h = i.length, f = r.length, g = et(e.padding); let m = g.height, y = 0, p = r.reduce((S, P) => S + P.before.length + P.lines.length + P.after.length, 0); if (p += t.beforeBody.length + t.afterBody.length, d && (m += d * u.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), p) { const S = e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight; m += f * S + (p - f) * l.lineHeight + (p - 1) * e.bodySpacing } h && (m += e.footerMarginTop + h * c.lineHeight + (h - 1) * e.footerSpacing); let v = 0; const b = function (S) { y = Math.max(y, n.measureText(S).width + v) }; return n.save(), n.font = u.string, ce(t.title, b), n.font = l.string, ce(t.beforeBody.concat(t.afterBody), b), v = e.displayColors ? o + 2 + e.boxPadding : 0, ce(r, S => { ce(S.before, b), ce(S.lines, b), ce(S.after, b) }), v = 0, n.font = c.string, ce(t.footer, b), n.restore(), y += g.width, { width: y, height: m } } function VI(t, e) { const { y: n, height: r } = e; return n < r / 2 ? "top" : n > t.height - r / 2 ? "bottom" : "center" } function BI(t, e, n, r) { const { x: i, width: s } = r, o = n.caretSize + n.caretPadding; if (t === "left" && i + s + o > e.width || t === "right" && i - s - o < 0) return !0 } function UI(t, e, n, r) { const { x: i, width: s } = n, { width: o, chartArea: { left: a, right: l } } = t; let u = "center"; return r === "center" ? u = i <= (a + l) / 2 ? "left" : "right" : i <= s / 2 ? u = "left" : i >= o - s / 2 && (u = "right"), BI(u, t, e, n) && (u = "center"), u } function ym(t, e, n) { const r = n.yAlign || e.yAlign || VI(t, n); return { xAlign: n.xAlign || e.xAlign || UI(t, e, n, r), yAlign: r } } function HI(t, e) { let { x: n, width: r } = t; return e === "right" ? n -= r : e === "center" && (n -= r / 2), n } function WI(t, e, n) { let { y: r, height: i } = t; return e === "top" ? r += n : e === "bottom" ? r -= i + n : r -= i / 2, r } function bm(t, e, n, r) { const { caretSize: i, caretPadding: s, cornerRadius: o } = t, { xAlign: a, yAlign: l } = n, u = i + s, { topLeft: c, topRight: d, bottomLeft: h, bottomRight: f } = Er(o); let g = HI(e, a); const m = WI(e, l, u); return l === "center" ? a === "left" ? g += u : a === "right" && (g -= u) : a === "left" ? g -= Math.max(c, h) + i : a === "right" && (g += Math.max(d, f) + i), { x: Wt(g, 0, r.width - e.width), y: Wt(m, 0, r.height - e.height) } } function ia(t, e, n) { const r = et(n.padding); return e === "center" ? t.x + t.width / 2 : e === "right" ? t.x + t.width - r.right : t.x + r.left } function _m(t) { return Xt([], pn(t)) } function qI(t, e, n) { return Vr(t, { tooltip: e, tooltipItems: n, type: "tooltip" }) } function wm(t, e) { const n = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks; return n ? t.override(n) : t } const Zb = { beforeTitle: dn, title(t) { if (t.length > 0) { const e = t[0], n = e.chart.data.labels, r = n ? n.length : 0; if (this && this.options && this.options.mode === "dataset") return e.dataset.label || ""; if (e.label) return e.label; if (r > 0 && e.dataIndex < r) return n[e.dataIndex] } return "" }, afterTitle: dn, beforeBody: dn, beforeLabel: dn, label(t) { if (this && this.options && this.options.mode === "dataset") return t.label + ": " + t.formattedValue || t.formattedValue; let e = t.dataset.label || ""; e && (e += ": "); const n = t.formattedValue; return fe(n) || (e += n), e }, labelColor(t) { const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { borderColor: n.borderColor, backgroundColor: n.backgroundColor, borderWidth: n.borderWidth, borderDash: n.borderDash, borderDashOffset: n.borderDashOffset, borderRadius: 0 } }, labelTextColor() { return this.options.bodyColor }, labelPointStyle(t) { const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { pointStyle: n.pointStyle, rotation: n.rotation } }, afterLabel: dn, afterBody: dn, beforeFooter: dn, footer: dn, afterFooter: dn }; function at(t, e, n, r) { const i = t[e].call(n, r); return typeof i > "u" ? Zb[e].call(n, r) : i } class Id extends Ui { constructor(e) { super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(e) { this.options = e, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations() { const e = this._cachedAnimations; if (e) return e; const n = this.chart, r = this.options.setContext(this.getContext()), i = r.enabled && n.options.animation && r.animations, s = new Fb(this.chart, i); return i._cacheable && (this._cachedAnimations = Object.freeze(s)), s } getContext() { return this.$context || (this.$context = qI(this.chart.getContext(), this, this._tooltipItems)) } getTitle(e, n) { const { callbacks: r } = n, i = at(r, "beforeTitle", this, e), s = at(r, "title", this, e), o = at(r, "afterTitle", this, e); let a = []; return a = Xt(a, pn(i)), a = Xt(a, pn(s)), a = Xt(a, pn(o)), a } getBeforeBody(e, n) { return _m(at(n.callbacks, "beforeBody", this, e)) } getBody(e, n) { const { callbacks: r } = n, i = []; return ce(e, s => { const o = { before: [], lines: [], after: [] }, a = wm(r, s); Xt(o.before, pn(at(a, "beforeLabel", this, s))), Xt(o.lines, at(a, "label", this, s)), Xt(o.after, pn(at(a, "afterLabel", this, s))), i.push(o) }), i } getAfterBody(e, n) { return _m(at(n.callbacks, "afterBody", this, e)) } getFooter(e, n) { const { callbacks: r } = n, i = at(r, "beforeFooter", this, e), s = at(r, "footer", this, e), o = at(r, "afterFooter", this, e); let a = []; return a = Xt(a, pn(i)), a = Xt(a, pn(s)), a = Xt(a, pn(o)), a } _createItems(e) { const n = this._active, r = this.chart.data, i = [], s = [], o = []; let a = [], l, u; for (l = 0, u = n.length; l < u; ++l)a.push(zI(this.chart, n[l])); return e.filter && (a = a.filter((c, d, h) => e.filter(c, d, h, r))), e.itemSort && (a = a.sort((c, d) => e.itemSort(c, d, r))), ce(a, c => { const d = wm(e.callbacks, c); i.push(at(d, "labelColor", this, c)), s.push(at(d, "labelPointStyle", this, c)), o.push(at(d, "labelTextColor", this, c)) }), this.labelColors = i, this.labelPointStyles = s, this.labelTextColors = o, this.dataPoints = a, a } update(e, n) { const r = this.options.setContext(this.getContext()), i = this._active; let s, o = []; if (!i.length) this.opacity !== 0 && (s = { opacity: 0 }); else { const a = ms[r.position].call(this, i, this._eventPosition); o = this._createItems(r), this.title = this.getTitle(o, r), this.beforeBody = this.getBeforeBody(o, r), this.body = this.getBody(o, r), this.afterBody = this.getAfterBody(o, r), this.footer = this.getFooter(o, r); const l = this._size = vm(this, r), u = Object.assign({}, a, l), c = ym(this.chart, r, u), d = bm(r, u, c, this.chart); this.xAlign = c.xAlign, this.yAlign = c.yAlign, s = { opacity: 1, x: d.x, y: d.y, width: l.width, height: l.height, caretX: a.x, caretY: a.y } } this._tooltipItems = o, this.$context = void 0, s && this._resolveAnimations().update(this, s), e && r.external && r.external.call(this, { chart: this.chart, tooltip: this, replay: n }) } drawCaret(e, n, r, i) { const s = this.getCaretPosition(e, r, i); n.lineTo(s.x1, s.y1), n.lineTo(s.x2, s.y2), n.lineTo(s.x3, s.y3) } getCaretPosition(e, n, r) { const { xAlign: i, yAlign: s } = this, { caretSize: o, cornerRadius: a } = r, { topLeft: l, topRight: u, bottomLeft: c, bottomRight: d } = Er(a), { x: h, y: f } = e, { width: g, height: m } = n; let y, p, v, b, S, P; return s === "center" ? (S = f + m / 2, i === "left" ? (y = h, p = y - o, b = S + o, P = S - o) : (y = h + g, p = y + o, b = S - o, P = S + o), v = y) : (i === "left" ? p = h + Math.max(l, c) + o : i === "right" ? p = h + g - Math.max(u, d) - o : p = this.caretX, s === "top" ? (b = f, S = b - o, y = p - o, v = p + o) : (b = f + m, S = b + o, y = p + o, v = p - o), P = b), { x1: y, x2: p, x3: v, y1: b, y2: S, y3: P } } drawTitle(e, n, r) { const i = this.title, s = i.length; let o, a, l; if (s) { const u = _i(r.rtl, this.x, this.width); for (e.x = ia(this, r.titleAlign, r), n.textAlign = u.textAlign(r.titleAlign), n.textBaseline = "middle", o = De(r.titleFont), a = r.titleSpacing, n.fillStyle = r.titleColor, n.font = o.string, l = 0; l < s; ++l)n.fillText(i[l], u.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + a, l + 1 === s && (e.y += r.titleMarginBottom - a) } } _drawColorBox(e, n, r, i, s) { const o = this.labelColors[r], a = this.labelPointStyles[r], { boxHeight: l, boxWidth: u } = s, c = De(s.bodyFont), d = ia(this, "left", s), h = i.x(d), f = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, g = n.y + f; if (s.usePointStyle) { const m = { radius: Math.min(u, l) / 2, pointStyle: a.pointStyle, rotation: a.rotation, borderWidth: 1 }, y = i.leftForLtr(h, u) + u / 2, p = g + l / 2; e.strokeStyle = s.multiKeyBackground, e.fillStyle = s.multiKeyBackground, Ag(e, m, y, p), e.strokeStyle = o.borderColor, e.fillStyle = o.backgroundColor, Ag(e, m, y, p) } else { e.lineWidth = ie(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, e.strokeStyle = o.borderColor, e.setLineDash(o.borderDash || []), e.lineDashOffset = o.borderDashOffset || 0; const m = i.leftForLtr(h, u), y = i.leftForLtr(i.xPlus(h, 1), u - 2), p = Er(o.borderRadius); Object.values(p).some(v => v !== 0) ? (e.beginPath(), e.fillStyle = s.multiKeyBackground, no(e, { x: m, y: g, w: u, h: l, radius: p }), e.fill(), e.stroke(), e.fillStyle = o.backgroundColor, e.beginPath(), no(e, { x: y, y: g + 1, w: u - 2, h: l - 2, radius: p }), e.fill()) : (e.fillStyle = s.multiKeyBackground, e.fillRect(m, g, u, l), e.strokeRect(m, g, u, l), e.fillStyle = o.backgroundColor, e.fillRect(y, g + 1, u - 2, l - 2)) } e.fillStyle = this.labelTextColors[r] } drawBody(e, n, r) { const { body: i } = this, { bodySpacing: s, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: u, boxPadding: c } = r, d = De(r.bodyFont); let h = d.lineHeight, f = 0; const g = _i(r.rtl, this.x, this.width), m = function (k) { n.fillText(k, g.x(e.x + f), e.y + h / 2), e.y += h + s }, y = g.textAlign(o); let p, v, b, S, P, I, T; for (n.textAlign = o, n.textBaseline = "middle", n.font = d.string, e.x = ia(this, y, r), n.fillStyle = r.bodyColor, ce(this.beforeBody, m), f = a && y !== "right" ? o === "center" ? u / 2 + c : u + 2 + c : 0, S = 0, I = i.length; S < I; ++S) { for (p = i[S], v = this.labelTextColors[S], n.fillStyle = v, ce(p.before, m), b = p.lines, a && b.length && (this._drawColorBox(n, e, S, g, r), h = Math.max(d.lineHeight, l)), P = 0, T = b.length; P < T; ++P)m(b[P]), h = d.lineHeight; ce(p.after, m) } f = 0, h = d.lineHeight, ce(this.afterBody, m), e.y -= s } drawFooter(e, n, r) { const i = this.footer, s = i.length; let o, a; if (s) { const l = _i(r.rtl, this.x, this.width); for (e.x = ia(this, r.footerAlign, r), e.y += r.footerMarginTop, n.textAlign = l.textAlign(r.footerAlign), n.textBaseline = "middle", o = De(r.footerFont), n.fillStyle = r.footerColor, n.font = o.string, a = 0; a < s; ++a)n.fillText(i[a], l.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + r.footerSpacing } } drawBackground(e, n, r, i) { const { xAlign: s, yAlign: o } = this, { x: a, y: l } = e, { width: u, height: c } = r, { topLeft: d, topRight: h, bottomLeft: f, bottomRight: g } = Er(i.cornerRadius); n.fillStyle = i.backgroundColor, n.strokeStyle = i.borderColor, n.lineWidth = i.borderWidth, n.beginPath(), n.moveTo(a + d, l), o === "top" && this.drawCaret(e, n, r, i), n.lineTo(a + u - h, l), n.quadraticCurveTo(a + u, l, a + u, l + h), o === "center" && s === "right" && this.drawCaret(e, n, r, i), n.lineTo(a + u, l + c - g), n.quadraticCurveTo(a + u, l + c, a + u - g, l + c), o === "bottom" && this.drawCaret(e, n, r, i), n.lineTo(a + f, l + c), n.quadraticCurveTo(a, l + c, a, l + c - f), o === "center" && s === "left" && this.drawCaret(e, n, r, i), n.lineTo(a, l + d), n.quadraticCurveTo(a, l, a + d, l), n.closePath(), n.fill(), i.borderWidth > 0 && n.stroke() } _updateAnimationTarget(e) { const n = this.chart, r = this.$animations, i = r && r.x, s = r && r.y; if (i || s) { const o = ms[e.position].call(this, this._active, this._eventPosition); if (!o) return; const a = this._size = vm(this, e), l = Object.assign({}, o, this._size), u = ym(n, e, l), c = bm(e, l, u, n); (i._to !== c.x || s._to !== c.y) && (this.xAlign = u.xAlign, this.yAlign = u.yAlign, this.width = a.width, this.height = a.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, c)) } } _willRender() { return !!this.opacity } draw(e) { const n = this.options.setContext(this.getContext()); let r = this.opacity; if (!r) return; this._updateAnimationTarget(n); const i = { width: this.width, height: this.height }, s = { x: this.x, y: this.y }; r = Math.abs(r) < .001 ? 0 : r; const o = et(n.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length; n.enabled && a && (e.save(), e.globalAlpha = r, this.drawBackground(s, e, i, n), jb(e, n.textDirection), s.y += o.top, this.drawTitle(s, e, n), this.drawBody(s, e, n), this.drawFooter(s, e, n), Nb(e, n.textDirection), e.restore()) } getActiveElements() { return this._active || [] } setActiveElements(e, n) { const r = this._active, i = e.map(({ datasetIndex: a, index: l }) => { const u = this.chart.getDatasetMeta(a); if (!u) throw new Error("Cannot find a dataset at index " + a); return { datasetIndex: a, element: u.data[l], index: l } }), s = !al(r, i), o = this._positionChanged(i, n); (s || o) && (this._active = i, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent(e, n, r = !0) { if (n && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const i = this.options, s = this._active || [], o = this._getActiveElements(e, s, n, r), a = this._positionChanged(o, e), l = n || !al(o, s) || a; return l && (this._active = o, (i.enabled || i.external) && (this._eventPosition = { x: e.x, y: e.y }, this.update(!0, n))), l } _getActiveElements(e, n, r, i) { const s = this.options; if (e.type === "mouseout") return []; if (!i) return n.filter(a => this.chart.data.datasets[a.datasetIndex] && this.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0); const o = this.chart.getElementsAtEventForMode(e, s.mode, s, r); return s.reverse && o.reverse(), o } _positionChanged(e, n) { const { caretX: r, caretY: i, options: s } = this, o = ms[s.position].call(this, e, n); return o !== !1 && (r !== o.x || i !== o.y) } } J(Id, "positioners", ms); var KI = { id: "tooltip", _element: Id, positioners: ms, afterInit(t, e, n) { n && (t.tooltip = new Id({ chart: t, options: n })) }, beforeUpdate(t, e, n) { t.tooltip && t.tooltip.initialize(n) }, reset(t, e, n) { t.tooltip && t.tooltip.initialize(n) }, afterDraw(t) { const e = t.tooltip; if (e && e._willRender()) { const n = { tooltip: e }; if (t.notifyPlugins("beforeTooltipDraw", { ...n, cancelable: !0 }) === !1) return; e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", n) } }, afterEvent(t, e) { if (t.tooltip) { const n = e.replay; t.tooltip.handleEvent(e.event, n, e.inChartArea) && (e.changed = !0) } }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (t, e) => e.bodyFont.size, boxWidth: (t, e) => e.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: Zb }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: t => t !== "filter" && t !== "itemSort" && t !== "external", _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] }; const GI = (t, e, n, r) => (typeof e == "string" ? (n = t.push(e) - 1, r.unshift({ index: n, label: e })) : isNaN(e) && (n = null), n); function YI(t, e, n, r) { const i = t.indexOf(e); if (i === -1) return GI(t, e, n, r); const s = t.lastIndexOf(e); return i !== s ? n : i } const QI = (t, e) => t === null ? null : Wt(Math.round(t), 0, e); function Sm(t) { const e = this.getLabels(); return t >= 0 && t < e.length ? e[t] : t } class Rd extends Br { constructor(e) { super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [] } init(e) { const n = this._addedLabels; if (n.length) { const r = this.getLabels(); for (const { index: i, label: s } of n) r[i] === s && r.splice(i, 1); this._addedLabels = [] } super.init(e) } parse(e, n) { if (fe(e)) return null; const r = this.getLabels(); return n = isFinite(n) && r[n] === e ? n : YI(r, e, le(n, e), this._addedLabels), QI(n, r.length - 1) } determineDataLimits() { const { minDefined: e, maxDefined: n } = this.getUserBounds(); let { min: r, max: i } = this.getMinMax(!0); this.options.bounds === "ticks" && (e || (r = 0), n || (i = this.getLabels().length - 1)), this.min = r, this.max = i } buildTicks() { const e = this.min, n = this.max, r = this.options.offset, i = []; let s = this.getLabels(); s = e === 0 && n === s.length - 1 ? s : s.slice(e, n + 1), this._valueRange = Math.max(s.length - (r ? 0 : 1), 1), this._startValue = this.min - (r ? .5 : 0); for (let o = e; o <= n; o++)i.push({ value: o }); return i } getLabelForValue(e) { return Sm.call(this, e) } configure() { super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } getPixelForValue(e) { return typeof e != "number" && (e = this.parse(e)), e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getPixelForTick(e) { const n = this.ticks; return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value) } getValueForPixel(e) { return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange) } getBasePixel() { return this.bottom } } J(Rd, "id", "category"), J(Rd, "defaults", { ticks: { callback: Sm } }); function XI(t, e) { const n = [], { bounds: i, step: s, min: o, max: a, precision: l, count: u, maxTicks: c, maxDigits: d, includeBounds: h } = t, f = s || 1, g = c - 1, { min: m, max: y } = e, p = !fe(o), v = !fe(a), b = !fe(u), S = (y - m) / (d + 1); let P = Pg((y - m) / g / f) * f, I, T, k, E; if (P < 1e-14 && !p && !v) return [{ value: m }, { value: y }]; E = Math.ceil(y / P) - Math.floor(m / P), E > g && (P = Pg(E * P / g / f) * f), fe(l) || (I = Math.pow(10, l), P = Math.ceil(P * I) / I), i === "ticks" ? (T = Math.floor(m / P) * P, k = Math.ceil(y / P) * P) : (T = m, k = y), p && v && s && tE((a - o) / s, P / 1e3) ? (E = Math.round(Math.min((a - o) / P, c)), P = (a - o) / E, T = o, k = a) : b ? (T = p ? o : T, k = v ? a : k, E = u - 1, P = (k - T) / E) : (E = (k - T) / P, Ca(E, Math.round(E), P / 1e3) ? E = Math.round(E) : E = Math.ceil(E)); const M = Math.max(Eg(P), Eg(T)); I = Math.pow(10, fe(l) ? M : l), T = Math.round(T * I) / I, k = Math.round(k * I) / I; let L = 0; for (p && (h && T !== o ? (n.push({ value: o }), T < o && L++, Ca(Math.round((T + L * P) * I) / I, o, xm(o, S, t)) && L++) : T < o && L++); L < E; ++L) { const N = Math.round((T + L * P) * I) / I; if (v && N > a) break; n.push({ value: N }) } return v && h && k !== a ? n.length && Ca(n[n.length - 1].value, a, xm(a, S, t)) ? n[n.length - 1].value = a : n.push({ value: a }) : (!v || k === a) && n.push({ value: k }), n } function xm(t, e, { horizontal: n, minRotation: r }) { const i = Un(r), s = (n ? Math.sin(i) : Math.cos(i)) || .001, o = .75 * e * ("" + t).length; return Math.min(e / s, o) } class pl extends Br { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse(e, n) { return fe(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e } handleTickRangeOptions() { const { beginAtZero: e } = this.options, { minDefined: n, maxDefined: r } = this.getUserBounds(); let { min: i, max: s } = this; const o = l => i = n ? i : l, a = l => s = r ? s : l; if (e) { const l = tr(i), u = tr(s); l < 0 && u < 0 ? a(0) : l > 0 && u > 0 && o(0) } if (i === s) { let l = s === 0 ? 1 : Math.abs(s * .05); a(s + l), e || o(i - l) } this.min = i, this.max = s } getTickLimit() { const e = this.options.ticks; let { maxTicksLimit: n, stepSize: r } = e, i; return r ? (i = Math.ceil(this.max / r) - Math.floor(this.min / r) + 1, i > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${i} ticks. Limiting to 1000.`), i = 1e3)) : (i = this.computeTickLimit(), n = n || 11), n && (i = Math.min(n, i)), i } computeTickLimit() { return Number.POSITIVE_INFINITY } buildTicks() { const e = this.options, n = e.ticks; let r = this.getTickLimit(); r = Math.max(2, r); const i = { maxTicks: r, bounds: e.bounds, min: e.min, max: e.max, precision: n.precision, step: n.stepSize, count: n.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: n.minRotation || 0, includeBounds: n.includeBounds !== !1 }, s = this._range || this, o = XI(i, s); return e.bounds === "ticks" && Sb(o, this, "value"), e.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o } configure() { const e = this.ticks; let n = this.min, r = this.max; if (super.configure(), this.options.offset && e.length) { const i = (r - n) / Math.max(e.length - 1, 1) / 2; n -= i, r += i } this._startValue = n, this._endValue = r, this._valueRange = r - n } getLabelForValue(e) { return tf(e, this.chart.options.locale, this.options.ticks.format) } } class Md extends pl { determineDataLimits() { const { min: e, max: n } = this.getMinMax(!0); this.min = Ne(e) ? e : 0, this.max = Ne(n) ? n : 1, this.handleTickRangeOptions() } computeTickLimit() { const e = this.isHorizontal(), n = e ? this.width : this.height, r = Un(this.options.ticks.minRotation), i = (e ? Math.sin(r) : Math.cos(r)) || .001, s = this._resolveTickFontOptions(0); return Math.ceil(n / Math.min(40, s.lineHeight / i)) } getPixelForValue(e) { return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getValueForPixel(e) { return this._startValue + this.getDecimalForPixel(e) * this._valueRange } } J(Md, "id", "linear"), J(Md, "defaults", { ticks: { callback: Jl.formatters.numeric } }); const io = t => Math.floor(Bn(t)), vr = (t, e) => Math.pow(10, io(t) + e); function km(t) { return t / Math.pow(10, io(t)) === 1 } function Cm(t, e, n) { const r = Math.pow(10, n), i = Math.floor(t / r); return Math.ceil(e / r) - i } function JI(t, e) { const n = e - t; let r = io(n); for (; Cm(t, e, r) > 10;)r++; for (; Cm(t, e, r) < 10;)r--; return Math.min(r, io(t)) } function ZI(t, { min: e, max: n }) { e = mt(t.min, e); const r = [], i = io(e); let s = JI(e, n), o = s < 0 ? Math.pow(10, Math.abs(s)) : 1; const a = Math.pow(10, s), l = i > s ? Math.pow(10, i) : 0, u = Math.round((e - l) * o) / o, c = Math.floor((e - l) / a / 10) * a * 10; let d = Math.floor((u - c) / Math.pow(10, s)), h = mt(t.min, Math.round((l + c + d * Math.pow(10, s)) * o) / o); for (; h < n;)r.push({ value: h, major: km(h), significand: d }), d >= 10 ? d = d < 15 ? 15 : 20 : d++, d >= 20 && (s++, d = 2, o = s >= 0 ? 1 : o), h = Math.round((l + c + d * Math.pow(10, s)) * o) / o; const f = mt(t.max, h); return r.push({ value: f, major: km(f), significand: d }), r } class Om extends Br { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(e, n) { const r = pl.prototype.parse.apply(this, [e, n]); if (r === 0) { this._zero = !0; return } return Ne(r) && r > 0 ? r : null } determineDataLimits() { const { min: e, max: n } = this.getMinMax(!0); this.min = Ne(e) ? Math.max(0, e) : null, this.max = Ne(n) ? Math.max(0, n) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Ne(this._userMin) && (this.min = e === vr(this.min, 0) ? vr(this.min, -1) : vr(this.min, 0)), this.handleTickRangeOptions() } handleTickRangeOptions() { const { minDefined: e, maxDefined: n } = this.getUserBounds(); let r = this.min, i = this.max; const s = a => r = e ? r : a, o = a => i = n ? i : a; r === i && (r <= 0 ? (s(1), o(10)) : (s(vr(r, -1)), o(vr(i, 1)))), r <= 0 && s(vr(i, -1)), i <= 0 && o(vr(r, 1)), this.min = r, this.max = i } buildTicks() { const e = this.options, n = { min: this._userMin, max: this._userMax }, r = ZI(n, this); return e.bounds === "ticks" && Sb(r, this, "value"), e.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r } getLabelForValue(e) { return e === void 0 ? "0" : tf(e, this.chart.options.locale, this.options.ticks.format) } configure() { const e = this.min; super.configure(), this._startValue = Bn(e), this._valueRange = Bn(this.max) - Bn(e) } getPixelForValue(e) { return (e === void 0 || e === 0) && (e = this.min), e === null || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (Bn(e) - this._startValue) / this._valueRange) } getValueForPixel(e) { const n = this.getDecimalForPixel(e); return Math.pow(10, this._startValue + n * this._valueRange) } } J(Om, "id", "logarithmic"), J(Om, "defaults", { ticks: { callback: Jl.formatters.logarithmic, major: { enabled: !0 } } }); function Ld(t) { const e = t.ticks; if (e.display && t.display) { const n = et(e.backdropPadding); return le(e.font && e.font.size, Ce.font.size) + n.height } return 0 } function e2(t, e, n) { return n = we(n) ? n : [n], { w: _E(t, e.string, n), h: n.length * e.lineHeight } } function Pm(t, e, n, r, i) { return t === r || t === i ? { start: e - n / 2, end: e + n / 2 } : t < r || t > i ? { start: e - n, end: e } : { start: e, end: e + n } } function t2(t) { const e = { l: t.left + t._padding.left, r: t.right - t._padding.right, t: t.top + t._padding.top, b: t.bottom - t._padding.bottom }, n = Object.assign({}, e), r = [], i = [], s = t._pointLabels.length, o = t.options.pointLabels, a = o.centerPointLabels ? $e / s : 0; for (let l = 0; l < s; l++) { const u = o.setContext(t.getPointLabelContext(l)); i[l] = u.padding; const c = t.getPointPosition(l, t.drawingArea + i[l], a), d = De(u.font), h = e2(t.ctx, d, t._pointLabels[l]); r[l] = h; const f = en(t.getIndexAngle(l) + a), g = Math.round(Jh(f)), m = Pm(g, c.x, h.w, 0, 180), y = Pm(g, c.y, h.h, 90, 270); n2(n, e, f, m, y) } t.setCenterPoint(e.l - n.l, n.r - e.r, e.t - n.t, n.b - e.b), t._pointLabelItems = s2(t, r, i) } function n2(t, e, n, r, i) { const s = Math.abs(Math.sin(n)), o = Math.abs(Math.cos(n)); let a = 0, l = 0; r.start < e.l ? (a = (e.l - r.start) / s, t.l = Math.min(t.l, e.l - a)) : r.end > e.r && (a = (r.end - e.r) / s, t.r = Math.max(t.r, e.r + a)), i.start < e.t ? (l = (e.t - i.start) / o, t.t = Math.min(t.t, e.t - l)) : i.end > e.b && (l = (i.end - e.b) / o, t.b = Math.max(t.b, e.b + l)) } function r2(t, e, n) { const r = t.drawingArea, { extra: i, additionalAngle: s, padding: o, size: a } = n, l = t.getPointPosition(e, r + i + o, s), u = Math.round(Jh(en(l.angle + bt))), c = l2(l.y, a.h, u), d = o2(u), h = a2(l.x, a.w, d); return { visible: !0, x: l.x, y: c, textAlign: d, left: h, top: c, right: h + a.w, bottom: c + a.h } } function i2(t, e) { if (!e) return !0; const { left: n, top: r, right: i, bottom: s } = t; return !(hi({ x: n, y: r }, e) || hi({ x: n, y: s }, e) || hi({ x: i, y: r }, e) || hi({ x: i, y: s }, e)) } function s2(t, e, n) { const r = [], i = t._pointLabels.length, s = t.options, { centerPointLabels: o, display: a } = s.pointLabels, l = { extra: Ld(s) / 2, additionalAngle: o ? $e / i : 0 }; let u; for (let c = 0; c < i; c++) { l.padding = n[c], l.size = e[c]; const d = r2(t, c, l); r.push(d), a === "auto" && (d.visible = i2(d, u), d.visible && (u = d)) } return r } function o2(t) { return t === 0 || t === 180 ? "center" : t < 180 ? "left" : "right" } function a2(t, e, n) { return n === "right" ? t -= e : n === "center" && (t -= e / 2), t } function l2(t, e, n) { return n === 90 || n === 270 ? t -= e / 2 : (n > 270 || n < 90) && (t -= e), t } function u2(t, e, n) { const { left: r, top: i, right: s, bottom: o } = n, { backdropColor: a } = e; if (!fe(a)) { const l = Er(e.borderRadius), u = et(e.backdropPadding); t.fillStyle = a; const c = r - u.left, d = i - u.top, h = s - r + u.width, f = o - i + u.height; Object.values(l).some(g => g !== 0) ? (t.beginPath(), no(t, { x: c, y: d, w: h, h: f, radius: l }), t.fill()) : t.fillRect(c, d, h, f) } } function c2(t, e) { const { ctx: n, options: { pointLabels: r } } = t; for (let i = e - 1; i >= 0; i--) { const s = t._pointLabelItems[i]; if (!s.visible) continue; const o = r.setContext(t.getPointLabelContext(i)); u2(n, o, s); const a = De(o.font), { x: l, y: u, textAlign: c } = s; jr(n, t._pointLabels[i], l, u + a.lineHeight / 2, a, { color: o.color, textAlign: c, textBaseline: "middle" }) } } function e_(t, e, n, r) { const { ctx: i } = t; if (n) i.arc(t.xCenter, t.yCenter, e, 0, an); else { let s = t.getPointPosition(0, e); i.moveTo(s.x, s.y); for (let o = 1; o < r; o++)s = t.getPointPosition(o, e), i.lineTo(s.x, s.y) } } function d2(t, e, n, r, i) { const s = t.ctx, o = e.circular, { color: a, lineWidth: l } = e; !o && !r || !a || !l || n < 0 || (s.save(), s.strokeStyle = a, s.lineWidth = l, s.setLineDash(i.dash), s.lineDashOffset = i.dashOffset, s.beginPath(), e_(t, n, o, r), s.closePath(), s.stroke(), s.restore()) } function h2(t, e, n) { return Vr(t, { label: n, index: e, type: "pointLabel" }) } class sa extends pl { constructor(e) { super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions() { const e = this._padding = et(Ld(this.options) / 2), n = this.width = this.maxWidth - e.width, r = this.height = this.maxHeight - e.height; this.xCenter = Math.floor(this.left + n / 2 + e.left), this.yCenter = Math.floor(this.top + r / 2 + e.top), this.drawingArea = Math.floor(Math.min(n, r) / 2) } determineDataLimits() { const { min: e, max: n } = this.getMinMax(!1); this.min = Ne(e) && !isNaN(e) ? e : 0, this.max = Ne(n) && !isNaN(n) ? n : 0, this.handleTickRangeOptions() } computeTickLimit() { return Math.ceil(this.drawingArea / Ld(this.options)) } generateTickLabels(e) { pl.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((n, r) => { const i = ge(this.options.pointLabels.callback, [n, r], this); return i || i === 0 ? i : "" }).filter((n, r) => this.chart.getDataVisibility(r)) } fit() { const e = this.options; e.display && e.pointLabels.display ? t2(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint(e, n, r, i) { this.xCenter += Math.floor((e - n) / 2), this.yCenter += Math.floor((r - i) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, n, r, i)) } getIndexAngle(e) { const n = an / (this._pointLabels.length || 1), r = this.options.startAngle || 0; return en(e * n + Un(r)) } getDistanceFromCenterForValue(e) { if (fe(e)) return NaN; const n = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - e) * n : (e - this.min) * n } getValueForDistanceFromCenter(e) { if (fe(e)) return NaN; const n = e / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - n : this.min + n } getPointLabelContext(e) { const n = this._pointLabels || []; if (e >= 0 && e < n.length) { const r = n[e]; return h2(this.getContext(), e, r) } } getPointPosition(e, n, r = 0) { const i = this.getIndexAngle(e) - bt + r; return { x: Math.cos(i) * n + this.xCenter, y: Math.sin(i) * n + this.yCenter, angle: i } } getPointPositionForValue(e, n) { return this.getPointPosition(e, this.getDistanceFromCenterForValue(n)) } getBasePosition(e) { return this.getPointPositionForValue(e || 0, this.getBaseValue()) } getPointLabelPosition(e) { const { left: n, top: r, right: i, bottom: s } = this._pointLabelItems[e]; return { left: n, top: r, right: i, bottom: s } } drawBackground() { const { backgroundColor: e, grid: { circular: n } } = this.options; if (e) { const r = this.ctx; r.save(), r.beginPath(), e_(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length), r.closePath(), r.fillStyle = e, r.fill(), r.restore() } } drawGrid() { const e = this.ctx, n = this.options, { angleLines: r, grid: i, border: s } = n, o = this._pointLabels.length; let a, l, u; if (n.pointLabels.display && c2(this, o), i.display && this.ticks.forEach((c, d) => { if (d !== 0 || d === 0 && this.min < 0) { l = this.getDistanceFromCenterForValue(c.value); const h = this.getContext(d), f = i.setContext(h), g = s.setContext(h); d2(this, f, l, o, g) } }), r.display) { for (e.save(), a = o - 1; a >= 0; a--) { const c = r.setContext(this.getPointLabelContext(a)), { color: d, lineWidth: h } = c; !h || !d || (e.lineWidth = h, e.strokeStyle = d, e.setLineDash(c.borderDash), e.lineDashOffset = c.borderDashOffset, l = this.getDistanceFromCenterForValue(n.ticks.reverse ? this.min : this.max), u = this.getPointPosition(a, l), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(u.x, u.y), e.stroke()) } e.restore() } } drawBorder() { } drawLabels() { const e = this.ctx, n = this.options, r = n.ticks; if (!r.display) return; const i = this.getIndexAngle(0); let s, o; e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(i), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((a, l) => { if (l === 0 && this.min >= 0 && !n.reverse) return; const u = r.setContext(this.getContext(l)), c = De(u.font); if (s = this.getDistanceFromCenterForValue(this.ticks[l].value), u.showLabelBackdrop) { e.font = c.string, o = e.measureText(a.label).width, e.fillStyle = u.backdropColor; const d = et(u.backdropPadding); e.fillRect(-o / 2 - d.left, -s - c.size / 2 - d.top, o + d.width, c.size + d.height) } jr(e, a.label, 0, -s, c, { color: u.color, strokeColor: u.textStrokeColor, strokeWidth: u.textStrokeWidth }) }), e.restore() } drawTitle() { } } J(sa, "id", "radialLinear"), J(sa, "defaults", { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: Jl.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback(e) { return e }, padding: 5, centerPointLabels: !1 } }), J(sa, "defaultRoutes", { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }), J(sa, "descriptors", { angleLines: { _fallback: "grid" } }); const tu = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, ut = Object.keys(tu); function Em(t, e) { return t - e } function Tm(t, e) { if (fe(e)) return null; const n = t._adapter, { parser: r, round: i, isoWeekday: s } = t._parseOpts; let o = e; return typeof r == "function" && (o = r(o)), Ne(o) || (o = typeof r == "string" ? n.parse(o, r) : n.parse(o)), o === null ? null : (i && (o = i === "week" && (cl(s) || s === !0) ? n.startOf(o, "isoWeek", s) : n.startOf(o, i)), +o) } function Im(t, e, n, r) { const i = ut.length; for (let s = ut.indexOf(t); s < i - 1; ++s) { const o = tu[ut[s]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER; if (o.common && Math.ceil((n - e) / (a * o.size)) <= r) return ut[s] } return ut[i - 1] } function f2(t, e, n, r, i) { for (let s = ut.length - 1; s >= ut.indexOf(n); s--) { const o = ut[s]; if (tu[o].common && t._adapter.diff(i, r, o) >= e - 1) return o } return ut[n ? ut.indexOf(n) : 0] } function p2(t) { for (let e = ut.indexOf(t) + 1, n = ut.length; e < n; ++e)if (tu[ut[e]].common) return ut[e] } function Rm(t, e, n) { if (!n) t[e] = !0; else if (n.length) { const { lo: r, hi: i } = Zh(n, e), s = n[r] >= e ? n[r] : n[i]; t[s] = !0 } } function g2(t, e, n, r) { const i = t._adapter, s = +i.startOf(e[0].value, r), o = e[e.length - 1].value; let a, l; for (a = s; a <= o; a = +i.add(a, 1, r))l = n[a], l >= 0 && (e[l].major = !0); return e } function Mm(t, e, n) { const r = [], i = {}, s = e.length; let o, a; for (o = 0; o < s; ++o)a = e[o], i[a] = o, r.push({ value: a, major: !1 }); return s === 0 || !n ? r : g2(t, r, i, n) } class gl extends Br { constructor(e) { super(e), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(e, n = {}) { const r = e.time || (e.time = {}), i = this._adapter = new vT._date(e.adapters.date); i.init(n), Ts(r.displayFormats, i.formats()), this._parseOpts = { parser: r.parser, round: r.round, isoWeekday: r.isoWeekday }, super.init(e), this._normalized = n.normalized } parse(e, n) { return e === void 0 ? null : Tm(this, e) } beforeLayout() { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits() { const e = this.options, n = this._adapter, r = e.time.unit || "day"; let { min: i, max: s, minDefined: o, maxDefined: a } = this.getUserBounds(); function l(u) { !o && !isNaN(u.min) && (i = Math.min(i, u.min)), !a && !isNaN(u.max) && (s = Math.max(s, u.max)) } (!o || !a) && (l(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && l(this.getMinMax(!1))), i = Ne(i) && !isNaN(i) ? i : +n.startOf(Date.now(), r), s = Ne(s) && !isNaN(s) ? s : +n.endOf(Date.now(), r) + 1, this.min = Math.min(i, s - 1), this.max = Math.max(i + 1, s) } _getLabelBounds() { const e = this.getLabelTimestamps(); let n = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY; return e.length && (n = e[0], r = e[e.length - 1]), { min: n, max: r } } buildTicks() { const e = this.options, n = e.time, r = e.ticks, i = r.source === "labels" ? this.getLabelTimestamps() : this._generate(); e.bounds === "ticks" && i.length && (this.min = this._userMin || i[0], this.max = this._userMax || i[i.length - 1]); const s = this.min, o = this.max, a = aE(i, s, o); return this._unit = n.unit || (r.autoSkip ? Im(n.minUnit, this.min, this.max, this._getLabelCapacity(s)) : f2(this, a.length, n.minUnit, this.min, this.max)), this._majorUnit = !r.major.enabled || this._unit === "year" ? void 0 : p2(this._unit), this.initOffsets(i), e.reverse && a.reverse(), Mm(this, a, this._majorUnit) } afterAutoSkip() { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(e => +e.value)) } initOffsets(e = []) { let n = 0, r = 0, i, s; this.options.offset && e.length && (i = this.getDecimalForValue(e[0]), e.length === 1 ? n = 1 - i : n = (this.getDecimalForValue(e[1]) - i) / 2, s = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? r = s : r = (s - this.getDecimalForValue(e[e.length - 2])) / 2); const o = e.length < 3 ? .5 : .25; n = Wt(n, 0, o), r = Wt(r, 0, o), this._offsets = { start: n, end: r, factor: 1 / (n + 1 + r) } } _generate() { const e = this._adapter, n = this.min, r = this.max, i = this.options, s = i.time, o = s.unit || Im(s.minUnit, n, r, this._getLabelCapacity(n)), a = le(i.ticks.stepSize, 1), l = o === "week" ? s.isoWeekday : !1, u = cl(l) || l === !0, c = {}; let d = n, h, f; if (u && (d = +e.startOf(d, "isoWeek", l)), d = +e.startOf(d, u ? "day" : o), e.diff(r, n, o) > 1e5 * a) throw new Error(n + " and " + r + " are too far apart with stepSize of " + a + " " + o); const g = i.ticks.source === "data" && this.getDataTimestamps(); for (h = d, f = 0; h < r; h = +e.add(h, a, o), f++)Rm(c, h, g); return (h === r || i.bounds === "ticks" || f === 1) && Rm(c, h, g), Object.keys(c).sort(Em).map(m => +m) } getLabelForValue(e) { const n = this._adapter, r = this.options.time; return r.tooltipFormat ? n.format(e, r.tooltipFormat) : n.format(e, r.displayFormats.datetime) } format(e, n) { const i = this.options.time.displayFormats, s = this._unit, o = n || i[s]; return this._adapter.format(e, o) } _tickFormatFunction(e, n, r, i) { const s = this.options, o = s.ticks.callback; if (o) return ge(o, [e, n, r], this); const a = s.time.displayFormats, l = this._unit, u = this._majorUnit, c = l && a[l], d = u && a[u], h = r[n], f = u && d && h && h.major; return this._adapter.format(e, i || (f ? d : c)) } generateTickLabels(e) { let n, r, i; for (n = 0, r = e.length; n < r; ++n)i = e[n], i.label = this._tickFormatFunction(i.value, n, e) } getDecimalForValue(e) { return e === null ? NaN : (e - this.min) / (this.max - this.min) } getPixelForValue(e) { const n = this._offsets, r = this.getDecimalForValue(e); return this.getPixelForDecimal((n.start + r) * n.factor) } getValueForPixel(e) { const n = this._offsets, r = this.getDecimalForPixel(e) / n.factor - n.end; return this.min + r * (this.max - this.min) } _getLabelSize(e) { const n = this.options.ticks, r = this.ctx.measureText(e).width, i = Un(this.isHorizontal() ? n.maxRotation : n.minRotation), s = Math.cos(i), o = Math.sin(i), a = this._resolveTickFontOptions(0).size; return { w: r * s + a * o, h: r * o + a * s } } _getLabelCapacity(e) { const n = this.options.time, r = n.displayFormats, i = r[n.unit] || r.millisecond, s = this._tickFormatFunction(e, 0, Mm(this, [e], this._majorUnit), i), o = this._getLabelSize(s), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1; return a > 0 ? a : 1 } getDataTimestamps() { let e = this._cache.data || [], n, r; if (e.length) return e; const i = this.getMatchingVisibleMetas(); if (this._normalized && i.length) return this._cache.data = i[0].controller.getAllParsedValues(this); for (n = 0, r = i.length; n < r; ++n)e = e.concat(i[n].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(e) } getLabelTimestamps() { const e = this._cache.labels || []; let n, r; if (e.length) return e; const i = this.getLabels(); for (n = 0, r = i.length; n < r; ++n)e.push(Tm(this, i[n])); return this._cache.labels = this._normalized ? e : this.normalize(e) } normalize(e) { return kb(e.sort(Em)) } } J(gl, "id", "time"), J(gl, "defaults", { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: !1, major: { enabled: !1 } } }); function oa(t, e, n) { let r = 0, i = t.length - 1, s, o, a, l; n ? (e >= t[r].pos && e <= t[i].pos && ({ lo: r, hi: i } = Od(t, "pos", e)), { pos: s, time: a } = t[r], { pos: o, time: l } = t[i]) : (e >= t[r].time && e <= t[i].time && ({ lo: r, hi: i } = Od(t, "time", e)), { time: s, pos: a } = t[r], { time: o, pos: l } = t[i]); const u = o - s; return u ? a + (l - a) * (e - s) / u : a } class Lm extends gl { constructor(e) { super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets() { const e = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(e); this._minPos = oa(n, this.min), this._tableRange = oa(n, this.max) - this._minPos, super.initOffsets(e) } buildLookupTable(e) { const { min: n, max: r } = this, i = [], s = []; let o, a, l, u, c; for (o = 0, a = e.length; o < a; ++o)u = e[o], u >= n && u <= r && i.push(u); if (i.length < 2) return [{ time: n, pos: 0 }, { time: r, pos: 1 }]; for (o = 0, a = i.length; o < a; ++o)c = i[o + 1], l = i[o - 1], u = i[o], Math.round((c + l) / 2) !== u && s.push({ time: u, pos: o / (a - 1) }); return s } _generate() { const e = this.min, n = this.max; let r = super.getDataTimestamps(); return (!r.includes(e) || !r.length) && r.splice(0, 0, e), (!r.includes(n) || r.length === 1) && r.push(n), r.sort((i, s) => i - s) } _getTimestampsForTable() { let e = this._cache.all || []; if (e.length) return e; const n = this.getDataTimestamps(), r = this.getLabelTimestamps(); return n.length && r.length ? e = this.normalize(n.concat(r)) : e = n.length ? n : r, e = this._cache.all = e, e } getDecimalForValue(e) { return (oa(this._table, e) - this._minPos) / this._tableRange } getValueForPixel(e) { const n = this._offsets, r = this.getDecimalForPixel(e) / n.factor - n.end; return oa(this._table, r * this._tableRange + this._minPos, !0) } } J(Lm, "id", "timeseries"), J(Lm, "defaults", gl.defaults); const t_ = "label"; function Dm(t, e) { typeof t == "function" ? t(e) : t && (t.current = e) } function m2(t, e) { const n = t.options; n && e && Object.assign(n, e) } function n_(t, e) { t.labels = e } function r_(t, e) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : t_; const r = []; t.datasets = e.map(i => { const s = t.datasets.find(o => o[n] === i[n]); return !s || !i.data || r.includes(s) ? { ...i } : (r.push(s), Object.assign(s, i), s) }) } function v2(t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t_; const n = { labels: [], datasets: [] }; return n_(n, t.labels), r_(n, t.datasets, e), n } function y2(t, e) { const { height: n = 150, width: r = 300, redraw: i = !1, datasetIdKey: s, type: o, data: a, options: l, plugins: u = [], fallbackContent: c, updateMode: d, ...h } = t, f = R.useRef(null), g = R.useRef(), m = () => { f.current && (g.current = new eu(f.current, { type: o, data: v2(a, s), options: l && { ...l }, plugins: u }), Dm(e, g.current)) }, y = () => { Dm(e, null), g.current && (g.current.destroy(), g.current = null) }; return R.useEffect(() => { !i && g.current && l && m2(g.current, l) }, [i, l]), R.useEffect(() => { !i && g.current && n_(g.current.config.data, a.labels) }, [i, a.labels]), R.useEffect(() => { !i && g.current && a.datasets && r_(g.current.config.data, a.datasets, s) }, [i, a.datasets]), R.useEffect(() => { g.current && (i ? (y(), setTimeout(m)) : g.current.update(d)) }, [i, l, a.labels, a.datasets, d]), R.useEffect(() => { g.current && (y(), setTimeout(m)) }, [o]), R.useEffect(() => (m(), () => y()), []), _t.createElement("canvas", Object.assign({ ref: f, role: "img", height: n, width: r }, h), c) } const b2 = R.forwardRef(y2); function _2(t, e) { return eu.register(e), R.forwardRef((n, r) => _t.createElement(b2, Object.assign({}, n, { ref: r, type: t }))) } const w2 = _2("bar", Oa); function Nr(t) { "@babel/helpers - typeof"; return Nr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Nr(t) } function S2(t, e) { if (Nr(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e || "default"); if (Nr(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function i_(t) { var e = S2(t, "string"); return Nr(e) == "symbol" ? e : e + "" } function vs(t, e, n) { return (e = i_(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Am(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Q(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? Am(Object(n), !0).forEach(function (r) { vs(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Am(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function x2(t) { if (Array.isArray(t)) return t } function k2(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, s, o, a = [], l = !0, u = !1; try { if (s = (n = n.call(t)).next, e === 0) { if (Object(n) !== n) return; l = !1 } else for (; !(l = (r = s.call(n)).done) && (a.push(r.value), a.length !== e); l = !0); } catch (c) { u = !0, i = c } finally { try { if (!l && n.return != null && (o = n.return(), Object(o) !== o)) return } finally { if (u) throw i } } return a } } function Dd(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } function s_(t, e) { if (t) { if (typeof t == "string") return Dd(t, e); var n = {}.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Dd(t, e) : void 0 } } function C2() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function wn(t, e) { return x2(t) || k2(t, e) || s_(t, e) || C2() } function O2(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if ({}.hasOwnProperty.call(t, r)) { if (e.includes(r)) continue; n[r] = t[r] } return n } function En(t, e) { if (t == null) return {}; var n, r, i = O2(t, e); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(t); for (r = 0; r < s.length; r++)n = s[r], e.includes(n) || {}.propertyIsEnumerable.call(t, n) && (i[n] = t[n]) } return i } var P2 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"]; function E2(t) { var e = t.defaultInputValue, n = e === void 0 ? "" : e, r = t.defaultMenuIsOpen, i = r === void 0 ? !1 : r, s = t.defaultValue, o = s === void 0 ? null : s, a = t.inputValue, l = t.menuIsOpen, u = t.onChange, c = t.onInputChange, d = t.onMenuClose, h = t.onMenuOpen, f = t.value, g = En(t, P2), m = R.useState(a !== void 0 ? a : n), y = wn(m, 2), p = y[0], v = y[1], b = R.useState(l !== void 0 ? l : i), S = wn(b, 2), P = S[0], I = S[1], T = R.useState(f !== void 0 ? f : o), k = wn(T, 2), E = k[0], M = k[1], L = R.useCallback(function (j, _) { typeof u == "function" && u(j, _), M(j) }, [u]), N = R.useCallback(function (j, _) { var x; typeof c == "function" && (x = c(j, _)), v(x !== void 0 ? x : j) }, [c]), $ = R.useCallback(function () { typeof h == "function" && h(), I(!0) }, [h]), B = R.useCallback(function () { typeof d == "function" && d(), I(!1) }, [d]), H = a !== void 0 ? a : p, V = l !== void 0 ? l : P, q = f !== void 0 ? f : E; return Q(Q({}, g), {}, { inputValue: H, menuIsOpen: V, onChange: L, onInputChange: N, onMenuClose: B, onMenuOpen: $, value: q }) } function X() { return X = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, X.apply(null, arguments) } function T2(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function jm(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, i_(r.key), r) } } function I2(t, e, n) { return e && jm(t.prototype, e), n && jm(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function Ad(t, e) { return Ad = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (n, r) { return n.__proto__ = r, n }, Ad(t, e) } function R2(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && Ad(t, e) } function ml(t) { return ml = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, ml(t) } function o_() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (o_ = function () { return !!t })() } function M2(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function L2(t, e) { if (e && (Nr(e) == "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return M2(t) } function D2(t) { var e = o_(); return function () { var n, r = ml(t); if (e) { var i = ml(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return L2(this, n) } } function A2(t) { if (Array.isArray(t)) return Dd(t) } function j2(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function N2() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function df(t) { return A2(t) || j2(t) || s_(t) || N2() } var F2 = !1; function $2(t) { if (t.sheet) return t.sheet; for (var e = 0; e < document.styleSheets.length; e++)if (document.styleSheets[e].ownerNode === t) return document.styleSheets[e] } function z2(t) { var e = document.createElement("style"); return e.setAttribute("data-emotion", t.key), t.nonce !== void 0 && e.setAttribute("nonce", t.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e } var V2 = function () { function t(n) { var r = this; this._insertTag = function (i) { var s; r.tags.length === 0 ? r.insertionPoint ? s = r.insertionPoint.nextSibling : r.prepend ? s = r.container.firstChild : s = r.before : s = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, s), r.tags.push(i) }, this.isSpeedy = n.speedy === void 0 ? !F2 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null } var e = t.prototype; return e.hydrate = function (r) { r.forEach(this._insertTag) }, e.insert = function (r) { this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(z2(this)); var i = this.tags[this.tags.length - 1]; if (this.isSpeedy) { var s = $2(i); try { s.insertRule(r, s.cssRules.length) } catch { } } else i.appendChild(document.createTextNode(r)); this.ctr++ }, e.flush = function () { this.tags.forEach(function (r) { var i; return (i = r.parentNode) == null ? void 0 : i.removeChild(r) }), this.tags = [], this.ctr = 0 }, t }(), Ye = "-ms-", vl = "-moz-", se = "-webkit-", a_ = "comm", hf = "rule", ff = "decl", B2 = "@import", l_ = "@keyframes", U2 = "@layer", H2 = Math.abs, nu = String.fromCharCode, W2 = Object.assign; function q2(t, e) { return Ue(t, 0) ^ 45 ? (((e << 2 ^ Ue(t, 0)) << 2 ^ Ue(t, 1)) << 2 ^ Ue(t, 2)) << 2 ^ Ue(t, 3) : 0 } function u_(t) { return t.trim() } function K2(t, e) { return (t = e.exec(t)) ? t[0] : t } function oe(t, e, n) { return t.replace(e, n) } function jd(t, e) { return t.indexOf(e) } function Ue(t, e) { return t.charCodeAt(e) | 0 } function so(t, e, n) { return t.slice(e, n) } function tn(t) { return t.length } function pf(t) { return t.length } function aa(t, e) { return e.push(t), t } function G2(t, e) { return t.map(e).join("") } var ru = 1, Di = 1, c_ = 0, pt = 0, Te = 0, Hi = ""; function iu(t, e, n, r, i, s, o) { return { value: t, root: e, parent: n, type: r, props: i, children: s, line: ru, column: Di, length: o, return: "" } } function as(t, e) { return W2(iu("", null, null, "", null, null, 0), t, { length: -t.length }, e) } function Y2() { return Te } function Q2() { return Te = pt > 0 ? Ue(Hi, --pt) : 0, Di--, Te === 10 && (Di = 1, ru--), Te } function St() { return Te = pt < c_ ? Ue(Hi, pt++) : 0, Di++, Te === 10 && (Di = 1, ru++), Te } function ln() { return Ue(Hi, pt) } function Ia() { return pt } function wo(t, e) { return so(Hi, t, e) } function oo(t) { switch (t) { case 0: case 9: case 10: case 13: case 32: return 5; case 33: case 43: case 44: case 47: case 62: case 64: case 126: case 59: case 123: case 125: return 4; case 58: return 3; case 34: case 39: case 40: case 91: return 2; case 41: case 93: return 1 }return 0 } function d_(t) { return ru = Di = 1, c_ = tn(Hi = t), pt = 0, [] } function h_(t) { return Hi = "", t } function Ra(t) { return u_(wo(pt - 1, Nd(t === 91 ? t + 2 : t === 40 ? t + 1 : t))) } function X2(t) { for (; (Te = ln()) && Te < 33;)St(); return oo(t) > 2 || oo(Te) > 3 ? "" : " " } function J2(t, e) { for (; --e && St() && !(Te < 48 || Te > 102 || Te > 57 && Te < 65 || Te > 70 && Te < 97);); return wo(t, Ia() + (e < 6 && ln() == 32 && St() == 32)) } function Nd(t) { for (; St();)switch (Te) { case t: return pt; case 34: case 39: t !== 34 && t !== 39 && Nd(Te); break; case 40: t === 41 && Nd(t); break; case 92: St(); break }return pt } function Z2(t, e) { for (; St() && t + Te !== 57;)if (t + Te === 84 && ln() === 47) break; return "/*" + wo(e, pt - 1) + "*" + nu(t === 47 ? t : St()) } function eR(t) { for (; !oo(ln());)St(); return wo(t, pt) } function tR(t) { return h_(Ma("", null, null, null, [""], t = d_(t), 0, [0], t)) } function Ma(t, e, n, r, i, s, o, a, l) { for (var u = 0, c = 0, d = o, h = 0, f = 0, g = 0, m = 1, y = 1, p = 1, v = 0, b = "", S = i, P = s, I = r, T = b; y;)switch (g = v, v = St()) { case 40: if (g != 108 && Ue(T, d - 1) == 58) { jd(T += oe(Ra(v), "&", "&\f"), "&\f") != -1 && (p = -1); break } case 34: case 39: case 91: T += Ra(v); break; case 9: case 10: case 13: case 32: T += X2(g); break; case 92: T += J2(Ia() - 1, 7); continue; case 47: switch (ln()) { case 42: case 47: aa(nR(Z2(St(), Ia()), e, n), l); break; default: T += "/" }break; case 123 * m: a[u++] = tn(T) * p; case 125 * m: case 59: case 0: switch (v) { case 0: case 125: y = 0; case 59 + c: p == -1 && (T = oe(T, /\f/g, "")), f > 0 && tn(T) - d && aa(f > 32 ? Fm(T + ";", r, n, d - 1) : Fm(oe(T, " ", "") + ";", r, n, d - 2), l); break; case 59: T += ";"; default: if (aa(I = Nm(T, e, n, u, c, i, a, b, S = [], P = [], d), s), v === 123) if (c === 0) Ma(T, e, I, I, S, s, d, a, P); else switch (h === 99 && Ue(T, 3) === 110 ? 100 : h) { case 100: case 108: case 109: case 115: Ma(t, I, I, r && aa(Nm(t, I, I, 0, 0, i, a, b, i, S = [], d), P), i, P, d, a, r ? S : P); break; default: Ma(T, I, I, I, [""], P, 0, a, P) } }u = c = f = 0, m = p = 1, b = T = "", d = o; break; case 58: d = 1 + tn(T), f = g; default: if (m < 1) { if (v == 123) --m; else if (v == 125 && m++ == 0 && Q2() == 125) continue } switch (T += nu(v), v * m) { case 38: p = c > 0 ? 1 : (T += "\f", -1); break; case 44: a[u++] = (tn(T) - 1) * p, p = 1; break; case 64: ln() === 45 && (T += Ra(St())), h = ln(), c = d = tn(b = T += eR(Ia())), v++; break; case 45: g === 45 && tn(T) == 2 && (m = 0) } }return s } function Nm(t, e, n, r, i, s, o, a, l, u, c) { for (var d = i - 1, h = i === 0 ? s : [""], f = pf(h), g = 0, m = 0, y = 0; g < r; ++g)for (var p = 0, v = so(t, d + 1, d = H2(m = o[g])), b = t; p < f; ++p)(b = u_(m > 0 ? h[p] + " " + v : oe(v, /&\f/g, h[p]))) && (l[y++] = b); return iu(t, e, n, i === 0 ? hf : a, l, u, c) } function nR(t, e, n) { return iu(t, e, n, a_, nu(Y2()), so(t, 2, -2), 0) } function Fm(t, e, n, r) { return iu(t, e, n, ff, so(t, 0, r), so(t, r + 1, -1), r) } function wi(t, e) { for (var n = "", r = pf(t), i = 0; i < r; i++)n += e(t[i], i, t, e) || ""; return n } function rR(t, e, n, r) { switch (t.type) { case U2: if (t.children.length) break; case B2: case ff: return t.return = t.return || t.value; case a_: return ""; case l_: return t.return = t.value + "{" + wi(t.children, r) + "}"; case hf: t.value = t.props.join(",") }return tn(n = wi(t.children, r)) ? t.return = t.value + "{" + n + "}" : "" } function iR(t) { var e = pf(t); return function (n, r, i, s) { for (var o = "", a = 0; a < e; a++)o += t[a](n, r, i, s) || ""; return o } } function sR(t) { return function (e) { e.root || (e = e.return) && t(e) } } function oR(t) { var e = Object.create(null); return function (n) { return e[n] === void 0 && (e[n] = t(n)), e[n] } } var aR = function (e, n, r) { for (var i = 0, s = 0; i = s, s = ln(), i === 38 && s === 12 && (n[r] = 1), !oo(s);)St(); return wo(e, pt) }, lR = function (e, n) { var r = -1, i = 44; do switch (oo(i)) { case 0: i === 38 && ln() === 12 && (n[r] = 1), e[r] += aR(pt - 1, n, r); break; case 2: e[r] += Ra(i); break; case 4: if (i === 44) { e[++r] = ln() === 58 ? "&\f" : "", n[r] = e[r].length; break } default: e[r] += nu(i) } while (i = St()); return e }, uR = function (e, n) { return h_(lR(d_(e), n)) }, $m = new WeakMap, cR = function (e) { if (!(e.type !== "rule" || !e.parent || e.length < 1)) { for (var n = e.value, r = e.parent, i = e.column === r.column && e.line === r.line; r.type !== "rule";)if (r = r.parent, !r) return; if (!(e.props.length === 1 && n.charCodeAt(0) !== 58 && !$m.get(r)) && !i) { $m.set(e, !0); for (var s = [], o = uR(n, s), a = r.props, l = 0, u = 0; l < o.length; l++)for (var c = 0; c < a.length; c++, u++)e.props[u] = s[l] ? o[l].replace(/&\f/g, a[c]) : a[c] + " " + o[l] } } }, dR = function (e) { if (e.type === "decl") { var n = e.value; n.charCodeAt(0) === 108 && n.charCodeAt(2) === 98 && (e.return = "", e.value = "") } }; function f_(t, e) { switch (q2(t, e)) { case 5103: return se + "print-" + t + t; case 5737: case 4201: case 3177: case 3433: case 1641: case 4457: case 2921: case 5572: case 6356: case 5844: case 3191: case 6645: case 3005: case 6391: case 5879: case 5623: case 6135: case 4599: case 4855: case 4215: case 6389: case 5109: case 5365: case 5621: case 3829: return se + t + t; case 5349: case 4246: case 4810: case 6968: case 2756: return se + t + vl + t + Ye + t + t; case 6828: case 4268: return se + t + Ye + t + t; case 6165: return se + t + Ye + "flex-" + t + t; case 5187: return se + t + oe(t, /(\w+).+(:[^]+)/, se + "box-$1$2" + Ye + "flex-$1$2") + t; case 5443: return se + t + Ye + "flex-item-" + oe(t, /flex-|-self/, "") + t; case 4675: return se + t + Ye + "flex-line-pack" + oe(t, /align-content|flex-|-self/, "") + t; case 5548: return se + t + Ye + oe(t, "shrink", "negative") + t; case 5292: return se + t + Ye + oe(t, "basis", "preferred-size") + t; case 6060: return se + "box-" + oe(t, "-grow", "") + se + t + Ye + oe(t, "grow", "positive") + t; case 4554: return se + oe(t, /([^-])(transform)/g, "$1" + se + "$2") + t; case 6187: return oe(oe(oe(t, /(zoom-|grab)/, se + "$1"), /(image-set)/, se + "$1"), t, "") + t; case 5495: case 3959: return oe(t, /(image-set\([^]*)/, se + "$1$`$1"); case 4968: return oe(oe(t, /(.+:)(flex-)?(.*)/, se + "box-pack:$3" + Ye + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + se + t + t; case 4095: case 3583: case 4068: case 2532: return oe(t, /(.+)-inline(.+)/, se + "$1$2") + t; case 8116: case 7059: case 5753: case 5535: case 5445: case 5701: case 4933: case 4677: case 5533: case 5789: case 5021: case 4765: if (tn(t) - 1 - e > 6) switch (Ue(t, e + 1)) { case 109: if (Ue(t, e + 4) !== 45) break; case 102: return oe(t, /(.+:)(.+)-([^]+)/, "$1" + se + "$2-$3$1" + vl + (Ue(t, e + 3) == 108 ? "$3" : "$2-$3")) + t; case 115: return ~jd(t, "stretch") ? f_(oe(t, "stretch", "fill-available"), e) + t : t }break; case 4949: if (Ue(t, e + 1) !== 115) break; case 6444: switch (Ue(t, tn(t) - 3 - (~jd(t, "!important") && 10))) { case 107: return oe(t, ":", ":" + se) + t; case 101: return oe(t, /(.+:)([^;!]+)(;|!.+)?/, "$1" + se + (Ue(t, 14) === 45 ? "inline-" : "") + "box$3$1" + se + "$2$3$1" + Ye + "$2box$3") + t }break; case 5936: switch (Ue(t, e + 11)) { case 114: return se + t + Ye + oe(t, /[svh]\w+-[tblr]{2}/, "tb") + t; case 108: return se + t + Ye + oe(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t; case 45: return se + t + Ye + oe(t, /[svh]\w+-[tblr]{2}/, "lr") + t }return se + t + Ye + t + t }return t } var hR = function (e, n, r, i) { if (e.length > -1 && !e.return) switch (e.type) { case ff: e.return = f_(e.value, e.length); break; case l_: return wi([as(e, { value: oe(e.value, "@", "@" + se) })], i); case hf: if (e.length) return G2(e.props, function (s) { switch (K2(s, /(::plac\w+|:read-\w+)/)) { case ":read-only": case ":read-write": return wi([as(e, { props: [oe(s, /:(read-\w+)/, ":" + vl + "$1")] })], i); case "::placeholder": return wi([as(e, { props: [oe(s, /:(plac\w+)/, ":" + se + "input-$1")] }), as(e, { props: [oe(s, /:(plac\w+)/, ":" + vl + "$1")] }), as(e, { props: [oe(s, /:(plac\w+)/, Ye + "input-$1")] })], i) }return "" }) } }, fR = [hR], pR = function (e) { var n = e.key; if (n === "css") { var r = document.querySelectorAll("style[data-emotion]:not([data-s])"); Array.prototype.forEach.call(r, function (m) { var y = m.getAttribute("data-emotion"); y.indexOf(" ") !== -1 && (document.head.appendChild(m), m.setAttribute("data-s", "")) }) } var i = e.stylisPlugins || fR, s = {}, o, a = []; o = e.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + n + ' "]'), function (m) { for (var y = m.getAttribute("data-emotion").split(" "), p = 1; p < y.length; p++)s[y[p]] = !0; a.push(m) }); var l, u = [cR, dR]; { var c, d = [rR, sR(function (m) { c.insert(m) })], h = iR(u.concat(i, d)), f = function (y) { return wi(tR(y), h) }; l = function (y, p, v, b) { c = v, f(y ? y + "{" + p.styles + "}" : p.styles), b && (g.inserted[p.name] = !0) } } var g = { key: n, sheet: new V2({ key: n, container: o, nonce: e.nonce, speedy: e.speedy, prepend: e.prepend, insertionPoint: e.insertionPoint }), nonce: e.nonce, inserted: s, registered: {}, insert: l }; return g.sheet.hydrate(a), g }, p_ = { exports: {} }, he = {};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ze = typeof Symbol == "function" && Symbol.for, gf = ze ? Symbol.for("react.element") : 60103, mf = ze ? Symbol.for("react.portal") : 60106, su = ze ? Symbol.for("react.fragment") : 60107, ou = ze ? Symbol.for("react.strict_mode") : 60108, au = ze ? Symbol.for("react.profiler") : 60114, lu = ze ? Symbol.for("react.provider") : 60109, uu = ze ? Symbol.for("react.context") : 60110, vf = ze ? Symbol.for("react.async_mode") : 60111, cu = ze ? Symbol.for("react.concurrent_mode") : 60111, du = ze ? Symbol.for("react.forward_ref") : 60112, hu = ze ? Symbol.for("react.suspense") : 60113, gR = ze ? Symbol.for("react.suspense_list") : 60120, fu = ze ? Symbol.for("react.memo") : 60115, pu = ze ? Symbol.for("react.lazy") : 60116, mR = ze ? Symbol.for("react.block") : 60121, vR = ze ? Symbol.for("react.fundamental") : 60117, yR = ze ? Symbol.for("react.responder") : 60118, bR = ze ? Symbol.for("react.scope") : 60119; function Ot(t) { if (typeof t == "object" && t !== null) { var e = t.$$typeof; switch (e) { case gf: switch (t = t.type, t) { case vf: case cu: case su: case au: case ou: case hu: return t; default: switch (t = t && t.$$typeof, t) { case uu: case du: case pu: case fu: case lu: return t; default: return e } }case mf: return e } } } function g_(t) { return Ot(t) === cu } he.AsyncMode = vf; he.ConcurrentMode = cu; he.ContextConsumer = uu; he.ContextProvider = lu; he.Element = gf; he.ForwardRef = du; he.Fragment = su; he.Lazy = pu; he.Memo = fu; he.Portal = mf; he.Profiler = au; he.StrictMode = ou; he.Suspense = hu; he.isAsyncMode = function (t) { return g_(t) || Ot(t) === vf }; he.isConcurrentMode = g_; he.isContextConsumer = function (t) { return Ot(t) === uu }; he.isContextProvider = function (t) { return Ot(t) === lu }; he.isElement = function (t) { return typeof t == "object" && t !== null && t.$$typeof === gf }; he.isForwardRef = function (t) { return Ot(t) === du }; he.isFragment = function (t) { return Ot(t) === su }; he.isLazy = function (t) { return Ot(t) === pu }; he.isMemo = function (t) { return Ot(t) === fu }; he.isPortal = function (t) { return Ot(t) === mf }; he.isProfiler = function (t) { return Ot(t) === au }; he.isStrictMode = function (t) { return Ot(t) === ou }; he.isSuspense = function (t) { return Ot(t) === hu }; he.isValidElementType = function (t) { return typeof t == "string" || typeof t == "function" || t === su || t === cu || t === au || t === ou || t === hu || t === gR || typeof t == "object" && t !== null && (t.$$typeof === pu || t.$$typeof === fu || t.$$typeof === lu || t.$$typeof === uu || t.$$typeof === du || t.$$typeof === vR || t.$$typeof === yR || t.$$typeof === bR || t.$$typeof === mR) }; he.typeOf = Ot; p_.exports = he; var _R = p_.exports, m_ = _R, wR = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, SR = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, v_ = {}; v_[m_.ForwardRef] = wR; v_[m_.Memo] = SR; var xR = !0; function kR(t, e, n) { var r = ""; return n.split(" ").forEach(function (i) { t[i] !== void 0 ? e.push(t[i] + ";") : r += i + " " }), r } var y_ = function (e, n, r) { var i = e.key + "-" + n.name; (r === !1 || xR === !1) && e.registered[i] === void 0 && (e.registered[i] = n.styles) }, CR = function (e, n, r) { y_(e, n, r); var i = e.key + "-" + n.name; if (e.inserted[n.name] === void 0) { var s = n; do e.insert(n === s ? "." + i : "", s, e.sheet, !0), s = s.next; while (s !== void 0) } }; function OR(t) { for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4)n = t.charCodeAt(r) & 255 | (t.charCodeAt(++r) & 255) << 8 | (t.charCodeAt(++r) & 255) << 16 | (t.charCodeAt(++r) & 255) << 24, n = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= n >>> 24, e = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16); switch (i) { case 3: e ^= (t.charCodeAt(r + 2) & 255) << 16; case 2: e ^= (t.charCodeAt(r + 1) & 255) << 8; case 1: e ^= t.charCodeAt(r) & 255, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16) }return e ^= e >>> 13, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36) } var PR = { animationIterationCount: 1, aspectRatio: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 }, ER = !1, TR = /[A-Z]|^ms/g, IR = /_EMO_([^_]+?)_([^]*?)_EMO_/g, b_ = function (e) { return e.charCodeAt(1) === 45 }, zm = function (e) { return e != null && typeof e != "boolean" }, fc = oR(function (t) { return b_(t) ? t : t.replace(TR, "-$&").toLowerCase() }), Vm = function (e, n) { switch (e) { case "animation": case "animationName": if (typeof n == "string") return n.replace(IR, function (r, i, s) { return nn = { name: i, styles: s, next: nn }, i }) }return PR[e] !== 1 && !b_(e) && typeof n == "number" && n !== 0 ? n + "px" : n }, RR = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform."; function ao(t, e, n) { if (n == null) return ""; var r = n; if (r.__emotion_styles !== void 0) return r; switch (typeof n) { case "boolean": return ""; case "object": { var i = n; if (i.anim === 1) return nn = { name: i.name, styles: i.styles, next: nn }, i.name; var s = n; if (s.styles !== void 0) { var o = s.next; if (o !== void 0) for (; o !== void 0;)nn = { name: o.name, styles: o.styles, next: nn }, o = o.next; var a = s.styles + ";"; return a } return MR(t, e, n) } case "function": { if (t !== void 0) { var l = nn, u = n(t); return nn = l, ao(t, e, u) } break } }var c = n; return c } function MR(t, e, n) { var r = ""; if (Array.isArray(n)) for (var i = 0; i < n.length; i++)r += ao(t, e, n[i]) + ";"; else for (var s in n) { var o = n[s]; if (typeof o != "object") { var a = o; zm(a) && (r += fc(s) + ":" + Vm(s, a) + ";") } else { if (s === "NO_COMPONENT_SELECTOR" && ER) throw new Error(RR); if (Array.isArray(o) && typeof o[0] == "string" && e == null) for (var l = 0; l < o.length; l++)zm(o[l]) && (r += fc(s) + ":" + Vm(s, o[l]) + ";"); else { var u = ao(t, e, o); switch (s) { case "animation": case "animationName": { r += fc(s) + ":" + u + ";"; break } default: r += s + "{" + u + "}" } } } } return r } var Bm = /label:\s*([^\s;\n{]+)\s*(;|$)/g, nn; function __(t, e, n) { if (t.length === 1 && typeof t[0] == "object" && t[0] !== null && t[0].styles !== void 0) return t[0]; var r = !0, i = ""; nn = void 0; var s = t[0]; if (s == null || s.raw === void 0) r = !1, i += ao(n, e, s); else { var o = s; i += o[0] } for (var a = 1; a < t.length; a++)if (i += ao(n, e, t[a]), r) { var l = s; i += l[a] } Bm.lastIndex = 0; for (var u = "", c; (c = Bm.exec(i)) !== null;)u += "-" + c[1]; var d = OR(i) + u; return { name: d, styles: i, next: nn } } var LR = function (e) { return e() }, DR = wc.useInsertionEffect ? wc.useInsertionEffect : !1, AR = DR || LR, jR = !1, w_ = R.createContext(typeof HTMLElement < "u" ? pR({ key: "css" }) : null); w_.Provider; var NR = function (e) { return R.forwardRef(function (n, r) { var i = R.useContext(w_); return e(n, i, r) }) }, FR = R.createContext({}), yf = {}.hasOwnProperty, Fd = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", $R = function (e, n) { var r = {}; for (var i in n) yf.call(n, i) && (r[i] = n[i]); return r[Fd] = e, r }, zR = function (e) { var n = e.cache, r = e.serialized, i = e.isStringTag; return y_(n, r, i), AR(function () { return CR(n, r, i) }), null }, VR = NR(function (t, e, n) { var r = t.css; typeof r == "string" && e.registered[r] !== void 0 && (r = e.registered[r]); var i = t[Fd], s = [r], o = ""; typeof t.className == "string" ? o = kR(e.registered, s, t.className) : t.className != null && (o = t.className + " "); var a = __(s, void 0, R.useContext(FR)); o += e.key + "-" + a.name; var l = {}; for (var u in t) yf.call(t, u) && u !== "css" && u !== Fd && !jR && (l[u] = t[u]); return l.className = o, n && (l.ref = n), R.createElement(R.Fragment, null, R.createElement(zR, { cache: e, serialized: a, isStringTag: typeof i == "string" }), R.createElement(i, l)) }), BR = VR, Y = function (e, n) { var r = arguments; if (n == null || !yf.call(n, "css")) return R.createElement.apply(void 0, r); var i = r.length, s = new Array(i); s[0] = BR, s[1] = $R(e, n); for (var o = 2; o < i; o++)s[o] = r[o]; return R.createElement.apply(null, s) }; function bf() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return __(e) } var UR = function () { var e = bf.apply(void 0, arguments), n = "animation-" + e.name; return { name: n, styles: "@keyframes " + n + "{" + e.styles + "}", anim: 1, toString: function () { return "_EMO_" + this.name + "_" + this.styles + "_EMO_" } } }; function HR(t, e) { return e || (e = t.slice(0)), Object.freeze(Object.defineProperties(t, { raw: { value: Object.freeze(e) } })) } const WR = Math.min, qR = Math.max, yl = Math.round, la = Math.floor, bl = t => ({ x: t, y: t }); function KR(t) { const { x: e, y: n, width: r, height: i } = t; return { width: r, height: i, top: n, left: e, right: e + r, bottom: n + i, x: e, y: n } } function S_(t) { return k_(t) ? (t.nodeName || "").toLowerCase() : "#document" } function On(t) { var e; return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window } function x_(t) { var e; return (e = (k_(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement } function k_(t) { return t instanceof Node || t instanceof On(t).Node } function GR(t) { return t instanceof Element || t instanceof On(t).Element } function _f(t) { return t instanceof HTMLElement || t instanceof On(t).HTMLElement } function Um(t) { return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof On(t).ShadowRoot } function C_(t) { const { overflow: e, overflowX: n, overflowY: r, display: i } = wf(t); return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(i) } function YR() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } function QR(t) { return ["html", "body", "#document"].includes(S_(t)) } function wf(t) { return On(t).getComputedStyle(t) } function XR(t) { if (S_(t) === "html") return t; const e = t.assignedSlot || t.parentNode || Um(t) && t.host || x_(t); return Um(e) ? e.host : e } function O_(t) { const e = XR(t); return QR(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : _f(e) && C_(e) ? e : O_(e) } function _l(t, e, n) { var r; e === void 0 && (e = []), n === void 0 && (n = !0); const i = O_(t), s = i === ((r = t.ownerDocument) == null ? void 0 : r.body), o = On(i); return s ? e.concat(o, o.visualViewport || [], C_(i) ? i : [], o.frameElement && n ? _l(o.frameElement) : []) : e.concat(i, _l(i, [], n)) } function JR(t) { const e = wf(t); let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0; const i = _f(t), s = i ? t.offsetWidth : n, o = i ? t.offsetHeight : r, a = yl(n) !== s || yl(r) !== o; return a && (n = s, r = o), { width: n, height: r, $: a } } function Sf(t) { return GR(t) ? t : t.contextElement } function Hm(t) { const e = Sf(t); if (!_f(e)) return bl(1); const n = e.getBoundingClientRect(), { width: r, height: i, $: s } = JR(e); let o = (s ? yl(n.width) : n.width) / r, a = (s ? yl(n.height) : n.height) / i; return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), { x: o, y: a } } const ZR = bl(0); function eM(t) { const e = On(t); return !YR() || !e.visualViewport ? ZR : { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop } } function tM(t, e, n) { return !1 } function Wm(t, e, n, r) { e === void 0 && (e = !1); const i = t.getBoundingClientRect(), s = Sf(t); let o = bl(1); e && (o = Hm(t)); const a = tM() ? eM(s) : bl(0); let l = (i.left + a.x) / o.x, u = (i.top + a.y) / o.y, c = i.width / o.x, d = i.height / o.y; if (s) { const h = On(s), f = r; let g = h, m = g.frameElement; for (; m && r && f !== g;) { const y = Hm(m), p = m.getBoundingClientRect(), v = wf(m), b = p.left + (m.clientLeft + parseFloat(v.paddingLeft)) * y.x, S = p.top + (m.clientTop + parseFloat(v.paddingTop)) * y.y; l *= y.x, u *= y.y, c *= y.x, d *= y.y, l += b, u += S, g = On(m), m = g.frameElement } } return KR({ width: c, height: d, x: l, y: u }) } function nM(t, e) { let n = null, r; const i = x_(t); function s() { var a; clearTimeout(r), (a = n) == null || a.disconnect(), n = null } function o(a, l) { a === void 0 && (a = !1), l === void 0 && (l = 1), s(); const { left: u, top: c, width: d, height: h } = t.getBoundingClientRect(); if (a || e(), !d || !h) return; const f = la(c), g = la(i.clientWidth - (u + d)), m = la(i.clientHeight - (c + h)), y = la(u), v = { rootMargin: -f + "px " + -g + "px " + -m + "px " + -y + "px", threshold: qR(0, WR(1, l)) || 1 }; let b = !0; function S(P) { const I = P[0].intersectionRatio; if (I !== l) { if (!b) return o(); I ? o(!1, I) : r = setTimeout(() => { o(!1, 1e-7) }, 1e3) } b = !1 } try { n = new IntersectionObserver(S, { ...v, root: i.ownerDocument }) } catch { n = new IntersectionObserver(S, v) } n.observe(t) } return o(!0), s } function rM(t, e, n, r) { r === void 0 && (r = {}); const { ancestorScroll: i = !0, ancestorResize: s = !0, elementResize: o = typeof ResizeObserver == "function", layoutShift: a = typeof IntersectionObserver == "function", animationFrame: l = !1 } = r, u = Sf(t), c = i || s ? [...u ? _l(u) : [], ..._l(e)] : []; c.forEach(p => { i && p.addEventListener("scroll", n, { passive: !0 }), s && p.addEventListener("resize", n) }); const d = u && a ? nM(u, n) : null; let h = -1, f = null; o && (f = new ResizeObserver(p => { let [v] = p; v && v.target === u && f && (f.unobserve(e), cancelAnimationFrame(h), h = requestAnimationFrame(() => { var b; (b = f) == null || b.observe(e) })), n() }), u && !l && f.observe(u), f.observe(e)); let g, m = l ? Wm(t) : null; l && y(); function y() { const p = Wm(t); m && (p.x !== m.x || p.y !== m.y || p.width !== m.width || p.height !== m.height) && n(), m = p, g = requestAnimationFrame(y) } return n(), () => { var p; c.forEach(v => { i && v.removeEventListener("scroll", n), s && v.removeEventListener("resize", n) }), d == null || d(), (p = f) == null || p.disconnect(), f = null, l && cancelAnimationFrame(g) } } var $d = R.useLayoutEffect, iM = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], wl = function () { }; function sM(t, e) { return e ? e[0] === "-" ? t + e : t + "__" + e : t } function oM(t, e) { for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)r[i - 2] = arguments[i]; var s = [].concat(r); if (e && t) for (var o in e) e.hasOwnProperty(o) && e[o] && s.push("".concat(sM(t, o))); return s.filter(function (a) { return a }).map(function (a) { return String(a).trim() }).join(" ") } var qm = function (e) { return gM(e) ? e.filter(Boolean) : Nr(e) === "object" && e !== null ? [e] : [] }, P_ = function (e) { e.className, e.clearValue, e.cx, e.getStyles, e.getClassNames, e.getValue, e.hasValue, e.isMulti, e.isRtl, e.options, e.selectOption, e.selectProps, e.setValue, e.theme; var n = En(e, iM); return Q({}, n) }, Oe = function (e, n, r) { var i = e.cx, s = e.getStyles, o = e.getClassNames, a = e.className; return { css: s(n, e), className: i(r ?? {}, o(n, e), a) } }; function gu(t) { return [document.documentElement, document.body, window].indexOf(t) > -1 } function aM(t) { return gu(t) ? window.innerHeight : t.clientHeight } function E_(t) { return gu(t) ? window.pageYOffset : t.scrollTop } function Sl(t, e) { if (gu(t)) { window.scrollTo(0, e); return } t.scrollTop = e } function lM(t) { var e = getComputedStyle(t), n = e.position === "absolute", r = /(auto|scroll)/; if (e.position === "fixed") return document.documentElement; for (var i = t; i = i.parentElement;)if (e = getComputedStyle(i), !(n && e.position === "static") && r.test(e.overflow + e.overflowY + e.overflowX)) return i; return document.documentElement } function uM(t, e, n, r) { return n * ((t = t / r - 1) * t * t + 1) + e } function ua(t, e) { var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : wl, i = E_(t), s = e - i, o = 10, a = 0; function l() { a += o; var u = uM(a, i, s, n); Sl(t, u), a < n ? window.requestAnimationFrame(l) : r(t) } l() } function Km(t, e) { var n = t.getBoundingClientRect(), r = e.getBoundingClientRect(), i = e.offsetHeight / 3; r.bottom + i > n.bottom ? Sl(t, Math.min(e.offsetTop + e.clientHeight - t.offsetHeight + i, t.scrollHeight)) : r.top - i < n.top && Sl(t, Math.max(e.offsetTop - i, 0)) } function cM(t) { var e = t.getBoundingClientRect(); return { bottom: e.bottom, height: e.height, left: e.left, right: e.right, top: e.top, width: e.width } } function Gm() { try { return document.createEvent("TouchEvent"), !0 } catch { return !1 } } function dM() { try { return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) } catch { return !1 } } var T_ = !1, hM = { get passive() { return T_ = !0 } }, ca = typeof window < "u" ? window : {}; ca.addEventListener && ca.removeEventListener && (ca.addEventListener("p", wl, hM), ca.removeEventListener("p", wl, !1)); var fM = T_; function pM(t) { return t != null } function gM(t) { return Array.isArray(t) } function da(t, e, n) { return t ? e : n } var mM = function (e) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; var s = Object.entries(e).filter(function (o) { var a = wn(o, 1), l = a[0]; return !r.includes(l) }); return s.reduce(function (o, a) { var l = wn(a, 2), u = l[0], c = l[1]; return o[u] = c, o }, {}) }, vM = ["children", "innerProps"], yM = ["children", "innerProps"]; function bM(t) { var e = t.maxHeight, n = t.menuEl, r = t.minHeight, i = t.placement, s = t.shouldScroll, o = t.isFixedPosition, a = t.controlHeight, l = lM(n), u = { placement: "bottom", maxHeight: e }; if (!n || !n.offsetParent) return u; var c = l.getBoundingClientRect(), d = c.height, h = n.getBoundingClientRect(), f = h.bottom, g = h.height, m = h.top, y = n.offsetParent.getBoundingClientRect(), p = y.top, v = o ? window.innerHeight : aM(l), b = E_(l), S = parseInt(getComputedStyle(n).marginBottom, 10), P = parseInt(getComputedStyle(n).marginTop, 10), I = p - P, T = v - m, k = I + b, E = d - b - m, M = f - v + b + S, L = b + m - P, N = 160; switch (i) { case "auto": case "bottom": if (T >= g) return { placement: "bottom", maxHeight: e }; if (E >= g && !o) return s && ua(l, M, N), { placement: "bottom", maxHeight: e }; if (!o && E >= r || o && T >= r) { s && ua(l, M, N); var $ = o ? T - S : E - S; return { placement: "bottom", maxHeight: $ } } if (i === "auto" || o) { var B = e, H = o ? I : k; return H >= r && (B = Math.min(H - S - a, e)), { placement: "top", maxHeight: B } } if (i === "bottom") return s && Sl(l, M), { placement: "bottom", maxHeight: e }; break; case "top": if (I >= g) return { placement: "top", maxHeight: e }; if (k >= g && !o) return s && ua(l, L, N), { placement: "top", maxHeight: e }; if (!o && k >= r || o && I >= r) { var V = e; return (!o && k >= r || o && I >= r) && (V = o ? I - P : k - P), s && ua(l, L, N), { placement: "top", maxHeight: V } } return { placement: "bottom", maxHeight: e }; default: throw new Error('Invalid placement provided "'.concat(i, '".')) }return u } function _M(t) { var e = { bottom: "top", top: "bottom" }; return t ? e[t] : "bottom" } var I_ = function (e) { return e === "auto" ? "bottom" : e }, wM = function (e, n) { var r, i = e.placement, s = e.theme, o = s.borderRadius, a = s.spacing, l = s.colors; return Q((r = { label: "menu" }, vs(r, _M(i), "100%"), vs(r, "position", "absolute"), vs(r, "width", "100%"), vs(r, "zIndex", 1), r), n ? {} : { backgroundColor: l.neutral0, borderRadius: o, boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)", marginBottom: a.menuGutter, marginTop: a.menuGutter }) }, R_ = R.createContext(null), SM = function (e) { var n = e.children, r = e.minMenuHeight, i = e.maxMenuHeight, s = e.menuPlacement, o = e.menuPosition, a = e.menuShouldScrollIntoView, l = e.theme, u = R.useContext(R_) || {}, c = u.setPortalPlacement, d = R.useRef(null), h = R.useState(i), f = wn(h, 2), g = f[0], m = f[1], y = R.useState(null), p = wn(y, 2), v = p[0], b = p[1], S = l.spacing.controlHeight; return $d(function () { var P = d.current; if (P) { var I = o === "fixed", T = a && !I, k = bM({ maxHeight: i, menuEl: P, minHeight: r, placement: s, shouldScroll: T, isFixedPosition: I, controlHeight: S }); m(k.maxHeight), b(k.placement), c == null || c(k.placement) } }, [i, s, o, a, r, c, S]), n({ ref: d, placerProps: Q(Q({}, e), {}, { placement: v || I_(s), maxHeight: g }) }) }, xM = function (e) { var n = e.children, r = e.innerRef, i = e.innerProps; return Y("div", X({}, Oe(e, "menu", { menu: !0 }), { ref: r }, i), n) }, kM = xM, CM = function (e, n) { var r = e.maxHeight, i = e.theme.spacing.baseUnit; return Q({ maxHeight: r, overflowY: "auto", position: "relative", WebkitOverflowScrolling: "touch" }, n ? {} : { paddingBottom: i, paddingTop: i }) }, OM = function (e) { var n = e.children, r = e.innerProps, i = e.innerRef, s = e.isMulti; return Y("div", X({}, Oe(e, "menuList", { "menu-list": !0, "menu-list--is-multi": s }), { ref: i }, r), n) }, M_ = function (e, n) { var r = e.theme, i = r.spacing.baseUnit, s = r.colors; return Q({ textAlign: "center" }, n ? {} : { color: s.neutral40, padding: "".concat(i * 2, "px ").concat(i * 3, "px") }) }, PM = M_, EM = M_, TM = function (e) { var n = e.children, r = n === void 0 ? "No options" : n, i = e.innerProps, s = En(e, vM); return Y("div", X({}, Oe(Q(Q({}, s), {}, { children: r, innerProps: i }), "noOptionsMessage", { "menu-notice": !0, "menu-notice--no-options": !0 }), i), r) }, IM = function (e) { var n = e.children, r = n === void 0 ? "Loading..." : n, i = e.innerProps, s = En(e, yM); return Y("div", X({}, Oe(Q(Q({}, s), {}, { children: r, innerProps: i }), "loadingMessage", { "menu-notice": !0, "menu-notice--loading": !0 }), i), r) }, RM = function (e) { var n = e.rect, r = e.offset, i = e.position; return { left: n.left, position: i, top: r, width: n.width, zIndex: 1 } }, MM = function (e) { var n = e.appendTo, r = e.children, i = e.controlElement, s = e.innerProps, o = e.menuPlacement, a = e.menuPosition, l = R.useRef(null), u = R.useRef(null), c = R.useState(I_(o)), d = wn(c, 2), h = d[0], f = d[1], g = R.useMemo(function () { return { setPortalPlacement: f } }, []), m = R.useState(null), y = wn(m, 2), p = y[0], v = y[1], b = R.useCallback(function () { if (i) { var T = cM(i), k = a === "fixed" ? 0 : window.pageYOffset, E = T[h] + k; (E !== (p == null ? void 0 : p.offset) || T.left !== (p == null ? void 0 : p.rect.left) || T.width !== (p == null ? void 0 : p.rect.width)) && v({ offset: E, rect: T }) } }, [i, a, h, p == null ? void 0 : p.offset, p == null ? void 0 : p.rect.left, p == null ? void 0 : p.rect.width]); $d(function () { b() }, [b]); var S = R.useCallback(function () { typeof u.current == "function" && (u.current(), u.current = null), i && l.current && (u.current = rM(i, l.current, b, { elementResize: "ResizeObserver" in window })) }, [i, b]); $d(function () { S() }, [S]); var P = R.useCallback(function (T) { l.current = T, S() }, [S]); if (!n && a !== "fixed" || !p) return null; var I = Y("div", X({ ref: P }, Oe(Q(Q({}, e), {}, { offset: p.offset, position: a, rect: p.rect }), "menuPortal", { "menu-portal": !0 }), s), r); return Y(R_.Provider, { value: g }, n ? C0.createPortal(I, n) : I) }, LM = function (e) { var n = e.isDisabled, r = e.isRtl; return { label: "container", direction: r ? "rtl" : void 0, pointerEvents: n ? "none" : void 0, position: "relative" } }, DM = function (e) { var n = e.children, r = e.innerProps, i = e.isDisabled, s = e.isRtl; return Y("div", X({}, Oe(e, "container", { "--is-disabled": i, "--is-rtl": s }), r), n) }, AM = function (e, n) { var r = e.theme.spacing, i = e.isMulti, s = e.hasValue, o = e.selectProps.controlShouldRenderValue; return Q({ alignItems: "center", display: i && s && o ? "flex" : "grid", flex: 1, flexWrap: "wrap", WebkitOverflowScrolling: "touch", position: "relative", overflow: "hidden" }, n ? {} : { padding: "".concat(r.baseUnit / 2, "px ").concat(r.baseUnit * 2, "px") }) }, jM = function (e) { var n = e.children, r = e.innerProps, i = e.isMulti, s = e.hasValue; return Y("div", X({}, Oe(e, "valueContainer", { "value-container": !0, "value-container--is-multi": i, "value-container--has-value": s }), r), n) }, NM = function () { return { alignItems: "center", alignSelf: "stretch", display: "flex", flexShrink: 0 } }, FM = function (e) { var n = e.children, r = e.innerProps; return Y("div", X({}, Oe(e, "indicatorsContainer", { indicators: !0 }), r), n) }, Ym, $M = ["size"], zM = ["innerProps", "isRtl", "size"], VM = { name: "8mmkcg", styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0" }, L_ = function (e) { var n = e.size, r = En(e, $M); return Y("svg", X({ height: n, width: n, viewBox: "0 0 20 20", "aria-hidden": "true", focusable: "false", css: VM }, r)) }, xf = function (e) { return Y(L_, X({ size: 20 }, e), Y("path", { d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z" })) }, D_ = function (e) { return Y(L_, X({ size: 20 }, e), Y("path", { d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z" })) }, A_ = function (e, n) { var r = e.isFocused, i = e.theme, s = i.spacing.baseUnit, o = i.colors; return Q({ label: "indicatorContainer", display: "flex", transition: "color 150ms" }, n ? {} : { color: r ? o.neutral60 : o.neutral20, padding: s * 2, ":hover": { color: r ? o.neutral80 : o.neutral40 } }) }, BM = A_, UM = function (e) { var n = e.children, r = e.innerProps; return Y("div", X({}, Oe(e, "dropdownIndicator", { indicator: !0, "dropdown-indicator": !0 }), r), n || Y(D_, null)) }, HM = A_, WM = function (e) { var n = e.children, r = e.innerProps; return Y("div", X({}, Oe(e, "clearIndicator", { indicator: !0, "clear-indicator": !0 }), r), n || Y(xf, null)) }, qM = function (e, n) { var r = e.isDisabled, i = e.theme, s = i.spacing.baseUnit, o = i.colors; return Q({ label: "indicatorSeparator", alignSelf: "stretch", width: 1 }, n ? {} : { backgroundColor: r ? o.neutral10 : o.neutral20, marginBottom: s * 2, marginTop: s * 2 }) }, KM = function (e) { var n = e.innerProps; return Y("span", X({}, n, Oe(e, "indicatorSeparator", { "indicator-separator": !0 }))) }, GM = UR(Ym || (Ym = HR([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), YM = function (e, n) { var r = e.isFocused, i = e.size, s = e.theme, o = s.colors, a = s.spacing.baseUnit; return Q({ label: "loadingIndicator", display: "flex", transition: "color 150ms", alignSelf: "center", fontSize: i, lineHeight: 1, marginRight: i, textAlign: "center", verticalAlign: "middle" }, n ? {} : { color: r ? o.neutral60 : o.neutral20, padding: a * 2 }) }, pc = function (e) { var n = e.delay, r = e.offset; return Y("span", { css: bf({ animation: "".concat(GM, " 1s ease-in-out ").concat(n, "ms infinite;"), backgroundColor: "currentColor", borderRadius: "1em", display: "inline-block", marginLeft: r ? "1em" : void 0, height: "1em", verticalAlign: "top", width: "1em" }, "", "") }) }, QM = function (e) { var n = e.innerProps, r = e.isRtl, i = e.size, s = i === void 0 ? 4 : i, o = En(e, zM); return Y("div", X({}, Oe(Q(Q({}, o), {}, { innerProps: n, isRtl: r, size: s }), "loadingIndicator", { indicator: !0, "loading-indicator": !0 }), n), Y(pc, { delay: 0, offset: r }), Y(pc, { delay: 160, offset: !0 }), Y(pc, { delay: 320, offset: !r })) }, XM = function (e, n) { var r = e.isDisabled, i = e.isFocused, s = e.theme, o = s.colors, a = s.borderRadius, l = s.spacing; return Q({ label: "control", alignItems: "center", cursor: "default", display: "flex", flexWrap: "wrap", justifyContent: "space-between", minHeight: l.controlHeight, outline: "0 !important", position: "relative", transition: "all 100ms" }, n ? {} : { backgroundColor: r ? o.neutral5 : o.neutral0, borderColor: r ? o.neutral10 : i ? o.primary : o.neutral20, borderRadius: a, borderStyle: "solid", borderWidth: 1, boxShadow: i ? "0 0 0 1px ".concat(o.primary) : void 0, "&:hover": { borderColor: i ? o.primary : o.neutral30 } }) }, JM = function (e) { var n = e.children, r = e.isDisabled, i = e.isFocused, s = e.innerRef, o = e.innerProps, a = e.menuIsOpen; return Y("div", X({ ref: s }, Oe(e, "control", { control: !0, "control--is-disabled": r, "control--is-focused": i, "control--menu-is-open": a }), o, { "aria-disabled": r || void 0 }), n) }, ZM = JM, eL = ["data"], tL = function (e, n) { var r = e.theme.spacing; return n ? {} : { paddingBottom: r.baseUnit * 2, paddingTop: r.baseUnit * 2 } }, nL = function (e) { var n = e.children, r = e.cx, i = e.getStyles, s = e.getClassNames, o = e.Heading, a = e.headingProps, l = e.innerProps, u = e.label, c = e.theme, d = e.selectProps; return Y("div", X({}, Oe(e, "group", { group: !0 }), l), Y(o, X({}, a, { selectProps: d, theme: c, getStyles: i, getClassNames: s, cx: r }), u), Y("div", null, n)) }, rL = function (e, n) { var r = e.theme, i = r.colors, s = r.spacing; return Q({ label: "group", cursor: "default", display: "block" }, n ? {} : { color: i.neutral40, fontSize: "75%", fontWeight: 500, marginBottom: "0.25em", paddingLeft: s.baseUnit * 3, paddingRight: s.baseUnit * 3, textTransform: "uppercase" }) }, iL = function (e) { var n = P_(e); n.data; var r = En(n, eL); return Y("div", X({}, Oe(e, "groupHeading", { "group-heading": !0 }), r)) }, sL = nL, oL = ["innerRef", "isDisabled", "isHidden", "inputClassName"], aL = function (e, n) { var r = e.isDisabled, i = e.value, s = e.theme, o = s.spacing, a = s.colors; return Q(Q({ visibility: r ? "hidden" : "visible", transform: i ? "translateZ(0)" : "" }, lL), n ? {} : { margin: o.baseUnit / 2, paddingBottom: o.baseUnit / 2, paddingTop: o.baseUnit / 2, color: a.neutral80 }) }, j_ = { gridArea: "1 / 2", font: "inherit", minWidth: "2px", border: 0, margin: 0, outline: 0, padding: 0 }, lL = { flex: "1 1 auto", display: "inline-grid", gridArea: "1 / 1 / 2 / 3", gridTemplateColumns: "0 min-content", "&:after": Q({ content: 'attr(data-value) " "', visibility: "hidden", whiteSpace: "pre" }, j_) }, uL = function (e) { return Q({ label: "input", color: "inherit", background: 0, opacity: e ? 0 : 1, width: "100%" }, j_) }, cL = function (e) { var n = e.cx, r = e.value, i = P_(e), s = i.innerRef, o = i.isDisabled, a = i.isHidden, l = i.inputClassName, u = En(i, oL); return Y("div", X({}, Oe(e, "input", { "input-container": !0 }), { "data-value": r || "" }), Y("input", X({ className: n({ input: !0 }, l), ref: s, style: uL(a), disabled: o }, u))) }, dL = cL, hL = function (e, n) { var r = e.theme, i = r.spacing, s = r.borderRadius, o = r.colors; return Q({ label: "multiValue", display: "flex", minWidth: 0 }, n ? {} : { backgroundColor: o.neutral10, borderRadius: s / 2, margin: i.baseUnit / 2 }) }, fL = function (e, n) { var r = e.theme, i = r.borderRadius, s = r.colors, o = e.cropWithEllipsis; return Q({ overflow: "hidden", textOverflow: o || o === void 0 ? "ellipsis" : void 0, whiteSpace: "nowrap" }, n ? {} : { borderRadius: i / 2, color: s.neutral80, fontSize: "85%", padding: 3, paddingLeft: 6 }) }, pL = function (e, n) { var r = e.theme, i = r.spacing, s = r.borderRadius, o = r.colors, a = e.isFocused; return Q({ alignItems: "center", display: "flex" }, n ? {} : { borderRadius: s / 2, backgroundColor: a ? o.dangerLight : void 0, paddingLeft: i.baseUnit, paddingRight: i.baseUnit, ":hover": { backgroundColor: o.dangerLight, color: o.danger } }) }, N_ = function (e) { var n = e.children, r = e.innerProps; return Y("div", r, n) }, gL = N_, mL = N_; function vL(t) { var e = t.children, n = t.innerProps; return Y("div", X({ role: "button" }, n), e || Y(xf, { size: 14 })) } var yL = function (e) { var n = e.children, r = e.components, i = e.data, s = e.innerProps, o = e.isDisabled, a = e.removeProps, l = e.selectProps, u = r.Container, c = r.Label, d = r.Remove; return Y(u, { data: i, innerProps: Q(Q({}, Oe(e, "multiValue", { "multi-value": !0, "multi-value--is-disabled": o })), s), selectProps: l }, Y(c, { data: i, innerProps: Q({}, Oe(e, "multiValueLabel", { "multi-value__label": !0 })), selectProps: l }, n), Y(d, { data: i, innerProps: Q(Q({}, Oe(e, "multiValueRemove", { "multi-value__remove": !0 })), {}, { "aria-label": "Remove ".concat(n || "option") }, a), selectProps: l })) }, bL = yL, _L = function (e, n) { var r = e.isDisabled, i = e.isFocused, s = e.isSelected, o = e.theme, a = o.spacing, l = o.colors; return Q({ label: "option", cursor: "default", display: "block", fontSize: "inherit", width: "100%", userSelect: "none", WebkitTapHighlightColor: "rgba(0, 0, 0, 0)" }, n ? {} : { backgroundColor: s ? l.primary : i ? l.primary25 : "transparent", color: r ? l.neutral20 : s ? l.neutral0 : "inherit", padding: "".concat(a.baseUnit * 2, "px ").concat(a.baseUnit * 3, "px"), ":active": { backgroundColor: r ? void 0 : s ? l.primary : l.primary50 } }) }, wL = function (e) { var n = e.children, r = e.isDisabled, i = e.isFocused, s = e.isSelected, o = e.innerRef, a = e.innerProps; return Y("div", X({}, Oe(e, "option", { option: !0, "option--is-disabled": r, "option--is-focused": i, "option--is-selected": s }), { ref: o, "aria-disabled": r }, a), n) }, SL = wL, xL = function (e, n) { var r = e.theme, i = r.spacing, s = r.colors; return Q({ label: "placeholder", gridArea: "1 / 1 / 2 / 3" }, n ? {} : { color: s.neutral50, marginLeft: i.baseUnit / 2, marginRight: i.baseUnit / 2 }) }, kL = function (e) { var n = e.children, r = e.innerProps; return Y("div", X({}, Oe(e, "placeholder", { placeholder: !0 }), r), n) }, CL = kL, OL = function (e, n) { var r = e.isDisabled, i = e.theme, s = i.spacing, o = i.colors; return Q({ label: "singleValue", gridArea: "1 / 1 / 2 / 3", maxWidth: "100%", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }, n ? {} : { color: r ? o.neutral40 : o.neutral80, marginLeft: s.baseUnit / 2, marginRight: s.baseUnit / 2 }) }, PL = function (e) { var n = e.children, r = e.isDisabled, i = e.innerProps; return Y("div", X({}, Oe(e, "singleValue", { "single-value": !0, "single-value--is-disabled": r }), i), n) }, EL = PL, TL = { ClearIndicator: WM, Control: ZM, DropdownIndicator: UM, DownChevron: D_, CrossIcon: xf, Group: sL, GroupHeading: iL, IndicatorsContainer: FM, IndicatorSeparator: KM, Input: dL, LoadingIndicator: QM, Menu: kM, MenuList: OM, MenuPortal: MM, LoadingMessage: IM, NoOptionsMessage: TM, MultiValue: bL, MultiValueContainer: gL, MultiValueLabel: mL, MultiValueRemove: vL, Option: SL, Placeholder: CL, SelectContainer: DM, SingleValue: EL, ValueContainer: jM }, IL = function (e) { return Q(Q({}, TL), e.components) }, Qm = Number.isNaN || function (e) { return typeof e == "number" && e !== e }; function RL(t, e) { return !!(t === e || Qm(t) && Qm(e)) } function ML(t, e) { if (t.length !== e.length) return !1; for (var n = 0; n < t.length; n++)if (!RL(t[n], e[n])) return !1; return !0 } function LL(t, e) { e === void 0 && (e = ML); var n = null; function r() { for (var i = [], s = 0; s < arguments.length; s++)i[s] = arguments[s]; if (n && n.lastThis === this && e(i, n.lastArgs)) return n.lastResult; var o = t.apply(this, i); return n = { lastResult: o, lastArgs: i, lastThis: this }, o } return r.clear = function () { n = null }, r } var DL = { name: "7pg0cj-a11yText", styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap" }, AL = function (e) { return Y("span", X({ css: DL }, e)) }, Xm = AL, jL = { guidance: function (e) { var n = e.isSearchable, r = e.isMulti, i = e.tabSelectsValue, s = e.context, o = e.isInitialFocus; switch (s) { case "menu": return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(i ? ", press Tab to select the option and exit the menu" : "", "."); case "input": return o ? "".concat(e["aria-label"] || "Select", " is focused ").concat(n ? ",type to refine list" : "", ", press Down to open the menu, ").concat(r ? " press left to focus selected values" : "") : ""; case "value": return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value"; default: return "" } }, onChange: function (e) { var n = e.action, r = e.label, i = r === void 0 ? "" : r, s = e.labels, o = e.isDisabled; switch (n) { case "deselect-option": case "pop-value": case "remove-value": return "option ".concat(i, ", deselected."); case "clear": return "All selected options have been cleared."; case "initial-input-focus": return "option".concat(s.length > 1 ? "s" : "", " ").concat(s.join(","), ", selected."); case "select-option": return o ? "option ".concat(i, " is disabled. Select another option.") : "option ".concat(i, ", selected."); default: return "" } }, onFocus: function (e) { var n = e.context, r = e.focused, i = e.options, s = e.label, o = s === void 0 ? "" : s, a = e.selectValue, l = e.isDisabled, u = e.isSelected, c = e.isAppleDevice, d = function (m, y) { return m && m.length ? "".concat(m.indexOf(y) + 1, " of ").concat(m.length) : "" }; if (n === "value" && a) return "value ".concat(o, " focused, ").concat(d(a, r), "."); if (n === "menu" && c) { var h = l ? " disabled" : "", f = "".concat(u ? " selected" : "").concat(h); return "".concat(o).concat(f, ", ").concat(d(i, r), ".") } return "" }, onFilter: function (e) { var n = e.inputValue, r = e.resultsMessage; return "".concat(r).concat(n ? " for search term " + n : "", ".") } }, NL = function (e) { var n = e.ariaSelection, r = e.focusedOption, i = e.focusedValue, s = e.focusableOptions, o = e.isFocused, a = e.selectValue, l = e.selectProps, u = e.id, c = e.isAppleDevice, d = l.ariaLiveMessages, h = l.getOptionLabel, f = l.inputValue, g = l.isMulti, m = l.isOptionDisabled, y = l.isSearchable, p = l.menuIsOpen, v = l.options, b = l.screenReaderStatus, S = l.tabSelectsValue, P = l.isLoading, I = l["aria-label"], T = l["aria-live"], k = R.useMemo(function () { return Q(Q({}, jL), d || {}) }, [d]), E = R.useMemo(function () { var H = ""; if (n && k.onChange) { var V = n.option, q = n.options, j = n.removedValue, _ = n.removedValues, x = n.value, C = function (K) { return Array.isArray(K) ? null : K }, w = j || V || C(x), O = w ? h(w) : "", D = q || _ || void 0, F = D ? D.map(h) : [], z = Q({ isDisabled: w && m(w, a), label: O, labels: F }, n); H = k.onChange(z) } return H }, [n, k, m, a, h]), M = R.useMemo(function () { var H = "", V = r || i, q = !!(r && a && a.includes(r)); if (V && k.onFocus) { var j = { focused: V, label: h(V), isDisabled: m(V, a), isSelected: q, options: s, context: V === r ? "menu" : "value", selectValue: a, isAppleDevice: c }; H = k.onFocus(j) } return H }, [r, i, h, m, k, s, a, c]), L = R.useMemo(function () { var H = ""; if (p && v.length && !P && k.onFilter) { var V = b({ count: s.length }); H = k.onFilter({ inputValue: f, resultsMessage: V }) } return H }, [s, f, p, k, v, b, P]), N = (n == null ? void 0 : n.action) === "initial-input-focus", $ = R.useMemo(function () { var H = ""; if (k.guidance) { var V = i ? "value" : p ? "menu" : "input"; H = k.guidance({ "aria-label": I, context: V, isDisabled: r && m(r, a), isMulti: g, isSearchable: y, tabSelectsValue: S, isInitialFocus: N }) } return H }, [I, r, i, g, m, y, p, k, a, S, N]), B = Y(R.Fragment, null, Y("span", { id: "aria-selection" }, E), Y("span", { id: "aria-focused" }, M), Y("span", { id: "aria-results" }, L), Y("span", { id: "aria-guidance" }, $)); return Y(R.Fragment, null, Y(Xm, { id: u }, N && B), Y(Xm, { "aria-live": T, "aria-atomic": "false", "aria-relevant": "additions text", role: "log" }, o && !N && B)) }, FL = NL, zd = [{ base: "A", letters: "AⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ" }, { base: "AA", letters: "Ꜳ" }, { base: "AE", letters: "ÆǼǢ" }, { base: "AO", letters: "Ꜵ" }, { base: "AU", letters: "Ꜷ" }, { base: "AV", letters: "ꜸꜺ" }, { base: "AY", letters: "Ꜽ" }, { base: "B", letters: "BⒷＢḂḄḆɃƂƁ" }, { base: "C", letters: "CⒸＣĆĈĊČÇḈƇȻꜾ" }, { base: "D", letters: "DⒹＤḊĎḌḐḒḎĐƋƊƉꝹ" }, { base: "DZ", letters: "ǱǄ" }, { base: "Dz", letters: "ǲǅ" }, { base: "E", letters: "EⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎ" }, { base: "F", letters: "FⒻＦḞƑꝻ" }, { base: "G", letters: "GⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾ" }, { base: "H", letters: "HⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ" }, { base: "I", letters: "IⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ" }, { base: "J", letters: "JⒿＪĴɈ" }, { base: "K", letters: "KⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ" }, { base: "L", letters: "LⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ" }, { base: "LJ", letters: "Ǉ" }, { base: "Lj", letters: "ǈ" }, { base: "M", letters: "MⓂＭḾṀṂⱮƜ" }, { base: "N", letters: "NⓃＮǸŃÑṄŇṆŅṊṈȠƝꞐꞤ" }, { base: "NJ", letters: "Ǌ" }, { base: "Nj", letters: "ǋ" }, { base: "O", letters: "OⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ" }, { base: "OI", letters: "Ƣ" }, { base: "OO", letters: "Ꝏ" }, { base: "OU", letters: "Ȣ" }, { base: "P", letters: "PⓅＰṔṖƤⱣꝐꝒꝔ" }, { base: "Q", letters: "QⓆＱꝖꝘɊ" }, { base: "R", letters: "RⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ" }, { base: "S", letters: "SⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ" }, { base: "T", letters: "TⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ" }, { base: "TZ", letters: "Ꜩ" }, { base: "U", letters: "UⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ" }, { base: "V", letters: "VⓋＶṼṾƲꝞɅ" }, { base: "VY", letters: "Ꝡ" }, { base: "W", letters: "WⓌＷẀẂŴẆẄẈⱲ" }, { base: "X", letters: "XⓍＸẊẌ" }, { base: "Y", letters: "YⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ" }, { base: "Z", letters: "ZⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ" }, { base: "a", letters: "aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐ" }, { base: "aa", letters: "ꜳ" }, { base: "ae", letters: "æǽǣ" }, { base: "ao", letters: "ꜵ" }, { base: "au", letters: "ꜷ" }, { base: "av", letters: "ꜹꜻ" }, { base: "ay", letters: "ꜽ" }, { base: "b", letters: "bⓑｂḃḅḇƀƃɓ" }, { base: "c", letters: "cⓒｃćĉċčçḉƈȼꜿↄ" }, { base: "d", letters: "dⓓｄḋďḍḑḓḏđƌɖɗꝺ" }, { base: "dz", letters: "ǳǆ" }, { base: "e", letters: "eⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇɛǝ" }, { base: "f", letters: "fⓕｆḟƒꝼ" }, { base: "g", letters: "gⓖｇǵĝḡğġǧģǥɠꞡᵹꝿ" }, { base: "h", letters: "hⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ" }, { base: "hv", letters: "ƕ" }, { base: "i", letters: "iⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı" }, { base: "j", letters: "jⓙｊĵǰɉ" }, { base: "k", letters: "kⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ" }, { base: "l", letters: "lⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇ" }, { base: "lj", letters: "ǉ" }, { base: "m", letters: "mⓜｍḿṁṃɱɯ" }, { base: "n", letters: "nⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥ" }, { base: "nj", letters: "ǌ" }, { base: "o", letters: "oⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿɔꝋꝍɵ" }, { base: "oi", letters: "ƣ" }, { base: "ou", letters: "ȣ" }, { base: "oo", letters: "ꝏ" }, { base: "p", letters: "pⓟｐṕṗƥᵽꝑꝓꝕ" }, { base: "q", letters: "qⓠｑɋꝗꝙ" }, { base: "r", letters: "rⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ" }, { base: "s", letters: "sⓢｓßśṥŝṡšṧṣṩșşȿꞩꞅẛ" }, { base: "t", letters: "tⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ" }, { base: "tz", letters: "ꜩ" }, { base: "u", letters: "uⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ" }, { base: "v", letters: "vⓥｖṽṿʋꝟʌ" }, { base: "vy", letters: "ꝡ" }, { base: "w", letters: "wⓦｗẁẃŵẇẅẘẉⱳ" }, { base: "x", letters: "xⓧｘẋẍ" }, { base: "y", letters: "yⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ" }, { base: "z", letters: "zⓩｚźẑżžẓẕƶȥɀⱬꝣ" }], $L = new RegExp("[" + zd.map(function (t) { return t.letters }).join("") + "]", "g"), F_ = {}; for (var gc = 0; gc < zd.length; gc++)for (var mc = zd[gc], vc = 0; vc < mc.letters.length; vc++)F_[mc.letters[vc]] = mc.base; var $_ = function (e) { return e.replace($L, function (n) { return F_[n] }) }, zL = LL($_), Jm = function (e) { return e.replace(/^\s+|\s+$/g, "") }, VL = function (e) { return "".concat(e.label, " ").concat(e.value) }, BL = function (e) { return function (n, r) { if (n.data.__isNew__) return !0; var i = Q({ ignoreCase: !0, ignoreAccents: !0, stringify: VL, trim: !0, matchFrom: "any" }, e), s = i.ignoreCase, o = i.ignoreAccents, a = i.stringify, l = i.trim, u = i.matchFrom, c = l ? Jm(r) : r, d = l ? Jm(a(n)) : a(n); return s && (c = c.toLowerCase(), d = d.toLowerCase()), o && (c = zL(c), d = $_(d)), u === "start" ? d.substr(0, c.length) === c : d.indexOf(c) > -1 } }, UL = ["innerRef"]; function HL(t) { var e = t.innerRef, n = En(t, UL), r = mM(n, "onExited", "in", "enter", "exit", "appear"); return Y("input", X({ ref: e }, r, { css: bf({ label: "dummyInput", background: 0, border: 0, caretColor: "transparent", fontSize: "inherit", gridArea: "1 / 1 / 2 / 3", outline: 0, padding: 0, width: 1, color: "transparent", left: -100, opacity: 0, position: "relative", transform: "scale(.01)" }, "", "") })) } var WL = function (e) { e.cancelable && e.preventDefault(), e.stopPropagation() }; function qL(t) { var e = t.isEnabled, n = t.onBottomArrive, r = t.onBottomLeave, i = t.onTopArrive, s = t.onTopLeave, o = R.useRef(!1), a = R.useRef(!1), l = R.useRef(0), u = R.useRef(null), c = R.useCallback(function (y, p) { if (u.current !== null) { var v = u.current, b = v.scrollTop, S = v.scrollHeight, P = v.clientHeight, I = u.current, T = p > 0, k = S - P - b, E = !1; k > p && o.current && (r && r(y), o.current = !1), T && a.current && (s && s(y), a.current = !1), T && p > k ? (n && !o.current && n(y), I.scrollTop = S, E = !0, o.current = !0) : !T && -p > b && (i && !a.current && i(y), I.scrollTop = 0, E = !0, a.current = !0), E && WL(y) } }, [n, r, i, s]), d = R.useCallback(function (y) { c(y, y.deltaY) }, [c]), h = R.useCallback(function (y) { l.current = y.changedTouches[0].clientY }, []), f = R.useCallback(function (y) { var p = l.current - y.changedTouches[0].clientY; c(y, p) }, [c]), g = R.useCallback(function (y) { if (y) { var p = fM ? { passive: !1 } : !1; y.addEventListener("wheel", d, p), y.addEventListener("touchstart", h, p), y.addEventListener("touchmove", f, p) } }, [f, h, d]), m = R.useCallback(function (y) { y && (y.removeEventListener("wheel", d, !1), y.removeEventListener("touchstart", h, !1), y.removeEventListener("touchmove", f, !1)) }, [f, h, d]); return R.useEffect(function () { if (e) { var y = u.current; return g(y), function () { m(y) } } }, [e, g, m]), function (y) { u.current = y } } var Zm = ["boxSizing", "height", "overflow", "paddingRight", "position"], ev = { boxSizing: "border-box", overflow: "hidden", position: "relative", height: "100%" }; function tv(t) { t.preventDefault() } function nv(t) { t.stopPropagation() } function rv() { var t = this.scrollTop, e = this.scrollHeight, n = t + this.offsetHeight; t === 0 ? this.scrollTop = 1 : n === e && (this.scrollTop = t - 1) } function iv() { return "ontouchstart" in window || navigator.maxTouchPoints } var sv = !!(typeof window < "u" && window.document && window.document.createElement), ls = 0, Xr = { capture: !1, passive: !1 }; function KL(t) { var e = t.isEnabled, n = t.accountForScrollbars, r = n === void 0 ? !0 : n, i = R.useRef({}), s = R.useRef(null), o = R.useCallback(function (l) { if (sv) { var u = document.body, c = u && u.style; if (r && Zm.forEach(function (g) { var m = c && c[g]; i.current[g] = m }), r && ls < 1) { var d = parseInt(i.current.paddingRight, 10) || 0, h = document.body ? document.body.clientWidth : 0, f = window.innerWidth - h + d || 0; Object.keys(ev).forEach(function (g) { var m = ev[g]; c && (c[g] = m) }), c && (c.paddingRight = "".concat(f, "px")) } u && iv() && (u.addEventListener("touchmove", tv, Xr), l && (l.addEventListener("touchstart", rv, Xr), l.addEventListener("touchmove", nv, Xr))), ls += 1 } }, [r]), a = R.useCallback(function (l) { if (sv) { var u = document.body, c = u && u.style; ls = Math.max(ls - 1, 0), r && ls < 1 && Zm.forEach(function (d) { var h = i.current[d]; c && (c[d] = h) }), u && iv() && (u.removeEventListener("touchmove", tv, Xr), l && (l.removeEventListener("touchstart", rv, Xr), l.removeEventListener("touchmove", nv, Xr))) } }, [r]); return R.useEffect(function () { if (e) { var l = s.current; return o(l), function () { a(l) } } }, [e, o, a]), function (l) { s.current = l } } var GL = function (e) { var n = e.target; return n.ownerDocument.activeElement && n.ownerDocument.activeElement.blur() }, YL = { name: "1kfdb0e", styles: "position:fixed;left:0;bottom:0;right:0;top:0" }; function QL(t) { var e = t.children, n = t.lockEnabled, r = t.captureEnabled, i = r === void 0 ? !0 : r, s = t.onBottomArrive, o = t.onBottomLeave, a = t.onTopArrive, l = t.onTopLeave, u = qL({ isEnabled: i, onBottomArrive: s, onBottomLeave: o, onTopArrive: a, onTopLeave: l }), c = KL({ isEnabled: n }), d = function (f) { u(f), c(f) }; return Y(R.Fragment, null, n && Y("div", { onClick: GL, css: YL }), e(d)) } var XL = { name: "1a0ro4n-requiredInput", styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%" }, JL = function (e) { var n = e.name, r = e.onFocus; return Y("input", { required: !0, name: n, tabIndex: -1, "aria-hidden": "true", onFocus: r, css: XL, value: "", onChange: function () { } }) }, ZL = JL; function kf(t) { var e; return typeof window < "u" && window.navigator != null ? t.test(((e = window.navigator.userAgentData) === null || e === void 0 ? void 0 : e.platform) || window.navigator.platform) : !1 } function eD() { return kf(/^iPhone/i) } function z_() { return kf(/^Mac/i) } function tD() { return kf(/^iPad/i) || z_() && navigator.maxTouchPoints > 1 } function nD() { return eD() || tD() } function rD() { return z_() || nD() } var iD = function (e) { return e.label }, sD = function (e) { return e.label }, oD = function (e) { return e.value }, aD = function (e) { return !!e.isDisabled }, lD = { clearIndicator: HM, container: LM, control: XM, dropdownIndicator: BM, group: tL, groupHeading: rL, indicatorsContainer: NM, indicatorSeparator: qM, input: aL, loadingIndicator: YM, loadingMessage: EM, menu: wM, menuList: CM, menuPortal: RM, multiValue: hL, multiValueLabel: fL, multiValueRemove: pL, noOptionsMessage: PM, option: _L, placeholder: xL, singleValue: OL, valueContainer: AM }, uD = { primary: "#2684FF", primary75: "#4C9AFF", primary50: "#B2D4FF", primary25: "#DEEBFF", danger: "#DE350B", dangerLight: "#FFBDAD", neutral0: "hsl(0, 0%, 100%)", neutral5: "hsl(0, 0%, 95%)", neutral10: "hsl(0, 0%, 90%)", neutral20: "hsl(0, 0%, 80%)", neutral30: "hsl(0, 0%, 70%)", neutral40: "hsl(0, 0%, 60%)", neutral50: "hsl(0, 0%, 50%)", neutral60: "hsl(0, 0%, 40%)", neutral70: "hsl(0, 0%, 30%)", neutral80: "hsl(0, 0%, 20%)", neutral90: "hsl(0, 0%, 10%)" }, cD = 4, V_ = 4, dD = 38, hD = V_ * 2, fD = { baseUnit: V_, controlHeight: dD, menuGutter: hD }, yc = { borderRadius: cD, colors: uD, spacing: fD }, pD = { "aria-live": "polite", backspaceRemovesValue: !0, blurInputOnSelect: Gm(), captureMenuScroll: !Gm(), classNames: {}, closeMenuOnSelect: !0, closeMenuOnScroll: !1, components: {}, controlShouldRenderValue: !0, escapeClearsValue: !1, filterOption: BL(), formatGroupLabel: iD, getOptionLabel: sD, getOptionValue: oD, isDisabled: !1, isLoading: !1, isMulti: !1, isRtl: !1, isSearchable: !0, isOptionDisabled: aD, loadingMessage: function () { return "Loading..." }, maxMenuHeight: 300, minMenuHeight: 140, menuIsOpen: !1, menuPlacement: "bottom", menuPosition: "absolute", menuShouldBlockScroll: !1, menuShouldScrollIntoView: !dM(), noOptionsMessage: function () { return "No options" }, openMenuOnFocus: !1, openMenuOnClick: !0, options: [], pageSize: 5, placeholder: "Select...", screenReaderStatus: function (e) { var n = e.count; return "".concat(n, " result").concat(n !== 1 ? "s" : "", " available") }, styles: {}, tabIndex: 0, tabSelectsValue: !0, unstyled: !1 }; function ov(t, e, n, r) { var i = H_(t, e, n), s = W_(t, e, n), o = U_(t, e), a = xl(t, e); return { type: "option", data: e, isDisabled: i, isSelected: s, label: o, value: a, index: r } } function La(t, e) { return t.options.map(function (n, r) { if ("options" in n) { var i = n.options.map(function (o, a) { return ov(t, o, e, a) }).filter(function (o) { return lv(t, o) }); return i.length > 0 ? { type: "group", data: n, options: i, index: r } : void 0 } var s = ov(t, n, e, r); return lv(t, s) ? s : void 0 }).filter(pM) } function B_(t) { return t.reduce(function (e, n) { return n.type === "group" ? e.push.apply(e, df(n.options.map(function (r) { return r.data }))) : e.push(n.data), e }, []) } function av(t, e) { return t.reduce(function (n, r) { return r.type === "group" ? n.push.apply(n, df(r.options.map(function (i) { return { data: i.data, id: "".concat(e, "-").concat(r.index, "-").concat(i.index) } }))) : n.push({ data: r.data, id: "".concat(e, "-").concat(r.index) }), n }, []) } function gD(t, e) { return B_(La(t, e)) } function lv(t, e) { var n = t.inputValue, r = n === void 0 ? "" : n, i = e.data, s = e.isSelected, o = e.label, a = e.value; return (!K_(t) || !s) && q_(t, { label: o, value: a, data: i }, r) } function mD(t, e) { var n = t.focusedValue, r = t.selectValue, i = r.indexOf(n); if (i > -1) { var s = e.indexOf(n); if (s > -1) return n; if (i < e.length) return e[i] } return null } function vD(t, e) { var n = t.focusedOption; return n && e.indexOf(n) > -1 ? n : e[0] } var bc = function (e, n) { var r, i = (r = e.find(function (s) { return s.data === n })) === null || r === void 0 ? void 0 : r.id; return i || null }, U_ = function (e, n) { return e.getOptionLabel(n) }, xl = function (e, n) { return e.getOptionValue(n) }; function H_(t, e, n) { return typeof t.isOptionDisabled == "function" ? t.isOptionDisabled(e, n) : !1 } function W_(t, e, n) { if (n.indexOf(e) > -1) return !0; if (typeof t.isOptionSelected == "function") return t.isOptionSelected(e, n); var r = xl(t, e); return n.some(function (i) { return xl(t, i) === r }) } function q_(t, e, n) { return t.filterOption ? t.filterOption(e, n) : !0 } var K_ = function (e) { var n = e.hideSelectedOptions, r = e.isMulti; return n === void 0 ? r : n }, yD = 1, G_ = function (t) { R2(n, t); var e = D2(n); function n(r) { var i; if (T2(this, n), i = e.call(this, r), i.state = { ariaSelection: null, focusedOption: null, focusedOptionId: null, focusableOptionsWithIds: [], focusedValue: null, inputIsHidden: !1, isFocused: !1, selectValue: [], clearFocusValueOnUpdate: !1, prevWasFocused: !1, inputIsHiddenAfterUpdate: void 0, prevProps: void 0, instancePrefix: "" }, i.blockOptionHover = !1, i.isComposing = !1, i.commonProps = void 0, i.initialTouchX = 0, i.initialTouchY = 0, i.openAfterFocus = !1, i.scrollToFocusedOptionOnUpdate = !1, i.userIsDragging = void 0, i.isAppleDevice = rD(), i.controlRef = null, i.getControlRef = function (l) { i.controlRef = l }, i.focusedOptionRef = null, i.getFocusedOptionRef = function (l) { i.focusedOptionRef = l }, i.menuListRef = null, i.getMenuListRef = function (l) { i.menuListRef = l }, i.inputRef = null, i.getInputRef = function (l) { i.inputRef = l }, i.focus = i.focusInput, i.blur = i.blurInput, i.onChange = function (l, u) { var c = i.props, d = c.onChange, h = c.name; u.name = h, i.ariaOnChange(l, u), d(l, u) }, i.setValue = function (l, u, c) { var d = i.props, h = d.closeMenuOnSelect, f = d.isMulti, g = d.inputValue; i.onInputChange("", { action: "set-value", prevInputValue: g }), h && (i.setState({ inputIsHiddenAfterUpdate: !f }), i.onMenuClose()), i.setState({ clearFocusValueOnUpdate: !0 }), i.onChange(l, { action: u, option: c }) }, i.selectOption = function (l) { var u = i.props, c = u.blurInputOnSelect, d = u.isMulti, h = u.name, f = i.state.selectValue, g = d && i.isOptionSelected(l, f), m = i.isOptionDisabled(l, f); if (g) { var y = i.getOptionValue(l); i.setValue(f.filter(function (p) { return i.getOptionValue(p) !== y }), "deselect-option", l) } else if (!m) d ? i.setValue([].concat(df(f), [l]), "select-option", l) : i.setValue(l, "select-option"); else { i.ariaOnChange(l, { action: "select-option", option: l, name: h }); return } c && i.blurInput() }, i.removeValue = function (l) { var u = i.props.isMulti, c = i.state.selectValue, d = i.getOptionValue(l), h = c.filter(function (g) { return i.getOptionValue(g) !== d }), f = da(u, h, h[0] || null); i.onChange(f, { action: "remove-value", removedValue: l }), i.focusInput() }, i.clearValue = function () { var l = i.state.selectValue; i.onChange(da(i.props.isMulti, [], null), { action: "clear", removedValues: l }) }, i.popValue = function () { var l = i.props.isMulti, u = i.state.selectValue, c = u[u.length - 1], d = u.slice(0, u.length - 1), h = da(l, d, d[0] || null); i.onChange(h, { action: "pop-value", removedValue: c }) }, i.getFocusedOptionId = function (l) { return bc(i.state.focusableOptionsWithIds, l) }, i.getFocusableOptionsWithIds = function () { return av(La(i.props, i.state.selectValue), i.getElementId("option")) }, i.getValue = function () { return i.state.selectValue }, i.cx = function () { for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)u[c] = arguments[c]; return oM.apply(void 0, [i.props.classNamePrefix].concat(u)) }, i.getOptionLabel = function (l) { return U_(i.props, l) }, i.getOptionValue = function (l) { return xl(i.props, l) }, i.getStyles = function (l, u) { var c = i.props.unstyled, d = lD[l](u, c); d.boxSizing = "border-box"; var h = i.props.styles[l]; return h ? h(d, u) : d }, i.getClassNames = function (l, u) { var c, d; return (c = (d = i.props.classNames)[l]) === null || c === void 0 ? void 0 : c.call(d, u) }, i.getElementId = function (l) { return "".concat(i.state.instancePrefix, "-").concat(l) }, i.getComponents = function () { return IL(i.props) }, i.buildCategorizedOptions = function () { return La(i.props, i.state.selectValue) }, i.getCategorizedOptions = function () { return i.props.menuIsOpen ? i.buildCategorizedOptions() : [] }, i.buildFocusableOptions = function () { return B_(i.buildCategorizedOptions()) }, i.getFocusableOptions = function () { return i.props.menuIsOpen ? i.buildFocusableOptions() : [] }, i.ariaOnChange = function (l, u) { i.setState({ ariaSelection: Q({ value: l }, u) }) }, i.onMenuMouseDown = function (l) { l.button === 0 && (l.stopPropagation(), l.preventDefault(), i.focusInput()) }, i.onMenuMouseMove = function (l) { i.blockOptionHover = !1 }, i.onControlMouseDown = function (l) { if (!l.defaultPrevented) { var u = i.props.openMenuOnClick; i.state.isFocused ? i.props.menuIsOpen ? l.target.tagName !== "INPUT" && l.target.tagName !== "TEXTAREA" && i.onMenuClose() : u && i.openMenu("first") : (u && (i.openAfterFocus = !0), i.focusInput()), l.target.tagName !== "INPUT" && l.target.tagName !== "TEXTAREA" && l.preventDefault() } }, i.onDropdownIndicatorMouseDown = function (l) { if (!(l && l.type === "mousedown" && l.button !== 0) && !i.props.isDisabled) { var u = i.props, c = u.isMulti, d = u.menuIsOpen; i.focusInput(), d ? (i.setState({ inputIsHiddenAfterUpdate: !c }), i.onMenuClose()) : i.openMenu("first"), l.preventDefault() } }, i.onClearIndicatorMouseDown = function (l) { l && l.type === "mousedown" && l.button !== 0 || (i.clearValue(), l.preventDefault(), i.openAfterFocus = !1, l.type === "touchend" ? i.focusInput() : setTimeout(function () { return i.focusInput() })) }, i.onScroll = function (l) { typeof i.props.closeMenuOnScroll == "boolean" ? l.target instanceof HTMLElement && gu(l.target) && i.props.onMenuClose() : typeof i.props.closeMenuOnScroll == "function" && i.props.closeMenuOnScroll(l) && i.props.onMenuClose() }, i.onCompositionStart = function () { i.isComposing = !0 }, i.onCompositionEnd = function () { i.isComposing = !1 }, i.onTouchStart = function (l) { var u = l.touches, c = u && u.item(0); c && (i.initialTouchX = c.clientX, i.initialTouchY = c.clientY, i.userIsDragging = !1) }, i.onTouchMove = function (l) { var u = l.touches, c = u && u.item(0); if (c) { var d = Math.abs(c.clientX - i.initialTouchX), h = Math.abs(c.clientY - i.initialTouchY), f = 5; i.userIsDragging = d > f || h > f } }, i.onTouchEnd = function (l) { i.userIsDragging || (i.controlRef && !i.controlRef.contains(l.target) && i.menuListRef && !i.menuListRef.contains(l.target) && i.blurInput(), i.initialTouchX = 0, i.initialTouchY = 0) }, i.onControlTouchEnd = function (l) { i.userIsDragging || i.onControlMouseDown(l) }, i.onClearIndicatorTouchEnd = function (l) { i.userIsDragging || i.onClearIndicatorMouseDown(l) }, i.onDropdownIndicatorTouchEnd = function (l) { i.userIsDragging || i.onDropdownIndicatorMouseDown(l) }, i.handleInputChange = function (l) { var u = i.props.inputValue, c = l.currentTarget.value; i.setState({ inputIsHiddenAfterUpdate: !1 }), i.onInputChange(c, { action: "input-change", prevInputValue: u }), i.props.menuIsOpen || i.onMenuOpen() }, i.onInputFocus = function (l) { i.props.onFocus && i.props.onFocus(l), i.setState({ inputIsHiddenAfterUpdate: !1, isFocused: !0 }), (i.openAfterFocus || i.props.openMenuOnFocus) && i.openMenu("first"), i.openAfterFocus = !1 }, i.onInputBlur = function (l) { var u = i.props.inputValue; if (i.menuListRef && i.menuListRef.contains(document.activeElement)) { i.inputRef.focus(); return } i.props.onBlur && i.props.onBlur(l), i.onInputChange("", { action: "input-blur", prevInputValue: u }), i.onMenuClose(), i.setState({ focusedValue: null, isFocused: !1 }) }, i.onOptionHover = function (l) { if (!(i.blockOptionHover || i.state.focusedOption === l)) { var u = i.getFocusableOptions(), c = u.indexOf(l); i.setState({ focusedOption: l, focusedOptionId: c > -1 ? i.getFocusedOptionId(l) : null }) } }, i.shouldHideSelectedOptions = function () { return K_(i.props) }, i.onValueInputFocus = function (l) { l.preventDefault(), l.stopPropagation(), i.focus() }, i.onKeyDown = function (l) { var u = i.props, c = u.isMulti, d = u.backspaceRemovesValue, h = u.escapeClearsValue, f = u.inputValue, g = u.isClearable, m = u.isDisabled, y = u.menuIsOpen, p = u.onKeyDown, v = u.tabSelectsValue, b = u.openMenuOnFocus, S = i.state, P = S.focusedOption, I = S.focusedValue, T = S.selectValue; if (!m && !(typeof p == "function" && (p(l), l.defaultPrevented))) { switch (i.blockOptionHover = !0, l.key) { case "ArrowLeft": if (!c || f) return; i.focusValue("previous"); break; case "ArrowRight": if (!c || f) return; i.focusValue("next"); break; case "Delete": case "Backspace": if (f) return; if (I) i.removeValue(I); else { if (!d) return; c ? i.popValue() : g && i.clearValue() } break; case "Tab": if (i.isComposing || l.shiftKey || !y || !v || !P || b && i.isOptionSelected(P, T)) return; i.selectOption(P); break; case "Enter": if (l.keyCode === 229) break; if (y) { if (!P || i.isComposing) return; i.selectOption(P); break } return; case "Escape": y ? (i.setState({ inputIsHiddenAfterUpdate: !1 }), i.onInputChange("", { action: "menu-close", prevInputValue: f }), i.onMenuClose()) : g && h && i.clearValue(); break; case " ": if (f) return; if (!y) { i.openMenu("first"); break } if (!P) return; i.selectOption(P); break; case "ArrowUp": y ? i.focusOption("up") : i.openMenu("last"); break; case "ArrowDown": y ? i.focusOption("down") : i.openMenu("first"); break; case "PageUp": if (!y) return; i.focusOption("pageup"); break; case "PageDown": if (!y) return; i.focusOption("pagedown"); break; case "Home": if (!y) return; i.focusOption("first"); break; case "End": if (!y) return; i.focusOption("last"); break; default: return }l.preventDefault() } }, i.state.instancePrefix = "react-select-" + (i.props.instanceId || ++yD), i.state.selectValue = qm(r.value), r.menuIsOpen && i.state.selectValue.length) { var s = i.getFocusableOptionsWithIds(), o = i.buildFocusableOptions(), a = o.indexOf(i.state.selectValue[0]); i.state.focusableOptionsWithIds = s, i.state.focusedOption = o[a], i.state.focusedOptionId = bc(s, o[a]) } return i } return I2(n, [{ key: "componentDidMount", value: function () { this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && Km(this.menuListRef, this.focusedOptionRef) } }, { key: "componentDidUpdate", value: function (i) { var s = this.props, o = s.isDisabled, a = s.menuIsOpen, l = this.state.isFocused; (l && !o && i.isDisabled || l && a && !i.menuIsOpen) && this.focusInput(), l && o && !i.isDisabled ? this.setState({ isFocused: !1 }, this.onMenuClose) : !l && !o && i.isDisabled && this.inputRef === document.activeElement && this.setState({ isFocused: !0 }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (Km(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1) } }, { key: "componentWillUnmount", value: function () { this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0) } }, { key: "onMenuOpen", value: function () { this.props.onMenuOpen() } }, { key: "onMenuClose", value: function () { this.onInputChange("", { action: "menu-close", prevInputValue: this.props.inputValue }), this.props.onMenuClose() } }, { key: "onInputChange", value: function (i, s) { this.props.onInputChange(i, s) } }, { key: "focusInput", value: function () { this.inputRef && this.inputRef.focus() } }, { key: "blurInput", value: function () { this.inputRef && this.inputRef.blur() } }, { key: "openMenu", value: function (i) { var s = this, o = this.state, a = o.selectValue, l = o.isFocused, u = this.buildFocusableOptions(), c = i === "first" ? 0 : u.length - 1; if (!this.props.isMulti) { var d = u.indexOf(a[0]); d > -1 && (c = d) } this.scrollToFocusedOptionOnUpdate = !(l && this.menuListRef), this.setState({ inputIsHiddenAfterUpdate: !1, focusedValue: null, focusedOption: u[c], focusedOptionId: this.getFocusedOptionId(u[c]) }, function () { return s.onMenuOpen() }) } }, { key: "focusValue", value: function (i) { var s = this.state, o = s.selectValue, a = s.focusedValue; if (this.props.isMulti) { this.setState({ focusedOption: null }); var l = o.indexOf(a); a || (l = -1); var u = o.length - 1, c = -1; if (o.length) { switch (i) { case "previous": l === 0 ? c = 0 : l === -1 ? c = u : c = l - 1; break; case "next": l > -1 && l < u && (c = l + 1); break }this.setState({ inputIsHidden: c !== -1, focusedValue: o[c] }) } } } }, { key: "focusOption", value: function () { var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", s = this.props.pageSize, o = this.state.focusedOption, a = this.getFocusableOptions(); if (a.length) { var l = 0, u = a.indexOf(o); o || (u = -1), i === "up" ? l = u > 0 ? u - 1 : a.length - 1 : i === "down" ? l = (u + 1) % a.length : i === "pageup" ? (l = u - s, l < 0 && (l = 0)) : i === "pagedown" ? (l = u + s, l > a.length - 1 && (l = a.length - 1)) : i === "last" && (l = a.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({ focusedOption: a[l], focusedValue: null, focusedOptionId: this.getFocusedOptionId(a[l]) }) } } }, { key: "getTheme", value: function () { return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(yc) : Q(Q({}, yc), this.props.theme) : yc } }, { key: "getCommonProps", value: function () { var i = this.clearValue, s = this.cx, o = this.getStyles, a = this.getClassNames, l = this.getValue, u = this.selectOption, c = this.setValue, d = this.props, h = d.isMulti, f = d.isRtl, g = d.options, m = this.hasValue(); return { clearValue: i, cx: s, getStyles: o, getClassNames: a, getValue: l, hasValue: m, isMulti: h, isRtl: f, options: g, selectOption: u, selectProps: d, setValue: c, theme: this.getTheme() } } }, { key: "hasValue", value: function () { var i = this.state.selectValue; return i.length > 0 } }, { key: "hasOptions", value: function () { return !!this.getFocusableOptions().length } }, { key: "isClearable", value: function () { var i = this.props, s = i.isClearable, o = i.isMulti; return s === void 0 ? o : s } }, { key: "isOptionDisabled", value: function (i, s) { return H_(this.props, i, s) } }, { key: "isOptionSelected", value: function (i, s) { return W_(this.props, i, s) } }, { key: "filterOption", value: function (i, s) { return q_(this.props, i, s) } }, { key: "formatOptionLabel", value: function (i, s) { if (typeof this.props.formatOptionLabel == "function") { var o = this.props.inputValue, a = this.state.selectValue; return this.props.formatOptionLabel(i, { context: s, inputValue: o, selectValue: a }) } else return this.getOptionLabel(i) } }, { key: "formatGroupLabel", value: function (i) { return this.props.formatGroupLabel(i) } }, { key: "startListeningComposition", value: function () { document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1)) } }, { key: "stopListeningComposition", value: function () { document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd)) } }, { key: "startListeningToTouch", value: function () { document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1)) } }, { key: "stopListeningToTouch", value: function () { document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd)) } }, { key: "renderInput", value: function () { var i = this.props, s = i.isDisabled, o = i.isSearchable, a = i.inputId, l = i.inputValue, u = i.tabIndex, c = i.form, d = i.menuIsOpen, h = i.required, f = this.getComponents(), g = f.Input, m = this.state, y = m.inputIsHidden, p = m.ariaSelection, v = this.commonProps, b = a || this.getElementId("input"), S = Q(Q(Q({ "aria-autocomplete": "list", "aria-expanded": d, "aria-haspopup": !0, "aria-errormessage": this.props["aria-errormessage"], "aria-invalid": this.props["aria-invalid"], "aria-label": this.props["aria-label"], "aria-labelledby": this.props["aria-labelledby"], "aria-required": h, role: "combobox", "aria-activedescendant": this.isAppleDevice ? void 0 : this.state.focusedOptionId || "" }, d && { "aria-controls": this.getElementId("listbox") }), !o && { "aria-readonly": !0 }), this.hasValue() ? (p == null ? void 0 : p.action) === "initial-input-focus" && { "aria-describedby": this.getElementId("live-region") } : { "aria-describedby": this.getElementId("placeholder") }); return o ? R.createElement(g, X({}, v, { autoCapitalize: "none", autoComplete: "off", autoCorrect: "off", id: b, innerRef: this.getInputRef, isDisabled: s, isHidden: y, onBlur: this.onInputBlur, onChange: this.handleInputChange, onFocus: this.onInputFocus, spellCheck: "false", tabIndex: u, form: c, type: "text", value: l }, S)) : R.createElement(HL, X({ id: b, innerRef: this.getInputRef, onBlur: this.onInputBlur, onChange: wl, onFocus: this.onInputFocus, disabled: s, tabIndex: u, inputMode: "none", form: c, value: "" }, S)) } }, { key: "renderPlaceholderOrValue", value: function () { var i = this, s = this.getComponents(), o = s.MultiValue, a = s.MultiValueContainer, l = s.MultiValueLabel, u = s.MultiValueRemove, c = s.SingleValue, d = s.Placeholder, h = this.commonProps, f = this.props, g = f.controlShouldRenderValue, m = f.isDisabled, y = f.isMulti, p = f.inputValue, v = f.placeholder, b = this.state, S = b.selectValue, P = b.focusedValue, I = b.isFocused; if (!this.hasValue() || !g) return p ? null : R.createElement(d, X({}, h, { key: "placeholder", isDisabled: m, isFocused: I, innerProps: { id: this.getElementId("placeholder") } }), v); if (y) return S.map(function (k, E) { var M = k === P, L = "".concat(i.getOptionLabel(k), "-").concat(i.getOptionValue(k)); return R.createElement(o, X({}, h, { components: { Container: a, Label: l, Remove: u }, isFocused: M, isDisabled: m, key: L, index: E, removeProps: { onClick: function () { return i.removeValue(k) }, onTouchEnd: function () { return i.removeValue(k) }, onMouseDown: function ($) { $.preventDefault() } }, data: k }), i.formatOptionLabel(k, "value")) }); if (p) return null; var T = S[0]; return R.createElement(c, X({}, h, { data: T, isDisabled: m }), this.formatOptionLabel(T, "value")) } }, { key: "renderClearIndicator", value: function () { var i = this.getComponents(), s = i.ClearIndicator, o = this.commonProps, a = this.props, l = a.isDisabled, u = a.isLoading, c = this.state.isFocused; if (!this.isClearable() || !s || l || !this.hasValue() || u) return null; var d = { onMouseDown: this.onClearIndicatorMouseDown, onTouchEnd: this.onClearIndicatorTouchEnd, "aria-hidden": "true" }; return R.createElement(s, X({}, o, { innerProps: d, isFocused: c })) } }, { key: "renderLoadingIndicator", value: function () { var i = this.getComponents(), s = i.LoadingIndicator, o = this.commonProps, a = this.props, l = a.isDisabled, u = a.isLoading, c = this.state.isFocused; if (!s || !u) return null; var d = { "aria-hidden": "true" }; return R.createElement(s, X({}, o, { innerProps: d, isDisabled: l, isFocused: c })) } }, { key: "renderIndicatorSeparator", value: function () { var i = this.getComponents(), s = i.DropdownIndicator, o = i.IndicatorSeparator; if (!s || !o) return null; var a = this.commonProps, l = this.props.isDisabled, u = this.state.isFocused; return R.createElement(o, X({}, a, { isDisabled: l, isFocused: u })) } }, { key: "renderDropdownIndicator", value: function () { var i = this.getComponents(), s = i.DropdownIndicator; if (!s) return null; var o = this.commonProps, a = this.props.isDisabled, l = this.state.isFocused, u = { onMouseDown: this.onDropdownIndicatorMouseDown, onTouchEnd: this.onDropdownIndicatorTouchEnd, "aria-hidden": "true" }; return R.createElement(s, X({}, o, { innerProps: u, isDisabled: a, isFocused: l })) } }, { key: "renderMenu", value: function () { var i = this, s = this.getComponents(), o = s.Group, a = s.GroupHeading, l = s.Menu, u = s.MenuList, c = s.MenuPortal, d = s.LoadingMessage, h = s.NoOptionsMessage, f = s.Option, g = this.commonProps, m = this.state.focusedOption, y = this.props, p = y.captureMenuScroll, v = y.inputValue, b = y.isLoading, S = y.loadingMessage, P = y.minMenuHeight, I = y.maxMenuHeight, T = y.menuIsOpen, k = y.menuPlacement, E = y.menuPosition, M = y.menuPortalTarget, L = y.menuShouldBlockScroll, N = y.menuShouldScrollIntoView, $ = y.noOptionsMessage, B = y.onMenuScrollToTop, H = y.onMenuScrollToBottom; if (!T) return null; var V = function (O, D) { var F = O.type, z = O.data, W = O.isDisabled, K = O.isSelected, Z = O.label, ae = O.value, ue = m === z, tt = W ? void 0 : function () { return i.onOptionHover(z) }, ot = W ? void 0 : function () { return i.selectOption(z) }, Yt = "".concat(i.getElementId("option"), "-").concat(D), qe = { id: Yt, onClick: ot, onMouseMove: tt, onMouseOver: tt, tabIndex: -1, role: "option", "aria-selected": i.isAppleDevice ? void 0 : K }; return R.createElement(f, X({}, g, { innerProps: qe, data: z, isDisabled: W, isSelected: K, key: Yt, label: Z, type: F, value: ae, isFocused: ue, innerRef: ue ? i.getFocusedOptionRef : void 0 }), i.formatOptionLabel(O.data, "menu")) }, q; if (this.hasOptions()) q = this.getCategorizedOptions().map(function (w) { if (w.type === "group") { var O = w.data, D = w.options, F = w.index, z = "".concat(i.getElementId("group"), "-").concat(F), W = "".concat(z, "-heading"); return R.createElement(o, X({}, g, { key: z, data: O, options: D, Heading: a, headingProps: { id: W, data: w.data }, label: i.formatGroupLabel(w.data) }), w.options.map(function (K) { return V(K, "".concat(F, "-").concat(K.index)) })) } else if (w.type === "option") return V(w, "".concat(w.index)) }); else if (b) { var j = S({ inputValue: v }); if (j === null) return null; q = R.createElement(d, g, j) } else { var _ = $({ inputValue: v }); if (_ === null) return null; q = R.createElement(h, g, _) } var x = { minMenuHeight: P, maxMenuHeight: I, menuPlacement: k, menuPosition: E, menuShouldScrollIntoView: N }, C = R.createElement(SM, X({}, g, x), function (w) { var O = w.ref, D = w.placerProps, F = D.placement, z = D.maxHeight; return R.createElement(l, X({}, g, x, { innerRef: O, innerProps: { onMouseDown: i.onMenuMouseDown, onMouseMove: i.onMenuMouseMove }, isLoading: b, placement: F }), R.createElement(QL, { captureEnabled: p, onTopArrive: B, onBottomArrive: H, lockEnabled: L }, function (W) { return R.createElement(u, X({}, g, { innerRef: function (Z) { i.getMenuListRef(Z), W(Z) }, innerProps: { role: "listbox", "aria-multiselectable": g.isMulti, id: i.getElementId("listbox") }, isLoading: b, maxHeight: z, focusedOption: m }), q) })) }); return M || E === "fixed" ? R.createElement(c, X({}, g, { appendTo: M, controlElement: this.controlRef, menuPlacement: k, menuPosition: E }), C) : C } }, { key: "renderFormField", value: function () { var i = this, s = this.props, o = s.delimiter, a = s.isDisabled, l = s.isMulti, u = s.name, c = s.required, d = this.state.selectValue; if (c && !this.hasValue() && !a) return R.createElement(ZL, { name: u, onFocus: this.onValueInputFocus }); if (!(!u || a)) if (l) if (o) { var h = d.map(function (m) { return i.getOptionValue(m) }).join(o); return R.createElement("input", { name: u, type: "hidden", value: h }) } else { var f = d.length > 0 ? d.map(function (m, y) { return R.createElement("input", { key: "i-".concat(y), name: u, type: "hidden", value: i.getOptionValue(m) }) }) : R.createElement("input", { name: u, type: "hidden", value: "" }); return R.createElement("div", null, f) } else { var g = d[0] ? this.getOptionValue(d[0]) : ""; return R.createElement("input", { name: u, type: "hidden", value: g }) } } }, { key: "renderLiveRegion", value: function () { var i = this.commonProps, s = this.state, o = s.ariaSelection, a = s.focusedOption, l = s.focusedValue, u = s.isFocused, c = s.selectValue, d = this.getFocusableOptions(); return R.createElement(FL, X({}, i, { id: this.getElementId("live-region"), ariaSelection: o, focusedOption: a, focusedValue: l, isFocused: u, selectValue: c, focusableOptions: d, isAppleDevice: this.isAppleDevice })) } }, { key: "render", value: function () { var i = this.getComponents(), s = i.Control, o = i.IndicatorsContainer, a = i.SelectContainer, l = i.ValueContainer, u = this.props, c = u.className, d = u.id, h = u.isDisabled, f = u.menuIsOpen, g = this.state.isFocused, m = this.commonProps = this.getCommonProps(); return R.createElement(a, X({}, m, { className: c, innerProps: { id: d, onKeyDown: this.onKeyDown }, isDisabled: h, isFocused: g }), this.renderLiveRegion(), R.createElement(s, X({}, m, { innerRef: this.getControlRef, innerProps: { onMouseDown: this.onControlMouseDown, onTouchEnd: this.onControlTouchEnd }, isDisabled: h, isFocused: g, menuIsOpen: f }), R.createElement(l, X({}, m, { isDisabled: h }), this.renderPlaceholderOrValue(), this.renderInput()), R.createElement(o, X({}, m, { isDisabled: h }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField()) } }], [{ key: "getDerivedStateFromProps", value: function (i, s) { var o = s.prevProps, a = s.clearFocusValueOnUpdate, l = s.inputIsHiddenAfterUpdate, u = s.ariaSelection, c = s.isFocused, d = s.prevWasFocused, h = s.instancePrefix, f = i.options, g = i.value, m = i.menuIsOpen, y = i.inputValue, p = i.isMulti, v = qm(g), b = {}; if (o && (g !== o.value || f !== o.options || m !== o.menuIsOpen || y !== o.inputValue)) { var S = m ? gD(i, v) : [], P = m ? av(La(i, v), "".concat(h, "-option")) : [], I = a ? mD(s, v) : null, T = vD(s, S), k = bc(P, T); b = { selectValue: v, focusedOption: T, focusedOptionId: k, focusableOptionsWithIds: P, focusedValue: I, clearFocusValueOnUpdate: !1 } } var E = l != null && i !== o ? { inputIsHidden: l, inputIsHiddenAfterUpdate: void 0 } : {}, M = u, L = c && d; return c && !L && (M = { value: da(p, v, v[0] || null), options: v, action: "initial-input-focus" }, L = !d), (u == null ? void 0 : u.action) === "initial-input-focus" && (M = null), Q(Q(Q({}, b), E), {}, { prevProps: i, ariaSelection: M, prevWasFocused: L }) } }]), n }(R.Component); G_.defaultProps = pD; var bD = R.forwardRef(function (t, e) { var n = E2(t); return R.createElement(G_, X({ ref: e }, n)) }), _c = bD; eu.register(Rd, Md, Ta, $I, KI, NI); const _D = ({ accounts: t }) => { const [e, n] = R.useState([]), [r, i] = R.useState([]), [s, o] = R.useState("year"), [a, l] = R.useState("DepenseCarteBleue"), [u, c] = R.useState([]), d = T => { n(T) }, h = T => { o(T.value) }, f = T => { l(T.value) }, g = T => { if (!T) return null; const [k, E, M] = T.split("/").map(Number); return new Date(M, E - 1, k) }, m = R.useMemo(() => t.filter(T => { const k = g(T.date); return k ? (e.length === 0 || e.some(E => E.value === T.Categorie)) && (r.length === 0 || r.some(E => { const M = g(E.value); return M ? s === "month" ? M.getMonth() === k.getMonth() : M.getFullYear() === k.getFullYear() : !1 })) : !1 }), [t, e, r, s]), y = T => { const k = g(T); if (!k) return T; switch (s) { case "year": return k.getFullYear().toString(); case "month": return k.toLocaleString("default", { month: "long", year: "numeric" }); case "day": return T; default: return T } }, [p, v] = R.useState({ labels: [], datasets: [{ label: a, data: [], backgroundColor: "rgba(75, 192, 192, 0.2)", borderColor: "rgba(75, 192, 192, 1)", borderWidth: 1 }] }); R.useEffect(() => { const T = Array.from(new Set(m.map(E => y(E.date)))).sort((E, M) => { let L, N; return s === "day" ? (L = g(E), N = g(M)) : (L = new Date(E), N = new Date(M)), (L ? L.getTime() : 0) - (N ? N.getTime() : 0) }), k = T.map(E => m.filter(M => y(M.date) === E).reduce((M, L) => M + parseFloat(L[a] || "0"), 0)); v({ labels: T, datasets: [{ label: a, data: k, backgroundColor: "rgba(75, 192, 192, 0.2)", borderColor: "rgba(75, 192, 192, 1)", borderWidth: 1 }] }) }, [m, a, s]); const b = R.useMemo(() => { if (t.length === 0) return []; const T = t[0]; return Object.keys(T).filter(k => k !== "id" && k !== "date" && k !== "NomDeLaDepense" && k !== "Categorie" && k !== "ARevoir" && k !== "user_id").map(k => ({ value: k, label: k.replace(/([A-Z])/g, " $1").trim() })) }, [t]), S = R.useMemo(() => t.reduce((T, k) => (b.forEach(E => { const M = E.value; T[M] || (T[M] = new Set), k[M] && parseFloat(k[M]) !== 0 && T[M].add(k.Categorie) }), T), {}), [t, b]); R.useEffect(() => { S[a] ? c(Array.from(S[a]).map(T => ({ value: T, label: T }))) : c([]) }, [a, S]), Array.from(new Set(t.map(T => T.date))).map(T => ({ value: T, label: T })); const P = [{ value: "year", label: "Année" }, { value: "month", label: "Mois" }, { value: "day", label: "Jour" }], I = { option: (T, k) => ({ ...T, color: k.isSelected ? "darkgray" : "gray" }), singleValue: (T, k) => ({ ...T, color: "darkgray" }), multiValue: (T, k) => ({ ...T, color: "darkgray" }), multiValueLabel: (T, k) => ({ ...T, color: "darkgray" }) }; return A.jsxs("div", { className: "account-charts w-2/3 mx-auto p-4 m-4 bg-gray-100 rounded-md text-center", children: [A.jsx("h2", { className: "text-xl text-black mb-4", children: "Graphiques des Dépenses" }), A.jsxs("div", { className: "mb-4 flex justify-around", children: [A.jsx(_c, { options: P, onChange: h, placeholder: "Trier par", className: "w-1/3", styles: I }), A.jsx(_c, { options: b, onChange: f, placeholder: "Sélectionner le type de dépense", className: "w-1/3", styles: I }), A.jsx(_c, { isMulti: !0, options: u, onChange: d, placeholder: "Filtrer par catégorie", className: "w-1/3", styles: I })] }), A.jsx(w2, { data: p, options: { responsive: !0, plugins: { legend: { position: "top" }, title: { display: !0, text: a } } } })] }) }, wD = () => { const [t, e] = R.useState(""), [n, r] = R.useState(""), [i, s] = R.useState(!1), o = Ul(), a = async l => { if (l.preventDefault(), i) { const { error: u } = await je.auth.signUp({ email: t, password: n }); u ? alert("Erreur lors de la création du compte : " + u.message) : (alert("Veuillez vérifier votre boîte de réception pour confirmer votre compte."), s(!1)) } else { const { error: u } = await je.auth.signInWithPassword({ email: t, password: n }); u ? alert("Erreur de connexion : " + u.message) : (o("/"), window.location.reload()) } }; return A.jsxs("form", { onSubmit: a, className: "contact-form mx-auto w-96 bg-gray-500 p-8 rounded-lg shadow-md m-8", children: [A.jsx("h2", { className: "text-2xl mb-4", children: i ? "Sign Up" : "Login" }), A.jsxs("div", { className: "mb-4", children: [A.jsx("label", { children: "Email" }), A.jsx("input", { type: "email", value: t, onChange: l => e(l.target.value), className: "border p-2 w-full" })] }), A.jsxs("div", { className: "mb-4", children: [A.jsx("label", { children: "Password" }), A.jsx("input", { type: "password", value: n, onChange: l => r(l.target.value), className: "border p-2 w-full" })] }), A.jsx("button", { type: "submit", className: "bg-blue-500 text-white p-2", children: i ? "Sign Up" : "Login" }), A.jsx("div", { className: "mt-4", children: A.jsx("button", { type: "button", onClick: () => s(!i), className: "text-blue-500", children: i ? "Already have an account? Login" : "Don't have an account? Sign Up" }) })] }) }; var Y_ = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, uv = _t.createContext && _t.createContext(Y_), SD = ["attr", "size", "title"]; function xD(t, e) { if (t == null) return {}; var n = kD(t, e), r, i; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(t); for (i = 0; i < s.length; i++)r = s[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function kD(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function kl() { return kl = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, kl.apply(this, arguments) } function cv(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Cl(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? cv(Object(n), !0).forEach(function (r) { CD(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : cv(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function CD(t, e, n) { return e = OD(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function OD(t) { var e = PD(t, "string"); return typeof e == "symbol" ? e : e + "" } function PD(t, e) { if (typeof t != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e || "default"); if (typeof r != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function Q_(t) { return t && t.map((e, n) => _t.createElement(e.tag, Cl({ key: n }, e.attr), Q_(e.child))) } function ED(t) { return e => _t.createElement(TD, kl({ attr: Cl({}, t.attr) }, e), Q_(t.child)) } function TD(t) { var e = n => { var { attr: r, size: i, title: s } = t, o = xD(t, SD), a = i || n.size || "1em", l; return n.className && (l = n.className), t.className && (l = (l ? l + " " : "") + t.className), _t.createElement("svg", kl({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, n.attr, r, o, { className: l, style: Cl(Cl({ color: t.color || n.color }, n.style), t.style), height: a, width: a, xmlns: "http://www.w3.org/2000/svg" }), s && _t.createElement("title", null, s), t.children) }; return uv !== void 0 ? _t.createElement(uv.Consumer, null, n => e(n)) : e(Y_) } function ID(t) { return ED({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z" }, child: [] }] })(t) } const RD = () => { const [t, e] = R.useState(null), [n, r] = R.useState(""), [i, s] = R.useState([]), [o, a] = R.useState(""), [l, u] = R.useState(["date", "NomDeLaDepense", "Categorie", "ARevoir"]), [c, d] = R.useState(null), [h, f] = R.useState(""); R.useEffect(() => { (async () => { var j, _, x; const { data: N, error: $ } = await je.auth.getUser(); if ($) { console.error("Erreur lors de la récupération de l’utilisateur :", $); return } const B = N.user; e(B), r(((j = B == null ? void 0 : B.user_metadata) == null ? void 0 : j.full_name) || ""); const V = (((_ = B == null ? void 0 : B.user_metadata) == null ? void 0 : _.livrets) || []).map(C => ({ ...C, id: C.id || `${C.name}-${Date.now()}` })); V.some(C => C.id === "CarteBleue-Initial") || V.push({ id: "CarteBleue-Initial", name: "CarteBleue", obtained: !1, expense: !1, move: !1 }), s(V), u(((x = B == null ? void 0 : B.user_metadata) == null ? void 0 : x.columnOrder) || ["date", "NomDeLaDepense", "Categorie", "ARevoir"]) })() }, []); const g = async L => { if (L.preventDefault(), !window.confirm("Êtes-vous sûr de vouloir sauvegarder les modifications ?")) return; if (!t) { console.error("Utilisateur non authentifié"); return } if (l.some((H, V) => l.indexOf(H) !== V)) { alert("Chaque colonne doit être unique. Veuillez vérifier l’ordre des colonnes."); return } const { error: B } = await je.auth.updateUser({ data: { full_name: n, livrets: i, columnOrder: l } }); if (B) { console.error("Erreur lors de la mise à jour des informations de l’utilisateur :", B); return } e(H => ({ ...H, user_metadata: { ...H.user_metadata, full_name: n, livrets: i, columnOrder: l } })), window.location.reload() }, m = (L, N) => { const $ = [...l]; $[L] = N, u($) }, y = () => { const L = [...l], N = L.length - 1; L.splice(N, 0, "date"), u(L) }, p = L => { window.confirm("Êtes-vous sûr de vouloir supprimer cette colonne ?") && u(l.filter(($, B) => B !== L)) }, v = L => L.replace(/CarteBleue/, "Carte Bleue"), b = L => L.replace(/Carte Bleue/, "CarteBleue"), S = () => { if (o && !i.find(L => L.name === b(o))) { const L = `${b(o)}-${Date.now()}`; s([...i, { id: L, name: b(o), obtained: !1, expense: !1, move: !1 }]), a("") } }, P = L => { window.confirm("Êtes-vous sûr de vouloir supprimer ce livret ?") && s(i.filter($ => $.id !== L)) }, I = (L, N, $) => { const B = [...i]; B[L][N] = $, s(B) }, T = (L, N, $) => { const B = [...i], H = B[L]; $ ? (H.moveTo || (H.moveTo = []), H.moveTo.includes(N) || H.moveTo.push(N)) : H.moveTo && (H.moveTo = H.moveTo.filter(V => V !== N)), s(B) }, k = () => i.every(L => L.obtained || L.expense || L.move), E = L => { d(L), f(i[L].name) }, M = L => { const N = [...i]; N[L].name = b(h), s(N), d(null) }; return A.jsxs("div", { className: "p-4", children: [A.jsx("h2", { className: "text-2xl mb-4", children: "Paramètres du compte" }), t && A.jsxs("form", { onSubmit: g, children: [A.jsxs("div", { className: "flex flex-row justify-center gap-20", children: [A.jsxs("div", { className: "mb-4", children: [A.jsx("label", { children: "Email" }), A.jsx("input", { type: "email", value: t.email, disabled: !0, className: "border p-2 w-full" })] }), A.jsxs("div", { className: "mb-4", children: [A.jsx("label", { children: "Nom" }), A.jsx("input", { type: "text", value: n, onChange: L => r(L.target.value), className: "border p-2 w-full" })] })] }), A.jsxs("div", { className: "mb-4", children: [A.jsx("label", { children: "Mes Livrets" }), A.jsx("div", { className: "grid grid-cols-12 gap-2 items-center grid-rows-fixed", children: i.map((L, N) => A.jsxs(_t.Fragment, { children: [A.jsx("div", { className: "col-span-2 flex items-center gap-2", children: c === N ? A.jsxs(A.Fragment, { children: [A.jsx("input", { type: "text", value: h, onChange: $ => f($.target.value), className: "border p-2" }), A.jsx("button", { type: "button", onClick: () => M(N), className: "bg-blue-500 text-white p-2 rounded", children: "Save" })] }) : A.jsxs(A.Fragment, { children: [A.jsx("span", { className: "font-bold", children: v(L.name) }), A.jsx(ID, { onClick: () => E(N), className: "cursor-pointer text-blue-500" })] }) }), A.jsxs("label", { className: "col-span-2 flex items-center", children: ["Obtenu", A.jsx("input", { type: "checkbox", checked: L.obtained, onChange: $ => I(N, "obtained", $.target.checked), className: "ml-1" })] }), A.jsxs("label", { className: "col-span-2 flex items-center", children: ["Dépense", A.jsx("input", { type: "checkbox", checked: L.expense, onChange: $ => I(N, "expense", $.target.checked), className: "ml-1" })] }), A.jsxs("label", { className: "col-span-2 flex items-center", children: ["Déplacer vers", A.jsx("input", { type: "checkbox", checked: L.move, onChange: $ => I(N, "move", $.target.checked), className: "ml-1" })] }), A.jsx("div", { className: "col-span-2", children: L.move ? A.jsx("div", { children: i.filter(($, B) => B !== N).map($ => { var B; return A.jsxs("label", { className: "flex items-center gap-2", children: [A.jsx("input", { type: "checkbox", checked: ((B = L.moveTo) == null ? void 0 : B.includes($.name)) || !1, onChange: H => T(N, $.name, H.target.checked) }), v($.name)] }, $.id) }) }) : A.jsx("div", {}) }), L.id !== "CarteBleue-Initial" ? A.jsx("button", { type: "button", onClick: () => P(L.id), className: "col-span-1 bg-red-800 text-white px-2 py-1 rounded ml-2", children: "Supprimer" }) : A.jsx("div", { className: "col-span-1" })] }, L.id)) }), A.jsxs("div", { className: "flex flex-col w-fit p-2 mx-auto gap-3 ", children: [A.jsx("input", { type: "text", value: o, onChange: L => a(L.target.value), className: "border p-2 mb-2", placeholder: "Ajouter un nouveau livret" }), A.jsx("button", { className: "bg-green-600", type: "button", onClick: S, children: "Ajouter Livret" })] })] }), A.jsxs("div", { className: "mb-20", children: [A.jsx("label", { children: "Ordre des Colonnes" }), A.jsx("div", { className: "grid grid-cols-2 gap-4 mx-auto mb-4", children: l.map((L, N) => A.jsxs("div", { className: "flex items-center mb-2 gap-4 mx-auto", children: [A.jsxs("span", { children: [N + 1, "."] }), " ", A.jsxs("select", { value: L, onChange: $ => m(N, $.target.value), className: "border p-2 min-w-max max-w-xs", style: { width: "auto" }, children: [A.jsx("option", { value: "date", children: "Date" }), A.jsx("option", { value: "NomDeLaDepense", children: "Nom de la dépense" }), A.jsx("option", { value: "Categorie", children: "Catégorie" }), A.jsx("option", { value: "ARevoir", children: "A revoir" }), i.map($ => $.obtained && A.jsxs("option", { value: "Obtenu" + $.name, children: ["Obtenu ", v($.name)] }, "Obtenu" + $.name)), i.map($ => $.expense && A.jsxs("option", { value: "Depense" + $.name, children: ["Dépense ", v($.name)] }, "Depense" + $.name)), i.map($ => { var B; return $.move && ((B = $.moveTo) == null ? void 0 : B.map(H => A.jsxs("option", { value: "Deplace" + $.name + "Vers" + b(H), children: ["Déplacer ", v($.name), " vers ", v(H)] }, "Deplace" + $.name + "Vers" + b(H)))) })] }), A.jsx("button", { type: "button", onClick: () => p(N), className: "bg-red-500 text-white p-2 ml-2 rounded", children: "X" })] }, N)) }), A.jsx("button", { type: "button", onClick: y, className: "bg-green-600 text-white px-4 py-2 rounded-full mt-2", children: "+" })] }), A.jsx("button", { type: "submit", className: "bg-blue-500 text-white p-2 rounded", disabled: !k(), children: "Mettre à jour" })] })] }) }, lo = { _origin: "https://api.emailjs.com" }, MD = (t, e = "https://api.emailjs.com") => { lo._userID = t, lo._origin = e }, X_ = (t, e, n) => { if (!t) throw "The user ID is required. Visit https://dashboard.emailjs.com/admin/integration"; if (!e) throw "The service ID is required. Visit https://dashboard.emailjs.com/admin"; if (!n) throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates"; return !0 }; class dv { constructor(e) { this.status = e.status, this.text = e.responseText } } const J_ = (t, e, n = {}) => new Promise((r, i) => { const s = new XMLHttpRequest; s.addEventListener("load", ({ target: o }) => { const a = new dv(o); a.status === 200 || a.text === "OK" ? r(a) : i(a) }), s.addEventListener("error", ({ target: o }) => { i(new dv(o)) }), s.open("POST", lo._origin + t, !0), Object.keys(n).forEach(o => { s.setRequestHeader(o, n[o]) }), s.send(e) }), LD = (t, e, n, r) => { const i = r || lo._userID; return X_(i, t, e), J_("/api/v1.0/email/send", JSON.stringify({ lib_version: "3.2.0", user_id: i, service_id: t, template_id: e, template_params: n }), { "Content-type": "application/json" }) }, DD = t => { let e; if (typeof t == "string" ? e = document.querySelector(t) : e = t, !e || e.nodeName !== "FORM") throw "The 3rd parameter is expected to be the HTML form element or the style selector of form"; return e }, AD = (t, e, n, r) => { const i = r || lo._userID, s = DD(n); X_(i, t, e); const o = new FormData(s); return o.append("lib_version", "3.2.0"), o.append("service_id", t), o.append("template_id", e), o.append("user_id", i), J_("/api/v1.0/email/send-form", o) }, hv = { init: MD, send: LD, sendForm: AD }, Z_ = () => {
  R.useEffect(() => { hv.init("fF2Ie6GtG1pIakaeG") }, []); const t = () => {
    const e = document.getElementById("name").value, n = document.getElementById("email").value, r = document.getElementById("message").value, i = `Message de ${e},

Adresse de contact du client : ${n},
Message : ${r}`, s = { sendername: e, replyto: n, message: i }; hv.send("service_7ytleyo", "template_z5ny6gu", s).then(() => {
      alert(`Message envoyé ! 
 (Nous répondons généralement en moins d'une semaine)`)
    }).catch(l => {
      console.error(`Une erreur est survenue lors de l'envoi,
 Veuillez nous excuser. Si le problème persiste, contactez le support par un autre moyen. 
 Contact > adresse mail du support:`, l)
    })
  }; return A.jsxs("form", { method: "POST", className: "contact-form mx-auto w-96 bg-gray-500 p-8 rounded-lg shadow-md m-8", children: [A.jsx("h2", { className: "text-2xl font-bold mb-4", children: "Formulaire de contact" }), A.jsxs("div", { className: "form-group mb-4", children: [A.jsx("label", { htmlFor: "name", className: "block font-bold mb-2", children: "Nom :" }), A.jsx("input", { type: "text", id: "name", name: "name", placeholder: "Nom*", required: !0, className: "w-full p-2 border border-gray-300 rounded-md" })] }), A.jsxs("div", { className: "form-group mb-4", children: [A.jsx("label", { htmlFor: "email", className: "block font-bold mb-2", children: "Email :" }), A.jsx("input", { type: "email", id: "email", name: "email", placeholder: "Email*", required: !0, className: "w-full p-2 border border-gray-300 rounded-md" })] }), A.jsxs("div", { className: "form-group mb-4", children: [A.jsx("label", { htmlFor: "message", className: "block font-bold mb-2", children: "Message :" }), A.jsx("textarea", { id: "message", name: "message", placeholder: "Votre message*", required: !0, className: "w-full p-2 border border-gray-300 rounded-md" })] }), A.jsx("button", { type: "button", className: "submit-btn w-full py-2 bg-blue-500 text-white font-bold rounded-md hover:bg-blue-600", onClick: t, children: "Envoyer" })] })
}, jD = () => A.jsx("div", { className: "home-container text-center p-8", children: A.jsxs("div", { className: "flex flex-row items-center space-x-4", children: [A.jsxs("div", { className: "flex-1 w-3/4", children: [A.jsx("h1", { className: "text-3xl font-bold mb-4", children: "Bienvenue sur Personnal Banking" }), A.jsx("p", { className: "mb-4", children: 'Ce site vous permet de faire vos comptes simplement et de regrouper vos différents livrets ou "enveloppes de dépense".' }), A.jsx("p", { className: "mb-4", children: "Ce projet a été réalisé par Peguin Quentin" }), A.jsx("p", { className: "mt-8", children: "Pour accéder à toutes les fonctionnalités, veuillez vous connecter." }), A.jsx("button", { className: "bg-gray-300 mt-4 py-2 px-4 rounded", children: A.jsx(Jr, { to: "/auth", className: "login-button", children: "Connexion" }) }), A.jsx("p", { className: "mb-4", children: "Pour toutes questions, merci de me contacter via le formulaire suivant :" }), A.jsx(Z_, {})] }), A.jsx("div", { className: "flex-shrink-0 w-1/4", children: A.jsx("img", { src: ol, alt: "Logo", className: "object-contain w-full h-full rounded-full" }) })] }) }), ND = () => { const [t, e] = R.useState([]), [n, r] = R.useState(null), [i, s] = R.useState([]), [o, a] = R.useState(!0); R.useEffect(() => { (async () => { var g; const { data: { user: f } } = await je.auth.getUser(); r(f), s(((g = f == null ? void 0 : f.user_metadata) == null ? void 0 : g.livrets) || []), a(!1) })() }, []), R.useEffect(() => { if (!n) return; (async () => { const { data: f, error: g } = await je.from("accounts").select("*").eq("user_id", n.id); if (g) { console.error("Erreur lors de la récupération des comptes :", g); return } if (f) { const m = f.map(y => ({ id: y.id, ...y })); e(m) } else console.error("Les données récupérées sont nulles") })() }, [n]); const l = async h => { try { const f = h.replace(/[^a-zA-Z0-9_]/g, "_"), { error: g } = await je.rpc("check_and_add_column", { table_name: "accounts", column_name: f, column_type: "text" }); if (g) throw g } catch (f) { console.error(`Erreur lors de la vérification/ajout de la colonne ${h} :`, f) } }, u = async h => { h.id = ub(); for (const f in h) h.hasOwnProperty(f) && f !== "id" && f !== "user_id" && await l(f); try { const { data: f, error: g } = await je.from("accounts").insert({ ...h, user_id: n == null ? void 0 : n.id }).select(); if (g) { console.error("Erreur lors de l'insertion du compte :", g); return } f ? e([...t, { ...h }]) : console.error("Les données insérées sont nulles") } catch (f) { console.error("Erreur lors de l'ajout du compte :", f) } }, c = async (h, f) => { for (const g in f) f.hasOwnProperty(g) && g !== "id" && g !== "user_id" && await l(g); try { const { error: g } = await je.from("accounts").update(f).eq("id", h).eq("user_id", n == null ? void 0 : n.id); if (g) { console.error("Erreur lors de la mise à jour du compte :", g); return } e(t.map(m => m.id === h ? { ...m, ...f } : m)) } catch (g) { console.error("Erreur lors de la mise à jour du compte :", g) } }, d = async h => { try { const { error: f } = await je.from("accounts").delete().eq("id", h).eq("user_id", n == null ? void 0 : n.id); if (f) { console.error("Erreur lors de la suppression du compte :", f); return } e(t.filter(g => g.id !== h)) } catch (f) { console.error("Erreur lors de la suppression du compte :", f) } }; return o ? A.jsx("div", { children: "Loading..." }) : A.jsx(E1, { basename: "/Personal_Banking", children: A.jsxs("div", { className: "App w-full h-full", children: [A.jsx(AC, {}), A.jsxs(w1, { children: [A.jsx(hn, { path: "/", element: n ? A.jsx(cr, { to: "/accountform" }) : A.jsx(cr, { to: "/Home" }) }), A.jsx(hn, { path: "/Home", element: A.jsx(jD, {}) }), A.jsx(hn, { path: "/accountform", element: n ? A.jsx(SP, { addAccount: u, accounts: t, livrets: i }) : A.jsx(cr, { to: "/" }) }), A.jsx(hn, { path: "/tableau", element: n ? A.jsx(xP, { accounts: t, deleteAccount: d, updateAccount: c, livrets: i }) : A.jsx(cr, { to: "/" }) }), A.jsx(hn, { path: "/graphique", element: n ? A.jsx(_D, { accounts: t }) : A.jsx(cr, { to: "/" }) }), A.jsx(hn, { path: "/auth", element: A.jsx(wD, {}) }), A.jsx(hn, { path: "/parametres", element: n ? A.jsx(RD, {}) : A.jsx(cr, { to: "/" }) }), A.jsx(hn, { path: "/contact", element: n ? A.jsx(Z_, {}) : A.jsx(cr, { to: "/" }) })] })] }) }) }, FD = document.getElementById("root"), $D = O0(FD); $D.render(A.jsx(_t.StrictMode, { children: A.jsx(ND, {}) })); export { Vd as g };
