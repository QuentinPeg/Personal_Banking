var ow = Object.defineProperty; var aw = (t, e, n) => e in t ? ow(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n; var J = (t, e, n) => aw(t, typeof e != "symbol" ? e + "" : e, n); function lw(t, e) { for (var n = 0; n < e.length; n++) { const r = e[n]; if (typeof r != "string" && !Array.isArray(r)) { for (const i in r) if (i !== "default" && !(i in t)) { const s = Object.getOwnPropertyDescriptor(r, i); s && Object.defineProperty(t, i, s.get ? s : { enumerable: !0, get: () => r[i] }) } } } return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })) } (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const s of i) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(i) { if (i.ep) return; i.ep = !0; const s = n(i); fetch(i.href, s) } })(); var At = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function Bd(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } function uw(t) { if (t.__esModule) return t; var e = t.default; if (typeof e == "function") { var n = function r() { return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments) }; n.prototype = e.prototype } else n = {}; return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function (r) { var i = Object.getOwnPropertyDescriptor(t, r); Object.defineProperty(n, r, i.get ? i : { enumerable: !0, get: function () { return t[r] } }) }), n } var mv = { exports: {} }, Pl = {}, vv = { exports: {} }, te = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ho = Symbol.for("react.element"), cw = Symbol.for("react.portal"), dw = Symbol.for("react.fragment"), hw = Symbol.for("react.strict_mode"), fw = Symbol.for("react.profiler"), pw = Symbol.for("react.provider"), gw = Symbol.for("react.context"), mw = Symbol.for("react.forward_ref"), vw = Symbol.for("react.suspense"), yw = Symbol.for("react.memo"), bw = Symbol.for("react.lazy"), Af = Symbol.iterator; function _w(t) { return t === null || typeof t != "object" ? null : (t = Af && t[Af] || t["@@iterator"], typeof t == "function" ? t : null) } var yv = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, bv = Object.assign, _v = {}; function Ai(t, e, n) { this.props = t, this.context = e, this.refs = _v, this.updater = n || yv } Ai.prototype.isReactComponent = {}; Ai.prototype.setState = function (t, e) { if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, t, e, "setState") }; Ai.prototype.forceUpdate = function (t) { this.updater.enqueueForceUpdate(this, t, "forceUpdate") }; function wv() { } wv.prototype = Ai.prototype; function Ud(t, e, n) { this.props = t, this.context = e, this.refs = _v, this.updater = n || yv } var Hd = Ud.prototype = new wv; Hd.constructor = Ud; bv(Hd, Ai.prototype); Hd.isPureReactComponent = !0; var Nf = Array.isArray, xv = Object.prototype.hasOwnProperty, Wd = { current: null }, Sv = { key: !0, ref: !0, __self: !0, __source: !0 }; function kv(t, e, n) { var r, i = {}, s = null, o = null; if (e != null) for (r in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) xv.call(e, r) && !Sv.hasOwnProperty(r) && (i[r] = e[r]); var a = arguments.length - 2; if (a === 1) i.children = n; else if (1 < a) { for (var l = Array(a), u = 0; u < a; u++)l[u] = arguments[u + 2]; i.children = l } if (t && t.defaultProps) for (r in a = t.defaultProps, a) i[r] === void 0 && (i[r] = a[r]); return { $$typeof: ho, type: t, key: s, ref: o, props: i, _owner: Wd.current } } function ww(t, e) { return { $$typeof: ho, type: t.type, key: e, ref: t.ref, props: t.props, _owner: t._owner } } function qd(t) { return typeof t == "object" && t !== null && t.$$typeof === ho } function xw(t) { var e = { "=": "=0", ":": "=2" }; return "$" + t.replace(/[=:]/g, function (n) { return e[n] }) } var Ff = /\/+/g; function wu(t, e) { return typeof t == "object" && t !== null && t.key != null ? xw("" + t.key) : e.toString(36) } function ga(t, e, n, r, i) { var s = typeof t; (s === "undefined" || s === "boolean") && (t = null); var o = !1; if (t === null) o = !0; else switch (s) { case "string": case "number": o = !0; break; case "object": switch (t.$$typeof) { case ho: case cw: o = !0 } }if (o) return o = t, i = i(o), t = r === "" ? "." + wu(o, 0) : r, Nf(i) ? (n = "", t != null && (n = t.replace(Ff, "$&/") + "/"), ga(i, e, n, "", function (u) { return u })) : i != null && (qd(i) && (i = ww(i, n + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(Ff, "$&/") + "/") + t)), e.push(i)), 1; if (o = 0, r = r === "" ? "." : r + ":", Nf(t)) for (var a = 0; a < t.length; a++) { s = t[a]; var l = r + wu(s, a); o += ga(s, e, n, l, i) } else if (l = _w(t), typeof l == "function") for (t = l.call(t), a = 0; !(s = t.next()).done;)s = s.value, l = r + wu(s, a++), o += ga(s, e, n, l, i); else if (s === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return o } function Po(t, e, n) { if (t == null) return t; var r = [], i = 0; return ga(t, r, "", "", function (s) { return e.call(n, s, i++) }), r } function Sw(t) { if (t._status === -1) { var e = t._result; e = e(), e.then(function (n) { (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n) }, function (n) { (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n) }), t._status === -1 && (t._status = 0, t._result = e) } if (t._status === 1) return t._result.default; throw t._result } var it = { current: null }, ma = { transition: null }, kw = { ReactCurrentDispatcher: it, ReactCurrentBatchConfig: ma, ReactCurrentOwner: Wd }; function Cv() { throw Error("act(...) is not supported in production builds of React.") } te.Children = { map: Po, forEach: function (t, e, n) { Po(t, function () { e.apply(this, arguments) }, n) }, count: function (t) { var e = 0; return Po(t, function () { e++ }), e }, toArray: function (t) { return Po(t, function (e) { return e }) || [] }, only: function (t) { if (!qd(t)) throw Error("React.Children.only expected to receive a single React element child."); return t } }; te.Component = Ai; te.Fragment = dw; te.Profiler = fw; te.PureComponent = Ud; te.StrictMode = hw; te.Suspense = vw; te.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = kw; te.act = Cv; te.cloneElement = function (t, e, n) { if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + "."); var r = bv({}, t.props), i = t.key, s = t.ref, o = t._owner; if (e != null) { if (e.ref !== void 0 && (s = e.ref, o = Wd.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps) var a = t.type.defaultProps; for (l in e) xv.call(e, l) && !Sv.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]) } var l = arguments.length - 2; if (l === 1) r.children = n; else if (1 < l) { a = Array(l); for (var u = 0; u < l; u++)a[u] = arguments[u + 2]; r.children = a } return { $$typeof: ho, type: t.type, key: i, ref: s, props: r, _owner: o } }; te.createContext = function (t) { return t = { $$typeof: gw, _currentValue: t, _currentValue2: t, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, t.Provider = { $$typeof: pw, _context: t }, t.Consumer = t }; te.createElement = kv; te.createFactory = function (t) { var e = kv.bind(null, t); return e.type = t, e }; te.createRef = function () { return { current: null } }; te.forwardRef = function (t) { return { $$typeof: mw, render: t } }; te.isValidElement = qd; te.lazy = function (t) { return { $$typeof: bw, _payload: { _status: -1, _result: t }, _init: Sw } }; te.memo = function (t, e) { return { $$typeof: yw, type: t, compare: e === void 0 ? null : e } }; te.startTransition = function (t) { var e = ma.transition; ma.transition = {}; try { t() } finally { ma.transition = e } }; te.unstable_act = Cv; te.useCallback = function (t, e) { return it.current.useCallback(t, e) }; te.useContext = function (t) { return it.current.useContext(t) }; te.useDebugValue = function () { }; te.useDeferredValue = function (t) { return it.current.useDeferredValue(t) }; te.useEffect = function (t, e) { return it.current.useEffect(t, e) }; te.useId = function () { return it.current.useId() }; te.useImperativeHandle = function (t, e, n) { return it.current.useImperativeHandle(t, e, n) }; te.useInsertionEffect = function (t, e) { return it.current.useInsertionEffect(t, e) }; te.useLayoutEffect = function (t, e) { return it.current.useLayoutEffect(t, e) }; te.useMemo = function (t, e) { return it.current.useMemo(t, e) }; te.useReducer = function (t, e, n) { return it.current.useReducer(t, e, n) }; te.useRef = function (t) { return it.current.useRef(t) }; te.useState = function (t) { return it.current.useState(t) }; te.useSyncExternalStore = function (t, e, n) { return it.current.useSyncExternalStore(t, e, n) }; te.useTransition = function () { return it.current.useTransition() }; te.version = "18.3.1"; vv.exports = te; var R = vv.exports; const Dt = Bd(R), wc = lw({ __proto__: null, default: Dt }, [R]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Cw = R, Ow = Symbol.for("react.element"), Pw = Symbol.for("react.fragment"), Ew = Object.prototype.hasOwnProperty, Tw = Cw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, Iw = { key: !0, ref: !0, __self: !0, __source: !0 }; function Ov(t, e, n) { var r, i = {}, s = null, o = null; n !== void 0 && (s = "" + n), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref); for (r in e) Ew.call(e, r) && !Iw.hasOwnProperty(r) && (i[r] = e[r]); if (t && t.defaultProps) for (r in e = t.defaultProps, e) i[r] === void 0 && (i[r] = e[r]); return { $$typeof: Ow, type: t, key: s, ref: o, props: i, _owner: Tw.current } } Pl.Fragment = Pw; Pl.jsx = Ov; Pl.jsxs = Ov; mv.exports = Pl; var k = mv.exports, Pv = { exports: {} }, St = {}, Ev = { exports: {} }, Tv = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (t) { function e(A, _) { var S = A.length; A.push(_); e: for (; 0 < S;) { var E = S - 1 >>> 1, w = A[E]; if (0 < i(w, _)) A[E] = _, A[S] = w, S = E; else break e } } function n(A) { return A.length === 0 ? null : A[0] } function r(A) { if (A.length === 0) return null; var _ = A[0], S = A.pop(); if (S !== _) { A[0] = S; e: for (var E = 0, w = A.length, O = w >>> 1; E < O;) { var j = 2 * (E + 1) - 1, $ = A[j], z = j + 1, W = A[z]; if (0 > i($, S)) z < w && 0 > i(W, $) ? (A[E] = W, A[z] = S, E = z) : (A[E] = $, A[j] = S, E = j); else if (z < w && 0 > i(W, S)) A[E] = W, A[z] = S, E = z; else break e } } return _ } function i(A, _) { var S = A.sortIndex - _.sortIndex; return S !== 0 ? S : A.id - _.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; t.unstable_now = function () { return s.now() } } else { var o = Date, a = o.now(); t.unstable_now = function () { return o.now() - a } } var l = [], u = [], c = 1, d = null, h = 3, f = !1, g = !1, m = !1, y = typeof setTimeout == "function" ? setTimeout : null, p = typeof clearTimeout == "function" ? clearTimeout : null, v = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function b(A) { for (var _ = n(u); _ !== null;) { if (_.callback === null) r(u); else if (_.startTime <= A) r(u), _.sortIndex = _.expirationTime, e(l, _); else break; _ = n(u) } } function x(A) { if (m = !1, b(A), !g) if (n(l) !== null) g = !0, q(P); else { var _ = n(u); _ !== null && V(x, _.startTime - A) } } function P(A, _) { g = !1, m && (m = !1, p(C), C = -1), f = !0; var S = h; try { for (b(_), d = n(l); d !== null && (!(d.expirationTime > _) || A && !D());) { var E = d.callback; if (typeof E == "function") { d.callback = null, h = d.priorityLevel; var w = E(d.expirationTime <= _); _ = t.unstable_now(), typeof w == "function" ? d.callback = w : d === n(l) && r(l), b(_) } else r(l); d = n(l) } if (d !== null) var O = !0; else { var j = n(u); j !== null && V(x, j.startTime - _), O = !1 } return O } finally { d = null, h = S, f = !1 } } var M = !1, I = null, C = -1, T = 5, L = -1; function D() { return !(t.unstable_now() - L < T) } function N() { if (I !== null) { var A = t.unstable_now(); L = A; var _ = !0; try { _ = I(!0, A) } finally { _ ? F() : (M = !1, I = null) } } else M = !1 } var F; if (typeof v == "function") F = function () { v(N) }; else if (typeof MessageChannel < "u") { var B = new MessageChannel, H = B.port2; B.port1.onmessage = N, F = function () { H.postMessage(null) } } else F = function () { y(N, 0) }; function q(A) { I = A, M || (M = !0, F()) } function V(A, _) { C = y(function () { A(t.unstable_now()) }, _) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (A) { A.callback = null }, t.unstable_continueExecution = function () { g || f || (g = !0, q(P)) }, t.unstable_forceFrameRate = function (A) { 0 > A || 125 < A ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : T = 0 < A ? Math.floor(1e3 / A) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return h }, t.unstable_getFirstCallbackNode = function () { return n(l) }, t.unstable_next = function (A) { switch (h) { case 1: case 2: case 3: var _ = 3; break; default: _ = h }var S = h; h = _; try { return A() } finally { h = S } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (A, _) { switch (A) { case 1: case 2: case 3: case 4: case 5: break; default: A = 3 }var S = h; h = A; try { return _() } finally { h = S } }, t.unstable_scheduleCallback = function (A, _, S) { var E = t.unstable_now(); switch (typeof S == "object" && S !== null ? (S = S.delay, S = typeof S == "number" && 0 < S ? E + S : E) : S = E, A) { case 1: var w = -1; break; case 2: w = 250; break; case 5: w = 1073741823; break; case 4: w = 1e4; break; default: w = 5e3 }return w = S + w, A = { id: c++, callback: _, priorityLevel: A, startTime: S, expirationTime: w, sortIndex: -1 }, S > E ? (A.sortIndex = S, e(u, A), n(l) === null && A === n(u) && (m ? (p(C), C = -1) : m = !0, V(x, S - E))) : (A.sortIndex = w, e(l, A), g || f || (g = !0, q(P))), A }, t.unstable_shouldYield = D, t.unstable_wrapCallback = function (A) { var _ = h; return function () { var S = h; h = _; try { return A.apply(this, arguments) } finally { h = S } } } })(Tv); Ev.exports = Tv; var Rw = Ev.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Mw = R, xt = Rw; function U(t) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)e += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Iv = new Set, js = {}; function $r(t, e) { Si(t, e), Si(t + "Capture", e) } function Si(t, e) { for (js[t] = e, t = 0; t < e.length; t++)Iv.add(e[t]) } var Sn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), xc = Object.prototype.hasOwnProperty, Lw = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, $f = {}, zf = {}; function Dw(t) { return xc.call(zf, t) ? !0 : xc.call($f, t) ? !1 : Lw.test(t) ? zf[t] = !0 : ($f[t] = !0, !1) } function jw(t, e, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-"); default: return !1 } } function Aw(t, e, n, r) { if (e === null || typeof e > "u" || jw(t, e, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function st(t, e, n, r, i, s, o) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o } var We = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) { We[t] = new st(t, 0, !1, t, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) { var e = t[0]; We[e] = new st(e, 1, !1, t[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) { We[t] = new st(t, 2, !1, t.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) { We[t] = new st(t, 2, !1, t, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) { We[t] = new st(t, 3, !1, t.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (t) { We[t] = new st(t, 3, !0, t, null, !1, !1) });["capture", "download"].forEach(function (t) { We[t] = new st(t, 4, !1, t, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (t) { We[t] = new st(t, 6, !1, t, null, !1, !1) });["rowSpan", "start"].forEach(function (t) { We[t] = new st(t, 5, !1, t.toLowerCase(), null, !1, !1) }); var Kd = /[\-:]([a-z])/g; function Gd(t) { return t[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) { var e = t.replace(Kd, Gd); We[e] = new st(e, 1, !1, t, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) { var e = t.replace(Kd, Gd); We[e] = new st(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (t) { var e = t.replace(Kd, Gd); We[e] = new st(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (t) { We[t] = new st(t, 1, !1, t.toLowerCase(), null, !1, !1) }); We.xlinkHref = new st("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (t) { We[t] = new st(t, 1, !1, t.toLowerCase(), null, !0, !0) }); function Yd(t, e, n, r) { var i = We.hasOwnProperty(e) ? We[e] : null; (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (Aw(e, n, i, r) && (n = null), r || i === null ? Dw(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (e = i.attributeName, r = i.attributeNamespace, n === null ? t.removeAttribute(e) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n)))) } var En = Mw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Eo = Symbol.for("react.element"), ei = Symbol.for("react.portal"), ti = Symbol.for("react.fragment"), Qd = Symbol.for("react.strict_mode"), Sc = Symbol.for("react.profiler"), Rv = Symbol.for("react.provider"), Mv = Symbol.for("react.context"), Xd = Symbol.for("react.forward_ref"), kc = Symbol.for("react.suspense"), Cc = Symbol.for("react.suspense_list"), Jd = Symbol.for("react.memo"), Dn = Symbol.for("react.lazy"), Lv = Symbol.for("react.offscreen"), Vf = Symbol.iterator; function Ki(t) { return t === null || typeof t != "object" ? null : (t = Vf && t[Vf] || t["@@iterator"], typeof t == "function" ? t : null) } var ke = Object.assign, xu; function cs(t) {
  if (xu === void 0) try { throw Error() } catch (n) { var e = n.stack.trim().match(/\n( *(at )?)/); xu = e && e[1] || "" } return `
`+ xu + t
} var Su = !1; function ku(t, e) {
  if (!t || Su) return ""; Su = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (u) { var r = u } Reflect.construct(t, [], e) } else { try { e.call() } catch (u) { r = u } t.call(e.prototype) } else { try { throw Error() } catch (u) { r = u } t() } } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (var i = u.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (i[o] !== s[a]) {
        if (o !== 1 || a !== 1) do if (o--, a--, 0 > a || i[o] !== s[a]) {
          var l = `
`+ i[o].replace(" at new ", " at "); return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)), l
        } while (1 <= o && 0 <= a); break
      }
    }
  } finally { Su = !1, Error.prepareStackTrace = n } return (t = t ? t.displayName || t.name : "") ? cs(t) : ""
} function Nw(t) { switch (t.tag) { case 5: return cs(t.type); case 16: return cs("Lazy"); case 13: return cs("Suspense"); case 19: return cs("SuspenseList"); case 0: case 2: case 15: return t = ku(t.type, !1), t; case 11: return t = ku(t.type.render, !1), t; case 1: return t = ku(t.type, !0), t; default: return "" } } function Oc(t) { if (t == null) return null; if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t; switch (t) { case ti: return "Fragment"; case ei: return "Portal"; case Sc: return "Profiler"; case Qd: return "StrictMode"; case kc: return "Suspense"; case Cc: return "SuspenseList" }if (typeof t == "object") switch (t.$$typeof) { case Mv: return (t.displayName || "Context") + ".Consumer"; case Rv: return (t._context.displayName || "Context") + ".Provider"; case Xd: var e = t.render; return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t; case Jd: return e = t.displayName || null, e !== null ? e : Oc(t.type) || "Memo"; case Dn: e = t._payload, t = t._init; try { return Oc(t(e)) } catch { } }return null } function Fw(t) { var e = t.type; switch (t.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Oc(e); case 8: return e === Qd ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function ir(t) { switch (typeof t) { case "boolean": case "number": case "string": case "undefined": return t; case "object": return t; default: return "" } } function Dv(t) { var e = t.type; return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function $w(t) { var e = Dv(t) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), r = "" + t[e]; if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, s = n.set; return Object.defineProperty(t, e, { configurable: !0, get: function () { return i.call(this) }, set: function (o) { r = "" + o, s.call(this, o) } }), Object.defineProperty(t, e, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (o) { r = "" + o }, stopTracking: function () { t._valueTracker = null, delete t[e] } } } } function To(t) { t._valueTracker || (t._valueTracker = $w(t)) } function jv(t) { if (!t) return !1; var e = t._valueTracker; if (!e) return !0; var n = e.getValue(), r = ""; return t && (r = Dv(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== n ? (e.setValue(t), !0) : !1 } function Aa(t) { if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null; try { return t.activeElement || t.body } catch { return t.body } } function Pc(t, e) { var n = e.checked; return ke({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? t._wrapperState.initialChecked }) } function Bf(t, e) { var n = e.defaultValue == null ? "" : e.defaultValue, r = e.checked != null ? e.checked : e.defaultChecked; n = ir(e.value != null ? e.value : n), t._wrapperState = { initialChecked: r, initialValue: n, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function Av(t, e) { e = e.checked, e != null && Yd(t, "checked", e, !1) } function Ec(t, e) { Av(t, e); var n = ir(e.value), r = e.type; if (n != null) r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n); else if (r === "submit" || r === "reset") { t.removeAttribute("value"); return } e.hasOwnProperty("value") ? Tc(t, e.type, n) : e.hasOwnProperty("defaultValue") && Tc(t, e.type, ir(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked) } function Uf(t, e, n) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var r = e.type; if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e } n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n) } function Tc(t, e, n) { (e !== "number" || Aa(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n)) } var ds = Array.isArray; function pi(t, e, n, r) { if (t = t.options, e) { e = {}; for (var i = 0; i < n.length; i++)e["$" + n[i]] = !0; for (n = 0; n < t.length; n++)i = e.hasOwnProperty("$" + t[n].value), t[n].selected !== i && (t[n].selected = i), i && r && (t[n].defaultSelected = !0) } else { for (n = "" + ir(n), e = null, i = 0; i < t.length; i++) { if (t[i].value === n) { t[i].selected = !0, r && (t[i].defaultSelected = !0); return } e !== null || t[i].disabled || (e = t[i]) } e !== null && (e.selected = !0) } } function Ic(t, e) { if (e.dangerouslySetInnerHTML != null) throw Error(U(91)); return ke({}, e, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue }) } function Hf(t, e) { var n = e.value; if (n == null) { if (n = e.children, e = e.defaultValue, n != null) { if (e != null) throw Error(U(92)); if (ds(n)) { if (1 < n.length) throw Error(U(93)); n = n[0] } e = n } e == null && (e = ""), n = e } t._wrapperState = { initialValue: ir(n) } } function Nv(t, e) { var n = ir(e.value), r = ir(e.defaultValue); n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), r != null && (t.defaultValue = "" + r) } function Wf(t) { var e = t.textContent; e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e) } function Fv(t) { switch (t) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Rc(t, e) { return t == null || t === "http://www.w3.org/1999/xhtml" ? Fv(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t } var Io, $v = function (t) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return t(e, n, r, i) }) } : t }(function (t, e) { if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e; else { for (Io = Io || document.createElement("div"), Io.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Io.firstChild; t.firstChild;)t.removeChild(t.firstChild); for (; e.firstChild;)t.appendChild(e.firstChild) } }); function As(t, e) { if (e) { var n = t.firstChild; if (n && n === t.lastChild && n.nodeType === 3) { n.nodeValue = e; return } } t.textContent = e } var bs = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, zw = ["Webkit", "ms", "Moz", "O"]; Object.keys(bs).forEach(function (t) { zw.forEach(function (e) { e = e + t.charAt(0).toUpperCase() + t.substring(1), bs[e] = bs[t] }) }); function zv(t, e, n) { return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || bs.hasOwnProperty(t) && bs[t] ? ("" + e).trim() : e + "px" } function Vv(t, e) { t = t.style; for (var n in e) if (e.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = zv(n, e[n], r); n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : t[n] = i } } var Vw = ke({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Mc(t, e) { if (e) { if (Vw[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(U(137, t)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(U(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(U(61)) } if (e.style != null && typeof e.style != "object") throw Error(U(62)) } } function Lc(t, e) { if (t.indexOf("-") === -1) return typeof e.is == "string"; switch (t) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Dc = null; function Zd(t) { return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t } var jc = null, gi = null, mi = null; function qf(t) { if (t = go(t)) { if (typeof jc != "function") throw Error(U(280)); var e = t.stateNode; e && (e = Ml(e), jc(t.stateNode, t.type, e)) } } function Bv(t) { gi ? mi ? mi.push(t) : mi = [t] : gi = t } function Uv() { if (gi) { var t = gi, e = mi; if (mi = gi = null, qf(t), e) for (t = 0; t < e.length; t++)qf(e[t]) } } function Hv(t, e) { return t(e) } function Wv() { } var Cu = !1; function qv(t, e, n) { if (Cu) return t(e, n); Cu = !0; try { return Hv(t, e, n) } finally { Cu = !1, (gi !== null || mi !== null) && (Wv(), Uv()) } } function Ns(t, e) { var n = t.stateNode; if (n === null) return null; var r = Ml(n); if (r === null) return null; n = r[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r; break e; default: t = !1 }if (t) return null; if (n && typeof n != "function") throw Error(U(231, e, typeof n)); return n } var Ac = !1; if (Sn) try { var Gi = {}; Object.defineProperty(Gi, "passive", { get: function () { Ac = !0 } }), window.addEventListener("test", Gi, Gi), window.removeEventListener("test", Gi, Gi) } catch { Ac = !1 } function Bw(t, e, n, r, i, s, o, a, l) { var u = Array.prototype.slice.call(arguments, 3); try { e.apply(n, u) } catch (c) { this.onError(c) } } var _s = !1, Na = null, Fa = !1, Nc = null, Uw = { onError: function (t) { _s = !0, Na = t } }; function Hw(t, e, n, r, i, s, o, a, l) { _s = !1, Na = null, Bw.apply(Uw, arguments) } function Ww(t, e, n, r, i, s, o, a, l) { if (Hw.apply(this, arguments), _s) { if (_s) { var u = Na; _s = !1, Na = null } else throw Error(U(198)); Fa || (Fa = !0, Nc = u) } } function zr(t) { var e = t, n = t; if (t.alternate) for (; e.return;)e = e.return; else { t = e; do e = t, e.flags & 4098 && (n = e.return), t = e.return; while (t) } return e.tag === 3 ? n : null } function Kv(t) { if (t.tag === 13) { var e = t.memoizedState; if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated } return null } function Kf(t) { if (zr(t) !== t) throw Error(U(188)) } function qw(t) { var e = t.alternate; if (!e) { if (e = zr(t), e === null) throw Error(U(188)); return e !== t ? null : t } for (var n = t, r = e; ;) { var i = n.return; if (i === null) break; var s = i.alternate; if (s === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === s.child) { for (s = i.child; s;) { if (s === n) return Kf(i), t; if (s === r) return Kf(i), e; s = s.sibling } throw Error(U(188)) } if (n.return !== r.return) n = i, r = s; else { for (var o = !1, a = i.child; a;) { if (a === n) { o = !0, n = i, r = s; break } if (a === r) { o = !0, r = i, n = s; break } a = a.sibling } if (!o) { for (a = s.child; a;) { if (a === n) { o = !0, n = s, r = i; break } if (a === r) { o = !0, r = s, n = i; break } a = a.sibling } if (!o) throw Error(U(189)) } } if (n.alternate !== r) throw Error(U(190)) } if (n.tag !== 3) throw Error(U(188)); return n.stateNode.current === n ? t : e } function Gv(t) { return t = qw(t), t !== null ? Yv(t) : null } function Yv(t) { if (t.tag === 5 || t.tag === 6) return t; for (t = t.child; t !== null;) { var e = Yv(t); if (e !== null) return e; t = t.sibling } return null } var Qv = xt.unstable_scheduleCallback, Gf = xt.unstable_cancelCallback, Kw = xt.unstable_shouldYield, Gw = xt.unstable_requestPaint, Ee = xt.unstable_now, Yw = xt.unstable_getCurrentPriorityLevel, eh = xt.unstable_ImmediatePriority, Xv = xt.unstable_UserBlockingPriority, $a = xt.unstable_NormalPriority, Qw = xt.unstable_LowPriority, Jv = xt.unstable_IdlePriority, El = null, an = null; function Xw(t) { if (an && typeof an.onCommitFiberRoot == "function") try { an.onCommitFiberRoot(El, t, void 0, (t.current.flags & 128) === 128) } catch { } } var Kt = Math.clz32 ? Math.clz32 : ex, Jw = Math.log, Zw = Math.LN2; function ex(t) { return t >>>= 0, t === 0 ? 32 : 31 - (Jw(t) / Zw | 0) | 0 } var Ro = 64, Mo = 4194304; function hs(t) { switch (t & -t) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return t & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return t } } function za(t, e) { var n = t.pendingLanes; if (n === 0) return 0; var r = 0, i = t.suspendedLanes, s = t.pingedLanes, o = n & 268435455; if (o !== 0) { var a = o & ~i; a !== 0 ? r = hs(a) : (s &= o, s !== 0 && (r = hs(s))) } else o = n & ~i, o !== 0 ? r = hs(o) : s !== 0 && (r = hs(s)); if (r === 0) return 0; if (e !== 0 && e !== r && !(e & i) && (i = r & -r, s = e & -e, i >= s || i === 16 && (s & 4194240) !== 0)) return e; if (r & 4 && (r |= n & 16), e = t.entangledLanes, e !== 0) for (t = t.entanglements, e &= r; 0 < e;)n = 31 - Kt(e), i = 1 << n, r |= t[n], e &= ~i; return r } function tx(t, e) { switch (t) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function nx(t, e) { for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, s = t.pendingLanes; 0 < s;) { var o = 31 - Kt(s), a = 1 << o, l = i[o]; l === -1 ? (!(a & n) || a & r) && (i[o] = tx(a, e)) : l <= e && (t.expiredLanes |= a), s &= ~a } } function Fc(t) { return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0 } function Zv() { var t = Ro; return Ro <<= 1, !(Ro & 4194240) && (Ro = 64), t } function Ou(t) { for (var e = [], n = 0; 31 > n; n++)e.push(t); return e } function fo(t, e, n) { t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - Kt(e), t[e] = n } function rx(t, e) { var n = t.pendingLanes & ~e; t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements; var r = t.eventTimes; for (t = t.expirationTimes; 0 < n;) { var i = 31 - Kt(n), s = 1 << i; e[i] = 0, r[i] = -1, t[i] = -1, n &= ~s } } function th(t, e) { var n = t.entangledLanes |= e; for (t = t.entanglements; n;) { var r = 31 - Kt(n), i = 1 << r; i & e | t[r] & e && (t[r] |= e), n &= ~i } } var de = 0; function ey(t) { return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1 } var ty, nh, ny, ry, iy, $c = !1, Lo = [], Kn = null, Gn = null, Yn = null, Fs = new Map, $s = new Map, Nn = [], ix = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Yf(t, e) { switch (t) { case "focusin": case "focusout": Kn = null; break; case "dragenter": case "dragleave": Gn = null; break; case "mouseover": case "mouseout": Yn = null; break; case "pointerover": case "pointerout": Fs.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": $s.delete(e.pointerId) } } function Yi(t, e, n, r, i, s) { return t === null || t.nativeEvent !== s ? (t = { blockedOn: e, domEventName: n, eventSystemFlags: r, nativeEvent: s, targetContainers: [i] }, e !== null && (e = go(e), e !== null && nh(e)), t) : (t.eventSystemFlags |= r, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t) } function sx(t, e, n, r, i) { switch (e) { case "focusin": return Kn = Yi(Kn, t, e, n, r, i), !0; case "dragenter": return Gn = Yi(Gn, t, e, n, r, i), !0; case "mouseover": return Yn = Yi(Yn, t, e, n, r, i), !0; case "pointerover": var s = i.pointerId; return Fs.set(s, Yi(Fs.get(s) || null, t, e, n, r, i)), !0; case "gotpointercapture": return s = i.pointerId, $s.set(s, Yi($s.get(s) || null, t, e, n, r, i)), !0 }return !1 } function sy(t) { var e = kr(t.target); if (e !== null) { var n = zr(e); if (n !== null) { if (e = n.tag, e === 13) { if (e = Kv(n), e !== null) { t.blockedOn = e, iy(t.priority, function () { ny(n) }); return } } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) { t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } t.blockedOn = null } function va(t) { if (t.blockedOn !== null) return !1; for (var e = t.targetContainers; 0 < e.length;) { var n = zc(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent); if (n === null) { n = t.nativeEvent; var r = new n.constructor(n.type, n); Dc = r, n.target.dispatchEvent(r), Dc = null } else return e = go(n), e !== null && nh(e), t.blockedOn = n, !1; e.shift() } return !0 } function Qf(t, e, n) { va(t) && n.delete(e) } function ox() { $c = !1, Kn !== null && va(Kn) && (Kn = null), Gn !== null && va(Gn) && (Gn = null), Yn !== null && va(Yn) && (Yn = null), Fs.forEach(Qf), $s.forEach(Qf) } function Qi(t, e) { t.blockedOn === e && (t.blockedOn = null, $c || ($c = !0, xt.unstable_scheduleCallback(xt.unstable_NormalPriority, ox))) } function zs(t) { function e(i) { return Qi(i, t) } if (0 < Lo.length) { Qi(Lo[0], t); for (var n = 1; n < Lo.length; n++) { var r = Lo[n]; r.blockedOn === t && (r.blockedOn = null) } } for (Kn !== null && Qi(Kn, t), Gn !== null && Qi(Gn, t), Yn !== null && Qi(Yn, t), Fs.forEach(e), $s.forEach(e), n = 0; n < Nn.length; n++)r = Nn[n], r.blockedOn === t && (r.blockedOn = null); for (; 0 < Nn.length && (n = Nn[0], n.blockedOn === null);)sy(n), n.blockedOn === null && Nn.shift() } var vi = En.ReactCurrentBatchConfig, Va = !0; function ax(t, e, n, r) { var i = de, s = vi.transition; vi.transition = null; try { de = 1, rh(t, e, n, r) } finally { de = i, vi.transition = s } } function lx(t, e, n, r) { var i = de, s = vi.transition; vi.transition = null; try { de = 4, rh(t, e, n, r) } finally { de = i, vi.transition = s } } function rh(t, e, n, r) { if (Va) { var i = zc(t, e, n, r); if (i === null) Au(t, e, r, Ba, n), Yf(t, r); else if (sx(i, t, e, n, r)) r.stopPropagation(); else if (Yf(t, r), e & 4 && -1 < ix.indexOf(t)) { for (; i !== null;) { var s = go(i); if (s !== null && ty(s), s = zc(t, e, n, r), s === null && Au(t, e, r, Ba, n), s === i) break; i = s } i !== null && r.stopPropagation() } else Au(t, e, r, null, n) } } var Ba = null; function zc(t, e, n, r) { if (Ba = null, t = Zd(r), t = kr(t), t !== null) if (e = zr(t), e === null) t = null; else if (n = e.tag, n === 13) { if (t = Kv(e), t !== null) return t; t = null } else if (n === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; t = null } else e !== t && (t = null); return Ba = t, null } function oy(t) { switch (t) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Yw()) { case eh: return 1; case Xv: return 4; case $a: case Qw: return 16; case Jv: return 536870912; default: return 16 }default: return 16 } } var zn = null, ih = null, ya = null; function ay() { if (ya) return ya; var t, e = ih, n = e.length, r, i = "value" in zn ? zn.value : zn.textContent, s = i.length; for (t = 0; t < n && e[t] === i[t]; t++); var o = n - t; for (r = 1; r <= o && e[n - r] === i[s - r]; r++); return ya = i.slice(t, 1 < r ? 1 - r : void 0) } function ba(t) { var e = t.keyCode; return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0 } function Do() { return !0 } function Xf() { return !1 } function kt(t) { function e(n, r, i, s, o) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = s, this.target = o, this.currentTarget = null; for (var a in t) t.hasOwnProperty(a) && (n = t[a], this[a] = n ? n(s) : s[a]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Do : Xf, this.isPropagationStopped = Xf, this } return ke(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Do) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Do) }, persist: function () { }, isPersistent: Do }), e } var Ni = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (t) { return t.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, sh = kt(Ni), po = ke({}, Ni, { view: 0, detail: 0 }), ux = kt(po), Pu, Eu, Xi, Tl = ke({}, po, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: oh, button: 0, buttons: 0, relatedTarget: function (t) { return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget }, movementX: function (t) { return "movementX" in t ? t.movementX : (t !== Xi && (Xi && t.type === "mousemove" ? (Pu = t.screenX - Xi.screenX, Eu = t.screenY - Xi.screenY) : Eu = Pu = 0, Xi = t), Pu) }, movementY: function (t) { return "movementY" in t ? t.movementY : Eu } }), Jf = kt(Tl), cx = ke({}, Tl, { dataTransfer: 0 }), dx = kt(cx), hx = ke({}, po, { relatedTarget: 0 }), Tu = kt(hx), fx = ke({}, Ni, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), px = kt(fx), gx = ke({}, Ni, { clipboardData: function (t) { return "clipboardData" in t ? t.clipboardData : window.clipboardData } }), mx = kt(gx), vx = ke({}, Ni, { data: 0 }), Zf = kt(vx), yx = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, bx = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, _x = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function wx(t) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(t) : (t = _x[t]) ? !!e[t] : !1 } function oh() { return wx } var xx = ke({}, po, { key: function (t) { if (t.key) { var e = yx[t.key] || t.key; if (e !== "Unidentified") return e } return t.type === "keypress" ? (t = ba(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? bx[t.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: oh, charCode: function (t) { return t.type === "keypress" ? ba(t) : 0 }, keyCode: function (t) { return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 }, which: function (t) { return t.type === "keypress" ? ba(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 } }), Sx = kt(xx), kx = ke({}, Tl, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), ep = kt(kx), Cx = ke({}, po, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: oh }), Ox = kt(Cx), Px = ke({}, Ni, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Ex = kt(Px), Tx = ke({}, Tl, { deltaX: function (t) { return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0 }, deltaY: function (t) { return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Ix = kt(Tx), Rx = [9, 13, 27, 32], ah = Sn && "CompositionEvent" in window, ws = null; Sn && "documentMode" in document && (ws = document.documentMode); var Mx = Sn && "TextEvent" in window && !ws, ly = Sn && (!ah || ws && 8 < ws && 11 >= ws), tp = " ", np = !1; function uy(t, e) { switch (t) { case "keyup": return Rx.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function cy(t) { return t = t.detail, typeof t == "object" && "data" in t ? t.data : null } var ni = !1; function Lx(t, e) { switch (t) { case "compositionend": return cy(e); case "keypress": return e.which !== 32 ? null : (np = !0, tp); case "textInput": return t = e.data, t === tp && np ? null : t; default: return null } } function Dx(t, e) { if (ni) return t === "compositionend" || !ah && uy(t, e) ? (t = ay(), ya = ih = zn = null, ni = !1, t) : null; switch (t) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return ly && e.locale !== "ko" ? null : e.data; default: return null } } var jx = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function rp(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e === "input" ? !!jx[t.type] : e === "textarea" } function dy(t, e, n, r) { Bv(r), e = Ua(e, "onChange"), 0 < e.length && (n = new sh("onChange", "change", null, n, r), t.push({ event: n, listeners: e })) } var xs = null, Vs = null; function Ax(t) { xy(t, 0) } function Il(t) { var e = si(t); if (jv(e)) return t } function Nx(t, e) { if (t === "change") return e } var hy = !1; if (Sn) { var Iu; if (Sn) { var Ru = "oninput" in document; if (!Ru) { var ip = document.createElement("div"); ip.setAttribute("oninput", "return;"), Ru = typeof ip.oninput == "function" } Iu = Ru } else Iu = !1; hy = Iu && (!document.documentMode || 9 < document.documentMode) } function sp() { xs && (xs.detachEvent("onpropertychange", fy), Vs = xs = null) } function fy(t) { if (t.propertyName === "value" && Il(Vs)) { var e = []; dy(e, Vs, t, Zd(t)), qv(Ax, e) } } function Fx(t, e, n) { t === "focusin" ? (sp(), xs = e, Vs = n, xs.attachEvent("onpropertychange", fy)) : t === "focusout" && sp() } function $x(t) { if (t === "selectionchange" || t === "keyup" || t === "keydown") return Il(Vs) } function zx(t, e) { if (t === "click") return Il(e) } function Vx(t, e) { if (t === "input" || t === "change") return Il(e) } function Bx(t, e) { return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e } var Yt = typeof Object.is == "function" ? Object.is : Bx; function Bs(t, e) { if (Yt(t, e)) return !0; if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1; var n = Object.keys(t), r = Object.keys(e); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!xc.call(e, i) || !Yt(t[i], e[i])) return !1 } return !0 } function op(t) { for (; t && t.firstChild;)t = t.firstChild; return t } function ap(t, e) { var n = op(t); t = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = t + n.textContent.length, t <= e && r >= e) return { node: n, offset: e - t }; t = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = op(n) } } function py(t, e) { return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? py(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1 } function gy() { for (var t = window, e = Aa(); e instanceof t.HTMLIFrameElement;) { try { var n = typeof e.contentWindow.location.href == "string" } catch { n = !1 } if (n) t = e.contentWindow; else break; e = Aa(t.document) } return e } function lh(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true") } function Ux(t) { var e = gy(), n = t.focusedElem, r = t.selectionRange; if (e !== n && n && n.ownerDocument && py(n.ownerDocument.documentElement, n)) { if (r !== null && lh(n)) { if (e = r.start, t = r.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length); else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) { t = t.getSelection(); var i = n.textContent.length, s = Math.min(r.start, i); r = r.end === void 0 ? s : Math.min(r.end, i), !t.extend && s > r && (i = r, r = s, s = i), i = ap(n, s); var o = ap(n, r); i && o && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), t.removeAllRanges(), s > r ? (t.addRange(e), t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), t.addRange(e))) } } for (e = [], t = n; t = t.parentNode;)t.nodeType === 1 && e.push({ element: t, left: t.scrollLeft, top: t.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top } } var Hx = Sn && "documentMode" in document && 11 >= document.documentMode, ri = null, Vc = null, Ss = null, Bc = !1; function lp(t, e, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Bc || ri == null || ri !== Aa(r) || (r = ri, "selectionStart" in r && lh(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), Ss && Bs(Ss, r) || (Ss = r, r = Ua(Vc, "onSelect"), 0 < r.length && (e = new sh("onSelect", "select", null, e, n), t.push({ event: e, listeners: r }), e.target = ri))) } function jo(t, e) { var n = {}; return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n } var ii = { animationend: jo("Animation", "AnimationEnd"), animationiteration: jo("Animation", "AnimationIteration"), animationstart: jo("Animation", "AnimationStart"), transitionend: jo("Transition", "TransitionEnd") }, Mu = {}, my = {}; Sn && (my = document.createElement("div").style, "AnimationEvent" in window || (delete ii.animationend.animation, delete ii.animationiteration.animation, delete ii.animationstart.animation), "TransitionEvent" in window || delete ii.transitionend.transition); function Rl(t) { if (Mu[t]) return Mu[t]; if (!ii[t]) return t; var e = ii[t], n; for (n in e) if (e.hasOwnProperty(n) && n in my) return Mu[t] = e[n]; return t } var vy = Rl("animationend"), yy = Rl("animationiteration"), by = Rl("animationstart"), _y = Rl("transitionend"), wy = new Map, up = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function ar(t, e) { wy.set(t, e), $r(e, [t]) } for (var Lu = 0; Lu < up.length; Lu++) { var Du = up[Lu], Wx = Du.toLowerCase(), qx = Du[0].toUpperCase() + Du.slice(1); ar(Wx, "on" + qx) } ar(vy, "onAnimationEnd"); ar(yy, "onAnimationIteration"); ar(by, "onAnimationStart"); ar("dblclick", "onDoubleClick"); ar("focusin", "onFocus"); ar("focusout", "onBlur"); ar(_y, "onTransitionEnd"); Si("onMouseEnter", ["mouseout", "mouseover"]); Si("onMouseLeave", ["mouseout", "mouseover"]); Si("onPointerEnter", ["pointerout", "pointerover"]); Si("onPointerLeave", ["pointerout", "pointerover"]); $r("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); $r("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); $r("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); $r("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); $r("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); $r("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var fs = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Kx = new Set("cancel close invalid load scroll toggle".split(" ").concat(fs)); function cp(t, e, n) { var r = t.type || "unknown-event"; t.currentTarget = n, Ww(r, e, void 0, t), t.currentTarget = null } function xy(t, e) { e = (e & 4) !== 0; for (var n = 0; n < t.length; n++) { var r = t[n], i = r.event; r = r.listeners; e: { var s = void 0; if (e) for (var o = r.length - 1; 0 <= o; o--) { var a = r[o], l = a.instance, u = a.currentTarget; if (a = a.listener, l !== s && i.isPropagationStopped()) break e; cp(i, a, u), s = l } else for (o = 0; o < r.length; o++) { if (a = r[o], l = a.instance, u = a.currentTarget, a = a.listener, l !== s && i.isPropagationStopped()) break e; cp(i, a, u), s = l } } } if (Fa) throw t = Nc, Fa = !1, Nc = null, t } function ve(t, e) { var n = e[Kc]; n === void 0 && (n = e[Kc] = new Set); var r = t + "__bubble"; n.has(r) || (Sy(e, t, 2, !1), n.add(r)) } function ju(t, e, n) { var r = 0; e && (r |= 4), Sy(n, t, r, e) } var Ao = "_reactListening" + Math.random().toString(36).slice(2); function Us(t) { if (!t[Ao]) { t[Ao] = !0, Iv.forEach(function (n) { n !== "selectionchange" && (Kx.has(n) || ju(n, !1, t), ju(n, !0, t)) }); var e = t.nodeType === 9 ? t : t.ownerDocument; e === null || e[Ao] || (e[Ao] = !0, ju("selectionchange", !1, e)) } } function Sy(t, e, n, r) { switch (oy(e)) { case 1: var i = ax; break; case 4: i = lx; break; default: i = rh }n = i.bind(null, e, n, t), i = void 0, !Ac || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0), r ? i !== void 0 ? t.addEventListener(e, n, { capture: !0, passive: i }) : t.addEventListener(e, n, !0) : i !== void 0 ? t.addEventListener(e, n, { passive: i }) : t.addEventListener(e, n, !1) } function Au(t, e, n, r, i) { var s = r; if (!(e & 1) && !(e & 2) && r !== null) e: for (; ;) { if (r === null) return; var o = r.tag; if (o === 3 || o === 4) { var a = r.stateNode.containerInfo; if (a === i || a.nodeType === 8 && a.parentNode === i) break; if (o === 4) for (o = r.return; o !== null;) { var l = o.tag; if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return; o = o.return } for (; a !== null;) { if (o = kr(a), o === null) return; if (l = o.tag, l === 5 || l === 6) { r = s = o; continue e } a = a.parentNode } } r = r.return } qv(function () { var u = s, c = Zd(n), d = []; e: { var h = wy.get(t); if (h !== void 0) { var f = sh, g = t; switch (t) { case "keypress": if (ba(n) === 0) break e; case "keydown": case "keyup": f = Sx; break; case "focusin": g = "focus", f = Tu; break; case "focusout": g = "blur", f = Tu; break; case "beforeblur": case "afterblur": f = Tu; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": f = Jf; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": f = dx; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": f = Ox; break; case vy: case yy: case by: f = px; break; case _y: f = Ex; break; case "scroll": f = ux; break; case "wheel": f = Ix; break; case "copy": case "cut": case "paste": f = mx; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": f = ep }var m = (e & 4) !== 0, y = !m && t === "scroll", p = m ? h !== null ? h + "Capture" : null : h; m = []; for (var v = u, b; v !== null;) { b = v; var x = b.stateNode; if (b.tag === 5 && x !== null && (b = x, p !== null && (x = Ns(v, p), x != null && m.push(Hs(v, x, b)))), y) break; v = v.return } 0 < m.length && (h = new f(h, g, null, n, c), d.push({ event: h, listeners: m })) } } if (!(e & 7)) { e: { if (h = t === "mouseover" || t === "pointerover", f = t === "mouseout" || t === "pointerout", h && n !== Dc && (g = n.relatedTarget || n.fromElement) && (kr(g) || g[kn])) break e; if ((f || h) && (h = c.window === c ? c : (h = c.ownerDocument) ? h.defaultView || h.parentWindow : window, f ? (g = n.relatedTarget || n.toElement, f = u, g = g ? kr(g) : null, g !== null && (y = zr(g), g !== y || g.tag !== 5 && g.tag !== 6) && (g = null)) : (f = null, g = u), f !== g)) { if (m = Jf, x = "onMouseLeave", p = "onMouseEnter", v = "mouse", (t === "pointerout" || t === "pointerover") && (m = ep, x = "onPointerLeave", p = "onPointerEnter", v = "pointer"), y = f == null ? h : si(f), b = g == null ? h : si(g), h = new m(x, v + "leave", f, n, c), h.target = y, h.relatedTarget = b, x = null, kr(c) === u && (m = new m(p, v + "enter", g, n, c), m.target = b, m.relatedTarget = y, x = m), y = x, f && g) t: { for (m = f, p = g, v = 0, b = m; b; b = Gr(b))v++; for (b = 0, x = p; x; x = Gr(x))b++; for (; 0 < v - b;)m = Gr(m), v--; for (; 0 < b - v;)p = Gr(p), b--; for (; v--;) { if (m === p || p !== null && m === p.alternate) break t; m = Gr(m), p = Gr(p) } m = null } else m = null; f !== null && dp(d, h, f, m, !1), g !== null && y !== null && dp(d, y, g, m, !0) } } e: { if (h = u ? si(u) : window, f = h.nodeName && h.nodeName.toLowerCase(), f === "select" || f === "input" && h.type === "file") var P = Nx; else if (rp(h)) if (hy) P = Vx; else { P = $x; var M = Fx } else (f = h.nodeName) && f.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (P = zx); if (P && (P = P(t, u))) { dy(d, P, n, c); break e } M && M(t, h, u), t === "focusout" && (M = h._wrapperState) && M.controlled && h.type === "number" && Tc(h, "number", h.value) } switch (M = u ? si(u) : window, t) { case "focusin": (rp(M) || M.contentEditable === "true") && (ri = M, Vc = u, Ss = null); break; case "focusout": Ss = Vc = ri = null; break; case "mousedown": Bc = !0; break; case "contextmenu": case "mouseup": case "dragend": Bc = !1, lp(d, n, c); break; case "selectionchange": if (Hx) break; case "keydown": case "keyup": lp(d, n, c) }var I; if (ah) e: { switch (t) { case "compositionstart": var C = "onCompositionStart"; break e; case "compositionend": C = "onCompositionEnd"; break e; case "compositionupdate": C = "onCompositionUpdate"; break e }C = void 0 } else ni ? uy(t, n) && (C = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (C = "onCompositionStart"); C && (ly && n.locale !== "ko" && (ni || C !== "onCompositionStart" ? C === "onCompositionEnd" && ni && (I = ay()) : (zn = c, ih = "value" in zn ? zn.value : zn.textContent, ni = !0)), M = Ua(u, C), 0 < M.length && (C = new Zf(C, t, null, n, c), d.push({ event: C, listeners: M }), I ? C.data = I : (I = cy(n), I !== null && (C.data = I)))), (I = Mx ? Lx(t, n) : Dx(t, n)) && (u = Ua(u, "onBeforeInput"), 0 < u.length && (c = new Zf("onBeforeInput", "beforeinput", null, n, c), d.push({ event: c, listeners: u }), c.data = I)) } xy(d, e) }) } function Hs(t, e, n) { return { instance: t, listener: e, currentTarget: n } } function Ua(t, e) { for (var n = e + "Capture", r = []; t !== null;) { var i = t, s = i.stateNode; i.tag === 5 && s !== null && (i = s, s = Ns(t, n), s != null && r.unshift(Hs(t, s, i)), s = Ns(t, e), s != null && r.push(Hs(t, s, i))), t = t.return } return r } function Gr(t) { if (t === null) return null; do t = t.return; while (t && t.tag !== 5); return t || null } function dp(t, e, n, r, i) { for (var s = e._reactName, o = []; n !== null && n !== r;) { var a = n, l = a.alternate, u = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && u !== null && (a = u, i ? (l = Ns(n, s), l != null && o.unshift(Hs(n, l, a))) : i || (l = Ns(n, s), l != null && o.push(Hs(n, l, a)))), n = n.return } o.length !== 0 && t.push({ event: e, listeners: o }) } var Gx = /\r\n?/g, Yx = /\u0000|\uFFFD/g; function hp(t) {
  return (typeof t == "string" ? t : "" + t).replace(Gx, `
`).replace(Yx, "")
} function No(t, e, n) { if (e = hp(e), hp(t) !== e && n) throw Error(U(425)) } function Ha() { } var Uc = null, Hc = null; function Wc(t, e) { return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var qc = typeof setTimeout == "function" ? setTimeout : void 0, Qx = typeof clearTimeout == "function" ? clearTimeout : void 0, fp = typeof Promise == "function" ? Promise : void 0, Xx = typeof queueMicrotask == "function" ? queueMicrotask : typeof fp < "u" ? function (t) { return fp.resolve(null).then(t).catch(Jx) } : qc; function Jx(t) { setTimeout(function () { throw t }) } function Nu(t, e) { var n = e, r = 0; do { var i = n.nextSibling; if (t.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { t.removeChild(i), zs(e); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); zs(e) } function Qn(t) { for (; t != null; t = t.nextSibling) { var e = t.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = t.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return t } function pp(t) { t = t.previousSibling; for (var e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "$" || n === "$!" || n === "$?") { if (e === 0) return t; e-- } else n === "/$" && e++ } t = t.previousSibling } return null } var Fi = Math.random().toString(36).slice(2), on = "__reactFiber$" + Fi, Ws = "__reactProps$" + Fi, kn = "__reactContainer$" + Fi, Kc = "__reactEvents$" + Fi, Zx = "__reactListeners$" + Fi, eS = "__reactHandles$" + Fi; function kr(t) { var e = t[on]; if (e) return e; for (var n = t.parentNode; n;) { if (e = n[kn] || n[on]) { if (n = e.alternate, e.child !== null || n !== null && n.child !== null) for (t = pp(t); t !== null;) { if (n = t[on]) return n; t = pp(t) } return e } t = n, n = t.parentNode } return null } function go(t) { return t = t[on] || t[kn], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t } function si(t) { if (t.tag === 5 || t.tag === 6) return t.stateNode; throw Error(U(33)) } function Ml(t) { return t[Ws] || null } var Gc = [], oi = -1; function lr(t) { return { current: t } } function ye(t) { 0 > oi || (t.current = Gc[oi], Gc[oi] = null, oi--) } function me(t, e) { oi++, Gc[oi] = t.current, t.current = e } var sr = {}, Ze = lr(sr), dt = lr(!1), Rr = sr; function ki(t, e) { var n = t.type.contextTypes; if (!n) return sr; var r = t.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext; var i = {}, s; for (s in n) i[s] = e[s]; return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i } function ht(t) { return t = t.childContextTypes, t != null } function Wa() { ye(dt), ye(Ze) } function gp(t, e, n) { if (Ze.current !== sr) throw Error(U(168)); me(Ze, e), me(dt, n) } function ky(t, e, n) { var r = t.stateNode; if (e = e.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in e)) throw Error(U(108, Fw(t) || "Unknown", i)); return ke({}, n, r) } function qa(t) { return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || sr, Rr = Ze.current, me(Ze, t), me(dt, dt.current), !0 } function mp(t, e, n) { var r = t.stateNode; if (!r) throw Error(U(169)); n ? (t = ky(t, e, Rr), r.__reactInternalMemoizedMergedChildContext = t, ye(dt), ye(Ze), me(Ze, t)) : ye(dt), me(dt, n) } var vn = null, Ll = !1, Fu = !1; function Cy(t) { vn === null ? vn = [t] : vn.push(t) } function tS(t) { Ll = !0, Cy(t) } function ur() { if (!Fu && vn !== null) { Fu = !0; var t = 0, e = de; try { var n = vn; for (de = 1; t < n.length; t++) { var r = n[t]; do r = r(!0); while (r !== null) } vn = null, Ll = !1 } catch (i) { throw vn !== null && (vn = vn.slice(t + 1)), Qv(eh, ur), i } finally { de = e, Fu = !1 } } return null } var ai = [], li = 0, Ka = null, Ga = 0, Tt = [], It = 0, Mr = null, bn = 1, _n = ""; function br(t, e) { ai[li++] = Ga, ai[li++] = Ka, Ka = t, Ga = e } function Oy(t, e, n) { Tt[It++] = bn, Tt[It++] = _n, Tt[It++] = Mr, Mr = t; var r = bn; t = _n; var i = 32 - Kt(r) - 1; r &= ~(1 << i), n += 1; var s = 32 - Kt(e) + i; if (30 < s) { var o = i - i % 5; s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, bn = 1 << 32 - Kt(e) + i | n << i | r, _n = s + t } else bn = 1 << s | n << i | r, _n = t } function uh(t) { t.return !== null && (br(t, 1), Oy(t, 1, 0)) } function ch(t) { for (; t === Ka;)Ka = ai[--li], ai[li] = null, Ga = ai[--li], ai[li] = null; for (; t === Mr;)Mr = Tt[--It], Tt[It] = null, _n = Tt[--It], Tt[It] = null, bn = Tt[--It], Tt[It] = null } var _t = null, yt = null, be = !1, Wt = null; function Py(t, e) { var n = Mt(5, null, null, 0); n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n) } function vp(t, e) { switch (t.tag) { case 5: var n = t.type; return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, _t = t, yt = Qn(e.firstChild), !0) : !1; case 6: return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, _t = t, yt = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (n = Mr !== null ? { id: bn, overflow: _n } : null, t.memoizedState = { dehydrated: e, treeContext: n, retryLane: 1073741824 }, n = Mt(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, _t = t, yt = null, !0) : !1; default: return !1 } } function Yc(t) { return (t.mode & 1) !== 0 && (t.flags & 128) === 0 } function Qc(t) { if (be) { var e = yt; if (e) { var n = e; if (!vp(t, e)) { if (Yc(t)) throw Error(U(418)); e = Qn(n.nextSibling); var r = _t; e && vp(t, e) ? Py(r, n) : (t.flags = t.flags & -4097 | 2, be = !1, _t = t) } } else { if (Yc(t)) throw Error(U(418)); t.flags = t.flags & -4097 | 2, be = !1, _t = t } } } function yp(t) { for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;)t = t.return; _t = t } function Fo(t) { if (t !== _t) return !1; if (!be) return yp(t), be = !0, !1; var e; if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !Wc(t.type, t.memoizedProps)), e && (e = yt)) { if (Yc(t)) throw Ey(), Error(U(418)); for (; e;)Py(t, e), e = Qn(e.nextSibling) } if (yp(t), t.tag === 13) { if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(U(317)); e: { for (t = t.nextSibling, e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "/$") { if (e === 0) { yt = Qn(t.nextSibling); break e } e-- } else n !== "$" && n !== "$!" && n !== "$?" || e++ } t = t.nextSibling } yt = null } } else yt = _t ? Qn(t.stateNode.nextSibling) : null; return !0 } function Ey() { for (var t = yt; t;)t = Qn(t.nextSibling) } function Ci() { yt = _t = null, be = !1 } function dh(t) { Wt === null ? Wt = [t] : Wt.push(t) } var nS = En.ReactCurrentBatchConfig; function Ji(t, e, n) { if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(U(309)); var r = n.stateNode } if (!r) throw Error(U(147, t)); var i = r, s = "" + t; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function (o) { var a = i.refs; o === null ? delete a[s] : a[s] = o }, e._stringRef = s, e) } if (typeof t != "string") throw Error(U(284)); if (!n._owner) throw Error(U(290, t)) } return t } function $o(t, e) { throw t = Object.prototype.toString.call(e), Error(U(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t)) } function bp(t) { var e = t._init; return e(t._payload) } function Ty(t) { function e(p, v) { if (t) { var b = p.deletions; b === null ? (p.deletions = [v], p.flags |= 16) : b.push(v) } } function n(p, v) { if (!t) return null; for (; v !== null;)e(p, v), v = v.sibling; return null } function r(p, v) { for (p = new Map; v !== null;)v.key !== null ? p.set(v.key, v) : p.set(v.index, v), v = v.sibling; return p } function i(p, v) { return p = er(p, v), p.index = 0, p.sibling = null, p } function s(p, v, b) { return p.index = b, t ? (b = p.alternate, b !== null ? (b = b.index, b < v ? (p.flags |= 2, v) : b) : (p.flags |= 2, v)) : (p.flags |= 1048576, v) } function o(p) { return t && p.alternate === null && (p.flags |= 2), p } function a(p, v, b, x) { return v === null || v.tag !== 6 ? (v = Wu(b, p.mode, x), v.return = p, v) : (v = i(v, b), v.return = p, v) } function l(p, v, b, x) { var P = b.type; return P === ti ? c(p, v, b.props.children, x, b.key) : v !== null && (v.elementType === P || typeof P == "object" && P !== null && P.$$typeof === Dn && bp(P) === v.type) ? (x = i(v, b.props), x.ref = Ji(p, v, b), x.return = p, x) : (x = Oa(b.type, b.key, b.props, null, p.mode, x), x.ref = Ji(p, v, b), x.return = p, x) } function u(p, v, b, x) { return v === null || v.tag !== 4 || v.stateNode.containerInfo !== b.containerInfo || v.stateNode.implementation !== b.implementation ? (v = qu(b, p.mode, x), v.return = p, v) : (v = i(v, b.children || []), v.return = p, v) } function c(p, v, b, x, P) { return v === null || v.tag !== 7 ? (v = Er(b, p.mode, x, P), v.return = p, v) : (v = i(v, b), v.return = p, v) } function d(p, v, b) { if (typeof v == "string" && v !== "" || typeof v == "number") return v = Wu("" + v, p.mode, b), v.return = p, v; if (typeof v == "object" && v !== null) { switch (v.$$typeof) { case Eo: return b = Oa(v.type, v.key, v.props, null, p.mode, b), b.ref = Ji(p, null, v), b.return = p, b; case ei: return v = qu(v, p.mode, b), v.return = p, v; case Dn: var x = v._init; return d(p, x(v._payload), b) }if (ds(v) || Ki(v)) return v = Er(v, p.mode, b, null), v.return = p, v; $o(p, v) } return null } function h(p, v, b, x) { var P = v !== null ? v.key : null; if (typeof b == "string" && b !== "" || typeof b == "number") return P !== null ? null : a(p, v, "" + b, x); if (typeof b == "object" && b !== null) { switch (b.$$typeof) { case Eo: return b.key === P ? l(p, v, b, x) : null; case ei: return b.key === P ? u(p, v, b, x) : null; case Dn: return P = b._init, h(p, v, P(b._payload), x) }if (ds(b) || Ki(b)) return P !== null ? null : c(p, v, b, x, null); $o(p, b) } return null } function f(p, v, b, x, P) { if (typeof x == "string" && x !== "" || typeof x == "number") return p = p.get(b) || null, a(v, p, "" + x, P); if (typeof x == "object" && x !== null) { switch (x.$$typeof) { case Eo: return p = p.get(x.key === null ? b : x.key) || null, l(v, p, x, P); case ei: return p = p.get(x.key === null ? b : x.key) || null, u(v, p, x, P); case Dn: var M = x._init; return f(p, v, b, M(x._payload), P) }if (ds(x) || Ki(x)) return p = p.get(b) || null, c(v, p, x, P, null); $o(v, x) } return null } function g(p, v, b, x) { for (var P = null, M = null, I = v, C = v = 0, T = null; I !== null && C < b.length; C++) { I.index > C ? (T = I, I = null) : T = I.sibling; var L = h(p, I, b[C], x); if (L === null) { I === null && (I = T); break } t && I && L.alternate === null && e(p, I), v = s(L, v, C), M === null ? P = L : M.sibling = L, M = L, I = T } if (C === b.length) return n(p, I), be && br(p, C), P; if (I === null) { for (; C < b.length; C++)I = d(p, b[C], x), I !== null && (v = s(I, v, C), M === null ? P = I : M.sibling = I, M = I); return be && br(p, C), P } for (I = r(p, I); C < b.length; C++)T = f(I, p, C, b[C], x), T !== null && (t && T.alternate !== null && I.delete(T.key === null ? C : T.key), v = s(T, v, C), M === null ? P = T : M.sibling = T, M = T); return t && I.forEach(function (D) { return e(p, D) }), be && br(p, C), P } function m(p, v, b, x) { var P = Ki(b); if (typeof P != "function") throw Error(U(150)); if (b = P.call(b), b == null) throw Error(U(151)); for (var M = P = null, I = v, C = v = 0, T = null, L = b.next(); I !== null && !L.done; C++, L = b.next()) { I.index > C ? (T = I, I = null) : T = I.sibling; var D = h(p, I, L.value, x); if (D === null) { I === null && (I = T); break } t && I && D.alternate === null && e(p, I), v = s(D, v, C), M === null ? P = D : M.sibling = D, M = D, I = T } if (L.done) return n(p, I), be && br(p, C), P; if (I === null) { for (; !L.done; C++, L = b.next())L = d(p, L.value, x), L !== null && (v = s(L, v, C), M === null ? P = L : M.sibling = L, M = L); return be && br(p, C), P } for (I = r(p, I); !L.done; C++, L = b.next())L = f(I, p, C, L.value, x), L !== null && (t && L.alternate !== null && I.delete(L.key === null ? C : L.key), v = s(L, v, C), M === null ? P = L : M.sibling = L, M = L); return t && I.forEach(function (N) { return e(p, N) }), be && br(p, C), P } function y(p, v, b, x) { if (typeof b == "object" && b !== null && b.type === ti && b.key === null && (b = b.props.children), typeof b == "object" && b !== null) { switch (b.$$typeof) { case Eo: e: { for (var P = b.key, M = v; M !== null;) { if (M.key === P) { if (P = b.type, P === ti) { if (M.tag === 7) { n(p, M.sibling), v = i(M, b.props.children), v.return = p, p = v; break e } } else if (M.elementType === P || typeof P == "object" && P !== null && P.$$typeof === Dn && bp(P) === M.type) { n(p, M.sibling), v = i(M, b.props), v.ref = Ji(p, M, b), v.return = p, p = v; break e } n(p, M); break } else e(p, M); M = M.sibling } b.type === ti ? (v = Er(b.props.children, p.mode, x, b.key), v.return = p, p = v) : (x = Oa(b.type, b.key, b.props, null, p.mode, x), x.ref = Ji(p, v, b), x.return = p, p = x) } return o(p); case ei: e: { for (M = b.key; v !== null;) { if (v.key === M) if (v.tag === 4 && v.stateNode.containerInfo === b.containerInfo && v.stateNode.implementation === b.implementation) { n(p, v.sibling), v = i(v, b.children || []), v.return = p, p = v; break e } else { n(p, v); break } else e(p, v); v = v.sibling } v = qu(b, p.mode, x), v.return = p, p = v } return o(p); case Dn: return M = b._init, y(p, v, M(b._payload), x) }if (ds(b)) return g(p, v, b, x); if (Ki(b)) return m(p, v, b, x); $o(p, b) } return typeof b == "string" && b !== "" || typeof b == "number" ? (b = "" + b, v !== null && v.tag === 6 ? (n(p, v.sibling), v = i(v, b), v.return = p, p = v) : (n(p, v), v = Wu(b, p.mode, x), v.return = p, p = v), o(p)) : n(p, v) } return y } var Oi = Ty(!0), Iy = Ty(!1), Ya = lr(null), Qa = null, ui = null, hh = null; function fh() { hh = ui = Qa = null } function ph(t) { var e = Ya.current; ye(Ya), t._currentValue = e } function Xc(t, e, n) { for (; t !== null;) { var r = t.alternate; if ((t.childLanes & e) !== e ? (t.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), t === n) break; t = t.return } } function yi(t, e) { Qa = t, hh = ui = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (ct = !0), t.firstContext = null) } function Nt(t) { var e = t._currentValue; if (hh !== t) if (t = { context: t, memoizedValue: e, next: null }, ui === null) { if (Qa === null) throw Error(U(308)); ui = t, Qa.dependencies = { lanes: 0, firstContext: t } } else ui = ui.next = t; return e } var Cr = null; function gh(t) { Cr === null ? Cr = [t] : Cr.push(t) } function Ry(t, e, n, r) { var i = e.interleaved; return i === null ? (n.next = n, gh(e)) : (n.next = i.next, i.next = n), e.interleaved = n, Cn(t, r) } function Cn(t, e) { t.lanes |= e; var n = t.alternate; for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;)t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return; return n.tag === 3 ? n.stateNode : null } var jn = !1; function mh(t) { t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function My(t, e) { t = t.updateQueue, e.updateQueue === t && (e.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects }) } function wn(t, e) { return { eventTime: t, lane: e, tag: 0, payload: null, callback: null, next: null } } function Xn(t, e, n) { var r = t.updateQueue; if (r === null) return null; if (r = r.shared, ie & 2) { var i = r.pending; return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, Cn(t, n) } return i = r.interleaved, i === null ? (e.next = e, gh(r)) : (e.next = i.next, i.next = e), r.interleaved = e, Cn(t, n) } function _a(t, e, n) { if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) { var r = e.lanes; r &= t.pendingLanes, n |= r, e.lanes = n, th(t, n) } } function _p(t, e) { var n = t.updateQueue, r = t.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var i = null, s = null; if (n = n.firstBaseUpdate, n !== null) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; s === null ? i = s = o : s = s.next = o, n = n.next } while (n !== null); s === null ? i = s = e : s = s.next = e } else i = s = e; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: s, shared: r.shared, effects: r.effects }, t.updateQueue = n; return } t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e } function Xa(t, e, n, r) { var i = t.updateQueue; jn = !1; var s = i.firstBaseUpdate, o = i.lastBaseUpdate, a = i.shared.pending; if (a !== null) { i.shared.pending = null; var l = a, u = l.next; l.next = null, o === null ? s = u : o.next = u, o = l; var c = t.alternate; c !== null && (c = c.updateQueue, a = c.lastBaseUpdate, a !== o && (a === null ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l)) } if (s !== null) { var d = i.baseState; o = 0, c = u = l = null, a = s; do { var h = a.lane, f = a.eventTime; if ((r & h) === h) { c !== null && (c = c.next = { eventTime: f, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var g = t, m = a; switch (h = e, f = n, m.tag) { case 1: if (g = m.payload, typeof g == "function") { d = g.call(f, d, h); break e } d = g; break e; case 3: g.flags = g.flags & -65537 | 128; case 0: if (g = m.payload, h = typeof g == "function" ? g.call(f, d, h) : g, h == null) break e; d = ke({}, d, h); break e; case 2: jn = !0 } } a.callback !== null && a.lane !== 0 && (t.flags |= 64, h = i.effects, h === null ? i.effects = [a] : h.push(a)) } else f = { eventTime: f, lane: h, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, c === null ? (u = c = f, l = d) : c = c.next = f, o |= h; if (a = a.next, a === null) { if (a = i.shared.pending, a === null) break; h = a, a = h.next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null } } while (!0); if (c === null && (l = d), i.baseState = l, i.firstBaseUpdate = u, i.lastBaseUpdate = c, e = i.shared.interleaved, e !== null) { i = e; do o |= i.lane, i = i.next; while (i !== e) } else s === null && (i.shared.lanes = 0); Dr |= o, t.lanes = o, t.memoizedState = d } } function wp(t, e, n) { if (t = e.effects, e.effects = null, t !== null) for (e = 0; e < t.length; e++) { var r = t[e], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(U(191, i)); i.call(r) } } } var mo = {}, ln = lr(mo), qs = lr(mo), Ks = lr(mo); function Or(t) { if (t === mo) throw Error(U(174)); return t } function vh(t, e) { switch (me(Ks, e), me(qs, t), me(ln, mo), t = e.nodeType, t) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : Rc(null, ""); break; default: t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = Rc(e, t) }ye(ln), me(ln, e) } function Pi() { ye(ln), ye(qs), ye(Ks) } function Ly(t) { Or(Ks.current); var e = Or(ln.current), n = Rc(e, t.type); e !== n && (me(qs, t), me(ln, n)) } function yh(t) { qs.current === t && (ye(ln), ye(qs)) } var _e = lr(0); function Ja(t) { for (var e = t; e !== null;) { if (e.tag === 13) { var n = e.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var $u = []; function bh() { for (var t = 0; t < $u.length; t++)$u[t]._workInProgressVersionPrimary = null; $u.length = 0 } var wa = En.ReactCurrentDispatcher, zu = En.ReactCurrentBatchConfig, Lr = 0, Se = null, Le = null, Ae = null, Za = !1, ks = !1, Gs = 0, rS = 0; function Ke() { throw Error(U(321)) } function _h(t, e) { if (e === null) return !1; for (var n = 0; n < e.length && n < t.length; n++)if (!Yt(t[n], e[n])) return !1; return !0 } function wh(t, e, n, r, i, s) { if (Lr = s, Se = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, wa.current = t === null || t.memoizedState === null ? aS : lS, t = n(r, i), ks) { s = 0; do { if (ks = !1, Gs = 0, 25 <= s) throw Error(U(301)); s += 1, Ae = Le = null, e.updateQueue = null, wa.current = uS, t = n(r, i) } while (ks) } if (wa.current = el, e = Le !== null && Le.next !== null, Lr = 0, Ae = Le = Se = null, Za = !1, e) throw Error(U(300)); return t } function xh() { var t = Gs !== 0; return Gs = 0, t } function en() { var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ae === null ? Se.memoizedState = Ae = t : Ae = Ae.next = t, Ae } function Ft() { if (Le === null) { var t = Se.alternate; t = t !== null ? t.memoizedState : null } else t = Le.next; var e = Ae === null ? Se.memoizedState : Ae.next; if (e !== null) Ae = e, Le = t; else { if (t === null) throw Error(U(310)); Le = t, t = { memoizedState: Le.memoizedState, baseState: Le.baseState, baseQueue: Le.baseQueue, queue: Le.queue, next: null }, Ae === null ? Se.memoizedState = Ae = t : Ae = Ae.next = t } return Ae } function Ys(t, e) { return typeof e == "function" ? e(t) : e } function Vu(t) { var e = Ft(), n = e.queue; if (n === null) throw Error(U(311)); n.lastRenderedReducer = t; var r = Le, i = r.baseQueue, s = n.pending; if (s !== null) { if (i !== null) { var o = i.next; i.next = s.next, s.next = o } r.baseQueue = i = s, n.pending = null } if (i !== null) { s = i.next, r = r.baseState; var a = o = null, l = null, u = s; do { var c = u.lane; if ((Lr & c) === c) l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : t(r, u.action); else { var d = { lane: c, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; l === null ? (a = l = d, o = r) : l = l.next = d, Se.lanes |= c, Dr |= c } u = u.next } while (u !== null && u !== s); l === null ? o = r : l.next = a, Yt(r, e.memoizedState) || (ct = !0), e.memoizedState = r, e.baseState = o, e.baseQueue = l, n.lastRenderedState = r } if (t = n.interleaved, t !== null) { i = t; do s = i.lane, Se.lanes |= s, Dr |= s, i = i.next; while (i !== t) } else i === null && (n.lanes = 0); return [e.memoizedState, n.dispatch] } function Bu(t) { var e = Ft(), n = e.queue; if (n === null) throw Error(U(311)); n.lastRenderedReducer = t; var r = n.dispatch, i = n.pending, s = e.memoizedState; if (i !== null) { n.pending = null; var o = i = i.next; do s = t(s, o.action), o = o.next; while (o !== i); Yt(s, e.memoizedState) || (ct = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), n.lastRenderedState = s } return [s, r] } function Dy() { } function jy(t, e) { var n = Se, r = Ft(), i = e(), s = !Yt(r.memoizedState, i); if (s && (r.memoizedState = i, ct = !0), r = r.queue, Sh(Fy.bind(null, n, r, t), [t]), r.getSnapshot !== e || s || Ae !== null && Ae.memoizedState.tag & 1) { if (n.flags |= 2048, Qs(9, Ny.bind(null, n, r, i, e), void 0, null), Fe === null) throw Error(U(349)); Lr & 30 || Ay(n, e, i) } return i } function Ay(t, e, n) { t.flags |= 16384, t = { getSnapshot: e, value: n }, e = Se.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Se.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t)) } function Ny(t, e, n, r) { e.value = n, e.getSnapshot = r, $y(e) && zy(t) } function Fy(t, e, n) { return n(function () { $y(e) && zy(t) }) } function $y(t) { var e = t.getSnapshot; t = t.value; try { var n = e(); return !Yt(t, n) } catch { return !0 } } function zy(t) { var e = Cn(t, 1); e !== null && Gt(e, t, 1, -1) } function xp(t) { var e = en(); return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ys, lastRenderedState: t }, e.queue = t, t = t.dispatch = oS.bind(null, Se, t), [e.memoizedState, t] } function Qs(t, e, n, r) { return t = { tag: t, create: e, destroy: n, deps: r, next: null }, e = Se.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Se.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t)), t } function Vy() { return Ft().memoizedState } function xa(t, e, n, r) { var i = en(); Se.flags |= t, i.memoizedState = Qs(1 | e, n, void 0, r === void 0 ? null : r) } function Dl(t, e, n, r) { var i = Ft(); r = r === void 0 ? null : r; var s = void 0; if (Le !== null) { var o = Le.memoizedState; if (s = o.destroy, r !== null && _h(r, o.deps)) { i.memoizedState = Qs(e, n, s, r); return } } Se.flags |= t, i.memoizedState = Qs(1 | e, n, s, r) } function Sp(t, e) { return xa(8390656, 8, t, e) } function Sh(t, e) { return Dl(2048, 8, t, e) } function By(t, e) { return Dl(4, 2, t, e) } function Uy(t, e) { return Dl(4, 4, t, e) } function Hy(t, e) { if (typeof e == "function") return t = t(), e(t), function () { e(null) }; if (e != null) return t = t(), e.current = t, function () { e.current = null } } function Wy(t, e, n) { return n = n != null ? n.concat([t]) : null, Dl(4, 4, Hy.bind(null, e, t), n) } function kh() { } function qy(t, e) { var n = Ft(); e = e === void 0 ? null : e; var r = n.memoizedState; return r !== null && e !== null && _h(e, r[1]) ? r[0] : (n.memoizedState = [t, e], t) } function Ky(t, e) { var n = Ft(); e = e === void 0 ? null : e; var r = n.memoizedState; return r !== null && e !== null && _h(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [t, e], t) } function Gy(t, e, n) { return Lr & 21 ? (Yt(n, e) || (n = Zv(), Se.lanes |= n, Dr |= n, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, ct = !0), t.memoizedState = n) } function iS(t, e) { var n = de; de = n !== 0 && 4 > n ? n : 4, t(!0); var r = zu.transition; zu.transition = {}; try { t(!1), e() } finally { de = n, zu.transition = r } } function Yy() { return Ft().memoizedState } function sS(t, e, n) { var r = Zn(t); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, Qy(t)) Xy(e, n); else if (n = Ry(t, e, n, r), n !== null) { var i = rt(); Gt(n, t, r, i), Jy(n, e, r) } } function oS(t, e, n) { var r = Zn(t), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Qy(t)) Xy(e, i); else { var s = t.alternate; if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try { var o = e.lastRenderedState, a = s(o, n); if (i.hasEagerState = !0, i.eagerState = a, Yt(a, o)) { var l = e.interleaved; l === null ? (i.next = i, gh(e)) : (i.next = l.next, l.next = i), e.interleaved = i; return } } catch { } finally { } n = Ry(t, e, i, r), n !== null && (i = rt(), Gt(n, t, r, i), Jy(n, e, r)) } } function Qy(t) { var e = t.alternate; return t === Se || e !== null && e === Se } function Xy(t, e) { ks = Za = !0; var n = t.pending; n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e } function Jy(t, e, n) { if (n & 4194240) { var r = e.lanes; r &= t.pendingLanes, n |= r, e.lanes = n, th(t, n) } } var el = { readContext: Nt, useCallback: Ke, useContext: Ke, useEffect: Ke, useImperativeHandle: Ke, useInsertionEffect: Ke, useLayoutEffect: Ke, useMemo: Ke, useReducer: Ke, useRef: Ke, useState: Ke, useDebugValue: Ke, useDeferredValue: Ke, useTransition: Ke, useMutableSource: Ke, useSyncExternalStore: Ke, useId: Ke, unstable_isNewReconciler: !1 }, aS = { readContext: Nt, useCallback: function (t, e) { return en().memoizedState = [t, e === void 0 ? null : e], t }, useContext: Nt, useEffect: Sp, useImperativeHandle: function (t, e, n) { return n = n != null ? n.concat([t]) : null, xa(4194308, 4, Hy.bind(null, e, t), n) }, useLayoutEffect: function (t, e) { return xa(4194308, 4, t, e) }, useInsertionEffect: function (t, e) { return xa(4, 2, t, e) }, useMemo: function (t, e) { var n = en(); return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t }, useReducer: function (t, e, n) { var r = en(); return e = n !== void 0 ? n(e) : e, r.memoizedState = r.baseState = e, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: e }, r.queue = t, t = t.dispatch = sS.bind(null, Se, t), [r.memoizedState, t] }, useRef: function (t) { var e = en(); return t = { current: t }, e.memoizedState = t }, useState: xp, useDebugValue: kh, useDeferredValue: function (t) { return en().memoizedState = t }, useTransition: function () { var t = xp(!1), e = t[0]; return t = iS.bind(null, t[1]), en().memoizedState = t, [e, t] }, useMutableSource: function () { }, useSyncExternalStore: function (t, e, n) { var r = Se, i = en(); if (be) { if (n === void 0) throw Error(U(407)); n = n() } else { if (n = e(), Fe === null) throw Error(U(349)); Lr & 30 || Ay(r, e, n) } i.memoizedState = n; var s = { value: n, getSnapshot: e }; return i.queue = s, Sp(Fy.bind(null, r, s, t), [t]), r.flags |= 2048, Qs(9, Ny.bind(null, r, s, n, e), void 0, null), n }, useId: function () { var t = en(), e = Fe.identifierPrefix; if (be) { var n = _n, r = bn; n = (r & ~(1 << 32 - Kt(r) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = Gs++, 0 < n && (e += "H" + n.toString(32)), e += ":" } else n = rS++, e = ":" + e + "r" + n.toString(32) + ":"; return t.memoizedState = e }, unstable_isNewReconciler: !1 }, lS = { readContext: Nt, useCallback: qy, useContext: Nt, useEffect: Sh, useImperativeHandle: Wy, useInsertionEffect: By, useLayoutEffect: Uy, useMemo: Ky, useReducer: Vu, useRef: Vy, useState: function () { return Vu(Ys) }, useDebugValue: kh, useDeferredValue: function (t) { var e = Ft(); return Gy(e, Le.memoizedState, t) }, useTransition: function () { var t = Vu(Ys)[0], e = Ft().memoizedState; return [t, e] }, useMutableSource: Dy, useSyncExternalStore: jy, useId: Yy, unstable_isNewReconciler: !1 }, uS = { readContext: Nt, useCallback: qy, useContext: Nt, useEffect: Sh, useImperativeHandle: Wy, useInsertionEffect: By, useLayoutEffect: Uy, useMemo: Ky, useReducer: Bu, useRef: Vy, useState: function () { return Bu(Ys) }, useDebugValue: kh, useDeferredValue: function (t) { var e = Ft(); return Le === null ? e.memoizedState = t : Gy(e, Le.memoizedState, t) }, useTransition: function () { var t = Bu(Ys)[0], e = Ft().memoizedState; return [t, e] }, useMutableSource: Dy, useSyncExternalStore: jy, useId: Yy, unstable_isNewReconciler: !1 }; function Bt(t, e) { if (t && t.defaultProps) { e = ke({}, e), t = t.defaultProps; for (var n in t) e[n] === void 0 && (e[n] = t[n]); return e } return e } function Jc(t, e, n, r) { e = t.memoizedState, n = n(r, e), n = n == null ? e : ke({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n) } var jl = { isMounted: function (t) { return (t = t._reactInternals) ? zr(t) === t : !1 }, enqueueSetState: function (t, e, n) { t = t._reactInternals; var r = rt(), i = Zn(t), s = wn(r, i); s.payload = e, n != null && (s.callback = n), e = Xn(t, s, i), e !== null && (Gt(e, t, i, r), _a(e, t, i)) }, enqueueReplaceState: function (t, e, n) { t = t._reactInternals; var r = rt(), i = Zn(t), s = wn(r, i); s.tag = 1, s.payload = e, n != null && (s.callback = n), e = Xn(t, s, i), e !== null && (Gt(e, t, i, r), _a(e, t, i)) }, enqueueForceUpdate: function (t, e) { t = t._reactInternals; var n = rt(), r = Zn(t), i = wn(n, r); i.tag = 2, e != null && (i.callback = e), e = Xn(t, i, r), e !== null && (Gt(e, t, r, n), _a(e, t, r)) } }; function kp(t, e, n, r, i, s, o) { return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Bs(n, r) || !Bs(i, s) : !0 } function Zy(t, e, n) { var r = !1, i = sr, s = e.contextType; return typeof s == "object" && s !== null ? s = Nt(s) : (i = ht(e) ? Rr : Ze.current, r = e.contextTypes, s = (r = r != null) ? ki(t, i) : sr), e = new e(n, s), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = jl, t.stateNode = e, e._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = s), e } function Cp(t, e, n, r) { t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && jl.enqueueReplaceState(e, e.state, null) } function Zc(t, e, n, r) { var i = t.stateNode; i.props = n, i.state = t.memoizedState, i.refs = {}, mh(t); var s = e.contextType; typeof s == "object" && s !== null ? i.context = Nt(s) : (s = ht(e) ? Rr : Ze.current, i.context = ki(t, s)), i.state = t.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (Jc(t, e, s, n), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && jl.enqueueReplaceState(i, i.state, null), Xa(t, n, i, r), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308) } function Ei(t, e) {
  try { var n = "", r = e; do n += Nw(r), r = r.return; while (r); var i = n } catch (s) {
    i = `
Error generating stack: `+ s.message + `
`+ s.stack
  } return { value: t, source: e, stack: i, digest: null }
} function Uu(t, e, n) { return { value: t, source: null, stack: n ?? null, digest: e ?? null } } function ed(t, e) { try { console.error(e.value) } catch (n) { setTimeout(function () { throw n }) } } var cS = typeof WeakMap == "function" ? WeakMap : Map; function e0(t, e, n) { n = wn(-1, n), n.tag = 3, n.payload = { element: null }; var r = e.value; return n.callback = function () { nl || (nl = !0, cd = r), ed(t, e) }, n } function t0(t, e, n) { n = wn(-1, n), n.tag = 3; var r = t.type.getDerivedStateFromError; if (typeof r == "function") { var i = e.value; n.payload = function () { return r(i) }, n.callback = function () { ed(t, e) } } var s = t.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function () { ed(t, e), typeof r != "function" && (Jn === null ? Jn = new Set([this]) : Jn.add(this)); var o = e.stack; this.componentDidCatch(e.value, { componentStack: o !== null ? o : "" }) }), n } function Op(t, e, n) { var r = t.pingCache; if (r === null) { r = t.pingCache = new cS; var i = new Set; r.set(e, i) } else i = r.get(e), i === void 0 && (i = new Set, r.set(e, i)); i.has(n) || (i.add(n), t = kS.bind(null, t, e, n), e.then(t, t)) } function Pp(t) { do { var e; if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t; t = t.return } while (t !== null); return null } function Ep(t, e, n, r, i) { return t.mode & 1 ? (t.flags |= 65536, t.lanes = i, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = wn(-1, 1), e.tag = 2, Xn(n, e, 1))), n.lanes |= 1), t) } var dS = En.ReactCurrentOwner, ct = !1; function nt(t, e, n, r) { e.child = t === null ? Iy(e, null, n, r) : Oi(e, t.child, n, r) } function Tp(t, e, n, r, i) { n = n.render; var s = e.ref; return yi(e, i), r = wh(t, e, n, r, s, i), n = xh(), t !== null && !ct ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, On(t, e, i)) : (be && n && uh(e), e.flags |= 1, nt(t, e, r, i), e.child) } function Ip(t, e, n, r, i) { if (t === null) { var s = n.type; return typeof s == "function" && !Mh(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = s, n0(t, e, s, r, i)) : (t = Oa(n.type, null, r, e, e.mode, i), t.ref = e.ref, t.return = e, e.child = t) } if (s = t.child, !(t.lanes & i)) { var o = s.memoizedProps; if (n = n.compare, n = n !== null ? n : Bs, n(o, r) && t.ref === e.ref) return On(t, e, i) } return e.flags |= 1, t = er(s, r), t.ref = e.ref, t.return = e, e.child = t } function n0(t, e, n, r, i) { if (t !== null) { var s = t.memoizedProps; if (Bs(s, r) && t.ref === e.ref) if (ct = !1, e.pendingProps = r = s, (t.lanes & i) !== 0) t.flags & 131072 && (ct = !0); else return e.lanes = t.lanes, On(t, e, i) } return td(t, e, n, r, i) } function r0(t, e, n) { var r = e.pendingProps, i = r.children, s = t !== null ? t.memoizedState : null; if (r.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, me(di, vt), vt |= n; else { if (!(n & 1073741824)) return t = s !== null ? s.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, e.updateQueue = null, me(di, vt), vt |= t, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = s !== null ? s.baseLanes : n, me(di, vt), vt |= r } else s !== null ? (r = s.baseLanes | n, e.memoizedState = null) : r = n, me(di, vt), vt |= r; return nt(t, e, i, n), e.child } function i0(t, e) { var n = e.ref; (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152) } function td(t, e, n, r, i) { var s = ht(n) ? Rr : Ze.current; return s = ki(e, s), yi(e, i), n = wh(t, e, n, r, s, i), r = xh(), t !== null && !ct ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, On(t, e, i)) : (be && r && uh(e), e.flags |= 1, nt(t, e, n, i), e.child) } function Rp(t, e, n, r, i) { if (ht(n)) { var s = !0; qa(e) } else s = !1; if (yi(e, i), e.stateNode === null) Sa(t, e), Zy(e, n, r), Zc(e, n, r, i), r = !0; else if (t === null) { var o = e.stateNode, a = e.memoizedProps; o.props = a; var l = o.context, u = n.contextType; typeof u == "object" && u !== null ? u = Nt(u) : (u = ht(n) ? Rr : Ze.current, u = ki(e, u)); var c = n.getDerivedStateFromProps, d = typeof c == "function" || typeof o.getSnapshotBeforeUpdate == "function"; d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== u) && Cp(e, o, r, u), jn = !1; var h = e.memoizedState; o.state = h, Xa(e, r, o, i), l = e.memoizedState, a !== r || h !== l || dt.current || jn ? (typeof c == "function" && (Jc(e, n, c, r), l = e.memoizedState), (a = jn || kp(e, n, a, r, h, l, u)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = l), o.props = r, o.state = l, o.context = u, r = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), r = !1) } else { o = e.stateNode, My(t, e), a = e.memoizedProps, u = e.type === e.elementType ? a : Bt(e.type, a), o.props = u, d = e.pendingProps, h = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = Nt(l) : (l = ht(n) ? Rr : Ze.current, l = ki(e, l)); var f = n.getDerivedStateFromProps; (c = typeof f == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || h !== l) && Cp(e, o, r, l), jn = !1, h = e.memoizedState, o.state = h, Xa(e, r, o, i); var g = e.memoizedState; a !== d || h !== g || dt.current || jn ? (typeof f == "function" && (Jc(e, n, f, r), g = e.memoizedState), (u = jn || kp(e, n, u, r, h, g, l) || !1) ? (c || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, g, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, g, l)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = g), o.props = r, o.state = g, o.context = l, r = u) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 1024), r = !1) } return nd(t, e, n, r, s, i) } function nd(t, e, n, r, i, s) { i0(t, e); var o = (e.flags & 128) !== 0; if (!r && !o) return i && mp(e, n, !1), On(t, e, s); r = e.stateNode, dS.current = e; var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return e.flags |= 1, t !== null && o ? (e.child = Oi(e, t.child, null, s), e.child = Oi(e, null, a, s)) : nt(t, e, a, s), e.memoizedState = r.state, i && mp(e, n, !0), e.child } function s0(t) { var e = t.stateNode; e.pendingContext ? gp(t, e.pendingContext, e.pendingContext !== e.context) : e.context && gp(t, e.context, !1), vh(t, e.containerInfo) } function Mp(t, e, n, r, i) { return Ci(), dh(i), e.flags |= 256, nt(t, e, n, r), e.child } var rd = { dehydrated: null, treeContext: null, retryLane: 0 }; function id(t) { return { baseLanes: t, cachePool: null, transitions: null } } function o0(t, e, n) { var r = e.pendingProps, i = _e.current, s = !1, o = (e.flags & 128) !== 0, a; if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1), me(_e, i & 1), t === null) return Qc(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = r.children, t = r.fallback, s ? (r = e.mode, s = e.child, o = { mode: "hidden", children: o }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = Fl(o, r, 0, null), t = Er(t, r, n, null), s.return = e, t.return = e, s.sibling = t, e.child = s, e.child.memoizedState = id(n), e.memoizedState = rd, t) : Ch(e, o)); if (i = t.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return hS(t, e, o, r, a, i, n); if (s) { s = r.fallback, o = e.mode, i = t.child, a = i.sibling; var l = { mode: "hidden", children: r.children }; return !(o & 1) && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = l, e.deletions = null) : (r = er(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? s = er(a, s) : (s = Er(s, o, n, null), s.flags |= 2), s.return = e, r.return = e, r.sibling = s, e.child = r, r = s, s = e.child, o = t.child.memoizedState, o = o === null ? id(n) : { baseLanes: o.baseLanes | n, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = t.childLanes & ~n, e.memoizedState = rd, r } return s = t.child, t = s.sibling, r = er(s, { mode: "visible", children: r.children }), !(e.mode & 1) && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = r, e.memoizedState = null, r } function Ch(t, e) { return e = Fl({ mode: "visible", children: e }, t.mode, 0, null), e.return = t, t.child = e } function zo(t, e, n, r) { return r !== null && dh(r), Oi(e, t.child, null, n), t = Ch(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t } function hS(t, e, n, r, i, s, o) { if (n) return e.flags & 256 ? (e.flags &= -257, r = Uu(Error(U(422))), zo(t, e, o, r)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (s = r.fallback, i = e.mode, r = Fl({ mode: "visible", children: r.children }, i, 0, null), s = Er(s, i, o, null), s.flags |= 2, r.return = e, s.return = e, r.sibling = s, e.child = r, e.mode & 1 && Oi(e, t.child, null, o), e.child.memoizedState = id(o), e.memoizedState = rd, s); if (!(e.mode & 1)) return zo(t, e, o, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst; return r = a, s = Error(U(419)), r = Uu(s, r, void 0), zo(t, e, o, r) } if (a = (o & t.childLanes) !== 0, ct || a) { if (r = Fe, r !== null) { switch (o & -o) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, Cn(t, i), Gt(r, t, i, -1)) } return Rh(), r = Uu(Error(U(421))), zo(t, e, o, r) } return i.data === "$?" ? (e.flags |= 128, e.child = t.child, e = CS.bind(null, t), i._reactRetry = e, null) : (t = s.treeContext, yt = Qn(i.nextSibling), _t = e, be = !0, Wt = null, t !== null && (Tt[It++] = bn, Tt[It++] = _n, Tt[It++] = Mr, bn = t.id, _n = t.overflow, Mr = e), e = Ch(e, r.children), e.flags |= 4096, e) } function Lp(t, e, n) { t.lanes |= e; var r = t.alternate; r !== null && (r.lanes |= e), Xc(t.return, e, n) } function Hu(t, e, n, r, i) { var s = t.memoizedState; s === null ? t.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i) } function a0(t, e, n) { var r = e.pendingProps, i = r.revealOrder, s = r.tail; if (nt(t, e, r.children, n), r = _e.current, r & 2) r = r & 1 | 2, e.flags |= 128; else { if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) { if (t.tag === 13) t.memoizedState !== null && Lp(t, n, e); else if (t.tag === 19) Lp(t, n, e); else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break e; for (; t.sibling === null;) { if (t.return === null || t.return === e) break e; t = t.return } t.sibling.return = t.return, t = t.sibling } r &= 1 } if (me(_e, r), !(e.mode & 1)) e.memoizedState = null; else switch (i) { case "forwards": for (n = e.child, i = null; n !== null;)t = n.alternate, t !== null && Ja(t) === null && (i = n), n = n.sibling; n = i, n === null ? (i = e.child, e.child = null) : (i = n.sibling, n.sibling = null), Hu(e, !1, i, n, s); break; case "backwards": for (n = null, i = e.child, e.child = null; i !== null;) { if (t = i.alternate, t !== null && Ja(t) === null) { e.child = i; break } t = i.sibling, i.sibling = n, n = i, i = t } Hu(e, !0, n, null, s); break; case "together": Hu(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function Sa(t, e) { !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2) } function On(t, e, n) { if (t !== null && (e.dependencies = t.dependencies), Dr |= e.lanes, !(n & e.childLanes)) return null; if (t !== null && e.child !== t.child) throw Error(U(153)); if (e.child !== null) { for (t = e.child, n = er(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;)t = t.sibling, n = n.sibling = er(t, t.pendingProps), n.return = e; n.sibling = null } return e.child } function fS(t, e, n) { switch (e.tag) { case 3: s0(e), Ci(); break; case 5: Ly(e); break; case 1: ht(e.type) && qa(e); break; case 4: vh(e, e.stateNode.containerInfo); break; case 10: var r = e.type._context, i = e.memoizedProps.value; me(Ya, r._currentValue), r._currentValue = i; break; case 13: if (r = e.memoizedState, r !== null) return r.dehydrated !== null ? (me(_e, _e.current & 1), e.flags |= 128, null) : n & e.child.childLanes ? o0(t, e, n) : (me(_e, _e.current & 1), t = On(t, e, n), t !== null ? t.sibling : null); me(_e, _e.current & 1); break; case 19: if (r = (n & e.childLanes) !== 0, t.flags & 128) { if (r) return a0(t, e, n); e.flags |= 128 } if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), me(_e, _e.current), r) break; return null; case 22: case 23: return e.lanes = 0, r0(t, e, n) }return On(t, e, n) } var l0, sd, u0, c0; l0 = function (t, e) { for (var n = e.child; n !== null;) { if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; sd = function () { }; u0 = function (t, e, n, r) { var i = t.memoizedProps; if (i !== r) { t = e.stateNode, Or(ln.current); var s = null; switch (n) { case "input": i = Pc(t, i), r = Pc(t, r), s = []; break; case "select": i = ke({}, i, { value: void 0 }), r = ke({}, r, { value: void 0 }), s = []; break; case "textarea": i = Ic(t, i), r = Ic(t, r), s = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = Ha) }Mc(n, r); var o; n = null; for (u in i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null) if (u === "style") { var a = i[u]; for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (js.hasOwnProperty(u) ? s || (s = []) : (s = s || []).push(u, null)); for (u in r) { var l = r[u]; if (a = i != null ? i[u] : void 0, r.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === "style") if (a) { for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o]) } else n || (s || (s = []), s.push(u, n)), n = l; else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (js.hasOwnProperty(u) ? (l != null && u === "onScroll" && ve("scroll", t), s || a === l || (s = [])) : (s = s || []).push(u, l)) } n && (s = s || []).push("style", n); var u = s; (e.updateQueue = u) && (e.flags |= 4) } }; c0 = function (t, e, n, r) { n !== r && (e.flags |= 4) }; function Zi(t, e) { if (!be) switch (t.tailMode) { case "hidden": e = t.tail; for (var n = null; e !== null;)e.alternate !== null && (n = e), e = e.sibling; n === null ? t.tail = null : n.sibling = null; break; case "collapsed": n = t.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null } } function Ge(t) { var e = t.alternate !== null && t.alternate.child === t.child, n = 0, r = 0; if (e) for (var i = t.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = t, i = i.sibling; else for (i = t.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = t, i = i.sibling; return t.subtreeFlags |= r, t.childLanes = n, e } function pS(t, e, n) { var r = e.pendingProps; switch (ch(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ge(e), null; case 1: return ht(e.type) && Wa(), Ge(e), null; case 3: return r = e.stateNode, Pi(), ye(dt), ye(Ze), bh(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (Fo(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, Wt !== null && (fd(Wt), Wt = null))), sd(t, e), Ge(e), null; case 5: yh(e); var i = Or(Ks.current); if (n = e.type, t !== null && e.stateNode != null) u0(t, e, n, r, i), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!r) { if (e.stateNode === null) throw Error(U(166)); return Ge(e), null } if (t = Or(ln.current), Fo(e)) { r = e.stateNode, n = e.type; var s = e.memoizedProps; switch (r[on] = e, r[Ws] = s, t = (e.mode & 1) !== 0, n) { case "dialog": ve("cancel", r), ve("close", r); break; case "iframe": case "object": case "embed": ve("load", r); break; case "video": case "audio": for (i = 0; i < fs.length; i++)ve(fs[i], r); break; case "source": ve("error", r); break; case "img": case "image": case "link": ve("error", r), ve("load", r); break; case "details": ve("toggle", r); break; case "input": Bf(r, s), ve("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!s.multiple }, ve("invalid", r); break; case "textarea": Hf(r, s), ve("invalid", r) }Mc(n, s), i = null; for (var o in s) if (s.hasOwnProperty(o)) { var a = s[o]; o === "children" ? typeof a == "string" ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && No(r.textContent, a, t), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && No(r.textContent, a, t), i = ["children", "" + a]) : js.hasOwnProperty(o) && a != null && o === "onScroll" && ve("scroll", r) } switch (n) { case "input": To(r), Uf(r, s, !0); break; case "textarea": To(r), Wf(r); break; case "select": case "option": break; default: typeof s.onClick == "function" && (r.onclick = Ha) }r = i, e.updateQueue = r, r !== null && (e.flags |= 4) } else { o = i.nodeType === 9 ? i : i.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = Fv(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = o.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = o.createElement(n, { is: r.is }) : (t = o.createElement(n), n === "select" && (o = t, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : t = o.createElementNS(t, n), t[on] = e, t[Ws] = r, l0(t, e, !1, !1), e.stateNode = t; e: { switch (o = Lc(n, r), n) { case "dialog": ve("cancel", t), ve("close", t), i = r; break; case "iframe": case "object": case "embed": ve("load", t), i = r; break; case "video": case "audio": for (i = 0; i < fs.length; i++)ve(fs[i], t); i = r; break; case "source": ve("error", t), i = r; break; case "img": case "image": case "link": ve("error", t), ve("load", t), i = r; break; case "details": ve("toggle", t), i = r; break; case "input": Bf(t, r), i = Pc(t, r), ve("invalid", t); break; case "option": i = r; break; case "select": t._wrapperState = { wasMultiple: !!r.multiple }, i = ke({}, r, { value: void 0 }), ve("invalid", t); break; case "textarea": Hf(t, r), i = Ic(t, r), ve("invalid", t); break; default: i = r }Mc(n, i), a = i; for (s in a) if (a.hasOwnProperty(s)) { var l = a[s]; s === "style" ? Vv(t, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && $v(t, l)) : s === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && As(t, l) : typeof l == "number" && As(t, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (js.hasOwnProperty(s) ? l != null && s === "onScroll" && ve("scroll", t) : l != null && Yd(t, s, l, o)) } switch (n) { case "input": To(t), Uf(t, r, !1); break; case "textarea": To(t), Wf(t); break; case "option": r.value != null && t.setAttribute("value", "" + ir(r.value)); break; case "select": t.multiple = !!r.multiple, s = r.value, s != null ? pi(t, !!r.multiple, s, !1) : r.defaultValue != null && pi(t, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (t.onclick = Ha) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return Ge(e), null; case 6: if (t && e.stateNode != null) c0(t, e, t.memoizedProps, r); else { if (typeof r != "string" && e.stateNode === null) throw Error(U(166)); if (n = Or(Ks.current), Or(ln.current), Fo(e)) { if (r = e.stateNode, n = e.memoizedProps, r[on] = e, (s = r.nodeValue !== n) && (t = _t, t !== null)) switch (t.tag) { case 3: No(r.nodeValue, n, (t.mode & 1) !== 0); break; case 5: t.memoizedProps.suppressHydrationWarning !== !0 && No(r.nodeValue, n, (t.mode & 1) !== 0) }s && (e.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[on] = e, e.stateNode = r } return Ge(e), null; case 13: if (ye(_e), r = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) { if (be && yt !== null && e.mode & 1 && !(e.flags & 128)) Ey(), Ci(), e.flags |= 98560, s = !1; else if (s = Fo(e), r !== null && r.dehydrated !== null) { if (t === null) { if (!s) throw Error(U(318)); if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(U(317)); s[on] = e } else Ci(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; Ge(e), s = !1 } else Wt !== null && (fd(Wt), Wt = null), s = !0; if (!s) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = n, e) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192, e.mode & 1 && (t === null || _e.current & 1 ? De === 0 && (De = 3) : Rh())), e.updateQueue !== null && (e.flags |= 4), Ge(e), null); case 4: return Pi(), sd(t, e), t === null && Us(e.stateNode.containerInfo), Ge(e), null; case 10: return ph(e.type._context), Ge(e), null; case 17: return ht(e.type) && Wa(), Ge(e), null; case 19: if (ye(_e), s = e.memoizedState, s === null) return Ge(e), null; if (r = (e.flags & 128) !== 0, o = s.rendering, o === null) if (r) Zi(s, !1); else { if (De !== 0 || t !== null && t.flags & 128) for (t = e.child; t !== null;) { if (o = Ja(t), o !== null) { for (e.flags |= 128, Zi(s, !1), r = o.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = n, n = e.child; n !== null;)s = n, t = r, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = t, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, t = o.dependencies, s.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), n = n.sibling; return me(_e, _e.current & 1 | 2), e.child } t = t.sibling } s.tail !== null && Ee() > Ti && (e.flags |= 128, r = !0, Zi(s, !1), e.lanes = 4194304) } else { if (!r) if (t = Ja(o), t !== null) { if (e.flags |= 128, r = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), Zi(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !be) return Ge(e), null } else 2 * Ee() - s.renderingStartTime > Ti && n !== 1073741824 && (e.flags |= 128, r = !0, Zi(s, !1), e.lanes = 4194304); s.isBackwards ? (o.sibling = e.child, e.child = o) : (n = s.last, n !== null ? n.sibling = o : e.child = o, s.last = o) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = Ee(), e.sibling = null, n = _e.current, me(_e, r ? n & 1 | 2 : n & 1), e) : (Ge(e), null); case 22: case 23: return Ih(), r = e.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (e.flags |= 8192), r && e.mode & 1 ? vt & 1073741824 && (Ge(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Ge(e), null; case 24: return null; case 25: return null }throw Error(U(156, e.tag)) } function gS(t, e) { switch (ch(e), e.tag) { case 1: return ht(e.type) && Wa(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 3: return Pi(), ye(dt), ye(Ze), bh(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null; case 5: return yh(e), null; case 13: if (ye(_e), t = e.memoizedState, t !== null && t.dehydrated !== null) { if (e.alternate === null) throw Error(U(340)); Ci() } return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 19: return ye(_e), null; case 4: return Pi(), null; case 10: return ph(e.type._context), null; case 22: case 23: return Ih(), null; case 24: return null; default: return null } } var Vo = !1, Je = !1, mS = typeof WeakSet == "function" ? WeakSet : Set, G = null; function ci(t, e) { var n = t.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { Ce(t, e, r) } else n.current = null } function od(t, e, n) { try { n() } catch (r) { Ce(t, e, r) } } var Dp = !1; function vS(t, e) { if (Uc = Va, t = gy(), lh(t)) { if ("selectionStart" in t) var n = { start: t.selectionStart, end: t.selectionEnd }; else e: { n = (n = t.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, s = r.focusNode; r = r.focusOffset; try { n.nodeType, s.nodeType } catch { n = null; break e } var o = 0, a = -1, l = -1, u = 0, c = 0, d = t, h = null; t: for (; ;) { for (var f; d !== n || i !== 0 && d.nodeType !== 3 || (a = o + i), d !== s || r !== 0 && d.nodeType !== 3 || (l = o + r), d.nodeType === 3 && (o += d.nodeValue.length), (f = d.firstChild) !== null;)h = d, d = f; for (; ;) { if (d === t) break t; if (h === n && ++u === i && (a = o), h === s && ++c === r && (l = o), (f = d.nextSibling) !== null) break; d = h, h = d.parentNode } d = f } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (Hc = { focusedElem: t, selectionRange: n }, Va = !1, G = e; G !== null;)if (e = G, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, G = t; else for (; G !== null;) { e = G; try { var g = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (g !== null) { var m = g.memoizedProps, y = g.memoizedState, p = e.stateNode, v = p.getSnapshotBeforeUpdate(e.elementType === e.type ? m : Bt(e.type, m), y); p.__reactInternalSnapshotBeforeUpdate = v } break; case 3: var b = e.stateNode.containerInfo; b.nodeType === 1 ? b.textContent = "" : b.nodeType === 9 && b.documentElement && b.removeChild(b.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(U(163)) } } catch (x) { Ce(e, e.return, x) } if (t = e.sibling, t !== null) { t.return = e.return, G = t; break } G = e.return } return g = Dp, Dp = !1, g } function Cs(t, e, n) { var r = e.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & t) === t) { var s = i.destroy; i.destroy = void 0, s !== void 0 && od(e, n, s) } i = i.next } while (i !== r) } } function Al(t, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var n = e = e.next; do { if ((n.tag & t) === t) { var r = n.create; n.destroy = r() } n = n.next } while (n !== e) } } function ad(t) { var e = t.ref; if (e !== null) { var n = t.stateNode; switch (t.tag) { case 5: t = n; break; default: t = n }typeof e == "function" ? e(t) : e.current = t } } function d0(t) { var e = t.alternate; e !== null && (t.alternate = null, d0(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[on], delete e[Ws], delete e[Kc], delete e[Zx], delete e[eS])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null } function h0(t) { return t.tag === 5 || t.tag === 3 || t.tag === 4 } function jp(t) { e: for (; ;) { for (; t.sibling === null;) { if (t.return === null || h0(t.return)) return null; t = t.return } for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) { if (t.flags & 2 || t.child === null || t.tag === 4) continue e; t.child.return = t, t = t.child } if (!(t.flags & 2)) return t.stateNode } } function ld(t, e, n) { var r = t.tag; if (r === 5 || r === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = Ha)); else if (r !== 4 && (t = t.child, t !== null)) for (ld(t, e, n), t = t.sibling; t !== null;)ld(t, e, n), t = t.sibling } function ud(t, e, n) { var r = t.tag; if (r === 5 || r === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t); else if (r !== 4 && (t = t.child, t !== null)) for (ud(t, e, n), t = t.sibling; t !== null;)ud(t, e, n), t = t.sibling } var Be = null, Ut = !1; function In(t, e, n) { for (n = n.child; n !== null;)f0(t, e, n), n = n.sibling } function f0(t, e, n) { if (an && typeof an.onCommitFiberUnmount == "function") try { an.onCommitFiberUnmount(El, n) } catch { } switch (n.tag) { case 5: Je || ci(n, e); case 6: var r = Be, i = Ut; Be = null, In(t, e, n), Be = r, Ut = i, Be !== null && (Ut ? (t = Be, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : Be.removeChild(n.stateNode)); break; case 18: Be !== null && (Ut ? (t = Be, n = n.stateNode, t.nodeType === 8 ? Nu(t.parentNode, n) : t.nodeType === 1 && Nu(t, n), zs(t)) : Nu(Be, n.stateNode)); break; case 4: r = Be, i = Ut, Be = n.stateNode.containerInfo, Ut = !0, In(t, e, n), Be = r, Ut = i; break; case 0: case 11: case 14: case 15: if (!Je && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var s = i, o = s.destroy; s = s.tag, o !== void 0 && (s & 2 || s & 4) && od(n, e, o), i = i.next } while (i !== r) } In(t, e, n); break; case 1: if (!Je && (ci(n, e), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { Ce(n, e, a) } In(t, e, n); break; case 21: In(t, e, n); break; case 22: n.mode & 1 ? (Je = (r = Je) || n.memoizedState !== null, In(t, e, n), Je = r) : In(t, e, n); break; default: In(t, e, n) } } function Ap(t) { var e = t.updateQueue; if (e !== null) { t.updateQueue = null; var n = t.stateNode; n === null && (n = t.stateNode = new mS), e.forEach(function (r) { var i = OS.bind(null, t, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function $t(t, e) { var n = e.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var s = t, o = e, a = o; e: for (; a !== null;) { switch (a.tag) { case 5: Be = a.stateNode, Ut = !1; break e; case 3: Be = a.stateNode.containerInfo, Ut = !0; break e; case 4: Be = a.stateNode.containerInfo, Ut = !0; break e }a = a.return } if (Be === null) throw Error(U(160)); f0(s, o, i), Be = null, Ut = !1; var l = i.alternate; l !== null && (l.return = null), i.return = null } catch (u) { Ce(i, e, u) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)p0(e, t), e = e.sibling } function p0(t, e) { var n = t.alternate, r = t.flags; switch (t.tag) { case 0: case 11: case 14: case 15: if ($t(e, t), Xt(t), r & 4) { try { Cs(3, t, t.return), Al(3, t) } catch (m) { Ce(t, t.return, m) } try { Cs(5, t, t.return) } catch (m) { Ce(t, t.return, m) } } break; case 1: $t(e, t), Xt(t), r & 512 && n !== null && ci(n, n.return); break; case 5: if ($t(e, t), Xt(t), r & 512 && n !== null && ci(n, n.return), t.flags & 32) { var i = t.stateNode; try { As(i, "") } catch (m) { Ce(t, t.return, m) } } if (r & 4 && (i = t.stateNode, i != null)) { var s = t.memoizedProps, o = n !== null ? n.memoizedProps : s, a = t.type, l = t.updateQueue; if (t.updateQueue = null, l !== null) try { a === "input" && s.type === "radio" && s.name != null && Av(i, s), Lc(a, o); var u = Lc(a, s); for (o = 0; o < l.length; o += 2) { var c = l[o], d = l[o + 1]; c === "style" ? Vv(i, d) : c === "dangerouslySetInnerHTML" ? $v(i, d) : c === "children" ? As(i, d) : Yd(i, c, d, u) } switch (a) { case "input": Ec(i, s); break; case "textarea": Nv(i, s); break; case "select": var h = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!s.multiple; var f = s.value; f != null ? pi(i, !!s.multiple, f, !1) : h !== !!s.multiple && (s.defaultValue != null ? pi(i, !!s.multiple, s.defaultValue, !0) : pi(i, !!s.multiple, s.multiple ? [] : "", !1)) }i[Ws] = s } catch (m) { Ce(t, t.return, m) } } break; case 6: if ($t(e, t), Xt(t), r & 4) { if (t.stateNode === null) throw Error(U(162)); i = t.stateNode, s = t.memoizedProps; try { i.nodeValue = s } catch (m) { Ce(t, t.return, m) } } break; case 3: if ($t(e, t), Xt(t), r & 4 && n !== null && n.memoizedState.isDehydrated) try { zs(e.containerInfo) } catch (m) { Ce(t, t.return, m) } break; case 4: $t(e, t), Xt(t); break; case 13: $t(e, t), Xt(t), i = t.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (Eh = Ee())), r & 4 && Ap(t); break; case 22: if (c = n !== null && n.memoizedState !== null, t.mode & 1 ? (Je = (u = Je) || c, $t(e, t), Je = u) : $t(e, t), Xt(t), r & 8192) { if (u = t.memoizedState !== null, (t.stateNode.isHidden = u) && !c && t.mode & 1) for (G = t, c = t.child; c !== null;) { for (d = G = c; G !== null;) { switch (h = G, f = h.child, h.tag) { case 0: case 11: case 14: case 15: Cs(4, h, h.return); break; case 1: ci(h, h.return); var g = h.stateNode; if (typeof g.componentWillUnmount == "function") { r = h, n = h.return; try { e = r, g.props = e.memoizedProps, g.state = e.memoizedState, g.componentWillUnmount() } catch (m) { Ce(r, n, m) } } break; case 5: ci(h, h.return); break; case 22: if (h.memoizedState !== null) { Fp(d); continue } }f !== null ? (f.return = h, G = f) : Fp(d) } c = c.sibling } e: for (c = null, d = t; ;) { if (d.tag === 5) { if (c === null) { c = d; try { i = d.stateNode, u ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = zv("display", o)) } catch (m) { Ce(t, t.return, m) } } } else if (d.tag === 6) { if (c === null) try { d.stateNode.nodeValue = u ? "" : d.memoizedProps } catch (m) { Ce(t, t.return, m) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === t) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === t) break e; for (; d.sibling === null;) { if (d.return === null || d.return === t) break e; c === d && (c = null), d = d.return } c === d && (c = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: $t(e, t), Xt(t), r & 4 && Ap(t); break; case 21: break; default: $t(e, t), Xt(t) } } function Xt(t) { var e = t.flags; if (e & 2) { try { e: { for (var n = t.return; n !== null;) { if (h0(n)) { var r = n; break e } n = n.return } throw Error(U(160)) } switch (r.tag) { case 5: var i = r.stateNode; r.flags & 32 && (As(i, ""), r.flags &= -33); var s = jp(t); ud(t, s, i); break; case 3: case 4: var o = r.stateNode.containerInfo, a = jp(t); ld(t, a, o); break; default: throw Error(U(161)) } } catch (l) { Ce(t, t.return, l) } t.flags &= -3 } e & 4096 && (t.flags &= -4097) } function yS(t, e, n) { G = t, g0(t) } function g0(t, e, n) { for (var r = (t.mode & 1) !== 0; G !== null;) { var i = G, s = i.child; if (i.tag === 22 && r) { var o = i.memoizedState !== null || Vo; if (!o) { var a = i.alternate, l = a !== null && a.memoizedState !== null || Je; a = Vo; var u = Je; if (Vo = o, (Je = l) && !u) for (G = i; G !== null;)o = G, l = o.child, o.tag === 22 && o.memoizedState !== null ? $p(i) : l !== null ? (l.return = o, G = l) : $p(i); for (; s !== null;)G = s, g0(s), s = s.sibling; G = i, Vo = a, Je = u } Np(t) } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, G = s) : Np(t) } } function Np(t) { for (; G !== null;) { var e = G; if (e.flags & 8772) { var n = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: Je || Al(5, e); break; case 1: var r = e.stateNode; if (e.flags & 4 && !Je) if (n === null) r.componentDidMount(); else { var i = e.elementType === e.type ? n.memoizedProps : Bt(e.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var s = e.updateQueue; s !== null && wp(e, s, r); break; case 3: var o = e.updateQueue; if (o !== null) { if (n = null, e.child !== null) switch (e.child.tag) { case 5: n = e.child.stateNode; break; case 1: n = e.child.stateNode }wp(e, o, n) } break; case 5: var a = e.stateNode; if (n === null && e.flags & 4) { n = a; var l = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var u = e.alternate; if (u !== null) { var c = u.memoizedState; if (c !== null) { var d = c.dehydrated; d !== null && zs(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(U(163)) }Je || e.flags & 512 && ad(e) } catch (h) { Ce(e, e.return, h) } } if (e === t) { G = null; break } if (n = e.sibling, n !== null) { n.return = e.return, G = n; break } G = e.return } } function Fp(t) { for (; G !== null;) { var e = G; if (e === t) { G = null; break } var n = e.sibling; if (n !== null) { n.return = e.return, G = n; break } G = e.return } } function $p(t) { for (; G !== null;) { var e = G; try { switch (e.tag) { case 0: case 11: case 15: var n = e.return; try { Al(4, e) } catch (l) { Ce(e, n, l) } break; case 1: var r = e.stateNode; if (typeof r.componentDidMount == "function") { var i = e.return; try { r.componentDidMount() } catch (l) { Ce(e, i, l) } } var s = e.return; try { ad(e) } catch (l) { Ce(e, s, l) } break; case 5: var o = e.return; try { ad(e) } catch (l) { Ce(e, o, l) } } } catch (l) { Ce(e, e.return, l) } if (e === t) { G = null; break } var a = e.sibling; if (a !== null) { a.return = e.return, G = a; break } G = e.return } } var bS = Math.ceil, tl = En.ReactCurrentDispatcher, Oh = En.ReactCurrentOwner, jt = En.ReactCurrentBatchConfig, ie = 0, Fe = null, Re = null, He = 0, vt = 0, di = lr(0), De = 0, Xs = null, Dr = 0, Nl = 0, Ph = 0, Os = null, lt = null, Eh = 0, Ti = 1 / 0, mn = null, nl = !1, cd = null, Jn = null, Bo = !1, Vn = null, rl = 0, Ps = 0, dd = null, ka = -1, Ca = 0; function rt() { return ie & 6 ? Ee() : ka !== -1 ? ka : ka = Ee() } function Zn(t) { return t.mode & 1 ? ie & 2 && He !== 0 ? He & -He : nS.transition !== null ? (Ca === 0 && (Ca = Zv()), Ca) : (t = de, t !== 0 || (t = window.event, t = t === void 0 ? 16 : oy(t.type)), t) : 1 } function Gt(t, e, n, r) { if (50 < Ps) throw Ps = 0, dd = null, Error(U(185)); fo(t, n, r), (!(ie & 2) || t !== Fe) && (t === Fe && (!(ie & 2) && (Nl |= n), De === 4 && Fn(t, He)), ft(t, r), n === 1 && ie === 0 && !(e.mode & 1) && (Ti = Ee() + 500, Ll && ur())) } function ft(t, e) { var n = t.callbackNode; nx(t, e); var r = za(t, t === Fe ? He : 0); if (r === 0) n !== null && Gf(n), t.callbackNode = null, t.callbackPriority = 0; else if (e = r & -r, t.callbackPriority !== e) { if (n != null && Gf(n), e === 1) t.tag === 0 ? tS(zp.bind(null, t)) : Cy(zp.bind(null, t)), Xx(function () { !(ie & 6) && ur() }), n = null; else { switch (ey(r)) { case 1: n = eh; break; case 4: n = Xv; break; case 16: n = $a; break; case 536870912: n = Jv; break; default: n = $a }n = S0(n, m0.bind(null, t)) } t.callbackPriority = e, t.callbackNode = n } } function m0(t, e) { if (ka = -1, Ca = 0, ie & 6) throw Error(U(327)); var n = t.callbackNode; if (bi() && t.callbackNode !== n) return null; var r = za(t, t === Fe ? He : 0); if (r === 0) return null; if (r & 30 || r & t.expiredLanes || e) e = il(t, r); else { e = r; var i = ie; ie |= 2; var s = y0(); (Fe !== t || He !== e) && (mn = null, Ti = Ee() + 500, Pr(t, e)); do try { xS(); break } catch (a) { v0(t, a) } while (!0); fh(), tl.current = s, ie = i, Re !== null ? e = 0 : (Fe = null, He = 0, e = De) } if (e !== 0) { if (e === 2 && (i = Fc(t), i !== 0 && (r = i, e = hd(t, i))), e === 1) throw n = Xs, Pr(t, 0), Fn(t, r), ft(t, Ee()), n; if (e === 6) Fn(t, r); else { if (i = t.current.alternate, !(r & 30) && !_S(i) && (e = il(t, r), e === 2 && (s = Fc(t), s !== 0 && (r = s, e = hd(t, s))), e === 1)) throw n = Xs, Pr(t, 0), Fn(t, r), ft(t, Ee()), n; switch (t.finishedWork = i, t.finishedLanes = r, e) { case 0: case 1: throw Error(U(345)); case 2: _r(t, lt, mn); break; case 3: if (Fn(t, r), (r & 130023424) === r && (e = Eh + 500 - Ee(), 10 < e)) { if (za(t, 0) !== 0) break; if (i = t.suspendedLanes, (i & r) !== r) { rt(), t.pingedLanes |= t.suspendedLanes & i; break } t.timeoutHandle = qc(_r.bind(null, t, lt, mn), e); break } _r(t, lt, mn); break; case 4: if (Fn(t, r), (r & 4194240) === r) break; for (e = t.eventTimes, i = -1; 0 < r;) { var o = 31 - Kt(r); s = 1 << o, o = e[o], o > i && (i = o), r &= ~s } if (r = i, r = Ee() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * bS(r / 1960)) - r, 10 < r) { t.timeoutHandle = qc(_r.bind(null, t, lt, mn), r); break } _r(t, lt, mn); break; case 5: _r(t, lt, mn); break; default: throw Error(U(329)) } } } return ft(t, Ee()), t.callbackNode === n ? m0.bind(null, t) : null } function hd(t, e) { var n = Os; return t.current.memoizedState.isDehydrated && (Pr(t, e).flags |= 256), t = il(t, e), t !== 2 && (e = lt, lt = n, e !== null && fd(e)), t } function fd(t) { lt === null ? lt = t : lt.push.apply(lt, t) } function _S(t) { for (var e = t; ;) { if (e.flags & 16384) { var n = e.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], s = i.getSnapshot; i = i.value; try { if (!Yt(s(), i)) return !1 } catch { return !1 } } } if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n; else { if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function Fn(t, e) { for (e &= ~Ph, e &= ~Nl, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) { var n = 31 - Kt(e), r = 1 << n; t[n] = -1, e &= ~r } } function zp(t) { if (ie & 6) throw Error(U(327)); bi(); var e = za(t, 0); if (!(e & 1)) return ft(t, Ee()), null; var n = il(t, e); if (t.tag !== 0 && n === 2) { var r = Fc(t); r !== 0 && (e = r, n = hd(t, r)) } if (n === 1) throw n = Xs, Pr(t, 0), Fn(t, e), ft(t, Ee()), n; if (n === 6) throw Error(U(345)); return t.finishedWork = t.current.alternate, t.finishedLanes = e, _r(t, lt, mn), ft(t, Ee()), null } function Th(t, e) { var n = ie; ie |= 1; try { return t(e) } finally { ie = n, ie === 0 && (Ti = Ee() + 500, Ll && ur()) } } function jr(t) { Vn !== null && Vn.tag === 0 && !(ie & 6) && bi(); var e = ie; ie |= 1; var n = jt.transition, r = de; try { if (jt.transition = null, de = 1, t) return t() } finally { de = r, jt.transition = n, ie = e, !(ie & 6) && ur() } } function Ih() { vt = di.current, ye(di) } function Pr(t, e) { t.finishedWork = null, t.finishedLanes = 0; var n = t.timeoutHandle; if (n !== -1 && (t.timeoutHandle = -1, Qx(n)), Re !== null) for (n = Re.return; n !== null;) { var r = n; switch (ch(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Wa(); break; case 3: Pi(), ye(dt), ye(Ze), bh(); break; case 5: yh(r); break; case 4: Pi(); break; case 13: ye(_e); break; case 19: ye(_e); break; case 10: ph(r.type._context); break; case 22: case 23: Ih() }n = n.return } if (Fe = t, Re = t = er(t.current, null), He = vt = e, De = 0, Xs = null, Ph = Nl = Dr = 0, lt = Os = null, Cr !== null) { for (e = 0; e < Cr.length; e++)if (n = Cr[e], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, s = n.pending; if (s !== null) { var o = s.next; s.next = i, r.next = o } n.pending = r } Cr = null } return t } function v0(t, e) { do { var n = Re; try { if (fh(), wa.current = el, Za) { for (var r = Se.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } Za = !1 } if (Lr = 0, Ae = Le = Se = null, ks = !1, Gs = 0, Oh.current = null, n === null || n.return === null) { De = 1, Xs = e, Re = null; break } e: { var s = t, o = n.return, a = n, l = e; if (e = He, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var u = l, c = a, d = c.tag; if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) { var h = c.alternate; h ? (c.updateQueue = h.updateQueue, c.memoizedState = h.memoizedState, c.lanes = h.lanes) : (c.updateQueue = null, c.memoizedState = null) } var f = Pp(o); if (f !== null) { f.flags &= -257, Ep(f, o, a, s, e), f.mode & 1 && Op(s, u, e), e = f, l = u; var g = e.updateQueue; if (g === null) { var m = new Set; m.add(l), e.updateQueue = m } else g.add(l); break e } else { if (!(e & 1)) { Op(s, u, e), Rh(); break e } l = Error(U(426)) } } else if (be && a.mode & 1) { var y = Pp(o); if (y !== null) { !(y.flags & 65536) && (y.flags |= 256), Ep(y, o, a, s, e), dh(Ei(l, a)); break e } } s = l = Ei(l, a), De !== 4 && (De = 2), Os === null ? Os = [s] : Os.push(s), s = o; do { switch (s.tag) { case 3: s.flags |= 65536, e &= -e, s.lanes |= e; var p = e0(s, l, e); _p(s, p); break e; case 1: a = l; var v = s.type, b = s.stateNode; if (!(s.flags & 128) && (typeof v.getDerivedStateFromError == "function" || b !== null && typeof b.componentDidCatch == "function" && (Jn === null || !Jn.has(b)))) { s.flags |= 65536, e &= -e, s.lanes |= e; var x = t0(s, a, e); _p(s, x); break e } }s = s.return } while (s !== null) } _0(n) } catch (P) { e = P, Re === n && n !== null && (Re = n = n.return); continue } break } while (!0) } function y0() { var t = tl.current; return tl.current = el, t === null ? el : t } function Rh() { (De === 0 || De === 3 || De === 2) && (De = 4), Fe === null || !(Dr & 268435455) && !(Nl & 268435455) || Fn(Fe, He) } function il(t, e) { var n = ie; ie |= 2; var r = y0(); (Fe !== t || He !== e) && (mn = null, Pr(t, e)); do try { wS(); break } catch (i) { v0(t, i) } while (!0); if (fh(), ie = n, tl.current = r, Re !== null) throw Error(U(261)); return Fe = null, He = 0, De } function wS() { for (; Re !== null;)b0(Re) } function xS() { for (; Re !== null && !Kw();)b0(Re) } function b0(t) { var e = x0(t.alternate, t, vt); t.memoizedProps = t.pendingProps, e === null ? _0(t) : Re = e, Oh.current = null } function _0(t) { var e = t; do { var n = e.alternate; if (t = e.return, e.flags & 32768) { if (n = gS(n, e), n !== null) { n.flags &= 32767, Re = n; return } if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null; else { De = 6, Re = null; return } } else if (n = pS(n, e, vt), n !== null) { Re = n; return } if (e = e.sibling, e !== null) { Re = e; return } Re = e = t } while (e !== null); De === 0 && (De = 5) } function _r(t, e, n) { var r = de, i = jt.transition; try { jt.transition = null, de = 1, SS(t, e, n, r) } finally { jt.transition = i, de = r } return null } function SS(t, e, n, r) { do bi(); while (Vn !== null); if (ie & 6) throw Error(U(327)); n = t.finishedWork; var i = t.finishedLanes; if (n === null) return null; if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(U(177)); t.callbackNode = null, t.callbackPriority = 0; var s = n.lanes | n.childLanes; if (rx(t, s), t === Fe && (Re = Fe = null, He = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Bo || (Bo = !0, S0($a, function () { return bi(), null })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) { s = jt.transition, jt.transition = null; var o = de; de = 1; var a = ie; ie |= 4, Oh.current = null, vS(t, n), p0(n, t), Ux(Hc), Va = !!Uc, Hc = Uc = null, t.current = n, yS(n), Gw(), ie = a, de = o, jt.transition = s } else t.current = n; if (Bo && (Bo = !1, Vn = t, rl = i), s = t.pendingLanes, s === 0 && (Jn = null), Xw(n.stateNode), ft(t, Ee()), e !== null) for (r = t.onRecoverableError, n = 0; n < e.length; n++)i = e[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (nl) throw nl = !1, t = cd, cd = null, t; return rl & 1 && t.tag !== 0 && bi(), s = t.pendingLanes, s & 1 ? t === dd ? Ps++ : (Ps = 0, dd = t) : Ps = 0, ur(), null } function bi() { if (Vn !== null) { var t = ey(rl), e = jt.transition, n = de; try { if (jt.transition = null, de = 16 > t ? 16 : t, Vn === null) var r = !1; else { if (t = Vn, Vn = null, rl = 0, ie & 6) throw Error(U(331)); var i = ie; for (ie |= 4, G = t.current; G !== null;) { var s = G, o = s.child; if (G.flags & 16) { var a = s.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var u = a[l]; for (G = u; G !== null;) { var c = G; switch (c.tag) { case 0: case 11: case 15: Cs(8, c, s) }var d = c.child; if (d !== null) d.return = c, G = d; else for (; G !== null;) { c = G; var h = c.sibling, f = c.return; if (d0(c), c === u) { G = null; break } if (h !== null) { h.return = f, G = h; break } G = f } } } var g = s.alternate; if (g !== null) { var m = g.child; if (m !== null) { g.child = null; do { var y = m.sibling; m.sibling = null, m = y } while (m !== null) } } G = s } } if (s.subtreeFlags & 2064 && o !== null) o.return = s, G = o; else e: for (; G !== null;) { if (s = G, s.flags & 2048) switch (s.tag) { case 0: case 11: case 15: Cs(9, s, s.return) }var p = s.sibling; if (p !== null) { p.return = s.return, G = p; break e } G = s.return } } var v = t.current; for (G = v; G !== null;) { o = G; var b = o.child; if (o.subtreeFlags & 2064 && b !== null) b.return = o, G = b; else e: for (o = v; G !== null;) { if (a = G, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: Al(9, a) } } catch (P) { Ce(a, a.return, P) } if (a === o) { G = null; break e } var x = a.sibling; if (x !== null) { x.return = a.return, G = x; break e } G = a.return } } if (ie = i, ur(), an && typeof an.onPostCommitFiberRoot == "function") try { an.onPostCommitFiberRoot(El, t) } catch { } r = !0 } return r } finally { de = n, jt.transition = e } } return !1 } function Vp(t, e, n) { e = Ei(n, e), e = e0(t, e, 1), t = Xn(t, e, 1), e = rt(), t !== null && (fo(t, 1, e), ft(t, e)) } function Ce(t, e, n) { if (t.tag === 3) Vp(t, t, n); else for (; e !== null;) { if (e.tag === 3) { Vp(e, t, n); break } else if (e.tag === 1) { var r = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Jn === null || !Jn.has(r))) { t = Ei(n, t), t = t0(e, t, 1), e = Xn(e, t, 1), t = rt(), e !== null && (fo(e, 1, t), ft(e, t)); break } } e = e.return } } function kS(t, e, n) { var r = t.pingCache; r !== null && r.delete(e), e = rt(), t.pingedLanes |= t.suspendedLanes & n, Fe === t && (He & n) === n && (De === 4 || De === 3 && (He & 130023424) === He && 500 > Ee() - Eh ? Pr(t, 0) : Ph |= n), ft(t, e) } function w0(t, e) { e === 0 && (t.mode & 1 ? (e = Mo, Mo <<= 1, !(Mo & 130023424) && (Mo = 4194304)) : e = 1); var n = rt(); t = Cn(t, e), t !== null && (fo(t, e, n), ft(t, n)) } function CS(t) { var e = t.memoizedState, n = 0; e !== null && (n = e.retryLane), w0(t, n) } function OS(t, e) { var n = 0; switch (t.tag) { case 13: var r = t.stateNode, i = t.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = t.stateNode; break; default: throw Error(U(314)) }r !== null && r.delete(e), w0(t, n) } var x0; x0 = function (t, e, n) { if (t !== null) if (t.memoizedProps !== e.pendingProps || dt.current) ct = !0; else { if (!(t.lanes & n) && !(e.flags & 128)) return ct = !1, fS(t, e, n); ct = !!(t.flags & 131072) } else ct = !1, be && e.flags & 1048576 && Oy(e, Ga, e.index); switch (e.lanes = 0, e.tag) { case 2: var r = e.type; Sa(t, e), t = e.pendingProps; var i = ki(e, Ze.current); yi(e, n), i = wh(null, e, r, t, i, n); var s = xh(); return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, ht(r) ? (s = !0, qa(e)) : s = !1, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, mh(e), i.updater = jl, e.stateNode = i, i._reactInternals = e, Zc(e, r, t, n), e = nd(null, e, r, !0, s, n)) : (e.tag = 0, be && s && uh(e), nt(null, e, i, n), e = e.child), e; case 16: r = e.elementType; e: { switch (Sa(t, e), t = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = ES(r), t = Bt(r, t), i) { case 0: e = td(null, e, r, t, n); break e; case 1: e = Rp(null, e, r, t, n); break e; case 11: e = Tp(null, e, r, t, n); break e; case 14: e = Ip(null, e, r, Bt(r.type, t), n); break e }throw Error(U(306, r, "")) } return e; case 0: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Bt(r, i), td(t, e, r, i, n); case 1: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Bt(r, i), Rp(t, e, r, i, n); case 3: e: { if (s0(e), t === null) throw Error(U(387)); r = e.pendingProps, s = e.memoizedState, i = s.element, My(t, e), Xa(e, r, null, n); var o = e.memoizedState; if (r = o.element, s.isDehydrated) if (s = { element: r, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) { i = Ei(Error(U(423)), e), e = Mp(t, e, r, n, i); break e } else if (r !== i) { i = Ei(Error(U(424)), e), e = Mp(t, e, r, n, i); break e } else for (yt = Qn(e.stateNode.containerInfo.firstChild), _t = e, be = !0, Wt = null, n = Iy(e, null, r, n), e.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (Ci(), r === i) { e = On(t, e, n); break e } nt(t, e, r, n) } e = e.child } return e; case 5: return Ly(e), t === null && Qc(e), r = e.type, i = e.pendingProps, s = t !== null ? t.memoizedProps : null, o = i.children, Wc(r, i) ? o = null : s !== null && Wc(r, s) && (e.flags |= 32), i0(t, e), nt(t, e, o, n), e.child; case 6: return t === null && Qc(e), null; case 13: return o0(t, e, n); case 4: return vh(e, e.stateNode.containerInfo), r = e.pendingProps, t === null ? e.child = Oi(e, null, r, n) : nt(t, e, r, n), e.child; case 11: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Bt(r, i), Tp(t, e, r, i, n); case 7: return nt(t, e, e.pendingProps, n), e.child; case 8: return nt(t, e, e.pendingProps.children, n), e.child; case 12: return nt(t, e, e.pendingProps.children, n), e.child; case 10: e: { if (r = e.type._context, i = e.pendingProps, s = e.memoizedProps, o = i.value, me(Ya, r._currentValue), r._currentValue = o, s !== null) if (Yt(s.value, o)) { if (s.children === i.children && !dt.current) { e = On(t, e, n); break e } } else for (s = e.child, s !== null && (s.return = e); s !== null;) { var a = s.dependencies; if (a !== null) { o = s.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (s.tag === 1) { l = wn(-1, n & -n), l.tag = 2; var u = s.updateQueue; if (u !== null) { u = u.shared; var c = u.pending; c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l } } s.lanes |= n, l = s.alternate, l !== null && (l.lanes |= n), Xc(s.return, n, e), a.lanes |= n; break } l = l.next } } else if (s.tag === 10) o = s.type === e.type ? null : s.child; else if (s.tag === 18) { if (o = s.return, o === null) throw Error(U(341)); o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), Xc(o, n, e), o = s.sibling } else o = s.child; if (o !== null) o.return = s; else for (o = s; o !== null;) { if (o === e) { o = null; break } if (s = o.sibling, s !== null) { s.return = o.return, o = s; break } o = o.return } s = o } nt(t, e, i.children, n), e = e.child } return e; case 9: return i = e.type, r = e.pendingProps.children, yi(e, n), i = Nt(i), r = r(i), e.flags |= 1, nt(t, e, r, n), e.child; case 14: return r = e.type, i = Bt(r, e.pendingProps), i = Bt(r.type, i), Ip(t, e, r, i, n); case 15: return n0(t, e, e.type, e.pendingProps, n); case 17: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Bt(r, i), Sa(t, e), e.tag = 1, ht(r) ? (t = !0, qa(e)) : t = !1, yi(e, n), Zy(e, r, i), Zc(e, r, i, n), nd(null, e, r, !0, t, n); case 19: return a0(t, e, n); case 22: return r0(t, e, n) }throw Error(U(156, e.tag)) }; function S0(t, e) { return Qv(t, e) } function PS(t, e, n, r) { this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Mt(t, e, n, r) { return new PS(t, e, n, r) } function Mh(t) { return t = t.prototype, !(!t || !t.isReactComponent) } function ES(t) { if (typeof t == "function") return Mh(t) ? 1 : 0; if (t != null) { if (t = t.$$typeof, t === Xd) return 11; if (t === Jd) return 14 } return 2 } function er(t, e) { var n = t.alternate; return n === null ? (n = Mt(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n } function Oa(t, e, n, r, i, s) { var o = 2; if (r = t, typeof t == "function") Mh(t) && (o = 1); else if (typeof t == "string") o = 5; else e: switch (t) { case ti: return Er(n.children, i, s, e); case Qd: o = 8, i |= 8; break; case Sc: return t = Mt(12, n, e, i | 2), t.elementType = Sc, t.lanes = s, t; case kc: return t = Mt(13, n, e, i), t.elementType = kc, t.lanes = s, t; case Cc: return t = Mt(19, n, e, i), t.elementType = Cc, t.lanes = s, t; case Lv: return Fl(n, i, s, e); default: if (typeof t == "object" && t !== null) switch (t.$$typeof) { case Rv: o = 10; break e; case Mv: o = 9; break e; case Xd: o = 11; break e; case Jd: o = 14; break e; case Dn: o = 16, r = null; break e }throw Error(U(130, t == null ? t : typeof t, "")) }return e = Mt(o, n, e, i), e.elementType = t, e.type = r, e.lanes = s, e } function Er(t, e, n, r) { return t = Mt(7, t, r, e), t.lanes = n, t } function Fl(t, e, n, r) { return t = Mt(22, t, r, e), t.elementType = Lv, t.lanes = n, t.stateNode = { isHidden: !1 }, t } function Wu(t, e, n) { return t = Mt(6, t, null, e), t.lanes = n, t } function qu(t, e, n) { return e = Mt(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, e } function TS(t, e, n, r, i) { this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ou(0), this.expirationTimes = Ou(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ou(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function Lh(t, e, n, r, i, s, o, a, l) { return t = new TS(t, e, n, a, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = Mt(3, null, null, e), t.current = s, s.stateNode = t, s.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, mh(s), t } function IS(t, e, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: ei, key: r == null ? null : "" + r, children: t, containerInfo: e, implementation: n } } function k0(t) { if (!t) return sr; t = t._reactInternals; e: { if (zr(t) !== t || t.tag !== 1) throw Error(U(170)); var e = t; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if (ht(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(U(171)) } if (t.tag === 1) { var n = t.type; if (ht(n)) return ky(t, n, e) } return e } function C0(t, e, n, r, i, s, o, a, l) { return t = Lh(n, r, !0, t, i, s, o, a, l), t.context = k0(null), n = t.current, r = rt(), i = Zn(n), s = wn(r, i), s.callback = e ?? null, Xn(n, s, i), t.current.lanes = i, fo(t, i, r), ft(t, r), t } function $l(t, e, n, r) { var i = e.current, s = rt(), o = Zn(i); return n = k0(n), e.context === null ? e.context = n : e.pendingContext = n, e = wn(s, o), e.payload = { element: t }, r = r === void 0 ? null : r, r !== null && (e.callback = r), t = Xn(i, e, o), t !== null && (Gt(t, i, o, s), _a(t, i, o)), o } function sl(t) { if (t = t.current, !t.child) return null; switch (t.child.tag) { case 5: return t.child.stateNode; default: return t.child.stateNode } } function Bp(t, e) { if (t = t.memoizedState, t !== null && t.dehydrated !== null) { var n = t.retryLane; t.retryLane = n !== 0 && n < e ? n : e } } function Dh(t, e) { Bp(t, e), (t = t.alternate) && Bp(t, e) } function RS() { return null } var O0 = typeof reportError == "function" ? reportError : function (t) { console.error(t) }; function jh(t) { this._internalRoot = t } zl.prototype.render = jh.prototype.render = function (t) { var e = this._internalRoot; if (e === null) throw Error(U(409)); $l(t, e, null, null) }; zl.prototype.unmount = jh.prototype.unmount = function () { var t = this._internalRoot; if (t !== null) { this._internalRoot = null; var e = t.containerInfo; jr(function () { $l(null, t, null, null) }), e[kn] = null } }; function zl(t) { this._internalRoot = t } zl.prototype.unstable_scheduleHydration = function (t) { if (t) { var e = ry(); t = { blockedOn: null, target: t, priority: e }; for (var n = 0; n < Nn.length && e !== 0 && e < Nn[n].priority; n++); Nn.splice(n, 0, t), n === 0 && sy(t) } }; function Ah(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) } function Vl(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable ")) } function Up() { } function MS(t, e, n, r, i) { if (i) { if (typeof r == "function") { var s = r; r = function () { var u = sl(o); s.call(u) } } var o = C0(e, r, t, 0, null, !1, !1, "", Up); return t._reactRootContainer = o, t[kn] = o.current, Us(t.nodeType === 8 ? t.parentNode : t), jr(), o } for (; i = t.lastChild;)t.removeChild(i); if (typeof r == "function") { var a = r; r = function () { var u = sl(l); a.call(u) } } var l = Lh(t, 0, !1, null, null, !1, !1, "", Up); return t._reactRootContainer = l, t[kn] = l.current, Us(t.nodeType === 8 ? t.parentNode : t), jr(function () { $l(e, l, n, r) }), l } function Bl(t, e, n, r, i) { var s = n._reactRootContainer; if (s) { var o = s; if (typeof i == "function") { var a = i; i = function () { var l = sl(o); a.call(l) } } $l(e, o, t, i) } else o = MS(n, e, t, i, r); return sl(o) } ty = function (t) { switch (t.tag) { case 3: var e = t.stateNode; if (e.current.memoizedState.isDehydrated) { var n = hs(e.pendingLanes); n !== 0 && (th(e, n | 1), ft(e, Ee()), !(ie & 6) && (Ti = Ee() + 500, ur())) } break; case 13: jr(function () { var r = Cn(t, 1); if (r !== null) { var i = rt(); Gt(r, t, 1, i) } }), Dh(t, 1) } }; nh = function (t) { if (t.tag === 13) { var e = Cn(t, 134217728); if (e !== null) { var n = rt(); Gt(e, t, 134217728, n) } Dh(t, 134217728) } }; ny = function (t) { if (t.tag === 13) { var e = Zn(t), n = Cn(t, e); if (n !== null) { var r = rt(); Gt(n, t, e, r) } Dh(t, e) } }; ry = function () { return de }; iy = function (t, e) { var n = de; try { return de = t, e() } finally { de = n } }; jc = function (t, e, n) { switch (e) { case "input": if (Ec(t, n), e = n.name, n.type === "radio" && e != null) { for (n = t; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) { var r = n[e]; if (r !== t && r.form === t.form) { var i = Ml(r); if (!i) throw Error(U(90)); jv(r), Ec(r, i) } } } break; case "textarea": Nv(t, n); break; case "select": e = n.value, e != null && pi(t, !!n.multiple, e, !1) } }; Hv = Th; Wv = jr; var LS = { usingClientEntryPoint: !1, Events: [go, si, Ml, Bv, Uv, Th] }, es = { findFiberByHostInstance: kr, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, DS = { bundleType: es.bundleType, version: es.version, rendererPackageName: es.rendererPackageName, rendererConfig: es.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: En.ReactCurrentDispatcher, findHostInstanceByFiber: function (t) { return t = Gv(t), t === null ? null : t.stateNode }, findFiberByHostInstance: es.findFiberByHostInstance || RS, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Uo = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Uo.isDisabled && Uo.supportsFiber) try { El = Uo.inject(DS), an = Uo } catch { } } St.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = LS; St.createPortal = function (t, e) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Ah(e)) throw Error(U(200)); return IS(t, e, null, n) }; St.createRoot = function (t, e) { if (!Ah(t)) throw Error(U(299)); var n = !1, r = "", i = O0; return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = Lh(t, 1, !1, null, null, n, !1, r, i), t[kn] = e.current, Us(t.nodeType === 8 ? t.parentNode : t), new jh(e) }; St.findDOMNode = function (t) { if (t == null) return null; if (t.nodeType === 1) return t; var e = t._reactInternals; if (e === void 0) throw typeof t.render == "function" ? Error(U(188)) : (t = Object.keys(t).join(","), Error(U(268, t))); return t = Gv(e), t = t === null ? null : t.stateNode, t }; St.flushSync = function (t) { return jr(t) }; St.hydrate = function (t, e, n) { if (!Vl(e)) throw Error(U(200)); return Bl(null, t, e, !0, n) }; St.hydrateRoot = function (t, e, n) { if (!Ah(t)) throw Error(U(405)); var r = n != null && n.hydratedSources || null, i = !1, s = "", o = O0; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), e = C0(e, null, t, 1, n ?? null, i, !1, s, o), t[kn] = e.current, Us(t), r) for (t = 0; t < r.length; t++)n = r[t], i = n._getVersion, i = i(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, i] : e.mutableSourceEagerHydrationData.push(n, i); return new zl(e) }; St.render = function (t, e, n) { if (!Vl(e)) throw Error(U(200)); return Bl(null, t, e, !1, n) }; St.unmountComponentAtNode = function (t) { if (!Vl(t)) throw Error(U(40)); return t._reactRootContainer ? (jr(function () { Bl(null, null, t, !1, function () { t._reactRootContainer = null, t[kn] = null }) }), !0) : !1 }; St.unstable_batchedUpdates = Th; St.unstable_renderSubtreeIntoContainer = function (t, e, n, r) { if (!Vl(n)) throw Error(U(200)); if (t == null || t._reactInternals === void 0) throw Error(U(38)); return Bl(t, e, n, !1, r) }; St.version = "18.3.1-next-f1338f8080-20240426"; function P0() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(P0) } catch (t) { console.error(t) } } P0(), Pv.exports = St; var E0 = Pv.exports, T0, Hp = E0; T0 = Hp.createRoot, Hp.hydrateRoot;/**
 * @remix-run/router v1.19.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Js() { return Js = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Js.apply(this, arguments) } var Bn; (function (t) { t.Pop = "POP", t.Push = "PUSH", t.Replace = "REPLACE" })(Bn || (Bn = {})); const Wp = "popstate"; function jS(t) { t === void 0 && (t = {}); function e(r, i) { let { pathname: s, search: o, hash: a } = r.location; return pd("", { pathname: s, search: o, hash: a }, i.state && i.state.usr || null, i.state && i.state.key || "default") } function n(r, i) { return typeof i == "string" ? i : ol(i) } return NS(e, n, null, t) } function Te(t, e) { if (t === !1 || t === null || typeof t > "u") throw new Error(e) } function I0(t, e) { if (!t) { typeof console < "u" && console.warn(e); try { throw new Error(e) } catch { } } } function AS() { return Math.random().toString(36).substr(2, 8) } function qp(t, e) { return { usr: t.state, key: t.key, idx: e } } function pd(t, e, n, r) { return n === void 0 && (n = null), Js({ pathname: typeof t == "string" ? t : t.pathname, search: "", hash: "" }, typeof e == "string" ? $i(e) : e, { state: n, key: e && e.key || r || AS() }) } function ol(t) { let { pathname: e = "/", search: n = "", hash: r = "" } = t; return n && n !== "?" && (e += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r), e } function $i(t) { let e = {}; if (t) { let n = t.indexOf("#"); n >= 0 && (e.hash = t.substr(n), t = t.substr(0, n)); let r = t.indexOf("?"); r >= 0 && (e.search = t.substr(r), t = t.substr(0, r)), t && (e.pathname = t) } return e } function NS(t, e, n, r) { r === void 0 && (r = {}); let { window: i = document.defaultView, v5Compat: s = !1 } = r, o = i.history, a = Bn.Pop, l = null, u = c(); u == null && (u = 0, o.replaceState(Js({}, o.state, { idx: u }), "")); function c() { return (o.state || { idx: null }).idx } function d() { a = Bn.Pop; let y = c(), p = y == null ? null : y - u; u = y, l && l({ action: a, location: m.location, delta: p }) } function h(y, p) { a = Bn.Push; let v = pd(m.location, y, p); u = c() + 1; let b = qp(v, u), x = m.createHref(v); try { o.pushState(b, "", x) } catch (P) { if (P instanceof DOMException && P.name === "DataCloneError") throw P; i.location.assign(x) } s && l && l({ action: a, location: m.location, delta: 1 }) } function f(y, p) { a = Bn.Replace; let v = pd(m.location, y, p); u = c(); let b = qp(v, u), x = m.createHref(v); o.replaceState(b, "", x), s && l && l({ action: a, location: m.location, delta: 0 }) } function g(y) { let p = i.location.origin !== "null" ? i.location.origin : i.location.href, v = typeof y == "string" ? y : ol(y); return v = v.replace(/ $/, "%20"), Te(p, "No window.location.(origin|href) available to create URL for href: " + v), new URL(v, p) } let m = { get action() { return a }, get location() { return t(i, o) }, listen(y) { if (l) throw new Error("A history only accepts one active listener"); return i.addEventListener(Wp, d), l = y, () => { i.removeEventListener(Wp, d), l = null } }, createHref(y) { return e(i, y) }, createURL: g, encodeLocation(y) { let p = g(y); return { pathname: p.pathname, search: p.search, hash: p.hash } }, push: h, replace: f, go(y) { return o.go(y) } }; return m } var Kp; (function (t) { t.data = "data", t.deferred = "deferred", t.redirect = "redirect", t.error = "error" })(Kp || (Kp = {})); function FS(t, e, n) { return n === void 0 && (n = "/"), $S(t, e, n, !1) } function $S(t, e, n, r) { let i = typeof e == "string" ? $i(e) : e, s = Nh(i.pathname || "/", n); if (s == null) return null; let o = R0(t); zS(o); let a = null; for (let l = 0; a == null && l < o.length; ++l) { let u = XS(s); a = YS(o[l], u, r) } return a } function R0(t, e, n, r) { e === void 0 && (e = []), n === void 0 && (n = []), r === void 0 && (r = ""); let i = (s, o, a) => { let l = { relativePath: a === void 0 ? s.path || "" : a, caseSensitive: s.caseSensitive === !0, childrenIndex: o, route: s }; l.relativePath.startsWith("/") && (Te(l.relativePath.startsWith(r), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(r.length)); let u = tr([r, l.relativePath]), c = n.concat(l); s.children && s.children.length > 0 && (Te(s.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + u + '".')), R0(s.children, e, c, u)), !(s.path == null && !s.index) && e.push({ path: u, score: KS(u, s.index), routesMeta: c }) }; return t.forEach((s, o) => { var a; if (s.path === "" || !((a = s.path) != null && a.includes("?"))) i(s, o); else for (let l of M0(s.path)) i(s, o, l) }), e } function M0(t) { let e = t.split("/"); if (e.length === 0) return []; let [n, ...r] = e, i = n.endsWith("?"), s = n.replace(/\?$/, ""); if (r.length === 0) return i ? [s, ""] : [s]; let o = M0(r.join("/")), a = []; return a.push(...o.map(l => l === "" ? s : [s, l].join("/"))), i && a.push(...o), a.map(l => t.startsWith("/") && l === "" ? "/" : l) } function zS(t) { t.sort((e, n) => e.score !== n.score ? n.score - e.score : GS(e.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex))) } const VS = /^:[\w-]+$/, BS = 3, US = 2, HS = 1, WS = 10, qS = -2, Gp = t => t === "*"; function KS(t, e) { let n = t.split("/"), r = n.length; return n.some(Gp) && (r += qS), e && (r += US), n.filter(i => !Gp(i)).reduce((i, s) => i + (VS.test(s) ? BS : s === "" ? HS : WS), r) } function GS(t, e) { return t.length === e.length && t.slice(0, -1).every((r, i) => r === e[i]) ? t[t.length - 1] - e[e.length - 1] : 0 } function YS(t, e, n) { let { routesMeta: r } = t, i = {}, s = "/", o = []; for (let a = 0; a < r.length; ++a) { let l = r[a], u = a === r.length - 1, c = s === "/" ? e : e.slice(s.length) || "/", d = Yp({ path: l.relativePath, caseSensitive: l.caseSensitive, end: u }, c), h = l.route; if (!d && u && n && !r[r.length - 1].route.index && (d = Yp({ path: l.relativePath, caseSensitive: l.caseSensitive, end: !1 }, c)), !d) return null; Object.assign(i, d.params), o.push({ params: i, pathname: tr([s, d.pathname]), pathnameBase: t1(tr([s, d.pathnameBase])), route: h }), d.pathnameBase !== "/" && (s = tr([s, d.pathnameBase])) } return o } function Yp(t, e) { typeof t == "string" && (t = { path: t, caseSensitive: !1, end: !0 }); let [n, r] = QS(t.path, t.caseSensitive, t.end), i = e.match(n); if (!i) return null; let s = i[0], o = s.replace(/(.)\/+$/, "$1"), a = i.slice(1); return { params: r.reduce((u, c, d) => { let { paramName: h, isOptional: f } = c; if (h === "*") { let m = a[d] || ""; o = s.slice(0, s.length - m.length).replace(/(.)\/+$/, "$1") } const g = a[d]; return f && !g ? u[h] = void 0 : u[h] = (g || "").replace(/%2F/g, "/"), u }, {}), pathname: s, pathnameBase: o, pattern: t } } function QS(t, e, n) { e === void 0 && (e = !1), n === void 0 && (n = !0), I0(t === "*" || !t.endsWith("*") || t.endsWith("/*"), 'Route path "' + t + '" will be treated as if it were ' + ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + t.replace(/\*$/, "/*") + '".')); let r = [], i = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, a, l) => (r.push({ paramName: a, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")); return t.endsWith("*") ? (r.push({ paramName: "*" }), i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : t !== "" && t !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, e ? void 0 : "i"), r] } function XS(t) { try { return t.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/") } catch (e) { return I0(!1, 'The URL path "' + t + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), t } } function Nh(t, e) { if (e === "/") return t; if (!t.toLowerCase().startsWith(e.toLowerCase())) return null; let n = e.endsWith("/") ? e.length - 1 : e.length, r = t.charAt(n); return r && r !== "/" ? null : t.slice(n) || "/" } function JS(t, e) { e === void 0 && (e = "/"); let { pathname: n, search: r = "", hash: i = "" } = typeof t == "string" ? $i(t) : t; return { pathname: n ? n.startsWith("/") ? n : ZS(n, e) : e, search: n1(r), hash: r1(i) } } function ZS(t, e) { let n = e.replace(/\/+$/, "").split("/"); return t.split("/").forEach(i => { i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i) }), n.length > 1 ? n.join("/") : "/" } function Ku(t, e, n, r) { return "Cannot include a '" + t + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function e1(t) { return t.filter((e, n) => n === 0 || e.route.path && e.route.path.length > 0) } function Fh(t, e) { let n = e1(t); return e ? n.map((r, i) => i === n.length - 1 ? r.pathname : r.pathnameBase) : n.map(r => r.pathnameBase) } function $h(t, e, n, r) { r === void 0 && (r = !1); let i; typeof t == "string" ? i = $i(t) : (i = Js({}, t), Te(!i.pathname || !i.pathname.includes("?"), Ku("?", "pathname", "search", i)), Te(!i.pathname || !i.pathname.includes("#"), Ku("#", "pathname", "hash", i)), Te(!i.search || !i.search.includes("#"), Ku("#", "search", "hash", i))); let s = t === "" || i.pathname === "", o = s ? "/" : i.pathname, a; if (o == null) a = n; else { let d = e.length - 1; if (!r && o.startsWith("..")) { let h = o.split("/"); for (; h[0] === "..";)h.shift(), d -= 1; i.pathname = h.join("/") } a = d >= 0 ? e[d] : "/" } let l = JS(i, a), u = o && o !== "/" && o.endsWith("/"), c = (s || o === ".") && n.endsWith("/"); return !l.pathname.endsWith("/") && (u || c) && (l.pathname += "/"), l } const tr = t => t.join("/").replace(/\/\/+/g, "/"), t1 = t => t.replace(/\/+$/, "").replace(/^\/*/, "/"), n1 = t => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t, r1 = t => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t; function i1(t) { return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.internal == "boolean" && "data" in t } const L0 = ["post", "put", "patch", "delete"]; new Set(L0); const s1 = ["get", ...L0]; new Set(s1);/**
 * React Router v6.26.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Zs() { return Zs = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Zs.apply(this, arguments) } const zh = R.createContext(null), o1 = R.createContext(null), cr = R.createContext(null), Ul = R.createContext(null), dr = R.createContext({ outlet: null, matches: [], isDataRoute: !1 }), D0 = R.createContext(null); function a1(t, e) { let { relative: n } = e === void 0 ? {} : e; zi() || Te(!1); let { basename: r, navigator: i } = R.useContext(cr), { hash: s, pathname: o, search: a } = A0(t, { relative: n }), l = o; return r !== "/" && (l = o === "/" ? r : tr([r, o])), i.createHref({ pathname: l, search: a, hash: s }) } function zi() { return R.useContext(Ul) != null } function vo() { return zi() || Te(!1), R.useContext(Ul).location } function j0(t) { R.useContext(cr).static || R.useLayoutEffect(t) } function Vr() { let { isDataRoute: t } = R.useContext(dr); return t ? _1() : l1() } function l1() { zi() || Te(!1); let t = R.useContext(zh), { basename: e, future: n, navigator: r } = R.useContext(cr), { matches: i } = R.useContext(dr), { pathname: s } = vo(), o = JSON.stringify(Fh(i, n.v7_relativeSplatPath)), a = R.useRef(!1); return j0(() => { a.current = !0 }), R.useCallback(function (u, c) { if (c === void 0 && (c = {}), !a.current) return; if (typeof u == "number") { r.go(u); return } let d = $h(u, JSON.parse(o), s, c.relative === "path"); t == null && e !== "/" && (d.pathname = d.pathname === "/" ? e : tr([e, d.pathname])), (c.replace ? r.replace : r.push)(d, c.state, c) }, [e, r, o, s, t]) } function A0(t, e) { let { relative: n } = e === void 0 ? {} : e, { future: r } = R.useContext(cr), { matches: i } = R.useContext(dr), { pathname: s } = vo(), o = JSON.stringify(Fh(i, r.v7_relativeSplatPath)); return R.useMemo(() => $h(t, JSON.parse(o), s, n === "path"), [t, o, s, n]) } function u1(t, e) { return c1(t, e) } function c1(t, e, n, r) { zi() || Te(!1); let { navigator: i } = R.useContext(cr), { matches: s } = R.useContext(dr), o = s[s.length - 1], a = o ? o.params : {}; o && o.pathname; let l = o ? o.pathnameBase : "/"; o && o.route; let u = vo(), c; if (e) { var d; let y = typeof e == "string" ? $i(e) : e; l === "/" || (d = y.pathname) != null && d.startsWith(l) || Te(!1), c = y } else c = u; let h = c.pathname || "/", f = h; if (l !== "/") { let y = l.replace(/^\//, "").split("/"); f = "/" + h.replace(/^\//, "").split("/").slice(y.length).join("/") } let g = FS(t, { pathname: f }), m = g1(g && g.map(y => Object.assign({}, y, { params: Object.assign({}, a, y.params), pathname: tr([l, i.encodeLocation ? i.encodeLocation(y.pathname).pathname : y.pathname]), pathnameBase: y.pathnameBase === "/" ? l : tr([l, i.encodeLocation ? i.encodeLocation(y.pathnameBase).pathname : y.pathnameBase]) })), s, n, r); return e && m ? R.createElement(Ul.Provider, { value: { location: Zs({ pathname: "/", search: "", hash: "", state: null, key: "default" }, c), navigationType: Bn.Pop } }, m) : m } function d1() { let t = b1(), e = i1(t) ? t.status + " " + t.statusText : t instanceof Error ? t.message : JSON.stringify(t), n = t instanceof Error ? t.stack : null, i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return R.createElement(R.Fragment, null, R.createElement("h2", null, "Unexpected Application Error!"), R.createElement("h3", { style: { fontStyle: "italic" } }, e), n ? R.createElement("pre", { style: i }, n) : null, null) } const h1 = R.createElement(d1, null); class f1 extends R.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, n) { return n.location !== e.location || n.revalidation !== "idle" && e.revalidation === "idle" ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: e.error !== void 0 ? e.error : n.error, location: n.location, revalidation: e.revalidation || n.revalidation } } componentDidCatch(e, n) { console.error("React Router caught the following error during render", e, n) } render() { return this.state.error !== void 0 ? R.createElement(dr.Provider, { value: this.props.routeContext }, R.createElement(D0.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function p1(t) { let { routeContext: e, match: n, children: r } = t, i = R.useContext(zh); return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id), R.createElement(dr.Provider, { value: e }, r) } function g1(t, e, n, r) { var i; if (e === void 0 && (e = []), n === void 0 && (n = null), r === void 0 && (r = null), t == null) { var s; if (!n) return null; if (n.errors) t = n.matches; else if ((s = r) != null && s.v7_partialHydration && e.length === 0 && !n.initialized && n.matches.length > 0) t = n.matches; else return null } let o = t, a = (i = n) == null ? void 0 : i.errors; if (a != null) { let c = o.findIndex(d => d.route.id && (a == null ? void 0 : a[d.route.id]) !== void 0); c >= 0 || Te(!1), o = o.slice(0, Math.min(o.length, c + 1)) } let l = !1, u = -1; if (n && r && r.v7_partialHydration) for (let c = 0; c < o.length; c++) { let d = o[c]; if ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (u = c), d.route.id) { let { loaderData: h, errors: f } = n, g = d.route.loader && h[d.route.id] === void 0 && (!f || f[d.route.id] === void 0); if (d.route.lazy || g) { l = !0, u >= 0 ? o = o.slice(0, u + 1) : o = [o[0]]; break } } } return o.reduceRight((c, d, h) => { let f, g = !1, m = null, y = null; n && (f = a && d.route.id ? a[d.route.id] : void 0, m = d.route.errorElement || h1, l && (u < 0 && h === 0 ? (g = !0, y = null) : u === h && (g = !0, y = d.route.hydrateFallbackElement || null))); let p = e.concat(o.slice(0, h + 1)), v = () => { let b; return f ? b = m : g ? b = y : d.route.Component ? b = R.createElement(d.route.Component, null) : d.route.element ? b = d.route.element : b = c, R.createElement(p1, { match: d, routeContext: { outlet: c, matches: p, isDataRoute: n != null }, children: b }) }; return n && (d.route.ErrorBoundary || d.route.errorElement || h === 0) ? R.createElement(f1, { location: n.location, revalidation: n.revalidation, component: m, error: f, children: v(), routeContext: { outlet: null, matches: p, isDataRoute: !0 } }) : v() }, null) } var N0 = function (t) { return t.UseBlocker = "useBlocker", t.UseRevalidator = "useRevalidator", t.UseNavigateStable = "useNavigate", t }(N0 || {}), al = function (t) { return t.UseBlocker = "useBlocker", t.UseLoaderData = "useLoaderData", t.UseActionData = "useActionData", t.UseRouteError = "useRouteError", t.UseNavigation = "useNavigation", t.UseRouteLoaderData = "useRouteLoaderData", t.UseMatches = "useMatches", t.UseRevalidator = "useRevalidator", t.UseNavigateStable = "useNavigate", t.UseRouteId = "useRouteId", t }(al || {}); function m1(t) { let e = R.useContext(zh); return e || Te(!1), e } function v1(t) { let e = R.useContext(o1); return e || Te(!1), e } function y1(t) { let e = R.useContext(dr); return e || Te(!1), e } function F0(t) { let e = y1(), n = e.matches[e.matches.length - 1]; return n.route.id || Te(!1), n.route.id } function b1() { var t; let e = R.useContext(D0), n = v1(al.UseRouteError), r = F0(al.UseRouteError); return e !== void 0 ? e : (t = n.errors) == null ? void 0 : t[r] } function _1() { let { router: t } = m1(N0.UseNavigateStable), e = F0(al.UseNavigateStable), n = R.useRef(!1); return j0(() => { n.current = !0 }), R.useCallback(function (i, s) { s === void 0 && (s = {}), n.current && (typeof i == "number" ? t.navigate(i) : t.navigate(i, Zs({ fromRouteId: e }, s))) }, [t, e]) } function Rn(t) { let { to: e, replace: n, state: r, relative: i } = t; zi() || Te(!1); let { future: s, static: o } = R.useContext(cr), { matches: a } = R.useContext(dr), { pathname: l } = vo(), u = Vr(), c = $h(e, Fh(a, s.v7_relativeSplatPath), l, i === "path"), d = JSON.stringify(c); return R.useEffect(() => u(JSON.parse(d), { replace: n, state: r, relative: i }), [u, d, i, n, r]), null } function Jt(t) { Te(!1) } function w1(t) { let { basename: e = "/", children: n = null, location: r, navigationType: i = Bn.Pop, navigator: s, static: o = !1, future: a } = t; zi() && Te(!1); let l = e.replace(/^\/*/, "/"), u = R.useMemo(() => ({ basename: l, navigator: s, static: o, future: Zs({ v7_relativeSplatPath: !1 }, a) }), [l, a, s, o]); typeof r == "string" && (r = $i(r)); let { pathname: c = "/", search: d = "", hash: h = "", state: f = null, key: g = "default" } = r, m = R.useMemo(() => { let y = Nh(c, l); return y == null ? null : { location: { pathname: y, search: d, hash: h, state: f, key: g }, navigationType: i } }, [l, c, d, h, f, g, i]); return m == null ? null : R.createElement(cr.Provider, { value: u }, R.createElement(Ul.Provider, { children: n, value: m })) } function x1(t) { let { children: e, location: n } = t; return u1(gd(e), n) } new Promise(() => { }); function gd(t, e) { e === void 0 && (e = []); let n = []; return R.Children.forEach(t, (r, i) => { if (!R.isValidElement(r)) return; let s = [...e, i]; if (r.type === R.Fragment) { n.push.apply(n, gd(r.props.children, s)); return } r.type !== Jt && Te(!1), !r.props.index || !r.props.children || Te(!1); let o = { id: r.props.id || s.join("-"), caseSensitive: r.props.caseSensitive, element: r.props.element, Component: r.props.Component, index: r.props.index, path: r.props.path, loader: r.props.loader, action: r.props.action, errorElement: r.props.errorElement, ErrorBoundary: r.props.ErrorBoundary, hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null, shouldRevalidate: r.props.shouldRevalidate, handle: r.props.handle, lazy: r.props.lazy }; r.props.children && (o.children = gd(r.props.children, s)), n.push(o) }), n }/**
 * React Router DOM v6.26.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function md() { return md = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, md.apply(this, arguments) } function S1(t, e) { if (t == null) return {}; var n = {}, r = Object.keys(t), i, s; for (s = 0; s < r.length; s++)i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]); return n } function k1(t) { return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) } function C1(t, e) { return t.button === 0 && (!e || e === "_self") && !k1(t) } const O1 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"], P1 = "6"; try { window.__reactRouterVersion = P1 } catch { } const E1 = "startTransition", Qp = wc[E1]; function T1(t) { let { basename: e, children: n, future: r, window: i } = t, s = R.useRef(); s.current == null && (s.current = jS({ window: i, v5Compat: !0 })); let o = s.current, [a, l] = R.useState({ action: o.action, location: o.location }), { v7_startTransition: u } = r || {}, c = R.useCallback(d => { u && Qp ? Qp(() => l(d)) : l(d) }, [l, u]); return R.useLayoutEffect(() => o.listen(c), [o, c]), R.createElement(w1, { basename: e, children: n, location: a.location, navigationType: a.action, navigator: o, future: r }) } const I1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", R1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Et = R.forwardRef(function (e, n) { let { onClick: r, relative: i, reloadDocument: s, replace: o, state: a, target: l, to: u, preventScrollReset: c, unstable_viewTransition: d } = e, h = S1(e, O1), { basename: f } = R.useContext(cr), g, m = !1; if (typeof u == "string" && R1.test(u) && (g = u, I1)) try { let b = new URL(window.location.href), x = u.startsWith("//") ? new URL(b.protocol + u) : new URL(u), P = Nh(x.pathname, f); x.origin === b.origin && P != null ? u = P + x.search + x.hash : m = !0 } catch { } let y = a1(u, { relative: i }), p = M1(u, { replace: o, state: a, target: l, preventScrollReset: c, relative: i, unstable_viewTransition: d }); function v(b) { r && r(b), b.defaultPrevented || p(b) } return R.createElement("a", md({}, h, { href: g || y, onClick: m || s ? r : v, ref: n, target: l })) }); var Xp; (function (t) { t.UseScrollRestoration = "useScrollRestoration", t.UseSubmit = "useSubmit", t.UseSubmitFetcher = "useSubmitFetcher", t.UseFetcher = "useFetcher", t.useViewTransitionState = "useViewTransitionState" })(Xp || (Xp = {})); var Jp; (function (t) { t.UseFetcher = "useFetcher", t.UseFetchers = "useFetchers", t.UseScrollRestoration = "useScrollRestoration" })(Jp || (Jp = {})); function M1(t, e) { let { target: n, replace: r, state: i, preventScrollReset: s, relative: o, unstable_viewTransition: a } = e === void 0 ? {} : e, l = Vr(), u = vo(), c = A0(t, { relative: o }); return R.useCallback(d => { if (C1(d, n)) { d.preventDefault(); let h = r !== void 0 ? r : ol(u) === ol(c); l(t, { replace: h, state: i, preventScrollReset: s, relative: o, unstable_viewTransition: a }) } }, [u, l, c, r, i, n, t, s, o, a]) } const L1 = "modulepreload", D1 = function (t) { return "/" + t }, Zp = {}, Ii = function (e, n, r) { let i = Promise.resolve(); if (n && n.length > 0) { document.getElementsByTagName("link"); const s = document.querySelector("meta[property=csp-nonce]"), o = (s == null ? void 0 : s.nonce) || (s == null ? void 0 : s.getAttribute("nonce")); i = Promise.all(n.map(a => { if (a = D1(a), a in Zp) return; Zp[a] = !0; const l = a.endsWith(".css"), u = l ? '[rel="stylesheet"]' : ""; if (document.querySelector(`link[href="${a}"]${u}`)) return; const c = document.createElement("link"); if (c.rel = l ? "stylesheet" : L1, l || (c.as = "script", c.crossOrigin = ""), c.href = a, o && c.setAttribute("nonce", o), document.head.appendChild(c), l) return new Promise((d, h) => { c.addEventListener("load", d), c.addEventListener("error", () => h(new Error(`Unable to preload CSS for ${a}`))) }) })) } return i.then(() => e()).catch(s => { const o = new Event("vite:preloadError", { cancelable: !0 }); if (o.payload = s, window.dispatchEvent(o), !o.defaultPrevented) throw s }) }, j1 = t => { let e; return t ? e = t : typeof fetch > "u" ? e = (...n) => Ii(async () => { const { default: r } = await Promise.resolve().then(() => Vi); return { default: r } }, void 0).then(({ default: r }) => r(...n)) : e = fetch, (...n) => e(...n) }; class Vh extends Error { constructor(e, n = "FunctionsError", r) { super(e), this.name = n, this.context = r } } class A1 extends Vh { constructor(e) { super("Failed to send a request to the Edge Function", "FunctionsFetchError", e) } } class N1 extends Vh { constructor(e) { super("Relay Error invoking the Edge Function", "FunctionsRelayError", e) } } class F1 extends Vh { constructor(e) { super("Edge Function returned a non-2xx status code", "FunctionsHttpError", e) } } var vd; (function (t) { t.Any = "any", t.ApNortheast1 = "ap-northeast-1", t.ApNortheast2 = "ap-northeast-2", t.ApSouth1 = "ap-south-1", t.ApSoutheast1 = "ap-southeast-1", t.ApSoutheast2 = "ap-southeast-2", t.CaCentral1 = "ca-central-1", t.EuCentral1 = "eu-central-1", t.EuWest1 = "eu-west-1", t.EuWest2 = "eu-west-2", t.EuWest3 = "eu-west-3", t.SaEast1 = "sa-east-1", t.UsEast1 = "us-east-1", t.UsWest1 = "us-west-1", t.UsWest2 = "us-west-2" })(vd || (vd = {})); var $1 = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; class z1 { constructor(e, { headers: n = {}, customFetch: r, region: i = vd.Any } = {}) { this.url = e, this.headers = n, this.region = i, this.fetch = j1(r) } setAuth(e) { this.headers.Authorization = `Bearer ${e}` } invoke(e, n = {}) { var r; return $1(this, void 0, void 0, function* () { try { const { headers: i, method: s, body: o } = n; let a = {}, { region: l } = n; l || (l = this.region), l && l !== "any" && (a["x-region"] = l); let u; o && (i && !Object.prototype.hasOwnProperty.call(i, "Content-Type") || !i) && (typeof Blob < "u" && o instanceof Blob || o instanceof ArrayBuffer ? (a["Content-Type"] = "application/octet-stream", u = o) : typeof o == "string" ? (a["Content-Type"] = "text/plain", u = o) : typeof FormData < "u" && o instanceof FormData ? u = o : (a["Content-Type"] = "application/json", u = JSON.stringify(o))); const c = yield this.fetch(`${this.url}/${e}`, { method: s || "POST", headers: Object.assign(Object.assign(Object.assign({}, a), this.headers), i), body: u }).catch(g => { throw new A1(g) }), d = c.headers.get("x-relay-error"); if (d && d === "true") throw new N1(c); if (!c.ok) throw new F1(c); let h = ((r = c.headers.get("Content-Type")) !== null && r !== void 0 ? r : "text/plain").split(";")[0].trim(), f; return h === "application/json" ? f = yield c.json() : h === "application/octet-stream" ? f = yield c.blob() : h === "text/event-stream" ? f = c : h === "multipart/form-data" ? f = yield c.formData() : f = yield c.text(), { data: f, error: null } } catch (i) { return { data: null, error: i } } }) } } var Rt = {}, Bh = {}, Hl = {}, yo = {}, Wl = {}, ql = {}, V1 = function () { if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("unable to locate global object") }, Ri = V1(); const B1 = Ri.fetch, $0 = Ri.fetch.bind(Ri), z0 = Ri.Headers, U1 = Ri.Request, H1 = Ri.Response, Vi = Object.freeze(Object.defineProperty({ __proto__: null, Headers: z0, Request: U1, Response: H1, default: $0, fetch: B1 }, Symbol.toStringTag, { value: "Module" })), W1 = uw(Vi); var Uh = {}; Object.defineProperty(Uh, "__esModule", { value: !0 }); class q1 extends Error { constructor(e) { super(e.message), this.name = "PostgrestError", this.details = e.details, this.hint = e.hint, this.code = e.code } } Uh.default = q1; var V0 = At && At.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(ql, "__esModule", { value: !0 }); const K1 = V0(W1), G1 = V0(Uh); let Y1 = class { constructor(e) { this.shouldThrowOnError = !1, this.method = e.method, this.url = e.url, this.headers = e.headers, this.schema = e.schema, this.body = e.body, this.shouldThrowOnError = e.shouldThrowOnError, this.signal = e.signal, this.isMaybeSingle = e.isMaybeSingle, e.fetch ? this.fetch = e.fetch : typeof fetch > "u" ? this.fetch = K1.default : this.fetch = fetch } throwOnError() { return this.shouldThrowOnError = !0, this } then(e, n) { this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers["Accept-Profile"] = this.schema : this.headers["Content-Profile"] = this.schema), this.method !== "GET" && this.method !== "HEAD" && (this.headers["Content-Type"] = "application/json"); const r = this.fetch; let i = r(this.url.toString(), { method: this.method, headers: this.headers, body: JSON.stringify(this.body), signal: this.signal }).then(async s => { var o, a, l; let u = null, c = null, d = null, h = s.status, f = s.statusText; if (s.ok) { if (this.method !== "HEAD") { const p = await s.text(); p === "" || (this.headers.Accept === "text/csv" || this.headers.Accept && this.headers.Accept.includes("application/vnd.pgrst.plan+text") ? c = p : c = JSON.parse(p)) } const m = (o = this.headers.Prefer) === null || o === void 0 ? void 0 : o.match(/count=(exact|planned|estimated)/), y = (a = s.headers.get("content-range")) === null || a === void 0 ? void 0 : a.split("/"); m && y && y.length > 1 && (d = parseInt(y[1])), this.isMaybeSingle && this.method === "GET" && Array.isArray(c) && (c.length > 1 ? (u = { code: "PGRST116", details: `Results contain ${c.length} rows, application/vnd.pgrst.object+json requires 1 row`, hint: null, message: "JSON object requested, multiple (or no) rows returned" }, c = null, d = null, h = 406, f = "Not Acceptable") : c.length === 1 ? c = c[0] : c = null) } else { const m = await s.text(); try { u = JSON.parse(m), Array.isArray(u) && s.status === 404 && (c = [], u = null, h = 200, f = "OK") } catch { s.status === 404 && m === "" ? (h = 204, f = "No Content") : u = { message: m } } if (u && this.isMaybeSingle && (!((l = u == null ? void 0 : u.details) === null || l === void 0) && l.includes("0 rows")) && (u = null, h = 200, f = "OK"), u && this.shouldThrowOnError) throw new G1.default(u) } return { error: u, data: c, count: d, status: h, statusText: f } }); return this.shouldThrowOnError || (i = i.catch(s => { var o, a, l; return { error: { message: `${(o = s == null ? void 0 : s.name) !== null && o !== void 0 ? o : "FetchError"}: ${s == null ? void 0 : s.message}`, details: `${(a = s == null ? void 0 : s.stack) !== null && a !== void 0 ? a : ""}`, hint: "", code: `${(l = s == null ? void 0 : s.code) !== null && l !== void 0 ? l : ""}` }, data: null, count: null, status: 0, statusText: "" } })), i.then(e, n) } }; ql.default = Y1; var Q1 = At && At.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(Wl, "__esModule", { value: !0 }); const X1 = Q1(ql); let J1 = class extends X1.default { select(e) { let n = !1; const r = (e ?? "*").split("").map(i => /\s/.test(i) && !n ? "" : (i === '"' && (n = !n), i)).join(""); return this.url.searchParams.set("select", r), this.headers.Prefer && (this.headers.Prefer += ","), this.headers.Prefer += "return=representation", this } order(e, { ascending: n = !0, nullsFirst: r, foreignTable: i, referencedTable: s = i } = {}) { const o = s ? `${s}.order` : "order", a = this.url.searchParams.get(o); return this.url.searchParams.set(o, `${a ? `${a},` : ""}${e}.${n ? "asc" : "desc"}${r === void 0 ? "" : r ? ".nullsfirst" : ".nullslast"}`), this } limit(e, { foreignTable: n, referencedTable: r = n } = {}) { const i = typeof r > "u" ? "limit" : `${r}.limit`; return this.url.searchParams.set(i, `${e}`), this } range(e, n, { foreignTable: r, referencedTable: i = r } = {}) { const s = typeof i > "u" ? "offset" : `${i}.offset`, o = typeof i > "u" ? "limit" : `${i}.limit`; return this.url.searchParams.set(s, `${e}`), this.url.searchParams.set(o, `${n - e + 1}`), this } abortSignal(e) { return this.signal = e, this } single() { return this.headers.Accept = "application/vnd.pgrst.object+json", this } maybeSingle() { return this.method === "GET" ? this.headers.Accept = "application/json" : this.headers.Accept = "application/vnd.pgrst.object+json", this.isMaybeSingle = !0, this } csv() { return this.headers.Accept = "text/csv", this } geojson() { return this.headers.Accept = "application/geo+json", this } explain({ analyze: e = !1, verbose: n = !1, settings: r = !1, buffers: i = !1, wal: s = !1, format: o = "text" } = {}) { var a; const l = [e ? "analyze" : null, n ? "verbose" : null, r ? "settings" : null, i ? "buffers" : null, s ? "wal" : null].filter(Boolean).join("|"), u = (a = this.headers.Accept) !== null && a !== void 0 ? a : "application/json"; return this.headers.Accept = `application/vnd.pgrst.plan+${o}; for="${u}"; options=${l};`, o === "json" ? this : this } rollback() { var e; return ((e = this.headers.Prefer) !== null && e !== void 0 ? e : "").trim().length > 0 ? this.headers.Prefer += ",tx=rollback" : this.headers.Prefer = "tx=rollback", this } returns() { return this } }; Wl.default = J1; var Z1 = At && At.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(yo, "__esModule", { value: !0 }); const ek = Z1(Wl); let tk = class extends ek.default { eq(e, n) { return this.url.searchParams.append(e, `eq.${n}`), this } neq(e, n) { return this.url.searchParams.append(e, `neq.${n}`), this } gt(e, n) { return this.url.searchParams.append(e, `gt.${n}`), this } gte(e, n) { return this.url.searchParams.append(e, `gte.${n}`), this } lt(e, n) { return this.url.searchParams.append(e, `lt.${n}`), this } lte(e, n) { return this.url.searchParams.append(e, `lte.${n}`), this } like(e, n) { return this.url.searchParams.append(e, `like.${n}`), this } likeAllOf(e, n) { return this.url.searchParams.append(e, `like(all).{${n.join(",")}}`), this } likeAnyOf(e, n) { return this.url.searchParams.append(e, `like(any).{${n.join(",")}}`), this } ilike(e, n) { return this.url.searchParams.append(e, `ilike.${n}`), this } ilikeAllOf(e, n) { return this.url.searchParams.append(e, `ilike(all).{${n.join(",")}}`), this } ilikeAnyOf(e, n) { return this.url.searchParams.append(e, `ilike(any).{${n.join(",")}}`), this } is(e, n) { return this.url.searchParams.append(e, `is.${n}`), this } in(e, n) { const r = Array.from(new Set(n)).map(i => typeof i == "string" && new RegExp("[,()]").test(i) ? `"${i}"` : `${i}`).join(","); return this.url.searchParams.append(e, `in.(${r})`), this } contains(e, n) { return typeof n == "string" ? this.url.searchParams.append(e, `cs.${n}`) : Array.isArray(n) ? this.url.searchParams.append(e, `cs.{${n.join(",")}}`) : this.url.searchParams.append(e, `cs.${JSON.stringify(n)}`), this } containedBy(e, n) { return typeof n == "string" ? this.url.searchParams.append(e, `cd.${n}`) : Array.isArray(n) ? this.url.searchParams.append(e, `cd.{${n.join(",")}}`) : this.url.searchParams.append(e, `cd.${JSON.stringify(n)}`), this } rangeGt(e, n) { return this.url.searchParams.append(e, `sr.${n}`), this } rangeGte(e, n) { return this.url.searchParams.append(e, `nxl.${n}`), this } rangeLt(e, n) { return this.url.searchParams.append(e, `sl.${n}`), this } rangeLte(e, n) { return this.url.searchParams.append(e, `nxr.${n}`), this } rangeAdjacent(e, n) { return this.url.searchParams.append(e, `adj.${n}`), this } overlaps(e, n) { return typeof n == "string" ? this.url.searchParams.append(e, `ov.${n}`) : this.url.searchParams.append(e, `ov.{${n.join(",")}}`), this } textSearch(e, n, { config: r, type: i } = {}) { let s = ""; i === "plain" ? s = "pl" : i === "phrase" ? s = "ph" : i === "websearch" && (s = "w"); const o = r === void 0 ? "" : `(${r})`; return this.url.searchParams.append(e, `${s}fts${o}.${n}`), this } match(e) { return Object.entries(e).forEach(([n, r]) => { this.url.searchParams.append(n, `eq.${r}`) }), this } not(e, n, r) { return this.url.searchParams.append(e, `not.${n}.${r}`), this } or(e, { foreignTable: n, referencedTable: r = n } = {}) { const i = r ? `${r}.or` : "or"; return this.url.searchParams.append(i, `(${e})`), this } filter(e, n, r) { return this.url.searchParams.append(e, `${n}.${r}`), this } }; yo.default = tk; var nk = At && At.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(Hl, "__esModule", { value: !0 }); const ts = nk(yo); let rk = class { constructor(e, { headers: n = {}, schema: r, fetch: i }) { this.url = e, this.headers = n, this.schema = r, this.fetch = i } select(e, { head: n = !1, count: r } = {}) { const i = n ? "HEAD" : "GET"; let s = !1; const o = (e ?? "*").split("").map(a => /\s/.test(a) && !s ? "" : (a === '"' && (s = !s), a)).join(""); return this.url.searchParams.set("select", o), r && (this.headers.Prefer = `count=${r}`), new ts.default({ method: i, url: this.url, headers: this.headers, schema: this.schema, fetch: this.fetch, allowEmpty: !1 }) } insert(e, { count: n, defaultToNull: r = !0 } = {}) { const i = "POST", s = []; if (this.headers.Prefer && s.push(this.headers.Prefer), n && s.push(`count=${n}`), r || s.push("missing=default"), this.headers.Prefer = s.join(","), Array.isArray(e)) { const o = e.reduce((a, l) => a.concat(Object.keys(l)), []); if (o.length > 0) { const a = [...new Set(o)].map(l => `"${l}"`); this.url.searchParams.set("columns", a.join(",")) } } return new ts.default({ method: i, url: this.url, headers: this.headers, schema: this.schema, body: e, fetch: this.fetch, allowEmpty: !1 }) } upsert(e, { onConflict: n, ignoreDuplicates: r = !1, count: i, defaultToNull: s = !0 } = {}) { const o = "POST", a = [`resolution=${r ? "ignore" : "merge"}-duplicates`]; if (n !== void 0 && this.url.searchParams.set("on_conflict", n), this.headers.Prefer && a.push(this.headers.Prefer), i && a.push(`count=${i}`), s || a.push("missing=default"), this.headers.Prefer = a.join(","), Array.isArray(e)) { const l = e.reduce((u, c) => u.concat(Object.keys(c)), []); if (l.length > 0) { const u = [...new Set(l)].map(c => `"${c}"`); this.url.searchParams.set("columns", u.join(",")) } } return new ts.default({ method: o, url: this.url, headers: this.headers, schema: this.schema, body: e, fetch: this.fetch, allowEmpty: !1 }) } update(e, { count: n } = {}) { const r = "PATCH", i = []; return this.headers.Prefer && i.push(this.headers.Prefer), n && i.push(`count=${n}`), this.headers.Prefer = i.join(","), new ts.default({ method: r, url: this.url, headers: this.headers, schema: this.schema, body: e, fetch: this.fetch, allowEmpty: !1 }) } delete({ count: e } = {}) { const n = "DELETE", r = []; return e && r.push(`count=${e}`), this.headers.Prefer && r.unshift(this.headers.Prefer), this.headers.Prefer = r.join(","), new ts.default({ method: n, url: this.url, headers: this.headers, schema: this.schema, fetch: this.fetch, allowEmpty: !1 }) } }; Hl.default = rk; var Kl = {}, Gl = {}; Object.defineProperty(Gl, "__esModule", { value: !0 }); Gl.version = void 0; Gl.version = "0.0.0-automated"; Object.defineProperty(Kl, "__esModule", { value: !0 }); Kl.DEFAULT_HEADERS = void 0; const ik = Gl; Kl.DEFAULT_HEADERS = { "X-Client-Info": `postgrest-js/${ik.version}` }; var B0 = At && At.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(Bh, "__esModule", { value: !0 }); const sk = B0(Hl), ok = B0(yo), ak = Kl; let lk = class U0 { constructor(e, { headers: n = {}, schema: r, fetch: i } = {}) { this.url = e, this.headers = Object.assign(Object.assign({}, ak.DEFAULT_HEADERS), n), this.schemaName = r, this.fetch = i } from(e) { const n = new URL(`${this.url}/${e}`); return new sk.default(n, { headers: Object.assign({}, this.headers), schema: this.schemaName, fetch: this.fetch }) } schema(e) { return new U0(this.url, { headers: this.headers, schema: e, fetch: this.fetch }) } rpc(e, n = {}, { head: r = !1, get: i = !1, count: s } = {}) { let o; const a = new URL(`${this.url}/rpc/${e}`); let l; r || i ? (o = r ? "HEAD" : "GET", Object.entries(n).filter(([c, d]) => d !== void 0).map(([c, d]) => [c, Array.isArray(d) ? `{${d.join(",")}}` : `${d}`]).forEach(([c, d]) => { a.searchParams.append(c, d) })) : (o = "POST", l = n); const u = Object.assign({}, this.headers); return s && (u.Prefer = `count=${s}`), new ok.default({ method: o, url: a, headers: u, schema: this.schemaName, body: l, fetch: this.fetch, allowEmpty: !1 }) } }; Bh.default = lk; var bo = At && At.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(Rt, "__esModule", { value: !0 }); Rt.PostgrestBuilder = Rt.PostgrestTransformBuilder = Rt.PostgrestFilterBuilder = Rt.PostgrestQueryBuilder = Rt.PostgrestClient = void 0; const H0 = bo(Bh); Rt.PostgrestClient = H0.default; const W0 = bo(Hl); Rt.PostgrestQueryBuilder = W0.default; const q0 = bo(yo); Rt.PostgrestFilterBuilder = q0.default; const K0 = bo(Wl); Rt.PostgrestTransformBuilder = K0.default; const G0 = bo(ql); Rt.PostgrestBuilder = G0.default; var uk = Rt.default = { PostgrestClient: H0.default, PostgrestQueryBuilder: W0.default, PostgrestFilterBuilder: q0.default, PostgrestTransformBuilder: K0.default, PostgrestBuilder: G0.default }; const { PostgrestClient: ck, PostgrestQueryBuilder: QD, PostgrestFilterBuilder: XD, PostgrestTransformBuilder: JD, PostgrestBuilder: ZD } = uk, dk = "2.10.2", hk = { "X-Client-Info": `realtime-js/${dk}` }, fk = "1.0.0", Y0 = 1e4, pk = 1e3; var _i; (function (t) { t[t.connecting = 0] = "connecting", t[t.open = 1] = "open", t[t.closing = 2] = "closing", t[t.closed = 3] = "closed" })(_i || (_i = {})); var gt; (function (t) { t.closed = "closed", t.errored = "errored", t.joined = "joined", t.joining = "joining", t.leaving = "leaving" })(gt || (gt = {})); var Ht; (function (t) { t.close = "phx_close", t.error = "phx_error", t.join = "phx_join", t.reply = "phx_reply", t.leave = "phx_leave", t.access_token = "access_token" })(Ht || (Ht = {})); var yd; (function (t) { t.websocket = "websocket" })(yd || (yd = {})); var Sr; (function (t) { t.Connecting = "connecting", t.Open = "open", t.Closing = "closing", t.Closed = "closed" })(Sr || (Sr = {})); class gk { constructor() { this.HEADER_LENGTH = 1 } decode(e, n) { return e.constructor === ArrayBuffer ? n(this._binaryDecode(e)) : n(typeof e == "string" ? JSON.parse(e) : {}) } _binaryDecode(e) { const n = new DataView(e), r = new TextDecoder; return this._decodeBroadcast(e, n, r) } _decodeBroadcast(e, n, r) { const i = n.getUint8(1), s = n.getUint8(2); let o = this.HEADER_LENGTH + 2; const a = r.decode(e.slice(o, o + i)); o = o + i; const l = r.decode(e.slice(o, o + s)); o = o + s; const u = JSON.parse(r.decode(e.slice(o, e.byteLength))); return { ref: null, topic: a, event: l, payload: u } } } class Q0 { constructor(e, n) { this.callback = e, this.timerCalc = n, this.timer = void 0, this.tries = 0, this.callback = e, this.timerCalc = n } reset() { this.tries = 0, clearTimeout(this.timer) } scheduleTimeout() { clearTimeout(this.timer), this.timer = setTimeout(() => { this.tries = this.tries + 1, this.callback() }, this.timerCalc(this.tries + 1)) } } var pe; (function (t) { t.abstime = "abstime", t.bool = "bool", t.date = "date", t.daterange = "daterange", t.float4 = "float4", t.float8 = "float8", t.int2 = "int2", t.int4 = "int4", t.int4range = "int4range", t.int8 = "int8", t.int8range = "int8range", t.json = "json", t.jsonb = "jsonb", t.money = "money", t.numeric = "numeric", t.oid = "oid", t.reltime = "reltime", t.text = "text", t.time = "time", t.timestamp = "timestamp", t.timestamptz = "timestamptz", t.timetz = "timetz", t.tsrange = "tsrange", t.tstzrange = "tstzrange" })(pe || (pe = {})); const eg = (t, e, n = {}) => { var r; const i = (r = n.skipTypes) !== null && r !== void 0 ? r : []; return Object.keys(e).reduce((s, o) => (s[o] = mk(o, t, e, i), s), {}) }, mk = (t, e, n, r) => { const i = e.find(a => a.name === t), s = i == null ? void 0 : i.type, o = n[t]; return s && !r.includes(s) ? X0(s, o) : bd(o) }, X0 = (t, e) => { if (t.charAt(0) === "_") { const n = t.slice(1, t.length); return _k(e, n) } switch (t) { case pe.bool: return vk(e); case pe.float4: case pe.float8: case pe.int2: case pe.int4: case pe.int8: case pe.numeric: case pe.oid: return yk(e); case pe.json: case pe.jsonb: return bk(e); case pe.timestamp: return wk(e); case pe.abstime: case pe.date: case pe.daterange: case pe.int4range: case pe.int8range: case pe.money: case pe.reltime: case pe.text: case pe.time: case pe.timestamptz: case pe.timetz: case pe.tsrange: case pe.tstzrange: return bd(e); default: return bd(e) } }, bd = t => t, vk = t => { switch (t) { case "t": return !0; case "f": return !1; default: return t } }, yk = t => { if (typeof t == "string") { const e = parseFloat(t); if (!Number.isNaN(e)) return e } return t }, bk = t => { if (typeof t == "string") try { return JSON.parse(t) } catch (e) { return console.log(`JSON parse error: ${e}`), t } return t }, _k = (t, e) => { if (typeof t != "string") return t; const n = t.length - 1, r = t[n]; if (t[0] === "{" && r === "}") { let s; const o = t.slice(1, n); try { s = JSON.parse("[" + o + "]") } catch { s = o ? o.split(",") : [] } return s.map(a => X0(e, a)) } return t }, wk = t => typeof t == "string" ? t.replace(" ", "T") : t, J0 = t => { let e = t; return e = e.replace(/^ws/i, "http"), e = e.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, ""), e.replace(/\/+$/, "") }; class Gu { constructor(e, n, r = {}, i = Y0) { this.channel = e, this.event = n, this.payload = r, this.timeout = i, this.sent = !1, this.timeoutTimer = void 0, this.ref = "", this.receivedResp = null, this.recHooks = [], this.refEvent = null } resend(e) { this.timeout = e, this._cancelRefEvent(), this.ref = "", this.refEvent = null, this.receivedResp = null, this.sent = !1, this.send() } send() { this._hasReceived("timeout") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({ topic: this.channel.topic, event: this.event, payload: this.payload, ref: this.ref, join_ref: this.channel._joinRef() })) } updatePayload(e) { this.payload = Object.assign(Object.assign({}, this.payload), e) } receive(e, n) { var r; return this._hasReceived(e) && n((r = this.receivedResp) === null || r === void 0 ? void 0 : r.response), this.recHooks.push({ status: e, callback: n }), this } startTimeout() { if (this.timeoutTimer) return; this.ref = this.channel.socket._makeRef(), this.refEvent = this.channel._replyEventName(this.ref); const e = n => { this._cancelRefEvent(), this._cancelTimeout(), this.receivedResp = n, this._matchReceive(n) }; this.channel._on(this.refEvent, {}, e), this.timeoutTimer = setTimeout(() => { this.trigger("timeout", {}) }, this.timeout) } trigger(e, n) { this.refEvent && this.channel._trigger(this.refEvent, { status: e, response: n }) } destroy() { this._cancelRefEvent(), this._cancelTimeout() } _cancelRefEvent() { this.refEvent && this.channel._off(this.refEvent, {}) } _cancelTimeout() { clearTimeout(this.timeoutTimer), this.timeoutTimer = void 0 } _matchReceive({ status: e, response: n }) { this.recHooks.filter(r => r.status === e).forEach(r => r.callback(n)) } _hasReceived(e) { return this.receivedResp && this.receivedResp.status === e } } var tg; (function (t) { t.SYNC = "sync", t.JOIN = "join", t.LEAVE = "leave" })(tg || (tg = {})); class Es { constructor(e, n) { this.channel = e, this.state = {}, this.pendingDiffs = [], this.joinRef = null, this.caller = { onJoin: () => { }, onLeave: () => { }, onSync: () => { } }; const r = (n == null ? void 0 : n.events) || { state: "presence_state", diff: "presence_diff" }; this.channel._on(r.state, {}, i => { const { onJoin: s, onLeave: o, onSync: a } = this.caller; this.joinRef = this.channel._joinRef(), this.state = Es.syncState(this.state, i, s, o), this.pendingDiffs.forEach(l => { this.state = Es.syncDiff(this.state, l, s, o) }), this.pendingDiffs = [], a() }), this.channel._on(r.diff, {}, i => { const { onJoin: s, onLeave: o, onSync: a } = this.caller; this.inPendingSyncState() ? this.pendingDiffs.push(i) : (this.state = Es.syncDiff(this.state, i, s, o), a()) }), this.onJoin((i, s, o) => { this.channel._trigger("presence", { event: "join", key: i, currentPresences: s, newPresences: o }) }), this.onLeave((i, s, o) => { this.channel._trigger("presence", { event: "leave", key: i, currentPresences: s, leftPresences: o }) }), this.onSync(() => { this.channel._trigger("presence", { event: "sync" }) }) } static syncState(e, n, r, i) { const s = this.cloneDeep(e), o = this.transformState(n), a = {}, l = {}; return this.map(s, (u, c) => { o[u] || (l[u] = c) }), this.map(o, (u, c) => { const d = s[u]; if (d) { const h = c.map(y => y.presence_ref), f = d.map(y => y.presence_ref), g = c.filter(y => f.indexOf(y.presence_ref) < 0), m = d.filter(y => h.indexOf(y.presence_ref) < 0); g.length > 0 && (a[u] = g), m.length > 0 && (l[u] = m) } else a[u] = c }), this.syncDiff(s, { joins: a, leaves: l }, r, i) } static syncDiff(e, n, r, i) { const { joins: s, leaves: o } = { joins: this.transformState(n.joins), leaves: this.transformState(n.leaves) }; return r || (r = () => { }), i || (i = () => { }), this.map(s, (a, l) => { var u; const c = (u = e[a]) !== null && u !== void 0 ? u : []; if (e[a] = this.cloneDeep(l), c.length > 0) { const d = e[a].map(f => f.presence_ref), h = c.filter(f => d.indexOf(f.presence_ref) < 0); e[a].unshift(...h) } r(a, c, l) }), this.map(o, (a, l) => { let u = e[a]; if (!u) return; const c = l.map(d => d.presence_ref); u = u.filter(d => c.indexOf(d.presence_ref) < 0), e[a] = u, i(a, u, l), u.length === 0 && delete e[a] }), e } static map(e, n) { return Object.getOwnPropertyNames(e).map(r => n(r, e[r])) } static transformState(e) { return e = this.cloneDeep(e), Object.getOwnPropertyNames(e).reduce((n, r) => { const i = e[r]; return "metas" in i ? n[r] = i.metas.map(s => (s.presence_ref = s.phx_ref, delete s.phx_ref, delete s.phx_ref_prev, s)) : n[r] = i, n }, {}) } static cloneDeep(e) { return JSON.parse(JSON.stringify(e)) } onJoin(e) { this.caller.onJoin = e } onLeave(e) { this.caller.onLeave = e } onSync(e) { this.caller.onSync = e } inPendingSyncState() { return !this.joinRef || this.joinRef !== this.channel._joinRef() } } var ng; (function (t) { t.ALL = "*", t.INSERT = "INSERT", t.UPDATE = "UPDATE", t.DELETE = "DELETE" })(ng || (ng = {})); var rg; (function (t) { t.BROADCAST = "broadcast", t.PRESENCE = "presence", t.POSTGRES_CHANGES = "postgres_changes" })(rg || (rg = {})); var ig; (function (t) { t.SUBSCRIBED = "SUBSCRIBED", t.TIMED_OUT = "TIMED_OUT", t.CLOSED = "CLOSED", t.CHANNEL_ERROR = "CHANNEL_ERROR" })(ig || (ig = {})); class Hh { constructor(e, n = { config: {} }, r) { this.topic = e, this.params = n, this.socket = r, this.bindings = {}, this.state = gt.closed, this.joinedOnce = !1, this.pushBuffer = [], this.subTopic = e.replace(/^realtime:/i, ""), this.params.config = Object.assign({ broadcast: { ack: !1, self: !1 }, presence: { key: "" }, private: !1 }, n.config), this.timeout = this.socket.timeout, this.joinPush = new Gu(this, Ht.join, this.params, this.timeout), this.rejoinTimer = new Q0(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs), this.joinPush.receive("ok", () => { this.state = gt.joined, this.rejoinTimer.reset(), this.pushBuffer.forEach(i => i.send()), this.pushBuffer = [] }), this._onClose(() => { this.rejoinTimer.reset(), this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`), this.state = gt.closed, this.socket._remove(this) }), this._onError(i => { this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, i), this.state = gt.errored, this.rejoinTimer.scheduleTimeout()) }), this.joinPush.receive("timeout", () => { this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout), this.state = gt.errored, this.rejoinTimer.scheduleTimeout()) }), this._on(Ht.reply, {}, (i, s) => { this._trigger(this._replyEventName(s), i) }), this.presence = new Es(this), this.broadcastEndpointURL = J0(this.socket.endPoint) + "/api/broadcast" } subscribe(e, n = this.timeout) { var r, i; if (this.socket.isConnected() || this.socket.connect(), this.joinedOnce) throw "tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance"; { const { config: { broadcast: s, presence: o, private: a } } = this.params; this._onError(c => e && e("CHANNEL_ERROR", c)), this._onClose(() => e && e("CLOSED")); const l = {}, u = { broadcast: s, presence: o, postgres_changes: (i = (r = this.bindings.postgres_changes) === null || r === void 0 ? void 0 : r.map(c => c.filter)) !== null && i !== void 0 ? i : [], private: a }; this.socket.accessToken && (l.access_token = this.socket.accessToken), this.updateJoinPayload(Object.assign({ config: u }, l)), this.joinedOnce = !0, this._rejoin(n), this.joinPush.receive("ok", ({ postgres_changes: c }) => { var d; if (this.socket.accessToken && this.socket.setAuth(this.socket.accessToken), c === void 0) { e && e("SUBSCRIBED"); return } else { const h = this.bindings.postgres_changes, f = (d = h == null ? void 0 : h.length) !== null && d !== void 0 ? d : 0, g = []; for (let m = 0; m < f; m++) { const y = h[m], { filter: { event: p, schema: v, table: b, filter: x } } = y, P = c && c[m]; if (P && P.event === p && P.schema === v && P.table === b && P.filter === x) g.push(Object.assign(Object.assign({}, y), { id: P.id })); else { this.unsubscribe(), e && e("CHANNEL_ERROR", new Error("mismatch between server and client bindings for postgres changes")); return } } this.bindings.postgres_changes = g, e && e("SUBSCRIBED"); return } }).receive("error", c => { e && e("CHANNEL_ERROR", new Error(JSON.stringify(Object.values(c).join(", ") || "error"))) }).receive("timeout", () => { e && e("TIMED_OUT") }) } return this } presenceState() { return this.presence.state } async track(e, n = {}) { return await this.send({ type: "presence", event: "track", payload: e }, n.timeout || this.timeout) } async untrack(e = {}) { return await this.send({ type: "presence", event: "untrack" }, e) } on(e, n, r) { return this._on(e, n, r) } async send(e, n = {}) { var r, i; if (!this._canPush() && e.type === "broadcast") { const { event: s, payload: o } = e, a = { method: "POST", headers: { Authorization: this.socket.accessToken ? `Bearer ${this.socket.accessToken}` : "", apikey: this.socket.apiKey ? this.socket.apiKey : "", "Content-Type": "application/json" }, body: JSON.stringify({ messages: [{ topic: this.subTopic, event: s, payload: o }] }) }; try { const l = await this._fetchWithTimeout(this.broadcastEndpointURL, a, (r = n.timeout) !== null && r !== void 0 ? r : this.timeout); return await ((i = l.body) === null || i === void 0 ? void 0 : i.cancel()), l.ok ? "ok" : "error" } catch (l) { return l.name === "AbortError" ? "timed out" : "error" } } else return new Promise(s => { var o, a, l; const u = this._push(e.type, e, n.timeout || this.timeout); e.type === "broadcast" && !(!((l = (a = (o = this.params) === null || o === void 0 ? void 0 : o.config) === null || a === void 0 ? void 0 : a.broadcast) === null || l === void 0) && l.ack) && s("ok"), u.receive("ok", () => s("ok")), u.receive("error", () => s("error")), u.receive("timeout", () => s("timed out")) }) } updateJoinPayload(e) { this.joinPush.updatePayload(e) } unsubscribe(e = this.timeout) { this.state = gt.leaving; const n = () => { this.socket.log("channel", `leave ${this.topic}`), this._trigger(Ht.close, "leave", this._joinRef()) }; return this.rejoinTimer.reset(), this.joinPush.destroy(), new Promise(r => { const i = new Gu(this, Ht.leave, {}, e); i.receive("ok", () => { n(), r("ok") }).receive("timeout", () => { n(), r("timed out") }).receive("error", () => { r("error") }), i.send(), this._canPush() || i.trigger("ok", {}) }) } async _fetchWithTimeout(e, n, r) { const i = new AbortController, s = setTimeout(() => i.abort(), r), o = await this.socket.fetch(e, Object.assign(Object.assign({}, n), { signal: i.signal })); return clearTimeout(s), o } _push(e, n, r = this.timeout) { if (!this.joinedOnce) throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`; let i = new Gu(this, e, n, r); return this._canPush() ? i.send() : (i.startTimeout(), this.pushBuffer.push(i)), i } _onMessage(e, n, r) { return n } _isMember(e) { return this.topic === e } _joinRef() { return this.joinPush.ref } _trigger(e, n, r) { var i, s; const o = e.toLocaleLowerCase(), { close: a, error: l, leave: u, join: c } = Ht; if (r && [a, l, u, c].indexOf(o) >= 0 && r !== this._joinRef()) return; let h = this._onMessage(o, n, r); if (n && !h) throw "channel onMessage callbacks must return the payload, modified or unmodified";["insert", "update", "delete"].includes(o) ? (i = this.bindings.postgres_changes) === null || i === void 0 || i.filter(f => { var g, m, y; return ((g = f.filter) === null || g === void 0 ? void 0 : g.event) === "*" || ((y = (m = f.filter) === null || m === void 0 ? void 0 : m.event) === null || y === void 0 ? void 0 : y.toLocaleLowerCase()) === o }).map(f => f.callback(h, r)) : (s = this.bindings[o]) === null || s === void 0 || s.filter(f => { var g, m, y, p, v, b; if (["broadcast", "presence", "postgres_changes"].includes(o)) if ("id" in f) { const x = f.id, P = (g = f.filter) === null || g === void 0 ? void 0 : g.event; return x && ((m = n.ids) === null || m === void 0 ? void 0 : m.includes(x)) && (P === "*" || (P == null ? void 0 : P.toLocaleLowerCase()) === ((y = n.data) === null || y === void 0 ? void 0 : y.type.toLocaleLowerCase())) } else { const x = (v = (p = f == null ? void 0 : f.filter) === null || p === void 0 ? void 0 : p.event) === null || v === void 0 ? void 0 : v.toLocaleLowerCase(); return x === "*" || x === ((b = n == null ? void 0 : n.event) === null || b === void 0 ? void 0 : b.toLocaleLowerCase()) } else return f.type.toLocaleLowerCase() === o }).map(f => { if (typeof h == "object" && "ids" in h) { const g = h.data, { schema: m, table: y, commit_timestamp: p, type: v, errors: b } = g; h = Object.assign(Object.assign({}, { schema: m, table: y, commit_timestamp: p, eventType: v, new: {}, old: {}, errors: b }), this._getPayloadRecords(g)) } f.callback(h, r) }) } _isClosed() { return this.state === gt.closed } _isJoined() { return this.state === gt.joined } _isJoining() { return this.state === gt.joining } _isLeaving() { return this.state === gt.leaving } _replyEventName(e) { return `chan_reply_${e}` } _on(e, n, r) { const i = e.toLocaleLowerCase(), s = { type: i, filter: n, callback: r }; return this.bindings[i] ? this.bindings[i].push(s) : this.bindings[i] = [s], this } _off(e, n) { const r = e.toLocaleLowerCase(); return this.bindings[r] = this.bindings[r].filter(i => { var s; return !(((s = i.type) === null || s === void 0 ? void 0 : s.toLocaleLowerCase()) === r && Hh.isEqual(i.filter, n)) }), this } static isEqual(e, n) { if (Object.keys(e).length !== Object.keys(n).length) return !1; for (const r in e) if (e[r] !== n[r]) return !1; return !0 } _rejoinUntilConnected() { this.rejoinTimer.scheduleTimeout(), this.socket.isConnected() && this._rejoin() } _onClose(e) { this._on(Ht.close, {}, e) } _onError(e) { this._on(Ht.error, {}, n => e(n)) } _canPush() { return this.socket.isConnected() && this._isJoined() } _rejoin(e = this.timeout) { this._isLeaving() || (this.socket._leaveOpenTopic(this.topic), this.state = gt.joining, this.joinPush.resend(e)) } _getPayloadRecords(e) { const n = { new: {}, old: {} }; return (e.type === "INSERT" || e.type === "UPDATE") && (n.new = eg(e.columns, e.record)), (e.type === "UPDATE" || e.type === "DELETE") && (n.old = eg(e.columns, e.old_record)), n } } const xk = () => { }, Sk = typeof WebSocket < "u"; class kk { constructor(e, n) { var r; this.accessToken = null, this.apiKey = null, this.channels = [], this.endPoint = "", this.httpEndpoint = "", this.headers = hk, this.params = {}, this.timeout = Y0, this.heartbeatIntervalMs = 3e4, this.heartbeatTimer = void 0, this.pendingHeartbeatRef = null, this.ref = 0, this.logger = xk, this.conn = null, this.sendBuffer = [], this.serializer = new gk, this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] }, this._resolveFetch = s => { let o; return s ? o = s : typeof fetch > "u" ? o = (...a) => Ii(async () => { const { default: l } = await Promise.resolve().then(() => Vi); return { default: l } }, void 0).then(({ default: l }) => l(...a)) : o = fetch, (...a) => o(...a) }, this.endPoint = `${e}/${yd.websocket}`, this.httpEndpoint = J0(e), n != null && n.transport ? this.transport = n.transport : this.transport = null, n != null && n.params && (this.params = n.params), n != null && n.headers && (this.headers = Object.assign(Object.assign({}, this.headers), n.headers)), n != null && n.timeout && (this.timeout = n.timeout), n != null && n.logger && (this.logger = n.logger), n != null && n.heartbeatIntervalMs && (this.heartbeatIntervalMs = n.heartbeatIntervalMs); const i = (r = n == null ? void 0 : n.params) === null || r === void 0 ? void 0 : r.apikey; i && (this.accessToken = i, this.apiKey = i), this.reconnectAfterMs = n != null && n.reconnectAfterMs ? n.reconnectAfterMs : s => [1e3, 2e3, 5e3, 1e4][s - 1] || 1e4, this.encode = n != null && n.encode ? n.encode : (s, o) => o(JSON.stringify(s)), this.decode = n != null && n.decode ? n.decode : this.serializer.decode.bind(this.serializer), this.reconnectTimer = new Q0(async () => { this.disconnect(), this.connect() }, this.reconnectAfterMs), this.fetch = this._resolveFetch(n == null ? void 0 : n.fetch) } connect() { if (!this.conn) { if (this.transport) { this.conn = new this.transport(this._endPointURL(), void 0, { headers: this.headers }); return } if (Sk) { this.conn = new WebSocket(this._endPointURL()), this.setupConnection(); return } this.conn = new Ck(this._endPointURL(), void 0, { close: () => { this.conn = null } }), Ii(async () => { const { default: e } = await import("./browser-CEVieTc7.js").then(n => n.b); return { default: e } }, []).then(({ default: e }) => { this.conn = new e(this._endPointURL(), void 0, { headers: this.headers }), this.setupConnection() }) } } disconnect(e, n) { this.conn && (this.conn.onclose = function () { }, e ? this.conn.close(e, n ?? "") : this.conn.close(), this.conn = null, this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.reconnectTimer.reset()) } getChannels() { return this.channels } async removeChannel(e) { const n = await e.unsubscribe(); return this.channels.length === 0 && this.disconnect(), n } async removeAllChannels() { const e = await Promise.all(this.channels.map(n => n.unsubscribe())); return this.disconnect(), e } log(e, n, r) { this.logger(e, n, r) } connectionState() { switch (this.conn && this.conn.readyState) { case _i.connecting: return Sr.Connecting; case _i.open: return Sr.Open; case _i.closing: return Sr.Closing; default: return Sr.Closed } } isConnected() { return this.connectionState() === Sr.Open } channel(e, n = { config: {} }) { const r = new Hh(`realtime:${e}`, n, this); return this.channels.push(r), r } push(e) { const { topic: n, event: r, payload: i, ref: s } = e, o = () => { this.encode(e, a => { var l; (l = this.conn) === null || l === void 0 || l.send(a) }) }; this.log("push", `${n} ${r} (${s})`, i), this.isConnected() ? o() : this.sendBuffer.push(o) } setAuth(e) { this.accessToken = e, this.channels.forEach(n => { e && n.updateJoinPayload({ access_token: e }), n.joinedOnce && n._isJoined() && n._push(Ht.access_token, { access_token: e }) }) } _makeRef() { let e = this.ref + 1; return e === this.ref ? this.ref = 0 : this.ref = e, this.ref.toString() } _leaveOpenTopic(e) { let n = this.channels.find(r => r.topic === e && (r._isJoined() || r._isJoining())); n && (this.log("transport", `leaving duplicate topic "${e}"`), n.unsubscribe()) } _remove(e) { this.channels = this.channels.filter(n => n._joinRef() !== e._joinRef()) } setupConnection() { this.conn && (this.conn.binaryType = "arraybuffer", this.conn.onopen = () => this._onConnOpen(), this.conn.onerror = e => this._onConnError(e), this.conn.onmessage = e => this._onConnMessage(e), this.conn.onclose = e => this._onConnClose(e)) } _endPointURL() { return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: fk })) } _onConnMessage(e) { this.decode(e.data, n => { let { topic: r, event: i, payload: s, ref: o } = n; (o && o === this.pendingHeartbeatRef || i === (s == null ? void 0 : s.type)) && (this.pendingHeartbeatRef = null), this.log("receive", `${s.status || ""} ${r} ${i} ${o && "(" + o + ")" || ""}`, s), this.channels.filter(a => a._isMember(r)).forEach(a => a._trigger(i, s, o)), this.stateChangeCallbacks.message.forEach(a => a(n)) }) } _onConnOpen() { this.log("transport", `connected to ${this._endPointURL()}`), this._flushSendBuffer(), this.reconnectTimer.reset(), this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs), this.stateChangeCallbacks.open.forEach(e => e()) } _onConnClose(e) { this.log("transport", "close", e), this._triggerChanError(), this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.reconnectTimer.scheduleTimeout(), this.stateChangeCallbacks.close.forEach(n => n(e)) } _onConnError(e) { this.log("transport", e.message), this._triggerChanError(), this.stateChangeCallbacks.error.forEach(n => n(e)) } _triggerChanError() { this.channels.forEach(e => e._trigger(Ht.error)) } _appendParams(e, n) { if (Object.keys(n).length === 0) return e; const r = e.match(/\?/) ? "&" : "?", i = new URLSearchParams(n); return `${e}${r}${i}` } _flushSendBuffer() { this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(e => e()), this.sendBuffer = []) } _sendHeartbeat() { var e; if (this.isConnected()) { if (this.pendingHeartbeatRef) { this.pendingHeartbeatRef = null, this.log("transport", "heartbeat timeout. Attempting to re-establish connection"), (e = this.conn) === null || e === void 0 || e.close(pk, "hearbeat timeout"); return } this.pendingHeartbeatRef = this._makeRef(), this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef }), this.setAuth(this.accessToken) } } } class Ck { constructor(e, n, r) { this.binaryType = "arraybuffer", this.onclose = () => { }, this.onerror = () => { }, this.onmessage = () => { }, this.onopen = () => { }, this.readyState = _i.connecting, this.send = () => { }, this.url = null, this.url = e, this.close = r.close } } class Wh extends Error { constructor(e) { super(e), this.__isStorageError = !0, this.name = "StorageError" } } function Xe(t) { return typeof t == "object" && t !== null && "__isStorageError" in t } class Ok extends Wh { constructor(e, n) { super(e), this.name = "StorageApiError", this.status = n } toJSON() { return { name: this.name, message: this.message, status: this.status } } } class sg extends Wh { constructor(e, n) { super(e), this.name = "StorageUnknownError", this.originalError = n } } var Pk = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; const Z0 = t => { let e; return t ? e = t : typeof fetch > "u" ? e = (...n) => Ii(async () => { const { default: r } = await Promise.resolve().then(() => Vi); return { default: r } }, void 0).then(({ default: r }) => r(...n)) : e = fetch, (...n) => e(...n) }, Ek = () => Pk(void 0, void 0, void 0, function* () { return typeof Response > "u" ? (yield Ii(() => Promise.resolve().then(() => Vi), void 0)).Response : Response }); var Bi = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; const Yu = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t), Tk = (t, e) => Bi(void 0, void 0, void 0, function* () { const n = yield Ek(); t instanceof n ? t.json().then(r => { e(new Ok(Yu(r), t.status || 500)) }).catch(r => { e(new sg(Yu(r), r)) }) : e(new sg(Yu(t), t)) }), Ik = (t, e, n, r) => { const i = { method: t, headers: (e == null ? void 0 : e.headers) || {} }; return t === "GET" ? i : (i.headers = Object.assign({ "Content-Type": "application/json" }, e == null ? void 0 : e.headers), i.body = JSON.stringify(r), Object.assign(Object.assign({}, i), n)) }; function Yl(t, e, n, r, i, s) { return Bi(this, void 0, void 0, function* () { return new Promise((o, a) => { t(n, Ik(e, r, i, s)).then(l => { if (!l.ok) throw l; return r != null && r.noResolveJson ? l : l.json() }).then(l => o(l)).catch(l => Tk(l, a)) }) }) } function _d(t, e, n, r) { return Bi(this, void 0, void 0, function* () { return Yl(t, "GET", e, n, r) }) } function An(t, e, n, r, i) { return Bi(this, void 0, void 0, function* () { return Yl(t, "POST", e, r, i, n) }) } function Rk(t, e, n, r, i) { return Bi(this, void 0, void 0, function* () { return Yl(t, "PUT", e, r, i, n) }) } function eb(t, e, n, r, i) { return Bi(this, void 0, void 0, function* () { return Yl(t, "DELETE", e, r, i, n) }) } var Ot = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; const Mk = { limit: 100, offset: 0, sortBy: { column: "name", order: "asc" } }, og = { cacheControl: "3600", contentType: "text/plain;charset=UTF-8", upsert: !1 }; class Lk { constructor(e, n = {}, r, i) { this.url = e, this.headers = n, this.bucketId = r, this.fetch = Z0(i) } uploadOrUpdate(e, n, r, i) { return Ot(this, void 0, void 0, function* () { try { let s; const o = Object.assign(Object.assign({}, og), i), a = Object.assign(Object.assign({}, this.headers), e === "POST" && { "x-upsert": String(o.upsert) }); typeof Blob < "u" && r instanceof Blob ? (s = new FormData, s.append("cacheControl", o.cacheControl), s.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (s = r, s.append("cacheControl", o.cacheControl)) : (s = r, a["cache-control"] = `max-age=${o.cacheControl}`, a["content-type"] = o.contentType); const l = this._removeEmptyFolders(n), u = this._getFinalPath(l), c = yield this.fetch(`${this.url}/object/${u}`, Object.assign({ method: e, body: s, headers: a }, o != null && o.duplex ? { duplex: o.duplex } : {})), d = yield c.json(); return c.ok ? { data: { path: l, id: d.Id, fullPath: d.Key }, error: null } : { data: null, error: d } } catch (s) { if (Xe(s)) return { data: null, error: s }; throw s } }) } upload(e, n, r) { return Ot(this, void 0, void 0, function* () { return this.uploadOrUpdate("POST", e, n, r) }) } uploadToSignedUrl(e, n, r, i) { return Ot(this, void 0, void 0, function* () { const s = this._removeEmptyFolders(e), o = this._getFinalPath(s), a = new URL(this.url + `/object/upload/sign/${o}`); a.searchParams.set("token", n); try { let l; const u = Object.assign({ upsert: og.upsert }, i), c = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(u.upsert) }); typeof Blob < "u" && r instanceof Blob ? (l = new FormData, l.append("cacheControl", u.cacheControl), l.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (l = r, l.append("cacheControl", u.cacheControl)) : (l = r, c["cache-control"] = `max-age=${u.cacheControl}`, c["content-type"] = u.contentType); const d = yield this.fetch(a.toString(), { method: "PUT", body: l, headers: c }), h = yield d.json(); return d.ok ? { data: { path: s, fullPath: h.Key }, error: null } : { data: null, error: h } } catch (l) { if (Xe(l)) return { data: null, error: l }; throw l } }) } createSignedUploadUrl(e, n) { return Ot(this, void 0, void 0, function* () { try { let r = this._getFinalPath(e); const i = Object.assign({}, this.headers); n != null && n.upsert && (i["x-upsert"] = "true"); const s = yield An(this.fetch, `${this.url}/object/upload/sign/${r}`, {}, { headers: i }), o = new URL(this.url + s.url), a = o.searchParams.get("token"); if (!a) throw new Wh("No token returned by API"); return { data: { signedUrl: o.toString(), path: e, token: a }, error: null } } catch (r) { if (Xe(r)) return { data: null, error: r }; throw r } }) } update(e, n, r) { return Ot(this, void 0, void 0, function* () { return this.uploadOrUpdate("PUT", e, n, r) }) } move(e, n, r) { return Ot(this, void 0, void 0, function* () { try { return { data: yield An(this.fetch, `${this.url}/object/move`, { bucketId: this.bucketId, sourceKey: e, destinationKey: n, destinationBucket: r == null ? void 0 : r.destinationBucket }, { headers: this.headers }), error: null } } catch (i) { if (Xe(i)) return { data: null, error: i }; throw i } }) } copy(e, n, r) { return Ot(this, void 0, void 0, function* () { try { return { data: { path: (yield An(this.fetch, `${this.url}/object/copy`, { bucketId: this.bucketId, sourceKey: e, destinationKey: n, destinationBucket: r == null ? void 0 : r.destinationBucket }, { headers: this.headers })).Key }, error: null } } catch (i) { if (Xe(i)) return { data: null, error: i }; throw i } }) } createSignedUrl(e, n, r) { return Ot(this, void 0, void 0, function* () { try { let i = this._getFinalPath(e), s = yield An(this.fetch, `${this.url}/object/sign/${i}`, Object.assign({ expiresIn: n }, r != null && r.transform ? { transform: r.transform } : {}), { headers: this.headers }); const o = r != null && r.download ? `&download=${r.download === !0 ? "" : r.download}` : ""; return s = { signedUrl: encodeURI(`${this.url}${s.signedURL}${o}`) }, { data: s, error: null } } catch (i) { if (Xe(i)) return { data: null, error: i }; throw i } }) } createSignedUrls(e, n, r) { return Ot(this, void 0, void 0, function* () { try { const i = yield An(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn: n, paths: e }, { headers: this.headers }), s = r != null && r.download ? `&download=${r.download === !0 ? "" : r.download}` : ""; return { data: i.map(o => Object.assign(Object.assign({}, o), { signedUrl: o.signedURL ? encodeURI(`${this.url}${o.signedURL}${s}`) : null })), error: null } } catch (i) { if (Xe(i)) return { data: null, error: i }; throw i } }) } download(e, n) { return Ot(this, void 0, void 0, function* () { const i = typeof (n == null ? void 0 : n.transform) < "u" ? "render/image/authenticated" : "object", s = this.transformOptsToQueryString((n == null ? void 0 : n.transform) || {}), o = s ? `?${s}` : ""; try { const a = this._getFinalPath(e); return { data: yield (yield _d(this.fetch, `${this.url}/${i}/${a}${o}`, { headers: this.headers, noResolveJson: !0 })).blob(), error: null } } catch (a) { if (Xe(a)) return { data: null, error: a }; throw a } }) } getPublicUrl(e, n) { const r = this._getFinalPath(e), i = [], s = n != null && n.download ? `download=${n.download === !0 ? "" : n.download}` : ""; s !== "" && i.push(s); const a = typeof (n == null ? void 0 : n.transform) < "u" ? "render/image" : "object", l = this.transformOptsToQueryString((n == null ? void 0 : n.transform) || {}); l !== "" && i.push(l); let u = i.join("&"); return u !== "" && (u = `?${u}`), { data: { publicUrl: encodeURI(`${this.url}/${a}/public/${r}${u}`) } } } remove(e) { return Ot(this, void 0, void 0, function* () { try { return { data: yield eb(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: e }, { headers: this.headers }), error: null } } catch (n) { if (Xe(n)) return { data: null, error: n }; throw n } }) } list(e, n, r) { return Ot(this, void 0, void 0, function* () { try { const i = Object.assign(Object.assign(Object.assign({}, Mk), n), { prefix: e || "" }); return { data: yield An(this.fetch, `${this.url}/object/list/${this.bucketId}`, i, { headers: this.headers }, r), error: null } } catch (i) { if (Xe(i)) return { data: null, error: i }; throw i } }) } _getFinalPath(e) { return `${this.bucketId}/${e}` } _removeEmptyFolders(e) { return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/") } transformOptsToQueryString(e) { const n = []; return e.width && n.push(`width=${e.width}`), e.height && n.push(`height=${e.height}`), e.resize && n.push(`resize=${e.resize}`), e.format && n.push(`format=${e.format}`), e.quality && n.push(`quality=${e.quality}`), n.join("&") } } const Dk = "2.6.0", jk = { "X-Client-Info": `storage-js/${Dk}` }; var Yr = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; class Ak { constructor(e, n = {}, r) { this.url = e, this.headers = Object.assign(Object.assign({}, jk), n), this.fetch = Z0(r) } listBuckets() { return Yr(this, void 0, void 0, function* () { try { return { data: yield _d(this.fetch, `${this.url}/bucket`, { headers: this.headers }), error: null } } catch (e) { if (Xe(e)) return { data: null, error: e }; throw e } }) } getBucket(e) { return Yr(this, void 0, void 0, function* () { try { return { data: yield _d(this.fetch, `${this.url}/bucket/${e}`, { headers: this.headers }), error: null } } catch (n) { if (Xe(n)) return { data: null, error: n }; throw n } }) } createBucket(e, n = { public: !1 }) { return Yr(this, void 0, void 0, function* () { try { return { data: yield An(this.fetch, `${this.url}/bucket`, { id: e, name: e, public: n.public, file_size_limit: n.fileSizeLimit, allowed_mime_types: n.allowedMimeTypes }, { headers: this.headers }), error: null } } catch (r) { if (Xe(r)) return { data: null, error: r }; throw r } }) } updateBucket(e, n) { return Yr(this, void 0, void 0, function* () { try { return { data: yield Rk(this.fetch, `${this.url}/bucket/${e}`, { id: e, name: e, public: n.public, file_size_limit: n.fileSizeLimit, allowed_mime_types: n.allowedMimeTypes }, { headers: this.headers }), error: null } } catch (r) { if (Xe(r)) return { data: null, error: r }; throw r } }) } emptyBucket(e) { return Yr(this, void 0, void 0, function* () { try { return { data: yield An(this.fetch, `${this.url}/bucket/${e}/empty`, {}, { headers: this.headers }), error: null } } catch (n) { if (Xe(n)) return { data: null, error: n }; throw n } }) } deleteBucket(e) { return Yr(this, void 0, void 0, function* () { try { return { data: yield eb(this.fetch, `${this.url}/bucket/${e}`, {}, { headers: this.headers }), error: null } } catch (n) { if (Xe(n)) return { data: null, error: n }; throw n } }) } } class Nk extends Ak { constructor(e, n = {}, r) { super(e, n, r) } from(e) { return new Lk(this.url, this.headers, e, this.fetch) } } const Fk = "2.45.0"; let ps = ""; typeof Deno < "u" ? ps = "deno" : typeof document < "u" ? ps = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? ps = "react-native" : ps = "node"; const $k = { "X-Client-Info": `supabase-js-${ps}/${Fk}` }, zk = { headers: $k }, Vk = { schema: "public" }, Bk = { autoRefreshToken: !0, persistSession: !0, detectSessionInUrl: !0, flowType: "implicit" }, Uk = {}; var Hk = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; const Wk = t => { let e; return t ? e = t : typeof fetch > "u" ? e = $0 : e = fetch, (...n) => e(...n) }, qk = () => typeof Headers > "u" ? z0 : Headers, Kk = (t, e, n) => { const r = Wk(n), i = qk(); return (s, o) => Hk(void 0, void 0, void 0, function* () { var a; const l = (a = yield e()) !== null && a !== void 0 ? a : t; let u = new i(o == null ? void 0 : o.headers); return u.has("apikey") || u.set("apikey", t), u.has("Authorization") || u.set("Authorization", `Bearer ${l}`), r(s, Object.assign(Object.assign({}, o), { headers: u })) }) }; var Gk = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; function Yk(t) { return t.replace(/\/$/, "") } function Qk(t, e) { const { db: n, auth: r, realtime: i, global: s } = t, { db: o, auth: a, realtime: l, global: u } = e, c = { db: Object.assign(Object.assign({}, o), n), auth: Object.assign(Object.assign({}, a), r), realtime: Object.assign(Object.assign({}, l), i), global: Object.assign(Object.assign({}, u), s), accessToken: () => Gk(this, void 0, void 0, function* () { return "" }) }; return t.accessToken ? c.accessToken = t.accessToken : delete c.accessToken, c } const tb = "2.64.4", Xk = "http://localhost:9999", Jk = "supabase.auth.token", Zk = { "X-Client-Info": `gotrue-js/${tb}` }, ag = 10, wd = "X-Supabase-Api-Version", nb = { "2024-01-01": { timestamp: Date.parse("2024-01-01T00:00:00.0Z"), name: "2024-01-01" } }; function eC(t) { return Math.round(Date.now() / 1e3) + t } function tC() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (t) { const e = Math.random() * 16 | 0; return (t == "x" ? e : e & 3 | 8).toString(16) }) } const Vt = () => typeof document < "u", hr = { tested: !1, writable: !1 }, Ts = () => { if (!Vt()) return !1; try { if (typeof globalThis.localStorage != "object") return !1 } catch { return !1 } if (hr.tested) return hr.writable; const t = `lswt-${Math.random()}${Math.random()}`; try { globalThis.localStorage.setItem(t, t), globalThis.localStorage.removeItem(t), hr.tested = !0, hr.writable = !0 } catch { hr.tested = !0, hr.writable = !1 } return hr.writable }; function Qu(t) { const e = {}, n = new URL(t); if (n.hash && n.hash[0] === "#") try { new URLSearchParams(n.hash.substring(1)).forEach((i, s) => { e[s] = i }) } catch { } return n.searchParams.forEach((r, i) => { e[i] = r }), e } const rb = t => { let e; return t ? e = t : typeof fetch > "u" ? e = (...n) => Ii(async () => { const { default: r } = await Promise.resolve().then(() => Vi); return { default: r } }, void 0).then(({ default: r }) => r(...n)) : e = fetch, (...n) => e(...n) }, nC = t => typeof t == "object" && t !== null && "status" in t && "ok" in t && "json" in t && typeof t.json == "function", ib = async (t, e, n) => { await t.setItem(e, JSON.stringify(n)) }, Ho = async (t, e) => { const n = await t.getItem(e); if (!n) return null; try { return JSON.parse(n) } catch { return n } }, Xu = async (t, e) => { await t.removeItem(e) }; function rC(t) { const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; let n = "", r, i, s, o, a, l, u, c = 0; for (t = t.replace("-", "+").replace("_", "/"); c < t.length;)o = e.indexOf(t.charAt(c++)), a = e.indexOf(t.charAt(c++)), l = e.indexOf(t.charAt(c++)), u = e.indexOf(t.charAt(c++)), r = o << 2 | a >> 4, i = (a & 15) << 4 | l >> 2, s = (l & 3) << 6 | u, n = n + String.fromCharCode(r), l != 64 && i != 0 && (n = n + String.fromCharCode(i)), u != 64 && s != 0 && (n = n + String.fromCharCode(s)); return n } class Ql { constructor() { this.promise = new Ql.promiseConstructor((e, n) => { this.resolve = e, this.reject = n }) } } Ql.promiseConstructor = Promise; function lg(t) { const e = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i, n = t.split("."); if (n.length !== 3) throw new Error("JWT is not valid: not a JWT structure"); if (!e.test(n[1])) throw new Error("JWT is not valid: payload is not in base64url format"); const r = n[1]; return JSON.parse(rC(r)) } async function iC(t) { return await new Promise(e => { setTimeout(() => e(null), t) }) } function sC(t, e) { return new Promise((r, i) => { (async () => { for (let s = 0; s < 1 / 0; s++)try { const o = await t(s); if (!e(s, null, o)) { r(o); return } } catch (o) { if (!e(s, o)) { i(o); return } } })() }) } function oC(t) { return ("0" + t.toString(16)).substr(-2) } function aC() { const e = new Uint32Array(56); if (typeof crypto > "u") { const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~", r = n.length; let i = ""; for (let s = 0; s < 56; s++)i += n.charAt(Math.floor(Math.random() * r)); return i } return crypto.getRandomValues(e), Array.from(e, oC).join("") } async function lC(t) { const n = new TextEncoder().encode(t), r = await crypto.subtle.digest("SHA-256", n), i = new Uint8Array(r); return Array.from(i).map(s => String.fromCharCode(s)).join("") } function uC(t) { return btoa(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "") } async function cC(t) { if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u")) return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."), t; const n = await lC(t); return uC(n) } async function Qr(t, e, n = !1) { const r = aC(); let i = r; n && (i += "/PASSWORD_RECOVERY"), await ib(t, `${e}-code-verifier`, i); const s = await cC(r); return [s, r === s ? "plain" : "s256"] } const dC = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i; function hC(t) { const e = t.headers.get(wd); if (!e || !e.match(dC)) return null; try { return new Date(`${e}T00:00:00.0Z`) } catch { return null } } class qh extends Error { constructor(e, n, r) { super(e), this.__isAuthError = !0, this.name = "AuthError", this.status = n, this.code = r } } function ee(t) { return typeof t == "object" && t !== null && "__isAuthError" in t } class fC extends qh { constructor(e, n, r) { super(e, n, r), this.name = "AuthApiError", this.status = n, this.code = r } } function pC(t) { return ee(t) && t.name === "AuthApiError" } class sb extends qh { constructor(e, n) { super(e), this.name = "AuthUnknownError", this.originalError = n } } class Br extends qh { constructor(e, n, r, i) { super(e, r, i), this.name = n, this.status = r } } class fr extends Br { constructor() { super("Auth session missing!", "AuthSessionMissingError", 400, void 0) } } class Ju extends Br { constructor() { super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0) } } class Wo extends Br { constructor(e) { super(e, "AuthInvalidCredentialsError", 400, void 0) } } class qo extends Br { constructor(e, n = null) { super(e, "AuthImplicitGrantRedirectError", 500, void 0), this.details = null, this.details = n } toJSON() { return { name: this.name, message: this.message, status: this.status, details: this.details } } } class ug extends Br { constructor(e, n = null) { super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0), this.details = null, this.details = n } toJSON() { return { name: this.name, message: this.message, status: this.status, details: this.details } } } class xd extends Br { constructor(e, n) { super(e, "AuthRetryableFetchError", n, void 0) } } function Zu(t) { return ee(t) && t.name === "AuthRetryableFetchError" } class cg extends Br { constructor(e, n, r) { super(e, "AuthWeakPasswordError", n, "weak_password"), this.reasons = r } } var gC = function (t, e) { var n = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]); return n }; const wr = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t), mC = [502, 503, 504]; async function dg(t) { var e; if (!nC(t)) throw new xd(wr(t), 0); if (mC.includes(t.status)) throw new xd(wr(t), t.status); let n; try { n = await t.json() } catch (s) { throw new sb(wr(s), s) } let r; const i = hC(t); if (i && i.getTime() >= nb["2024-01-01"].timestamp && typeof n == "object" && n && typeof n.code == "string" ? r = n.code : typeof n == "object" && n && typeof n.error_code == "string" && (r = n.error_code), r) { if (r === "weak_password") throw new cg(wr(n), t.status, ((e = n.weak_password) === null || e === void 0 ? void 0 : e.reasons) || []) } else if (typeof n == "object" && n && typeof n.weak_password == "object" && n.weak_password && Array.isArray(n.weak_password.reasons) && n.weak_password.reasons.length && n.weak_password.reasons.reduce((s, o) => s && typeof o == "string", !0)) throw new cg(wr(n), t.status, n.weak_password.reasons); throw new fC(wr(n), t.status || 500, r) } const vC = (t, e, n, r) => { const i = { method: t, headers: (e == null ? void 0 : e.headers) || {} }; return t === "GET" ? i : (i.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, e == null ? void 0 : e.headers), i.body = JSON.stringify(r), Object.assign(Object.assign({}, i), n)) }; async function ne(t, e, n, r) { var i; const s = Object.assign({}, r == null ? void 0 : r.headers); s[wd] || (s[wd] = nb["2024-01-01"].name), r != null && r.jwt && (s.Authorization = `Bearer ${r.jwt}`); const o = (i = r == null ? void 0 : r.query) !== null && i !== void 0 ? i : {}; r != null && r.redirectTo && (o.redirect_to = r.redirectTo); const a = Object.keys(o).length ? "?" + new URLSearchParams(o).toString() : "", l = await yC(t, e, n + a, { headers: s, noResolveJson: r == null ? void 0 : r.noResolveJson }, {}, r == null ? void 0 : r.body); return r != null && r.xform ? r == null ? void 0 : r.xform(l) : { data: Object.assign({}, l), error: null } } async function yC(t, e, n, r, i, s) { const o = vC(e, r, i, s); let a; try { a = await t(n, Object.assign({}, o)) } catch (l) { throw console.error(l), new xd(wr(l), 0) } if (a.ok || await dg(a), r != null && r.noResolveJson) return a; try { return await a.json() } catch (l) { await dg(l) } } function Ln(t) { var e; let n = null; xC(t) && (n = Object.assign({}, t), t.expires_at || (n.expires_at = eC(t.expires_in))); const r = (e = t.user) !== null && e !== void 0 ? e : t; return { data: { session: n, user: r }, error: null } } function hg(t) { const e = Ln(t); return !e.error && t.weak_password && typeof t.weak_password == "object" && Array.isArray(t.weak_password.reasons) && t.weak_password.reasons.length && t.weak_password.message && typeof t.weak_password.message == "string" && t.weak_password.reasons.reduce((n, r) => n && typeof r == "string", !0) && (e.data.weak_password = t.weak_password), e } function $n(t) { var e; return { data: { user: (e = t.user) !== null && e !== void 0 ? e : t }, error: null } } function bC(t) { return { data: t, error: null } } function _C(t) { const { action_link: e, email_otp: n, hashed_token: r, redirect_to: i, verification_type: s } = t, o = gC(t, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]), a = { action_link: e, email_otp: n, hashed_token: r, redirect_to: i, verification_type: s }, l = Object.assign({}, o); return { data: { properties: a, user: l }, error: null } } function wC(t) { return t } function xC(t) { return t.access_token && t.refresh_token && t.expires_in } var SC = function (t, e) { var n = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]); return n }; class kC { constructor({ url: e = "", headers: n = {}, fetch: r }) { this.url = e, this.headers = n, this.fetch = rb(r), this.mfa = { listFactors: this._listFactors.bind(this), deleteFactor: this._deleteFactor.bind(this) } } async signOut(e, n = "global") { try { return await ne(this.fetch, "POST", `${this.url}/logout?scope=${n}`, { headers: this.headers, jwt: e, noResolveJson: !0 }), { data: null, error: null } } catch (r) { if (ee(r)) return { data: null, error: r }; throw r } } async inviteUserByEmail(e, n = {}) { try { return await ne(this.fetch, "POST", `${this.url}/invite`, { body: { email: e, data: n.data }, headers: this.headers, redirectTo: n.redirectTo, xform: $n }) } catch (r) { if (ee(r)) return { data: { user: null }, error: r }; throw r } } async generateLink(e) { try { const { options: n } = e, r = SC(e, ["options"]), i = Object.assign(Object.assign({}, r), n); return "newEmail" in r && (i.new_email = r == null ? void 0 : r.newEmail, delete i.newEmail), await ne(this.fetch, "POST", `${this.url}/admin/generate_link`, { body: i, headers: this.headers, xform: _C, redirectTo: n == null ? void 0 : n.redirectTo }) } catch (n) { if (ee(n)) return { data: { properties: null, user: null }, error: n }; throw n } } async createUser(e) { try { return await ne(this.fetch, "POST", `${this.url}/admin/users`, { body: e, headers: this.headers, xform: $n }) } catch (n) { if (ee(n)) return { data: { user: null }, error: n }; throw n } } async listUsers(e) { var n, r, i, s, o, a, l; try { const u = { nextPage: null, lastPage: 0, total: 0 }, c = await ne(this.fetch, "GET", `${this.url}/admin/users`, { headers: this.headers, noResolveJson: !0, query: { page: (r = (n = e == null ? void 0 : e.page) === null || n === void 0 ? void 0 : n.toString()) !== null && r !== void 0 ? r : "", per_page: (s = (i = e == null ? void 0 : e.perPage) === null || i === void 0 ? void 0 : i.toString()) !== null && s !== void 0 ? s : "" }, xform: wC }); if (c.error) throw c.error; const d = await c.json(), h = (o = c.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0, f = (l = (a = c.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : []; return f.length > 0 && (f.forEach(g => { const m = parseInt(g.split(";")[0].split("=")[1].substring(0, 1)), y = JSON.parse(g.split(";")[1].split("=")[1]); u[`${y}Page`] = m }), u.total = parseInt(h)), { data: Object.assign(Object.assign({}, d), u), error: null } } catch (u) { if (ee(u)) return { data: { users: [] }, error: u }; throw u } } async getUserById(e) { try { return await ne(this.fetch, "GET", `${this.url}/admin/users/${e}`, { headers: this.headers, xform: $n }) } catch (n) { if (ee(n)) return { data: { user: null }, error: n }; throw n } } async updateUserById(e, n) { try { return await ne(this.fetch, "PUT", `${this.url}/admin/users/${e}`, { body: n, headers: this.headers, xform: $n }) } catch (r) { if (ee(r)) return { data: { user: null }, error: r }; throw r } } async deleteUser(e, n = !1) { try { return await ne(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, { headers: this.headers, body: { should_soft_delete: n }, xform: $n }) } catch (r) { if (ee(r)) return { data: { user: null }, error: r }; throw r } } async _listFactors(e) { try { const { data: n, error: r } = await ne(this.fetch, "GET", `${this.url}/admin/users/${e.userId}/factors`, { headers: this.headers, xform: i => ({ data: { factors: i }, error: null }) }); return { data: n, error: r } } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } } async _deleteFactor(e) { try { return { data: await ne(this.fetch, "DELETE", `${this.url}/admin/users/${e.userId}/factors/${e.id}`, { headers: this.headers }), error: null } } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } } } const CC = { getItem: t => Ts() ? globalThis.localStorage.getItem(t) : null, setItem: (t, e) => { Ts() && globalThis.localStorage.setItem(t, e) }, removeItem: t => { Ts() && globalThis.localStorage.removeItem(t) } }; function fg(t = {}) { return { getItem: e => t[e] || null, setItem: (e, n) => { t[e] = n }, removeItem: e => { delete t[e] } } } function OC() { if (typeof globalThis != "object") try { Object.defineProperty(Object.prototype, "__magic__", { get: function () { return this }, configurable: !0 }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__ } catch { typeof self < "u" && (self.globalThis = self) } } const Xr = { debug: !!(globalThis && Ts() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true") }; class ob extends Error { constructor(e) { super(e), this.isAcquireTimeout = !0 } } class PC extends ob { } async function EC(t, e, n) { Xr.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", t, e); const r = new globalThis.AbortController; return e > 0 && setTimeout(() => { r.abort(), Xr.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", t) }, e), await globalThis.navigator.locks.request(t, e === 0 ? { mode: "exclusive", ifAvailable: !0 } : { mode: "exclusive", signal: r.signal }, async i => { if (i) { Xr.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", t, i.name); try { return await n() } finally { Xr.debug && console.log("@supabase/gotrue-js: navigatorLock: released", t, i.name) } } else { if (e === 0) throw Xr.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", t), new PC(`Acquiring an exclusive Navigator LockManager lock "${t}" immediately failed`); if (Xr.debug) try { const s = await globalThis.navigator.locks.query(); console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(s, null, "  ")) } catch (s) { console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", s) } return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"), await n() } }) } OC(); const TC = { url: Xk, storageKey: Jk, autoRefreshToken: !0, persistSession: !0, detectSessionInUrl: !0, headers: Zk, flowType: "implicit", debug: !1, hasCustomAuthorizationHeader: !1 }, ns = 30 * 1e3, pg = 3; async function gg(t, e, n) { return await n() } class eo { constructor(e) { var n, r; this.memoryStorage = null, this.stateChangeEmitters = new Map, this.autoRefreshTicker = null, this.visibilityChangedCallback = null, this.refreshingDeferred = null, this.initializePromise = null, this.detectSessionInUrl = !0, this.hasCustomAuthorizationHeader = !1, this.suppressGetSessionWarning = !1, this.lockAcquired = !1, this.pendingInLock = [], this.broadcastChannel = null, this.logger = console.log, this.instanceID = eo.nextInstanceID, eo.nextInstanceID += 1, this.instanceID > 0 && Vt() && console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key."); const i = Object.assign(Object.assign({}, TC), e); if (this.logDebugMessages = !!i.debug, typeof i.debug == "function" && (this.logger = i.debug), this.persistSession = i.persistSession, this.storageKey = i.storageKey, this.autoRefreshToken = i.autoRefreshToken, this.admin = new kC({ url: i.url, headers: i.headers, fetch: i.fetch }), this.url = i.url, this.headers = i.headers, this.fetch = rb(i.fetch), this.lock = i.lock || gg, this.detectSessionInUrl = i.detectSessionInUrl, this.flowType = i.flowType, this.hasCustomAuthorizationHeader = i.hasCustomAuthorizationHeader, i.lock ? this.lock = i.lock : Vt() && (!((n = globalThis == null ? void 0 : globalThis.navigator) === null || n === void 0) && n.locks) ? this.lock = EC : this.lock = gg, this.mfa = { verify: this._verify.bind(this), enroll: this._enroll.bind(this), unenroll: this._unenroll.bind(this), challenge: this._challenge.bind(this), listFactors: this._listFactors.bind(this), challengeAndVerify: this._challengeAndVerify.bind(this), getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this) }, this.persistSession ? i.storage ? this.storage = i.storage : Ts() ? this.storage = CC : (this.memoryStorage = {}, this.storage = fg(this.memoryStorage)) : (this.memoryStorage = {}, this.storage = fg(this.memoryStorage)), Vt() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) { try { this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey) } catch (s) { console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", s) } (r = this.broadcastChannel) === null || r === void 0 || r.addEventListener("message", async s => { this._debug("received broadcast notification from other tab or client", s), await this._notifyAllSubscribers(s.data.event, s.data.session, !1) }) } this.initialize() } _debug(...e) { return this.logDebugMessages && this.logger(`GoTrueClient@${this.instanceID} (${tb}) ${new Date().toISOString()}`, ...e), this } async initialize() { return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))(), await this.initializePromise) } async _initialize() { try { const e = Vt() ? await this._isPKCEFlow() : !1; if (this._debug("#_initialize()", "begin", "is PKCE flow", e), e || this.detectSessionInUrl && this._isImplicitGrantFlow()) { const { data: n, error: r } = await this._getSessionFromURL(e); if (r) return this._debug("#_initialize()", "error detecting session from URL", r), (r == null ? void 0 : r.message) === "Identity is already linked" || (r == null ? void 0 : r.message) === "Identity is already linked to another user" ? { error: r } : (await this._removeSession(), { error: r }); const { session: i, redirectType: s } = n; return this._debug("#_initialize()", "detected session in URL", i, "redirect type", s), await this._saveSession(i), setTimeout(async () => { s === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", i) : await this._notifyAllSubscribers("SIGNED_IN", i) }, 0), { error: null } } return await this._recoverAndRefresh(), { error: null } } catch (e) { return ee(e) ? { error: e } : { error: new sb("Unexpected error during initialization", e) } } finally { await this._handleVisibilityChange(), this._debug("#_initialize()", "end") } } async signInAnonymously(e) { var n, r, i; try { const s = await ne(this.fetch, "POST", `${this.url}/signup`, { headers: this.headers, body: { data: (r = (n = e == null ? void 0 : e.options) === null || n === void 0 ? void 0 : n.data) !== null && r !== void 0 ? r : {}, gotrue_meta_security: { captcha_token: (i = e == null ? void 0 : e.options) === null || i === void 0 ? void 0 : i.captchaToken } }, xform: Ln }), { data: o, error: a } = s; if (a || !o) return { data: { user: null, session: null }, error: a }; const l = o.session, u = o.user; return o.session && (await this._saveSession(o.session), await this._notifyAllSubscribers("SIGNED_IN", l)), { data: { user: u, session: l }, error: null } } catch (s) { if (ee(s)) return { data: { user: null, session: null }, error: s }; throw s } } async signUp(e) { var n, r, i; try { let s; if ("email" in e) { const { email: c, password: d, options: h } = e; let f = null, g = null; this.flowType === "pkce" && ([f, g] = await Qr(this.storage, this.storageKey)), s = await ne(this.fetch, "POST", `${this.url}/signup`, { headers: this.headers, redirectTo: h == null ? void 0 : h.emailRedirectTo, body: { email: c, password: d, data: (n = h == null ? void 0 : h.data) !== null && n !== void 0 ? n : {}, gotrue_meta_security: { captcha_token: h == null ? void 0 : h.captchaToken }, code_challenge: f, code_challenge_method: g }, xform: Ln }) } else if ("phone" in e) { const { phone: c, password: d, options: h } = e; s = await ne(this.fetch, "POST", `${this.url}/signup`, { headers: this.headers, body: { phone: c, password: d, data: (r = h == null ? void 0 : h.data) !== null && r !== void 0 ? r : {}, channel: (i = h == null ? void 0 : h.channel) !== null && i !== void 0 ? i : "sms", gotrue_meta_security: { captcha_token: h == null ? void 0 : h.captchaToken } }, xform: Ln }) } else throw new Wo("You must provide either an email or phone number and a password"); const { data: o, error: a } = s; if (a || !o) return { data: { user: null, session: null }, error: a }; const l = o.session, u = o.user; return o.session && (await this._saveSession(o.session), await this._notifyAllSubscribers("SIGNED_IN", l)), { data: { user: u, session: l }, error: null } } catch (s) { if (ee(s)) return { data: { user: null, session: null }, error: s }; throw s } } async signInWithPassword(e) { try { let n; if ("email" in e) { const { email: s, password: o, options: a } = e; n = await ne(this.fetch, "POST", `${this.url}/token?grant_type=password`, { headers: this.headers, body: { email: s, password: o, gotrue_meta_security: { captcha_token: a == null ? void 0 : a.captchaToken } }, xform: hg }) } else if ("phone" in e) { const { phone: s, password: o, options: a } = e; n = await ne(this.fetch, "POST", `${this.url}/token?grant_type=password`, { headers: this.headers, body: { phone: s, password: o, gotrue_meta_security: { captcha_token: a == null ? void 0 : a.captchaToken } }, xform: hg }) } else throw new Wo("You must provide either an email or phone number and a password"); const { data: r, error: i } = n; return i ? { data: { user: null, session: null }, error: i } : !r || !r.session || !r.user ? { data: { user: null, session: null }, error: new Ju } : (r.session && (await this._saveSession(r.session), await this._notifyAllSubscribers("SIGNED_IN", r.session)), { data: Object.assign({ user: r.user, session: r.session }, r.weak_password ? { weakPassword: r.weak_password } : null), error: i }) } catch (n) { if (ee(n)) return { data: { user: null, session: null }, error: n }; throw n } } async signInWithOAuth(e) { var n, r, i, s; return await this._handleProviderSignIn(e.provider, { redirectTo: (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo, scopes: (r = e.options) === null || r === void 0 ? void 0 : r.scopes, queryParams: (i = e.options) === null || i === void 0 ? void 0 : i.queryParams, skipBrowserRedirect: (s = e.options) === null || s === void 0 ? void 0 : s.skipBrowserRedirect }) } async exchangeCodeForSession(e) { return await this.initializePromise, this._acquireLock(-1, async () => this._exchangeCodeForSession(e)) } async _exchangeCodeForSession(e) { const n = await Ho(this.storage, `${this.storageKey}-code-verifier`), [r, i] = (n ?? "").split("/"), { data: s, error: o } = await ne(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, { headers: this.headers, body: { auth_code: e, code_verifier: r }, xform: Ln }); return await Xu(this.storage, `${this.storageKey}-code-verifier`), o ? { data: { user: null, session: null, redirectType: null }, error: o } : !s || !s.session || !s.user ? { data: { user: null, session: null, redirectType: null }, error: new Ju } : (s.session && (await this._saveSession(s.session), await this._notifyAllSubscribers("SIGNED_IN", s.session)), { data: Object.assign(Object.assign({}, s), { redirectType: i ?? null }), error: o }) } async signInWithIdToken(e) { try { const { options: n, provider: r, token: i, access_token: s, nonce: o } = e, a = await ne(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, { headers: this.headers, body: { provider: r, id_token: i, access_token: s, nonce: o, gotrue_meta_security: { captcha_token: n == null ? void 0 : n.captchaToken } }, xform: Ln }), { data: l, error: u } = a; return u ? { data: { user: null, session: null }, error: u } : !l || !l.session || !l.user ? { data: { user: null, session: null }, error: new Ju } : (l.session && (await this._saveSession(l.session), await this._notifyAllSubscribers("SIGNED_IN", l.session)), { data: l, error: u }) } catch (n) { if (ee(n)) return { data: { user: null, session: null }, error: n }; throw n } } async signInWithOtp(e) { var n, r, i, s, o; try { if ("email" in e) { const { email: a, options: l } = e; let u = null, c = null; this.flowType === "pkce" && ([u, c] = await Qr(this.storage, this.storageKey)); const { error: d } = await ne(this.fetch, "POST", `${this.url}/otp`, { headers: this.headers, body: { email: a, data: (n = l == null ? void 0 : l.data) !== null && n !== void 0 ? n : {}, create_user: (r = l == null ? void 0 : l.shouldCreateUser) !== null && r !== void 0 ? r : !0, gotrue_meta_security: { captcha_token: l == null ? void 0 : l.captchaToken }, code_challenge: u, code_challenge_method: c }, redirectTo: l == null ? void 0 : l.emailRedirectTo }); return { data: { user: null, session: null }, error: d } } if ("phone" in e) { const { phone: a, options: l } = e, { data: u, error: c } = await ne(this.fetch, "POST", `${this.url}/otp`, { headers: this.headers, body: { phone: a, data: (i = l == null ? void 0 : l.data) !== null && i !== void 0 ? i : {}, create_user: (s = l == null ? void 0 : l.shouldCreateUser) !== null && s !== void 0 ? s : !0, gotrue_meta_security: { captcha_token: l == null ? void 0 : l.captchaToken }, channel: (o = l == null ? void 0 : l.channel) !== null && o !== void 0 ? o : "sms" } }); return { data: { user: null, session: null, messageId: u == null ? void 0 : u.message_id }, error: c } } throw new Wo("You must provide either an email or phone number.") } catch (a) { if (ee(a)) return { data: { user: null, session: null }, error: a }; throw a } } async verifyOtp(e) { var n, r; try { let i, s; "options" in e && (i = (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo, s = (r = e.options) === null || r === void 0 ? void 0 : r.captchaToken); const { data: o, error: a } = await ne(this.fetch, "POST", `${this.url}/verify`, { headers: this.headers, body: Object.assign(Object.assign({}, e), { gotrue_meta_security: { captcha_token: s } }), redirectTo: i, xform: Ln }); if (a) throw a; if (!o) throw new Error("An error occurred on token verification."); const l = o.session, u = o.user; return l != null && l.access_token && (await this._saveSession(l), await this._notifyAllSubscribers(e.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", l)), { data: { user: u, session: l }, error: null } } catch (i) { if (ee(i)) return { data: { user: null, session: null }, error: i }; throw i } } async signInWithSSO(e) { var n, r, i; try { let s = null, o = null; return this.flowType === "pkce" && ([s, o] = await Qr(this.storage, this.storageKey)), await ne(this.fetch, "POST", `${this.url}/sso`, { body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in e ? { provider_id: e.providerId } : null), "domain" in e ? { domain: e.domain } : null), { redirect_to: (r = (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo) !== null && r !== void 0 ? r : void 0 }), !((i = e == null ? void 0 : e.options) === null || i === void 0) && i.captchaToken ? { gotrue_meta_security: { captcha_token: e.options.captchaToken } } : null), { skip_http_redirect: !0, code_challenge: s, code_challenge_method: o }), headers: this.headers, xform: bC }) } catch (s) { if (ee(s)) return { data: null, error: s }; throw s } } async reauthenticate() { return await this.initializePromise, await this._acquireLock(-1, async () => await this._reauthenticate()) } async _reauthenticate() { try { return await this._useSession(async e => { const { data: { session: n }, error: r } = e; if (r) throw r; if (!n) throw new fr; const { error: i } = await ne(this.fetch, "GET", `${this.url}/reauthenticate`, { headers: this.headers, jwt: n.access_token }); return { data: { user: null, session: null }, error: i } }) } catch (e) { if (ee(e)) return { data: { user: null, session: null }, error: e }; throw e } } async resend(e) { try { const n = `${this.url}/resend`; if ("email" in e) { const { email: r, type: i, options: s } = e, { error: o } = await ne(this.fetch, "POST", n, { headers: this.headers, body: { email: r, type: i, gotrue_meta_security: { captcha_token: s == null ? void 0 : s.captchaToken } }, redirectTo: s == null ? void 0 : s.emailRedirectTo }); return { data: { user: null, session: null }, error: o } } else if ("phone" in e) { const { phone: r, type: i, options: s } = e, { data: o, error: a } = await ne(this.fetch, "POST", n, { headers: this.headers, body: { phone: r, type: i, gotrue_meta_security: { captcha_token: s == null ? void 0 : s.captchaToken } } }); return { data: { user: null, session: null, messageId: o == null ? void 0 : o.message_id }, error: a } } throw new Wo("You must provide either an email or phone number and a type") } catch (n) { if (ee(n)) return { data: { user: null, session: null }, error: n }; throw n } } async getSession() { return await this.initializePromise, await this._acquireLock(-1, async () => this._useSession(async n => n)) } async _acquireLock(e, n) { this._debug("#_acquireLock", "begin", e); try { if (this.lockAcquired) { const r = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve(), i = (async () => (await r, await n()))(); return this.pendingInLock.push((async () => { try { await i } catch { } })()), i } return await this.lock(`lock:${this.storageKey}`, e, async () => { this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey); try { this.lockAcquired = !0; const r = n(); for (this.pendingInLock.push((async () => { try { await r } catch { } })()), await r; this.pendingInLock.length;) { const i = [...this.pendingInLock]; await Promise.all(i), this.pendingInLock.splice(0, i.length) } return await r } finally { this._debug("#_acquireLock", "lock released for storage key", this.storageKey), this.lockAcquired = !1 } }) } finally { this._debug("#_acquireLock", "end") } } async _useSession(e) { this._debug("#_useSession", "begin"); try { const n = await this.__loadSession(); return await e(n) } finally { this._debug("#_useSession", "end") } } async __loadSession() { this._debug("#__loadSession()", "begin"), this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack); try { let e = null; const n = await Ho(this.storage, this.storageKey); if (this._debug("#getSession()", "session from storage", n), n !== null && (this._isValidSession(n) ? e = n : (this._debug("#getSession()", "session from storage is not valid"), await this._removeSession())), !e) return { data: { session: null }, error: null }; const r = e.expires_at ? e.expires_at <= Date.now() / 1e3 : !1; if (this._debug("#__loadSession()", `session has${r ? "" : " not"} expired`, "expires_at", e.expires_at), !r) { if (this.storage.isServer) { let o = this.suppressGetSessionWarning; e = new Proxy(e, { get: (l, u, c) => (!o && u === "user" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and many not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."), o = !0, this.suppressGetSessionWarning = !0), Reflect.get(l, u, c)) }) } return { data: { session: e }, error: null } } const { session: i, error: s } = await this._callRefreshToken(e.refresh_token); return s ? { data: { session: null }, error: s } : { data: { session: i }, error: null } } finally { this._debug("#__loadSession()", "end") } } async getUser(e) { return e ? await this._getUser(e) : (await this.initializePromise, await this._acquireLock(-1, async () => await this._getUser())) } async _getUser(e) { try { return e ? await ne(this.fetch, "GET", `${this.url}/user`, { headers: this.headers, jwt: e, xform: $n }) : await this._useSession(async n => { var r, i, s; const { data: o, error: a } = n; if (a) throw a; return !(!((r = o.session) === null || r === void 0) && r.access_token) && !this.hasCustomAuthorizationHeader ? { data: { user: null }, error: new fr } : await ne(this.fetch, "GET", `${this.url}/user`, { headers: this.headers, jwt: (s = (i = o.session) === null || i === void 0 ? void 0 : i.access_token) !== null && s !== void 0 ? s : void 0, xform: $n }) }) } catch (n) { if (ee(n)) return { data: { user: null }, error: n }; throw n } } async updateUser(e, n = {}) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._updateUser(e, n)) } async _updateUser(e, n = {}) { try { return await this._useSession(async r => { const { data: i, error: s } = r; if (s) throw s; if (!i.session) throw new fr; const o = i.session; let a = null, l = null; this.flowType === "pkce" && e.email != null && ([a, l] = await Qr(this.storage, this.storageKey)); const { data: u, error: c } = await ne(this.fetch, "PUT", `${this.url}/user`, { headers: this.headers, redirectTo: n == null ? void 0 : n.emailRedirectTo, body: Object.assign(Object.assign({}, e), { code_challenge: a, code_challenge_method: l }), jwt: o.access_token, xform: $n }); if (c) throw c; return o.user = u.user, await this._saveSession(o), await this._notifyAllSubscribers("USER_UPDATED", o), { data: { user: o.user }, error: null } }) } catch (r) { if (ee(r)) return { data: { user: null }, error: r }; throw r } } _decodeJWT(e) { return lg(e) } async setSession(e) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._setSession(e)) } async _setSession(e) { try { if (!e.access_token || !e.refresh_token) throw new fr; const n = Date.now() / 1e3; let r = n, i = !0, s = null; const o = lg(e.access_token); if (o.exp && (r = o.exp, i = r <= n), i) { const { session: a, error: l } = await this._callRefreshToken(e.refresh_token); if (l) return { data: { user: null, session: null }, error: l }; if (!a) return { data: { user: null, session: null }, error: null }; s = a } else { const { data: a, error: l } = await this._getUser(e.access_token); if (l) throw l; s = { access_token: e.access_token, refresh_token: e.refresh_token, user: a.user, token_type: "bearer", expires_in: r - n, expires_at: r }, await this._saveSession(s), await this._notifyAllSubscribers("SIGNED_IN", s) } return { data: { user: s.user, session: s }, error: null } } catch (n) { if (ee(n)) return { data: { session: null, user: null }, error: n }; throw n } } async refreshSession(e) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._refreshSession(e)) } async _refreshSession(e) { try { return await this._useSession(async n => { var r; if (!e) { const { data: o, error: a } = n; if (a) throw a; e = (r = o.session) !== null && r !== void 0 ? r : void 0 } if (!(e != null && e.refresh_token)) throw new fr; const { session: i, error: s } = await this._callRefreshToken(e.refresh_token); return s ? { data: { user: null, session: null }, error: s } : i ? { data: { user: i.user, session: i }, error: null } : { data: { user: null, session: null }, error: null } }) } catch (n) { if (ee(n)) return { data: { user: null, session: null }, error: n }; throw n } } async _getSessionFromURL(e) { try { if (!Vt()) throw new qo("No browser detected."); if (this.flowType === "implicit" && !this._isImplicitGrantFlow()) throw new qo("Not a valid implicit grant flow url."); if (this.flowType == "pkce" && !e) throw new ug("Not a valid PKCE flow url."); const n = Qu(window.location.href); if (e) { if (!n.code) throw new ug("No code detected."); const { data: v, error: b } = await this._exchangeCodeForSession(n.code); if (b) throw b; const x = new URL(window.location.href); return x.searchParams.delete("code"), window.history.replaceState(window.history.state, "", x.toString()), { data: { session: v.session, redirectType: null }, error: null } } if (n.error || n.error_description || n.error_code) throw new qo(n.error_description || "Error in URL with unspecified error_description", { error: n.error || "unspecified_error", code: n.error_code || "unspecified_code" }); const { provider_token: r, provider_refresh_token: i, access_token: s, refresh_token: o, expires_in: a, expires_at: l, token_type: u } = n; if (!s || !a || !o || !u) throw new qo("No session defined in URL"); const c = Math.round(Date.now() / 1e3), d = parseInt(a); let h = c + d; l && (h = parseInt(l)); const f = h - c; f * 1e3 <= ns && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${f}s, should have been closer to ${d}s`); const g = h - d; c - g >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", g, h, c) : c - g < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clok for skew", g, h, c); const { data: m, error: y } = await this._getUser(s); if (y) throw y; const p = { provider_token: r, provider_refresh_token: i, access_token: s, expires_in: d, expires_at: h, refresh_token: o, token_type: u, user: m.user }; return window.location.hash = "", this._debug("#_getSessionFromURL()", "clearing window.location.hash"), { data: { session: p, redirectType: n.type }, error: null } } catch (n) { if (ee(n)) return { data: { session: null, redirectType: null }, error: n }; throw n } } _isImplicitGrantFlow() { const e = Qu(window.location.href); return !!(Vt() && (e.access_token || e.error_description)) } async _isPKCEFlow() { const e = Qu(window.location.href), n = await Ho(this.storage, `${this.storageKey}-code-verifier`); return !!(e.code && n) } async signOut(e = { scope: "global" }) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._signOut(e)) } async _signOut({ scope: e } = { scope: "global" }) { return await this._useSession(async n => { var r; const { data: i, error: s } = n; if (s) return { error: s }; const o = (r = i.session) === null || r === void 0 ? void 0 : r.access_token; if (o) { const { error: a } = await this.admin.signOut(o, e); if (a && !(pC(a) && (a.status === 404 || a.status === 401 || a.status === 403))) return { error: a } } return e !== "others" && (await this._removeSession(), await Xu(this.storage, `${this.storageKey}-code-verifier`), await this._notifyAllSubscribers("SIGNED_OUT", null)), { error: null } }) } onAuthStateChange(e) { const n = tC(), r = { id: n, callback: e, unsubscribe: () => { this._debug("#unsubscribe()", "state change callback with id removed", n), this.stateChangeEmitters.delete(n) } }; return this._debug("#onAuthStateChange()", "registered callback with id", n), this.stateChangeEmitters.set(n, r), (async () => (await this.initializePromise, await this._acquireLock(-1, async () => { this._emitInitialSession(n) })))(), { data: { subscription: r } } } async _emitInitialSession(e) { return await this._useSession(async n => { var r, i; try { const { data: { session: s }, error: o } = n; if (o) throw o; await ((r = this.stateChangeEmitters.get(e)) === null || r === void 0 ? void 0 : r.callback("INITIAL_SESSION", s)), this._debug("INITIAL_SESSION", "callback id", e, "session", s) } catch (s) { await ((i = this.stateChangeEmitters.get(e)) === null || i === void 0 ? void 0 : i.callback("INITIAL_SESSION", null)), this._debug("INITIAL_SESSION", "callback id", e, "error", s), console.error(s) } }) } async resetPasswordForEmail(e, n = {}) { let r = null, i = null; this.flowType === "pkce" && ([r, i] = await Qr(this.storage, this.storageKey, !0)); try { return await ne(this.fetch, "POST", `${this.url}/recover`, { body: { email: e, code_challenge: r, code_challenge_method: i, gotrue_meta_security: { captcha_token: n.captchaToken } }, headers: this.headers, redirectTo: n.redirectTo }) } catch (s) { if (ee(s)) return { data: null, error: s }; throw s } } async getUserIdentities() { var e; try { const { data: n, error: r } = await this.getUser(); if (r) throw r; return { data: { identities: (e = n.user.identities) !== null && e !== void 0 ? e : [] }, error: null } } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } } async linkIdentity(e) { var n; try { const { data: r, error: i } = await this._useSession(async s => { var o, a, l, u, c; const { data: d, error: h } = s; if (h) throw h; const f = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, e.provider, { redirectTo: (o = e.options) === null || o === void 0 ? void 0 : o.redirectTo, scopes: (a = e.options) === null || a === void 0 ? void 0 : a.scopes, queryParams: (l = e.options) === null || l === void 0 ? void 0 : l.queryParams, skipBrowserRedirect: !0 }); return await ne(this.fetch, "GET", f, { headers: this.headers, jwt: (c = (u = d.session) === null || u === void 0 ? void 0 : u.access_token) !== null && c !== void 0 ? c : void 0 }) }); if (i) throw i; return Vt() && !(!((n = e.options) === null || n === void 0) && n.skipBrowserRedirect) && window.location.assign(r == null ? void 0 : r.url), { data: { provider: e.provider, url: r == null ? void 0 : r.url }, error: null } } catch (r) { if (ee(r)) return { data: { provider: e.provider, url: null }, error: r }; throw r } } async unlinkIdentity(e) { try { return await this._useSession(async n => { var r, i; const { data: s, error: o } = n; if (o) throw o; return await ne(this.fetch, "DELETE", `${this.url}/user/identities/${e.identity_id}`, { headers: this.headers, jwt: (i = (r = s.session) === null || r === void 0 ? void 0 : r.access_token) !== null && i !== void 0 ? i : void 0 }) }) } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } } async _refreshAccessToken(e) { const n = `#_refreshAccessToken(${e.substring(0, 5)}...)`; this._debug(n, "begin"); try { const r = Date.now(); return await sC(async i => (i > 0 && await iC(200 * Math.pow(2, i - 1)), this._debug(n, "refreshing attempt", i), await ne(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, { body: { refresh_token: e }, headers: this.headers, xform: Ln })), (i, s) => { const o = 200 * Math.pow(2, i); return s && Zu(s) && Date.now() + o - r < ns }) } catch (r) { if (this._debug(n, "error", r), ee(r)) return { data: { session: null, user: null }, error: r }; throw r } finally { this._debug(n, "end") } } _isValidSession(e) { return typeof e == "object" && e !== null && "access_token" in e && "refresh_token" in e && "expires_at" in e } async _handleProviderSignIn(e, n) { const r = await this._getUrlForProvider(`${this.url}/authorize`, e, { redirectTo: n.redirectTo, scopes: n.scopes, queryParams: n.queryParams }); return this._debug("#_handleProviderSignIn()", "provider", e, "options", n, "url", r), Vt() && !n.skipBrowserRedirect && window.location.assign(r), { data: { provider: e, url: r }, error: null } } async _recoverAndRefresh() { var e; const n = "#_recoverAndRefresh()"; this._debug(n, "begin"); try { const r = await Ho(this.storage, this.storageKey); if (this._debug(n, "session from storage", r), !this._isValidSession(r)) { this._debug(n, "session is not valid"), r !== null && await this._removeSession(); return } const i = Math.round(Date.now() / 1e3), s = ((e = r.expires_at) !== null && e !== void 0 ? e : 1 / 0) < i + ag; if (this._debug(n, `session has${s ? "" : " not"} expired with margin of ${ag}s`), s) { if (this.autoRefreshToken && r.refresh_token) { const { error: o } = await this._callRefreshToken(r.refresh_token); o && (console.error(o), Zu(o) || (this._debug(n, "refresh failed with a non-retryable error, removing the session", o), await this._removeSession())) } } else await this._notifyAllSubscribers("SIGNED_IN", r) } catch (r) { this._debug(n, "error", r), console.error(r); return } finally { this._debug(n, "end") } } async _callRefreshToken(e) { var n, r; if (!e) throw new fr; if (this.refreshingDeferred) return this.refreshingDeferred.promise; const i = `#_callRefreshToken(${e.substring(0, 5)}...)`; this._debug(i, "begin"); try { this.refreshingDeferred = new Ql; const { data: s, error: o } = await this._refreshAccessToken(e); if (o) throw o; if (!s.session) throw new fr; await this._saveSession(s.session), await this._notifyAllSubscribers("TOKEN_REFRESHED", s.session); const a = { session: s.session, error: null }; return this.refreshingDeferred.resolve(a), a } catch (s) { if (this._debug(i, "error", s), ee(s)) { const o = { session: null, error: s }; return Zu(s) || (await this._removeSession(), await this._notifyAllSubscribers("SIGNED_OUT", null)), (n = this.refreshingDeferred) === null || n === void 0 || n.resolve(o), o } throw (r = this.refreshingDeferred) === null || r === void 0 || r.reject(s), s } finally { this.refreshingDeferred = null, this._debug(i, "end") } } async _notifyAllSubscribers(e, n, r = !0) { const i = `#_notifyAllSubscribers(${e})`; this._debug(i, "begin", n, `broadcast = ${r}`); try { this.broadcastChannel && r && this.broadcastChannel.postMessage({ event: e, session: n }); const s = [], o = Array.from(this.stateChangeEmitters.values()).map(async a => { try { await a.callback(e, n) } catch (l) { s.push(l) } }); if (await Promise.all(o), s.length > 0) { for (let a = 0; a < s.length; a += 1)console.error(s[a]); throw s[0] } } finally { this._debug(i, "end") } } async _saveSession(e) { this._debug("#_saveSession()", e), this.suppressGetSessionWarning = !0, await ib(this.storage, this.storageKey, e) } async _removeSession() { this._debug("#_removeSession()"), await Xu(this.storage, this.storageKey) } _removeVisibilityChangedCallback() { this._debug("#_removeVisibilityChangedCallback()"); const e = this.visibilityChangedCallback; this.visibilityChangedCallback = null; try { e && Vt() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", e) } catch (n) { console.error("removing visibilitychange callback failed", n) } } async _startAutoRefresh() { await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()"); const e = setInterval(() => this._autoRefreshTokenTick(), ns); this.autoRefreshTicker = e, e && typeof e == "object" && typeof e.unref == "function" ? e.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(e), setTimeout(async () => { await this.initializePromise, await this._autoRefreshTokenTick() }, 0) } async _stopAutoRefresh() { this._debug("#_stopAutoRefresh()"); const e = this.autoRefreshTicker; this.autoRefreshTicker = null, e && clearInterval(e) } async startAutoRefresh() { this._removeVisibilityChangedCallback(), await this._startAutoRefresh() } async stopAutoRefresh() { this._removeVisibilityChangedCallback(), await this._stopAutoRefresh() } async _autoRefreshTokenTick() { this._debug("#_autoRefreshTokenTick()", "begin"); try { await this._acquireLock(0, async () => { try { const e = Date.now(); try { return await this._useSession(async n => { const { data: { session: r } } = n; if (!r || !r.refresh_token || !r.expires_at) { this._debug("#_autoRefreshTokenTick()", "no session"); return } const i = Math.floor((r.expires_at * 1e3 - e) / ns); this._debug("#_autoRefreshTokenTick()", `access token expires in ${i} ticks, a tick lasts ${ns}ms, refresh threshold is ${pg} ticks`), i <= pg && await this._callRefreshToken(r.refresh_token) }) } catch (n) { console.error("Auto refresh tick failed with error. This is likely a transient error.", n) } } finally { this._debug("#_autoRefreshTokenTick()", "end") } }) } catch (e) { if (e.isAcquireTimeout || e instanceof ob) this._debug("auto refresh token tick lock not available"); else throw e } } async _handleVisibilityChange() { if (this._debug("#_handleVisibilityChange()"), !Vt() || !(window != null && window.addEventListener)) return this.autoRefreshToken && this.startAutoRefresh(), !1; try { this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1), window == null || window.addEventListener("visibilitychange", this.visibilityChangedCallback), await this._onVisibilityChanged(!0) } catch (e) { console.error("_handleVisibilityChange", e) } } async _onVisibilityChanged(e) { const n = `#_onVisibilityChanged(${e})`; this._debug(n, "visibilityState", document.visibilityState), document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(), e || (await this.initializePromise, await this._acquireLock(-1, async () => { if (document.visibilityState !== "visible") { this._debug(n, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting"); return } await this._recoverAndRefresh() }))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh() } async _getUrlForProvider(e, n, r) { const i = [`provider=${encodeURIComponent(n)}`]; if (r != null && r.redirectTo && i.push(`redirect_to=${encodeURIComponent(r.redirectTo)}`), r != null && r.scopes && i.push(`scopes=${encodeURIComponent(r.scopes)}`), this.flowType === "pkce") { const [s, o] = await Qr(this.storage, this.storageKey), a = new URLSearchParams({ code_challenge: `${encodeURIComponent(s)}`, code_challenge_method: `${encodeURIComponent(o)}` }); i.push(a.toString()) } if (r != null && r.queryParams) { const s = new URLSearchParams(r.queryParams); i.push(s.toString()) } return r != null && r.skipBrowserRedirect && i.push(`skip_http_redirect=${r.skipBrowserRedirect}`), `${e}?${i.join("&")}` } async _unenroll(e) { try { return await this._useSession(async n => { var r; const { data: i, error: s } = n; return s ? { data: null, error: s } : await ne(this.fetch, "DELETE", `${this.url}/factors/${e.factorId}`, { headers: this.headers, jwt: (r = i == null ? void 0 : i.session) === null || r === void 0 ? void 0 : r.access_token }) }) } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } } async _enroll(e) { try { return await this._useSession(async n => { var r, i; const { data: s, error: o } = n; if (o) return { data: null, error: o }; const { data: a, error: l } = await ne(this.fetch, "POST", `${this.url}/factors`, { body: { friendly_name: e.friendlyName, factor_type: e.factorType, issuer: e.issuer }, headers: this.headers, jwt: (r = s == null ? void 0 : s.session) === null || r === void 0 ? void 0 : r.access_token }); return l ? { data: null, error: l } : (!((i = a == null ? void 0 : a.totp) === null || i === void 0) && i.qr_code && (a.totp.qr_code = `data:image/svg+xml;utf-8,${a.totp.qr_code}`), { data: a, error: null }) }) } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } } async _verify(e) { return this._acquireLock(-1, async () => { try { return await this._useSession(async n => { var r; const { data: i, error: s } = n; if (s) return { data: null, error: s }; const { data: o, error: a } = await ne(this.fetch, "POST", `${this.url}/factors/${e.factorId}/verify`, { body: { code: e.code, challenge_id: e.challengeId }, headers: this.headers, jwt: (r = i == null ? void 0 : i.session) === null || r === void 0 ? void 0 : r.access_token }); return a ? { data: null, error: a } : (await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + o.expires_in }, o)), await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", o), { data: o, error: a }) }) } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } }) } async _challenge(e) { return this._acquireLock(-1, async () => { try { return await this._useSession(async n => { var r; const { data: i, error: s } = n; return s ? { data: null, error: s } : await ne(this.fetch, "POST", `${this.url}/factors/${e.factorId}/challenge`, { headers: this.headers, jwt: (r = i == null ? void 0 : i.session) === null || r === void 0 ? void 0 : r.access_token }) }) } catch (n) { if (ee(n)) return { data: null, error: n }; throw n } }) } async _challengeAndVerify(e) { const { data: n, error: r } = await this._challenge({ factorId: e.factorId }); return r ? { data: null, error: r } : await this._verify({ factorId: e.factorId, challengeId: n.id, code: e.code }) } async _listFactors() { const { data: { user: e }, error: n } = await this.getUser(); if (n) return { data: null, error: n }; const r = (e == null ? void 0 : e.factors) || [], i = r.filter(s => s.factor_type === "totp" && s.status === "verified"); return { data: { all: r, totp: i }, error: null } } async _getAuthenticatorAssuranceLevel() { return this._acquireLock(-1, async () => await this._useSession(async e => { var n, r; const { data: { session: i }, error: s } = e; if (s) return { data: null, error: s }; if (!i) return { data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] }, error: null }; const o = this._decodeJWT(i.access_token); let a = null; o.aal && (a = o.aal); let l = a; ((r = (n = i.user.factors) === null || n === void 0 ? void 0 : n.filter(d => d.status === "verified")) !== null && r !== void 0 ? r : []).length > 0 && (l = "aal2"); const c = o.amr || []; return { data: { currentLevel: a, nextLevel: l, currentAuthenticationMethods: c }, error: null } })) } } eo.nextInstanceID = 0; const IC = eo; class RC extends IC { constructor(e) { super(e) } } var MC = function (t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) } return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : i(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }; class LC { constructor(e, n, r) { var i, s, o; if (this.supabaseUrl = e, this.supabaseKey = n, !e) throw new Error("supabaseUrl is required."); if (!n) throw new Error("supabaseKey is required."); const a = Yk(e); this.realtimeUrl = `${a}/realtime/v1`.replace(/^http/i, "ws"), this.authUrl = `${a}/auth/v1`, this.storageUrl = `${a}/storage/v1`, this.functionsUrl = `${a}/functions/v1`; const l = `sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`, u = { db: Vk, realtime: Uk, auth: Object.assign(Object.assign({}, Bk), { storageKey: l }), global: zk }, c = Qk(r ?? {}, u); this.storageKey = (i = c.auth.storageKey) !== null && i !== void 0 ? i : "", this.headers = (s = c.global.headers) !== null && s !== void 0 ? s : {}, c.accessToken ? (this.accessToken = c.accessToken, this.auth = new Proxy({}, { get: (d, h) => { throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(h)} is not possible`) } })) : this.auth = this._initSupabaseAuthClient((o = c.auth) !== null && o !== void 0 ? o : {}, this.headers, c.global.fetch), this.fetch = Kk(n, this._getAccessToken.bind(this), c.global.fetch), this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers }, c.realtime)), this.rest = new ck(`${a}/rest/v1`, { headers: this.headers, schema: c.db.schema, fetch: this.fetch }), c.accessToken || this._listenForAuthEvents() } get functions() { return new z1(this.functionsUrl, { headers: this.headers, customFetch: this.fetch }) } get storage() { return new Nk(this.storageUrl, this.headers, this.fetch) } from(e) { return this.rest.from(e) } schema(e) { return this.rest.schema(e) } rpc(e, n = {}, r = {}) { return this.rest.rpc(e, n, r) } channel(e, n = { config: {} }) { return this.realtime.channel(e, n) } getChannels() { return this.realtime.getChannels() } removeChannel(e) { return this.realtime.removeChannel(e) } removeAllChannels() { return this.realtime.removeAllChannels() } _getAccessToken() { var e, n; return MC(this, void 0, void 0, function* () { if (this.accessToken) return yield this.accessToken(); const { data: r } = yield this.auth.getSession(); return (n = (e = r.session) === null || e === void 0 ? void 0 : e.access_token) !== null && n !== void 0 ? n : null }) } _initSupabaseAuthClient({ autoRefreshToken: e, persistSession: n, detectSessionInUrl: r, storage: i, storageKey: s, flowType: o, debug: a }, l, u) { var c; const d = { Authorization: `Bearer ${this.supabaseKey}`, apikey: `${this.supabaseKey}` }; return new RC({ url: this.authUrl, headers: Object.assign(Object.assign({}, d), l), storageKey: s, autoRefreshToken: e, persistSession: n, detectSessionInUrl: r, storage: i, flowType: o, debug: a, fetch: u, hasCustomAuthorizationHeader: (c = "Authorization" in this.headers) !== null && c !== void 0 ? c : !1 }) } _initRealtimeClient(e) { return new kk(this.realtimeUrl, Object.assign(Object.assign({}, e), { params: Object.assign({ apikey: this.supabaseKey }, e == null ? void 0 : e.params) })) } _listenForAuthEvents() { return this.auth.onAuthStateChange((n, r) => { this._handleTokenChanged(n, "CLIENT", r == null ? void 0 : r.access_token) }) } _handleTokenChanged(e, n, r) { (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") && this.changedAccessToken !== r ? (this.realtime.setAuth(r ?? null), this.changedAccessToken = r) : e === "SIGNED_OUT" && (this.realtime.setAuth(this.supabaseKey), n == "STORAGE" && this.auth.signOut(), this.changedAccessToken = void 0) } } const DC = (t, e, n) => new LC(t, e, n), jC = "https://kbkzeihbxlpsvkjpczms.supabase.co", AC = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imtia3plaWhieGxwc3ZranBjem1zIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjExOTk2NzQsImV4cCI6MjAzNjc3NTY3NH0.fRsuMrxSGlAYFNGhysj46ajeecKWf5IGaJtchtMQA2Y", we = DC(jC, AC), Is = "./assets/banking-B5UmtjCw.jpg", NC = () => { var h; const [t, e] = R.useState(null), [n, r] = R.useState(!1), [i, s] = R.useState(!1), o = R.useRef(null), a = R.useRef(null), l = Vr(); R.useEffect(() => { (async () => { const { data: { user: g } } = await we.auth.getUser(); e(g) })() }, []); const u = () => { s(!i) }, c = () => { r(!n) }; R.useEffect(() => { const f = g => { o.current && !o.current.contains(g.target) && s(!1), a.current && !a.current.contains(g.target) && r(!1) }; return document.addEventListener("mousedown", f), () => { document.removeEventListener("mousedown", f) } }, []); const d = async () => { window.confirm("tes-vous sr de vouloir vous dconnecter ?") && (await we.auth.signOut(), l("/Home"), l("/"), window.location.reload()) }; return k.jsx("div", { children: k.jsx("nav", { className: "bg-blue-500 text-white p-4", children: k.jsxs("div", { className: "flex justify-between items-center", children: [k.jsxs(Et, { to: t ? "/accountform" : "/", className: "flex items-center text-white mr-4 max-sm:hidden", children: [k.jsx("img", { src: Is, alt: "Logo", className: "w-12 rounded-full", style: { cursor: "pointer" } }), k.jsx("h1", { className: "text-2xl pl-3", children: "Gestion de Comptes" })] }), t ? k.jsxs("div", { className: "flex justify-evenly w-1/2 items-center max-sm:hidden", children: [k.jsx(Et, { to: "/accountform", className: "text-white border border-gray-200 rounded-md p-2", children: "Accueil" }), k.jsx(Et, { to: "/tableau", className: "text-white border border-gray-200 rounded-md p-2", children: "Tableau" }), k.jsx(Et, { to: "/graphique", className: "text-white border border-gray-200 rounded-md p-2", children: "Graphique" }), k.jsx(Et, { to: "/EnvellopesVirtuelles", className: "text-white border border-gray-200 rounded-md p-2", children: "Envellopes Virtuelles" }), " "] }) : null, k.jsxs(Et, { to: t ? "/accountform" : "/", className: "flex items-center text-white mr-4 sm:hidden", children: [k.jsx("img", { src: Is, alt: "Logo", className: "w-12 rounded-full", style: { cursor: "pointer" } }), k.jsx("h1", { className: "text-2xl pl-3", children: "Gestion de Comptes" })] }), t ? k.jsxs("div", { className: "flex justify-evenly sm:flex-row flex-col w-max items-center sm:hidden", children: [k.jsx("button", { className: "sm:hidden text-white border border-gray-200 rounded-md p-2 mb-2", onClick: u, children: k.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: k.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M4 6h16M4 12h16m-7 6h7" }) }) }), k.jsxs("div", { ref: o, className: `flex sm:w-full sm:flex-row flex-col justify-evenly items-center sm:static sm:top-auto max-sm:absolute max-sm:top-[100px] max-sm:left-1/2 transform max-sm:-translate-x-1/2 bg-blue-500 p-4 rounded-md w-[100vw] z-10 ${i ? "block" : "hidden"} sm:block`, children: [k.jsx(Et, { to: "/accountform", className: "text-white border border-gray-200 rounded-md p-2 mb-2 sm:mb-0", children: "Accueil" }), k.jsx(Et, { to: "/tableau", className: "text-white border border-gray-200 rounded-md p-2 mb-2 sm:mb-0", children: "Tableau" }), k.jsx(Et, { to: "/graphique", className: "text-white border border-gray-200 rounded-md p-2 mb-2 sm:mb-0", children: "Graphique" }), k.jsx(Et, { to: "/EnvellopesVirtuelles", className: "text-white border border-gray-200 rounded-md p-2", children: "Envellopes Virtuelles" }), " "] })] }) : null, k.jsx("div", { className: "relative flex items-center", children: t ? k.jsxs("div", { className: "relative flex flex-col items-center pr-4", onClick: c, ref: a, children: [k.jsx("img", { src: Is, alt: "Avatar", className: "w-8 h-8 rounded-full cursor-pointer" }), k.jsx("span", { className: "text-sm cursor-pointer", children: ((h = t.user_metadata) == null ? void 0 : h.full_name) || t.email }), n && k.jsxs("div", { className: "absolute top-full mt-2 w-48 bg-white text-black rounded shadow-lg", children: [k.jsx("button", { onClick: () => l("/parametres"), className: "block w-full text-left px-4 py-2 bg-gray-200 hover:bg-slate-400", children: "Paramtres" }), k.jsx("button", { onClick: () => l("/contact"), className: "block w-full text-left px-4 py-2 bg-gray-200 hover:bg-slate-400", children: "Contact" }), k.jsx("button", { onClick: d, className: "block w-full text-left px-4 py-2 bg-gray-200 hover:bg-slate-400", children: "Dconnexion" })] })] }) : k.jsx(Et, { to: "/auth", className: "text-white mr-4", children: "Connexion" }) })] }) }) }) }; var FC = { exports: {} }; (function (t) { var e = function (n) { var r = Object.prototype, i = r.hasOwnProperty, s = Object.defineProperty || function (_, S, E) { _[S] = E.value }, o, a = typeof Symbol == "function" ? Symbol : {}, l = a.iterator || "@@iterator", u = a.asyncIterator || "@@asyncIterator", c = a.toStringTag || "@@toStringTag"; function d(_, S, E) { return Object.defineProperty(_, S, { value: E, enumerable: !0, configurable: !0, writable: !0 }), _[S] } try { d({}, "") } catch { d = function (S, E, w) { return S[E] = w } } function h(_, S, E, w) { var O = S && S.prototype instanceof b ? S : b, j = Object.create(O.prototype), $ = new q(w || []); return s(j, "_invoke", { value: N(_, E, $) }), j } n.wrap = h; function f(_, S, E) { try { return { type: "normal", arg: _.call(S, E) } } catch (w) { return { type: "throw", arg: w } } } var g = "suspendedStart", m = "suspendedYield", y = "executing", p = "completed", v = {}; function b() { } function x() { } function P() { } var M = {}; d(M, l, function () { return this }); var I = Object.getPrototypeOf, C = I && I(I(V([]))); C && C !== r && i.call(C, l) && (M = C); var T = P.prototype = b.prototype = Object.create(M); x.prototype = P, s(T, "constructor", { value: P, configurable: !0 }), s(P, "constructor", { value: x, configurable: !0 }), x.displayName = d(P, c, "GeneratorFunction"); function L(_) { ["next", "throw", "return"].forEach(function (S) { d(_, S, function (E) { return this._invoke(S, E) }) }) } n.isGeneratorFunction = function (_) { var S = typeof _ == "function" && _.constructor; return S ? S === x || (S.displayName || S.name) === "GeneratorFunction" : !1 }, n.mark = function (_) { return Object.setPrototypeOf ? Object.setPrototypeOf(_, P) : (_.__proto__ = P, d(_, c, "GeneratorFunction")), _.prototype = Object.create(T), _ }, n.awrap = function (_) { return { __await: _ } }; function D(_, S) { function E(j, $, z, W) { var K = f(_[j], _, $); if (K.type === "throw") W(K.arg); else { var Z = K.arg, re = Z.value; return re && typeof re == "object" && i.call(re, "__await") ? S.resolve(re.__await).then(function (ue) { E("next", ue, z, W) }, function (ue) { E("throw", ue, z, W) }) : S.resolve(re).then(function (ue) { Z.value = ue, z(Z) }, function (ue) { return E("throw", ue, z, W) }) } } var w; function O(j, $) { function z() { return new S(function (W, K) { E(j, $, W, K) }) } return w = w ? w.then(z, z) : z() } s(this, "_invoke", { value: O }) } L(D.prototype), d(D.prototype, u, function () { return this }), n.AsyncIterator = D, n.async = function (_, S, E, w, O) { O === void 0 && (O = Promise); var j = new D(h(_, S, E, w), O); return n.isGeneratorFunction(S) ? j : j.next().then(function ($) { return $.done ? $.value : j.next() }) }; function N(_, S, E) { var w = g; return function (j, $) { if (w === y) throw new Error("Generator is already running"); if (w === p) { if (j === "throw") throw $; return A() } for (E.method = j, E.arg = $; ;) { var z = E.delegate; if (z) { var W = F(z, E); if (W) { if (W === v) continue; return W } } if (E.method === "next") E.sent = E._sent = E.arg; else if (E.method === "throw") { if (w === g) throw w = p, E.arg; E.dispatchException(E.arg) } else E.method === "return" && E.abrupt("return", E.arg); w = y; var K = f(_, S, E); if (K.type === "normal") { if (w = E.done ? p : m, K.arg === v) continue; return { value: K.arg, done: E.done } } else K.type === "throw" && (w = p, E.method = "throw", E.arg = K.arg) } } } function F(_, S) { var E = S.method, w = _.iterator[E]; if (w === o) return S.delegate = null, E === "throw" && _.iterator.return && (S.method = "return", S.arg = o, F(_, S), S.method === "throw") || E !== "return" && (S.method = "throw", S.arg = new TypeError("The iterator does not provide a '" + E + "' method")), v; var O = f(w, _.iterator, S.arg); if (O.type === "throw") return S.method = "throw", S.arg = O.arg, S.delegate = null, v; var j = O.arg; if (!j) return S.method = "throw", S.arg = new TypeError("iterator result is not an object"), S.delegate = null, v; if (j.done) S[_.resultName] = j.value, S.next = _.nextLoc, S.method !== "return" && (S.method = "next", S.arg = o); else return j; return S.delegate = null, v } L(T), d(T, c, "Generator"), d(T, l, function () { return this }), d(T, "toString", function () { return "[object Generator]" }); function B(_) { var S = { tryLoc: _[0] }; 1 in _ && (S.catchLoc = _[1]), 2 in _ && (S.finallyLoc = _[2], S.afterLoc = _[3]), this.tryEntries.push(S) } function H(_) { var S = _.completion || {}; S.type = "normal", delete S.arg, _.completion = S } function q(_) { this.tryEntries = [{ tryLoc: "root" }], _.forEach(B, this), this.reset(!0) } n.keys = function (_) { var S = Object(_), E = []; for (var w in S) E.push(w); return E.reverse(), function O() { for (; E.length;) { var j = E.pop(); if (j in S) return O.value = j, O.done = !1, O } return O.done = !0, O } }; function V(_) { if (_) { var S = _[l]; if (S) return S.call(_); if (typeof _.next == "function") return _; if (!isNaN(_.length)) { var E = -1, w = function O() { for (; ++E < _.length;)if (i.call(_, E)) return O.value = _[E], O.done = !1, O; return O.value = o, O.done = !0, O }; return w.next = w } } return { next: A } } n.values = V; function A() { return { value: o, done: !0 } } return q.prototype = { constructor: q, reset: function (_) { if (this.prev = 0, this.next = 0, this.sent = this._sent = o, this.done = !1, this.delegate = null, this.method = "next", this.arg = o, this.tryEntries.forEach(H), !_) for (var S in this) S.charAt(0) === "t" && i.call(this, S) && !isNaN(+S.slice(1)) && (this[S] = o) }, stop: function () { this.done = !0; var _ = this.tryEntries[0], S = _.completion; if (S.type === "throw") throw S.arg; return this.rval }, dispatchException: function (_) { if (this.done) throw _; var S = this; function E(W, K) { return j.type = "throw", j.arg = _, S.next = W, K && (S.method = "next", S.arg = o), !!K } for (var w = this.tryEntries.length - 1; w >= 0; --w) { var O = this.tryEntries[w], j = O.completion; if (O.tryLoc === "root") return E("end"); if (O.tryLoc <= this.prev) { var $ = i.call(O, "catchLoc"), z = i.call(O, "finallyLoc"); if ($ && z) { if (this.prev < O.catchLoc) return E(O.catchLoc, !0); if (this.prev < O.finallyLoc) return E(O.finallyLoc) } else if ($) { if (this.prev < O.catchLoc) return E(O.catchLoc, !0) } else if (z) { if (this.prev < O.finallyLoc) return E(O.finallyLoc) } else throw new Error("try statement without catch or finally") } } }, abrupt: function (_, S) { for (var E = this.tryEntries.length - 1; E >= 0; --E) { var w = this.tryEntries[E]; if (w.tryLoc <= this.prev && i.call(w, "finallyLoc") && this.prev < w.finallyLoc) { var O = w; break } } O && (_ === "break" || _ === "continue") && O.tryLoc <= S && S <= O.finallyLoc && (O = null); var j = O ? O.completion : {}; return j.type = _, j.arg = S, O ? (this.method = "next", this.next = O.finallyLoc, v) : this.complete(j) }, complete: function (_, S) { if (_.type === "throw") throw _.arg; return _.type === "break" || _.type === "continue" ? this.next = _.arg : _.type === "return" ? (this.rval = this.arg = _.arg, this.method = "return", this.next = "end") : _.type === "normal" && S && (this.next = S), v }, finish: function (_) { for (var S = this.tryEntries.length - 1; S >= 0; --S) { var E = this.tryEntries[S]; if (E.finallyLoc === _) return this.complete(E.completion, E.afterLoc), H(E), v } }, catch: function (_) { for (var S = this.tryEntries.length - 1; S >= 0; --S) { var E = this.tryEntries[S]; if (E.tryLoc === _) { var w = E.completion; if (w.type === "throw") { var O = w.arg; H(E) } return O } } throw new Error("illegal catch attempt") }, delegateYield: function (_, S, E) { return this.delegate = { iterator: V(_), resultName: S, nextLoc: E }, this.method === "next" && (this.arg = o), v } }, n }(t.exports); try { regeneratorRuntime = e } catch { typeof globalThis == "object" ? globalThis.regeneratorRuntime = e : Function("r", "regeneratorRuntime = r")(e) } })(FC); var Kh = (t, e) => `${t}-${e}-${Math.random().toString(16).slice(3, 8)}`; const $C = Kh; let mg = 0; var ab = ({ id: t, action: e, payload: n = {} }) => { let r = t; return typeof r > "u" && (r = $C("Job", mg), mg += 1), { id: r, action: e, payload: n } }, Ui = {}; let Gh = !1; Ui.logging = Gh; Ui.setLogging = t => { Gh = t }; Ui.log = (...t) => Gh ? console.log.apply(void 0, t) : null; const zC = ab, { log: Ko } = Ui, VC = Kh; let vg = 0; var BC = () => { const t = VC("Scheduler", vg), e = {}, n = {}; let r = []; vg += 1; const i = () => r.length, s = () => Object.keys(e).length, o = () => { if (r.length !== 0) { const d = Object.keys(e); for (let h = 0; h < d.length; h += 1)if (typeof n[d[h]] > "u") { r[0](e[d[h]]); break } } }, a = (d, h) => new Promise((f, g) => { const m = zC({ action: d, payload: h }); r.push(async y => { r.shift(), n[y.id] = m; try { f(await y[d].apply(void 0, [...h, m.id])) } catch (p) { g(p) } finally { delete n[y.id], o() } }), Ko(`[${t}]: Add ${m.id} to JobQueue`), Ko(`[${t}]: JobQueue length=${r.length}`), o() }); return { addWorker: d => (e[d.id] = d, Ko(`[${t}]: Add ${d.id}`), Ko(`[${t}]: Number of workers=${s()}`), o(), d.id), addJob: async (d, ...h) => { if (s() === 0) throw Error(`[${t}]: You need to have at least one worker before adding jobs`); return a(d, h) }, terminate: async () => { Object.keys(e).forEach(async d => { await e[d].terminate() }), r = [] }, getQueueLen: i, getNumWorkers: s } }; function UC(t) { throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.') } function HC() { return !!(typeof window < "u" && typeof window.process == "object" && window.process.type === "renderer" || typeof process < "u" && typeof process.versions == "object" && process.versions.electron || typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Electron") >= 0) } var WC = HC; const qC = WC; var KC = t => { const e = {}; return typeof WorkerGlobalScope < "u" ? e.type = "webworker" : qC() ? e.type = "electron" : typeof document == "object" ? e.type = "browser" : typeof process == "object" && typeof UC == "function" && (e.type = "node"), typeof t > "u" ? e : e[t] }; const GC = KC("type") === "browser", YC = GC ? t => new URL(t, window.location.href).href : t => t; var QC = t => { const e = { ...t }; return ["corePath", "workerPath", "langPath"].forEach(n => { t[n] && (e[n] = YC(e[n])) }), e }, XC = t => { const e = [], n = [], r = [], i = [], s = []; return t.blocks && t.blocks.forEach(o => { o.paragraphs.forEach(a => { a.lines.forEach(l => { l.words.forEach(u => { u.symbols.forEach(c => { s.push({ ...c, page: t, block: o, paragraph: a, line: l, word: u }) }), i.push({ ...u, page: t, block: o, paragraph: a, line: l }) }), r.push({ ...l, page: t, block: o, paragraph: a }) }), n.push({ ...a, page: t, block: o }) }), e.push({ ...o, page: t }) }), { ...t, blocks: e, paragraphs: n, lines: r, words: i, symbols: s } }, lb = { TESSERACT_ONLY: 0, LSTM_ONLY: 1, TESSERACT_LSTM_COMBINED: 2, DEFAULT: 3 }; const JC = "tesseract.js", ZC = "5.1.0", eO = "Pure Javascript Multilingual OCR", tO = "src/index.js", nO = "src/index.d.ts", rO = "dist/tesseract.min.js", iO = "dist/tesseract.min.js", sO = { start: "node scripts/server.js", build: "rimraf dist && webpack --config scripts/webpack.config.prod.js && rollup -c scripts/rollup.esm.mjs", "profile:tesseract": "webpack-bundle-analyzer dist/tesseract-stats.json", "profile:worker": "webpack-bundle-analyzer dist/worker-stats.json", prepublishOnly: "npm run build", wait: "rimraf dist && wait-on http://localhost:3000/dist/tesseract.min.js", test: "npm-run-all -p -r start test:all", "test:all": "npm-run-all wait test:browser:* test:node:all", "test:node": "nyc mocha --exit --bail --require ./scripts/test-helper.js", "test:node:all": "npm run test:node -- ./tests/*.test.js", "test:browser-tpl": "mocha-headless-chrome -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000", "test:browser:detect": "npm run test:browser-tpl -- -f ./tests/detect.test.html", "test:browser:recognize": "npm run test:browser-tpl -- -f ./tests/recognize.test.html", "test:browser:scheduler": "npm run test:browser-tpl -- -f ./tests/scheduler.test.html", "test:browser:FS": "npm run test:browser-tpl -- -f ./tests/FS.test.html", lint: "eslint src", "lint:fix": "eslint --fix src", postinstall: "opencollective-postinstall || true" }, oO = { "./src/worker/node/index.js": "./src/worker/browser/index.js" }, aO = "", lO = ["jeromewu"], uO = "Apache-2.0", cO = { "@babel/core": "^7.21.4", "@babel/eslint-parser": "^7.21.3", "@babel/preset-env": "^7.21.4", "@rollup/plugin-commonjs": "^24.1.0", acorn: "^8.8.2", "babel-loader": "^9.1.2", buffer: "^6.0.3", cors: "^2.8.5", eslint: "^7.32.0", "eslint-config-airbnb-base": "^14.2.1", "eslint-plugin-import": "^2.27.5", "expect.js": "^0.3.1", express: "^4.18.2", mocha: "^10.2.0", "mocha-headless-chrome": "^4.0.0", "npm-run-all": "^4.1.5", nyc: "^15.1.0", rimraf: "^5.0.0", rollup: "^3.20.7", "wait-on": "^7.0.1", webpack: "^5.79.0", "webpack-bundle-analyzer": "^4.8.0", "webpack-cli": "^5.0.1", "webpack-dev-middleware": "^6.0.2", "rollup-plugin-sourcemaps": "^0.6.3" }, dO = { "bmp-js": "^0.1.0", "idb-keyval": "^6.2.0", "is-electron": "^2.2.2", "is-url": "^1.2.4", "node-fetch": "^2.6.9", "opencollective-postinstall": "^2.0.3", "regenerator-runtime": "^0.13.3", "tesseract.js-core": "^5.1.0", "wasm-feature-detect": "^1.2.11", zlibjs: "^0.3.1" }, hO = { "@rollup/pluginutils": "^5.0.2" }, fO = { type: "git", url: "https://github.com/naptha/tesseract.js.git" }, pO = { url: "https://github.com/naptha/tesseract.js/issues" }, gO = "https://github.com/naptha/tesseract.js", mO = { type: "opencollective", url: "https://opencollective.com/tesseractjs" }, vO = { name: JC, version: ZC, description: eO, main: tO, types: nO, unpkg: rO, jsdelivr: iO, scripts: sO, browser: oO, author: aO, contributors: lO, license: uO, devDependencies: cO, dependencies: dO, overrides: hO, repository: fO, bugs: pO, homepage: gO, collective: mO }; var yO = { workerBlobURL: !0, logger: () => { } }; const bO = vO.version, _O = yO; var wO = { ..._O, workerPath: `https://cdn.jsdelivr.net/npm/tesseract.js@v${bO}/dist/worker.min.js` }, xO = ({ workerPath: t, workerBlobURL: e }) => { let n; if (Blob && URL && e) { const r = new Blob([`importScripts("${t}");`], { type: "application/javascript" }); n = new Worker(URL.createObjectURL(r)) } else n = new Worker(t); return n }, SO = t => { t.terminate() }, kO = (t, e) => { t.onmessage = ({ data: n }) => { e(n) } }, CO = async (t, e) => { t.postMessage(e) }; const ec = t => new Promise((e, n) => { const r = new FileReader; r.onload = () => { e(r.result) }, r.onerror = ({ target: { error: { code: i } } }) => { n(Error(`File could not be read! Code=${i}`)) }, r.readAsArrayBuffer(t) }), Sd = async t => { let e = t; if (typeof t > "u") return "undefined"; if (typeof t == "string") /data:image\/([a-zA-Z]*);base64,([^"]*)/.test(t) ? e = atob(t.split(",")[1]).split("").map(n => n.charCodeAt(0)) : e = await (await fetch(t)).arrayBuffer(); else if (typeof HTMLElement < "u" && t instanceof HTMLElement) t.tagName === "IMG" && (e = await Sd(t.src)), t.tagName === "VIDEO" && (e = await Sd(t.poster)), t.tagName === "CANVAS" && await new Promise(n => { t.toBlob(async r => { e = await ec(r), n() }) }); else if (typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas) { const n = await t.convertToBlob(); e = await ec(n) } else (t instanceof File || t instanceof Blob) && (e = await ec(t)); return new Uint8Array(e) }; var OO = Sd; const PO = wO, EO = xO, TO = SO, IO = kO, RO = CO, MO = OO; var LO = { defaultOptions: PO, spawnWorker: EO, terminateWorker: TO, onMessage: IO, send: RO, loadImage: MO }; const DO = QC, jO = XC, zt = ab, { log: yg } = Ui, AO = Kh, pr = lb, { defaultOptions: NO, spawnWorker: FO, terminateWorker: $O, onMessage: zO, loadImage: bg, send: VO } = LO; let _g = 0; var ub = async (t = "eng", e = pr.LSTM_ONLY, n = {}, r = {}) => { const i = AO("Worker", _g), { logger: s, errorHandler: o, ...a } = DO({ ...NO, ...n }), l = {}, u = {}, c = typeof t == "string" ? t.split("+") : t; let d = e, h = r; const f = [pr.DEFAULT, pr.LSTM_ONLY].includes(e) && !a.legacyCore; let g, m; const y = new Promise((O, j) => { m = O, g = j }), p = O => { g(O.message) }; let v = FO(a); v.onerror = p, _g += 1; const b = (O, j) => { l[O] = j }, x = (O, j) => { u[O] = j }, P = ({ id: O, action: j, payload: $ }) => new Promise((z, W) => { yg(`[${i}]: Start ${O}, action=${j}`); const K = `${j}-${O}`; b(K, z), x(K, W), VO(v, { workerId: i, jobId: O, action: j, payload: $ }) }), M = () => console.warn("`load` is depreciated and should be removed from code (workers now come pre-loaded)"), I = O => P(zt({ id: O, action: "load", payload: { options: { lstmOnly: f, corePath: a.corePath, logging: a.logging } } })), C = (O, j, $) => P(zt({ id: $, action: "FS", payload: { method: "writeFile", args: [O, j] } })), T = (O, j) => P(zt({ id: j, action: "FS", payload: { method: "readFile", args: [O, { encoding: "utf8" }] } })), L = (O, j) => P(zt({ id: j, action: "FS", payload: { method: "unlink", args: [O] } })), D = (O, j, $) => P(zt({ id: $, action: "FS", payload: { method: O, args: j } })), N = () => console.warn("`loadLanguage` is depreciated and should be removed from code (workers now come with language pre-loaded)"), F = (O, j) => P(zt({ id: j, action: "loadLanguage", payload: { langs: O, options: { langPath: a.langPath, dataPath: a.dataPath, cachePath: a.cachePath, cacheMethod: a.cacheMethod, gzip: a.gzip, lstmOnly: [pr.LSTM_ONLY, pr.TESSERACT_LSTM_COMBINED].includes(d) && !a.legacyLang } } })), B = () => console.warn("`initialize` is depreciated and should be removed from code (workers now come pre-initialized)"), H = (O, j, $, z) => P(zt({ id: z, action: "initialize", payload: { langs: O, oem: j, config: $ } })), q = (O = "eng", j, $, z) => { if (f && [pr.TESSERACT_ONLY, pr.TESSERACT_LSTM_COMBINED].includes(j)) throw Error("Legacy model requested but code missing."); const W = j || d; d = W; const K = $ || h; h = K; const re = (typeof O == "string" ? O.split("+") : O).filter(ue => !c.includes(ue)); return c.push(...re), re.length > 0 ? F(re, z).then(() => H(O, W, K, z)) : H(O, W, K, z) }, V = (O = {}, j) => P(zt({ id: j, action: "setParameters", payload: { params: O } })), A = async (O, j = {}, $ = { blocks: !0, text: !0, hocr: !0, tsv: !0 }, z) => P(zt({ id: z, action: "recognize", payload: { image: await bg(O), options: j, output: $ } })), _ = (O = "Tesseract OCR Result", j = !1, $) => (console.log("`getPDF` function is depreciated. `recognize` option `savePDF` should be used instead."), P(zt({ id: $, action: "getPDF", payload: { title: O, textonly: j } }))), S = async (O, j) => { if (f) throw Error("`worker.detect` requires Legacy model, which was not loaded."); return P(zt({ id: j, action: "detect", payload: { image: await bg(O) } })) }, E = async () => (v !== null && ($O(v), v = null), Promise.resolve()); zO(v, ({ workerId: O, jobId: j, status: $, action: z, data: W }) => { const K = `${z}-${j}`; if ($ === "resolve") { yg(`[${O}]: Complete ${j}`); let Z = W; z === "recognize" ? Z = jO(W) : z === "getPDF" && (Z = Array.from({ ...W, length: Object.keys(W).length })), l[K]({ jobId: j, data: Z }) } else if ($ === "reject") if (u[K](W), z === "load" && g(W), o) o(W); else throw Error(W); else $ === "progress" && s({ ...W, userJobId: j }) }); const w = { id: i, worker: v, setResolve: b, setReject: x, load: M, writeText: C, readText: T, removeFile: L, FS: D, loadLanguage: N, initialize: B, reinitialize: q, setParameters: V, recognize: A, getPDF: _, detect: S, terminate: E }; return I().then(() => F(t)).then(() => H(t, e, r)).then(() => m(w)).catch(() => { }), y }; const cb = ub, BO = async (t, e, n) => { const r = await cb(e, 1, n); return r.recognize(t).finally(async () => { await r.terminate() }) }, UO = async (t, e) => { const n = await cb("osd", 0, e); return n.detect(t).finally(async () => { await n.terminate() }) }; var HO = { recognize: BO, detect: UO }, WO = { AFR: "afr", AMH: "amh", ARA: "ara", ASM: "asm", AZE: "aze", AZE_CYRL: "aze_cyrl", BEL: "bel", BEN: "ben", BOD: "bod", BOS: "bos", BUL: "bul", CAT: "cat", CEB: "ceb", CES: "ces", CHI_SIM: "chi_sim", CHI_TRA: "chi_tra", CHR: "chr", CYM: "cym", DAN: "dan", DEU: "deu", DZO: "dzo", ELL: "ell", ENG: "eng", ENM: "enm", EPO: "epo", EST: "est", EUS: "eus", FAS: "fas", FIN: "fin", FRA: "fra", FRK: "frk", FRM: "frm", GLE: "gle", GLG: "glg", GRC: "grc", GUJ: "guj", HAT: "hat", HEB: "heb", HIN: "hin", HRV: "hrv", HUN: "hun", IKU: "iku", IND: "ind", ISL: "isl", ITA: "ita", ITA_OLD: "ita_old", JAV: "jav", JPN: "jpn", KAN: "kan", KAT: "kat", KAT_OLD: "kat_old", KAZ: "kaz", KHM: "khm", KIR: "kir", KOR: "kor", KUR: "kur", LAO: "lao", LAT: "lat", LAV: "lav", LIT: "lit", MAL: "mal", MAR: "mar", MKD: "mkd", MLT: "mlt", MSA: "msa", MYA: "mya", NEP: "nep", NLD: "nld", NOR: "nor", ORI: "ori", PAN: "pan", POL: "pol", POR: "por", PUS: "pus", RON: "ron", RUS: "rus", SAN: "san", SIN: "sin", SLK: "slk", SLV: "slv", SPA: "spa", SPA_OLD: "spa_old", SQI: "sqi", SRP: "srp", SRP_LATN: "srp_latn", SWA: "swa", SWE: "swe", SYR: "syr", TAM: "tam", TEL: "tel", TGK: "tgk", TGL: "tgl", THA: "tha", TIR: "tir", TUR: "tur", UIG: "uig", UKR: "ukr", URD: "urd", UZB: "uzb", UZB_CYRL: "uzb_cyrl", VIE: "vie", YID: "yid" }, qO = { OSD_ONLY: "0", AUTO_OSD: "1", AUTO_ONLY: "2", AUTO: "3", SINGLE_COLUMN: "4", SINGLE_BLOCK_VERT_TEXT: "5", SINGLE_BLOCK: "6", SINGLE_LINE: "7", SINGLE_WORD: "8", CIRCLE_WORD: "9", SINGLE_CHAR: "10", SPARSE_TEXT: "11", SPARSE_TEXT_OSD: "12", RAW_LINE: "13" }; const KO = BC, GO = ub, YO = HO, QO = WO, XO = lb, JO = qO, { setLogging: ZO } = Ui; var eP = { languages: QO, OEM: XO, PSM: JO, createScheduler: KO, createWorker: GO, setLogging: ZO, ...YO }; const tP = Bd(eP), nP = t => { const e = new Date().getFullYear().toString(); let n = "", r = "", i = "", s = ""; console.log("Input text:", t); const a = /\d{2}\/\d{2}/g.exec(t); if (a) { const u = a.index, c = t.substring(u, u + 5), [d, h] = c.split("/"); n = `${e}-${h}-${d}`, r = t.substring(0, u - 1).replace(/X.{4}/, "").replace("(7)", "").replace(/\d{2}\/$/, "").replace(/[^a-zA-Z0-9\s]/g, ""), console.log("Extracted date:", n), console.log("Extracted name:", r) } const l = t.match(/([-+]?)\s?-?\s?\d+,\d{2}?/); if (console.log("Amount match:", l), l) { let u = l[0].replace(",", ".").replace("", "").replace(/\s+/g, "").trim(); console.log("Formatted amount:", u), u.startsWith("-") ? (i = "DepenseCarteBleue", s = u.replace("-", "")) : u.startsWith("+") ? (i = "ObtenuCarteBleue", s = u.replace("+", "")) : s = u, console.log("DepenseCarteBleue:", s), console.log("Selected option:", i) } return { Date: n, NomDeLaDepense: r, DepenseCarteBleue: s, selectedOption: i } }, rP = { CarteBleue: "Carte Bleue" }, Yh = ({ accounts: t }) => { const [e, n] = R.useState([]), [r, i] = R.useState({}), [s, o] = R.useState(null); return R.useEffect(() => { (async () => { var u; const { data: { user: l } } = await we.auth.getUser(); o(l), (u = l == null ? void 0 : l.user_metadata) != null && u.livrets && n(l.user_metadata.livrets.filter(c => c && typeof c == "object")) })() }, []), R.useEffect(() => { const a = () => { const l = {}; e.forEach(u => { l[u.name] = 0 }), t.forEach(u => { e.forEach(c => { const d = c.name, h = parseFloat(u[`Depense${d}`] || "0"), f = parseFloat(u[`Obtenu${d}`] || "0"); let g = 0, m = 0; e.forEach(y => { if (d !== y.name) { const p = parseFloat(u[`Deplace${d}Vers${y.name}`] || "0"), v = parseFloat(u[`Deplace${y.name}Vers${d}`] || "0"); g += p, m += v } }), l[d] += f - h - g + m }) }), i(l) }; e.length > 0 && a() }, [t, e]), k.jsxs("div", { className: "account-summary p-4 rounded-md bg-transparent", children: [k.jsx("h2", { className: "text-xl mb-2", children: "Rsum des comptes" }), k.jsx("ul", { className: "flex justify-between gap-4 flex-wrap mb-4 mt-4", children: e.map(a => { const l = a.name, u = rP[l] || l, c = r[l] || 0; return k.jsxs("li", { className: "p-2 border border-gray-200 rounded-md", children: ["Sur le compte ", u, ": ", k.jsxs("span", { className: `font-semibold ${c < 0 ? "text-red-500" : ""}`, children: [c.toFixed(2), " "] })] }, l) }) }), k.jsx("hr", { className: "my-2" }), k.jsx("div", { className: "flex justify-center mt-4", children: k.jsxs("div", { className: "p-2 border border-gray-200 rounded-md inline-block", children: ["Total: ", k.jsxs("span", { className: `font-bold ${e.reduce((a, l) => a + (r[l.name] || 0), 0) < 0 ? "text-red-500" : ""}`, children: [e.reduce((a, l) => a + (r[l.name] || 0), 0).toFixed(2), " "] })] }) })] }) }; var Ve = []; for (var tc = 0; tc < 256; ++tc)Ve.push((tc + 256).toString(16).slice(1)); function iP(t, e = 0) { return (Ve[t[e + 0]] + Ve[t[e + 1]] + Ve[t[e + 2]] + Ve[t[e + 3]] + "-" + Ve[t[e + 4]] + Ve[t[e + 5]] + "-" + Ve[t[e + 6]] + Ve[t[e + 7]] + "-" + Ve[t[e + 8]] + Ve[t[e + 9]] + "-" + Ve[t[e + 10]] + Ve[t[e + 11]] + Ve[t[e + 12]] + Ve[t[e + 13]] + Ve[t[e + 14]] + Ve[t[e + 15]]).toLowerCase() } var Go, sP = new Uint8Array(16); function oP() { if (!Go && (Go = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Go)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"); return Go(sP) } var aP = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto); const wg = { randomUUID: aP }; function Qh(t, e, n) { if (wg.randomUUID && !e && !t) return wg.randomUUID(); t = t || {}; var r = t.random || (t.rng || oP)(); return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, iP(r) } var db = {}, hb = { exports: {} }, lP = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", uP = lP, cP = uP; function fb() { } function pb() { } pb.resetWarningCache = fb; var dP = function () { function t(r, i, s, o, a, l) { if (l !== cP) { var u = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw u.name = "Invariant Violation", u } } t.isRequired = t; function e() { return t } var n = { array: t, bigint: t, bool: t, func: t, number: t, object: t, string: t, symbol: t, any: t, arrayOf: e, element: t, elementType: t, instanceOf: e, node: t, objectOf: e, oneOf: e, oneOfType: e, shape: e, exact: e, checkPropTypes: pb, resetWarningCache: fb }; return n.PropTypes = n, n }; hb.exports = dP(); var _o = hb.exports; function hP(t, e) { if (t === e) return !0; if (!t || !e) return !1; var n = t.length; if (e.length !== n) return !1; for (var r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } var fP = hP, gb = {}, xg = function () { function t(e, n) { var r = [], i = !0, s = !1, o = void 0; try { for (var a = e[Symbol.iterator](), l; !(i = (l = a.next()).done) && (r.push(l.value), !(n && r.length === n)); i = !0); } catch (u) { s = !0, o = u } finally { try { !i && a.return && a.return() } finally { if (s) throw o } } return r } return function (e, n) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, n); throw new TypeError("Invalid attempt to destructure non-iterable instance") } }(), pP = function (t) { var e = t.data, n = t.multiSection; function r(l) { for (l === null ? l = 0 : l++; l < e.length && e[l] === 0;)l++; return l === e.length ? null : l } function i(l) { for (l === null ? l = e.length - 1 : l--; l >= 0 && e[l] === 0;)l--; return l === -1 ? null : l } function s(l) { var u = xg(l, 2), c = u[0], d = u[1]; return n ? d === null || d === e[c] - 1 ? (c = r(c), c === null ? [null, null] : [c, 0]) : [c, d + 1] : e === 0 || d === e - 1 ? [null, null] : d === null ? [null, 0] : [null, d + 1] } function o(l) { var u = xg(l, 2), c = u[0], d = u[1]; return n ? d === null || d === 0 ? (c = i(c), c === null ? [null, null] : [c, e[c] - 1]) : [c, d - 1] : e === 0 || d === 0 ? [null, null] : d === null ? [null, e - 1] : [null, d - 1] } function a(l) { return s(l)[1] === null } return { next: s, prev: o, isLast: a } }, kd = { exports: {} }, gP = Object.prototype.propertyIsEnumerable; function mP(t) { if (t == null) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(t) } function vP(t) { var e = Object.getOwnPropertyNames(t); return Object.getOwnPropertySymbols && (e = e.concat(Object.getOwnPropertySymbols(t))), e.filter(function (n) { return gP.call(t, n) }) } var yP = Object.assign || function (t, e) { for (var n, r, i = mP(t), s = 1; s < arguments.length; s++) { n = arguments[s], r = vP(Object(n)); for (var o = 0; o < r.length; o++)i[r[o]] = n[r[o]] } return i }; (function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }); var n = function () { function l(u, c) { var d = [], h = !0, f = !1, g = void 0; try { for (var m = u[Symbol.iterator](), y; !(h = (y = m.next()).done) && (d.push(y.value), !(c && d.length === c)); h = !0); } catch (p) { f = !0, g = p } finally { try { !h && m.return && m.return() } finally { if (f) throw g } } return d } return function (u, c) { if (Array.isArray(u)) return u; if (Symbol.iterator in Object(u)) return l(u, c); throw new TypeError("Invalid attempt to destructure non-iterable instance") } }(); function r(l) { return l && l.__esModule ? l : { default: l } } function i(l) { if (Array.isArray(l)) { for (var u = 0, c = Array(l.length); u < l.length; u++)c[u] = l[u]; return c } else return Array.from(l) } var s = yP, o = r(s), a = function (u) { return u }; e.default = function (l) { var u = Array.isArray(l) && l.length === 2 ? l : [l, null], c = n(u, 2), d = c[0], h = c[1]; return function (f) { for (var g = arguments.length, m = Array(g > 1 ? g - 1 : 0), y = 1; y < g; y++)m[y - 1] = arguments[y]; var p = m.map(function (v) { return d[v] }).filter(a); return typeof p[0] == "string" || typeof h == "function" ? { key: f, className: h ? h.apply(void 0, i(p)) : p.join(" ") } : { key: f, style: o.default.apply(void 0, [{}].concat(i(p))) } } }, t.exports = e.default })(kd, kd.exports); var bP = kd.exports, mb = {}, Xl = {}; (function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n; function e(r) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? e = function (s) { return typeof s } : e = function (s) { return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s }, e(r) } function n(r, i) { var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : []; if (r === i) return !1; var o = Object.keys(r), a = Object.keys(i); if (o.length !== a.length) return !0; var l = {}, u, c; for (u = 0, c = s.length; u < c; u++)l[s[u]] = !0; for (u = 0, c = o.length; u < c; u++) { var d = o[u], h = r[d], f = i[d]; if (h !== f) { if (!l[d] || h === null || f === null || e(h) !== "object" || e(f) !== "object") return !0; var g = Object.keys(h), m = Object.keys(f); if (g.length !== m.length) return !0; for (var y = 0, p = g.length; y < p; y++) { var v = g[y]; if (h[v] !== f[v]) return !0 } } } return !1 } })(Xl); (function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var e = o(R), n = i(_o), r = i(Xl); function i(x) { return x && x.__esModule ? x : { default: x } } function s() { if (typeof WeakMap != "function") return null; var x = new WeakMap; return s = function () { return x }, x } function o(x) { if (x && x.__esModule) return x; if (x === null || a(x) !== "object" && typeof x != "function") return { default: x }; var P = s(); if (P && P.has(x)) return P.get(x); var M = {}, I = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var C in x) if (Object.prototype.hasOwnProperty.call(x, C)) { var T = I ? Object.getOwnPropertyDescriptor(x, C) : null; T && (T.get || T.set) ? Object.defineProperty(M, C, T) : M[C] = x[C] } return M.default = x, P && P.set(x, M), M } function a(x) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? a = function (M) { return typeof M } : a = function (M) { return M && typeof Symbol == "function" && M.constructor === Symbol && M !== Symbol.prototype ? "symbol" : typeof M }, a(x) } function l(x, P) { if (!(x instanceof P)) throw new TypeError("Cannot call a class as a function") } function u(x, P) { for (var M = 0; M < P.length; M++) { var I = P[M]; I.enumerable = I.enumerable || !1, I.configurable = !0, "value" in I && (I.writable = !0), Object.defineProperty(x, I.key, I) } } function c(x, P, M) { return P && u(x.prototype, P), x } function d(x) { return function () { var P = m(x), M; if (g()) { var I = m(this).constructor; M = Reflect.construct(P, arguments, I) } else M = P.apply(this, arguments); return h(this, M) } } function h(x, P) { return P && (a(P) === "object" || typeof P == "function") ? P : f(x) } function f(x) { if (x === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return x } function g() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch { return !1 } } function m(x) { return m = Object.setPrototypeOf ? Object.getPrototypeOf : function (M) { return M.__proto__ || Object.getPrototypeOf(M) }, m(x) } function y(x, P) { if (typeof P != "function" && P !== null) throw new TypeError("Super expression must either be null or a function"); x.prototype = Object.create(P && P.prototype, { constructor: { value: x, writable: !0, configurable: !0 } }), P && p(x, P) } function p(x, P) { return p = Object.setPrototypeOf || function (I, C) { return I.__proto__ = C, I }, p(x, P) } function v(x, P, M) { return P in x ? Object.defineProperty(x, P, { value: M, enumerable: !0, configurable: !0, writable: !0 }) : x[P] = M, x } var b = function (x) { y(M, x); var P = d(M); function M() { return l(this, M), P.apply(this, arguments) } return c(M, [{ key: "shouldComponentUpdate", value: function (C) { return (0, r.default)(C, this.props) } }, { key: "render", value: function () { var C = this.props, T = C.section, L = C.renderSectionTitle, D = C.theme, N = C.sectionKeyPrefix, F = L(T); return F ? e.default.createElement("div", D("".concat(N, "title"), "sectionTitle"), F) : null } }]), M }(e.Component); t.default = b, v(b, "propTypes", { section: n.default.any.isRequired, renderSectionTitle: n.default.func.isRequired, theme: n.default.func.isRequired, sectionKeyPrefix: n.default.string.isRequired }) })(mb); var vb = {}, yb = {}; (function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var e = o(R), n = i(_o), r = i(Xl); function i(T) { return T && T.__esModule ? T : { default: T } } function s() { if (typeof WeakMap != "function") return null; var T = new WeakMap; return s = function () { return T }, T } function o(T) { if (T && T.__esModule) return T; if (T === null || a(T) !== "object" && typeof T != "function") return { default: T }; var L = s(); if (L && L.has(T)) return L.get(T); var D = {}, N = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var F in T) if (Object.prototype.hasOwnProperty.call(T, F)) { var B = N ? Object.getOwnPropertyDescriptor(T, F) : null; B && (B.get || B.set) ? Object.defineProperty(D, F, B) : D[F] = T[F] } return D.default = T, L && L.set(T, D), D } function a(T) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? a = function (D) { return typeof D } : a = function (D) { return D && typeof Symbol == "function" && D.constructor === Symbol && D !== Symbol.prototype ? "symbol" : typeof D }, a(T) } function l() { return l = Object.assign || function (T) { for (var L = 1; L < arguments.length; L++) { var D = arguments[L]; for (var N in D) Object.prototype.hasOwnProperty.call(D, N) && (T[N] = D[N]) } return T }, l.apply(this, arguments) } function u(T, L) { var D = Object.keys(T); if (Object.getOwnPropertySymbols) { var N = Object.getOwnPropertySymbols(T); L && (N = N.filter(function (F) { return Object.getOwnPropertyDescriptor(T, F).enumerable })), D.push.apply(D, N) } return D } function c(T) { for (var L = 1; L < arguments.length; L++) { var D = arguments[L] != null ? arguments[L] : {}; L % 2 ? u(Object(D), !0).forEach(function (N) { I(T, N, D[N]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(T, Object.getOwnPropertyDescriptors(D)) : u(Object(D)).forEach(function (N) { Object.defineProperty(T, N, Object.getOwnPropertyDescriptor(D, N)) }) } return T } function d(T, L) { if (T == null) return {}; var D = h(T, L), N, F; if (Object.getOwnPropertySymbols) { var B = Object.getOwnPropertySymbols(T); for (F = 0; F < B.length; F++)N = B[F], !(L.indexOf(N) >= 0) && Object.prototype.propertyIsEnumerable.call(T, N) && (D[N] = T[N]) } return D } function h(T, L) { if (T == null) return {}; var D = {}, N = Object.keys(T), F, B; for (B = 0; B < N.length; B++)F = N[B], !(L.indexOf(F) >= 0) && (D[F] = T[F]); return D } function f(T, L) { if (!(T instanceof L)) throw new TypeError("Cannot call a class as a function") } function g(T, L) { for (var D = 0; D < L.length; D++) { var N = L[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(T, N.key, N) } } function m(T, L, D) { return L && g(T.prototype, L), T } function y(T) { return function () { var L = x(T), D; if (b()) { var N = x(this).constructor; D = Reflect.construct(L, arguments, N) } else D = L.apply(this, arguments); return p(this, D) } } function p(T, L) { return L && (a(L) === "object" || typeof L == "function") ? L : v(T) } function v(T) { if (T === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return T } function b() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch { return !1 } } function x(T) { return x = Object.setPrototypeOf ? Object.getPrototypeOf : function (D) { return D.__proto__ || Object.getPrototypeOf(D) }, x(T) } function P(T, L) { if (typeof L != "function" && L !== null) throw new TypeError("Super expression must either be null or a function"); T.prototype = Object.create(L && L.prototype, { constructor: { value: T, writable: !0, configurable: !0 } }), L && M(T, L) } function M(T, L) { return M = Object.setPrototypeOf || function (N, F) { return N.__proto__ = F, N }, M(T, L) } function I(T, L, D) { return L in T ? Object.defineProperty(T, L, { value: D, enumerable: !0, configurable: !0, writable: !0 }) : T[L] = D, T } var C = function (T) { P(D, T); var L = y(D); function D() { var N; f(this, D); for (var F = arguments.length, B = new Array(F), H = 0; H < F; H++)B[H] = arguments[H]; return N = L.call.apply(L, [this].concat(B)), I(v(N), "storeItemReference", function (q) { q !== null && (N.item = q) }), I(v(N), "onMouseEnter", function (q) { var V = N.props, A = V.sectionIndex, _ = V.itemIndex; N.props.onMouseEnter(q, { sectionIndex: A, itemIndex: _ }) }), I(v(N), "onMouseLeave", function (q) { var V = N.props, A = V.sectionIndex, _ = V.itemIndex; N.props.onMouseLeave(q, { sectionIndex: A, itemIndex: _ }) }), I(v(N), "onMouseDown", function (q) { var V = N.props, A = V.sectionIndex, _ = V.itemIndex; N.props.onMouseDown(q, { sectionIndex: A, itemIndex: _ }) }), I(v(N), "onClick", function (q) { var V = N.props, A = V.sectionIndex, _ = V.itemIndex; N.props.onClick(q, { sectionIndex: A, itemIndex: _ }) }), N } return m(D, [{ key: "shouldComponentUpdate", value: function (F) { return (0, r.default)(F, this.props, ["renderItemData"]) } }, { key: "render", value: function () { var F = this.props, B = F.isHighlighted, H = F.item, q = F.renderItem, V = F.renderItemData, A = d(F, ["isHighlighted", "item", "renderItem", "renderItemData"]); return delete A.sectionIndex, delete A.itemIndex, typeof A.onMouseEnter == "function" && (A.onMouseEnter = this.onMouseEnter), typeof A.onMouseLeave == "function" && (A.onMouseLeave = this.onMouseLeave), typeof A.onMouseDown == "function" && (A.onMouseDown = this.onMouseDown), typeof A.onClick == "function" && (A.onClick = this.onClick), e.default.createElement("li", l({ role: "option" }, A, { ref: this.storeItemReference }), q(H, c({ isHighlighted: B }, V))) } }]), D }(e.Component); t.default = C, I(C, "propTypes", { sectionIndex: n.default.number, isHighlighted: n.default.bool.isRequired, itemIndex: n.default.number.isRequired, item: n.default.any.isRequired, renderItem: n.default.func.isRequired, renderItemData: n.default.object.isRequired, onMouseEnter: n.default.func, onMouseLeave: n.default.func, onMouseDown: n.default.func, onClick: n.default.func }) })(yb); (function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var e = a(R), n = s(_o), r = s(yb), i = s(Xl); function s(C) { return C && C.__esModule ? C : { default: C } } function o() { if (typeof WeakMap != "function") return null; var C = new WeakMap; return o = function () { return C }, C } function a(C) { if (C && C.__esModule) return C; if (C === null || l(C) !== "object" && typeof C != "function") return { default: C }; var T = o(); if (T && T.has(C)) return T.get(C); var L = {}, D = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var N in C) if (Object.prototype.hasOwnProperty.call(C, N)) { var F = D ? Object.getOwnPropertyDescriptor(C, N) : null; F && (F.get || F.set) ? Object.defineProperty(L, N, F) : L[N] = C[N] } return L.default = C, T && T.set(C, L), L } function l(C) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? l = function (L) { return typeof L } : l = function (L) { return L && typeof Symbol == "function" && L.constructor === Symbol && L !== Symbol.prototype ? "symbol" : typeof L }, l(C) } function u() { return u = Object.assign || function (C) { for (var T = 1; T < arguments.length; T++) { var L = arguments[T]; for (var D in L) Object.prototype.hasOwnProperty.call(L, D) && (C[D] = L[D]) } return C }, u.apply(this, arguments) } function c(C, T) { var L = Object.keys(C); if (Object.getOwnPropertySymbols) { var D = Object.getOwnPropertySymbols(C); T && (D = D.filter(function (N) { return Object.getOwnPropertyDescriptor(C, N).enumerable })), L.push.apply(L, D) } return L } function d(C) { for (var T = 1; T < arguments.length; T++) { var L = arguments[T] != null ? arguments[T] : {}; T % 2 ? c(Object(L), !0).forEach(function (D) { M(C, D, L[D]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(C, Object.getOwnPropertyDescriptors(L)) : c(Object(L)).forEach(function (D) { Object.defineProperty(C, D, Object.getOwnPropertyDescriptor(L, D)) }) } return C } function h(C, T) { if (!(C instanceof T)) throw new TypeError("Cannot call a class as a function") } function f(C, T) { for (var L = 0; L < T.length; L++) { var D = T[L]; D.enumerable = D.enumerable || !1, D.configurable = !0, "value" in D && (D.writable = !0), Object.defineProperty(C, D.key, D) } } function g(C, T, L) { return T && f(C.prototype, T), C } function m(C) { return function () { var T = b(C), L; if (v()) { var D = b(this).constructor; L = Reflect.construct(T, arguments, D) } else L = T.apply(this, arguments); return y(this, L) } } function y(C, T) { return T && (l(T) === "object" || typeof T == "function") ? T : p(C) } function p(C) { if (C === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return C } function v() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch { return !1 } } function b(C) { return b = Object.setPrototypeOf ? Object.getPrototypeOf : function (L) { return L.__proto__ || Object.getPrototypeOf(L) }, b(C) } function x(C, T) { if (typeof T != "function" && T !== null) throw new TypeError("Super expression must either be null or a function"); C.prototype = Object.create(T && T.prototype, { constructor: { value: C, writable: !0, configurable: !0 } }), T && P(C, T) } function P(C, T) { return P = Object.setPrototypeOf || function (D, N) { return D.__proto__ = N, D }, P(C, T) } function M(C, T, L) { return T in C ? Object.defineProperty(C, T, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : C[T] = L, C } var I = function (C) { x(L, C); var T = m(L); function L() { var D; h(this, L); for (var N = arguments.length, F = new Array(N), B = 0; B < N; B++)F[B] = arguments[B]; return D = T.call.apply(T, [this].concat(F)), M(p(D), "storeHighlightedItemReference", function (H) { D.props.onHighlightedItemChange(H === null ? null : H.item) }), D } return g(L, [{ key: "shouldComponentUpdate", value: function (N) { return (0, i.default)(N, this.props, ["itemProps"]) } }, { key: "render", value: function () { var N = this, F = this.props, B = F.items, H = F.itemProps, q = F.renderItem, V = F.renderItemData, A = F.sectionIndex, _ = F.highlightedItemIndex, S = F.getItemId, E = F.theme, w = F.keyPrefix, O = A === null ? w : "".concat(w, "section-").concat(A, "-"), j = typeof H == "function"; return e.default.createElement("ul", u({ role: "listbox" }, E("".concat(O, "items-list"), "itemsList")), B.map(function ($, z) { var W = z === 0, K = z === _, Z = "".concat(O, "item-").concat(z), re = j ? H({ sectionIndex: A, itemIndex: z }) : H, ue = d({ id: S(A, z), "aria-selected": K }, E(Z, "item", W && "itemFirst", K && "itemHighlighted"), {}, re); return K && (ue.ref = N.storeHighlightedItemReference), e.default.createElement(r.default, u({}, ue, { sectionIndex: A, isHighlighted: K, itemIndex: z, item: $, renderItem: q, renderItemData: V })) })) } }]), L }(e.Component); t.default = I, M(I, "propTypes", { items: n.default.array.isRequired, itemProps: n.default.oneOfType([n.default.object, n.default.func]), renderItem: n.default.func.isRequired, renderItemData: n.default.object.isRequired, sectionIndex: n.default.number, highlightedItemIndex: n.default.number, onHighlightedItemChange: n.default.func.isRequired, getItemId: n.default.func.isRequired, theme: n.default.func.isRequired, keyPrefix: n.default.string.isRequired }), M(I, "defaultProps", { sectionIndex: null }) })(vb); (function (t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var e = u(R), n = a(_o), r = a(pP), i = a(bP), s = a(mb), o = a(vb); function a(_) { return _ && _.__esModule ? _ : { default: _ } } function l() { if (typeof WeakMap != "function") return null; var _ = new WeakMap; return l = function () { return _ }, _ } function u(_) { if (_ && _.__esModule) return _; if (_ === null || v(_) !== "object" && typeof _ != "function") return { default: _ }; var S = l(); if (S && S.has(_)) return S.get(_); var E = {}, w = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var O in _) if (Object.prototype.hasOwnProperty.call(_, O)) { var j = w ? Object.getOwnPropertyDescriptor(_, O) : null; j && (j.get || j.set) ? Object.defineProperty(E, O, j) : E[O] = _[O] } return E.default = _, S && S.set(_, E), E } function c(_, S) { var E = Object.keys(_); if (Object.getOwnPropertySymbols) { var w = Object.getOwnPropertySymbols(_); S && (w = w.filter(function (O) { return Object.getOwnPropertyDescriptor(_, O).enumerable })), E.push.apply(E, w) } return E } function d(_) { for (var S = 1; S < arguments.length; S++) { var E = arguments[S] != null ? arguments[S] : {}; S % 2 ? c(Object(E), !0).forEach(function (w) { F(_, w, E[w]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(E)) : c(Object(E)).forEach(function (w) { Object.defineProperty(_, w, Object.getOwnPropertyDescriptor(E, w)) }) } return _ } function h(_, S) { return p(_) || y(_, S) || g(_, S) || f() } function f() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function g(_, S) { if (_) { if (typeof _ == "string") return m(_, S); var E = Object.prototype.toString.call(_).slice(8, -1); if (E === "Object" && _.constructor && (E = _.constructor.name), E === "Map" || E === "Set") return Array.from(E); if (E === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(E)) return m(_, S) } } function m(_, S) { (S == null || S > _.length) && (S = _.length); for (var E = 0, w = new Array(S); E < S; E++)w[E] = _[E]; return w } function y(_, S) { if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(_)))) { var E = [], w = !0, O = !1, j = void 0; try { for (var $ = _[Symbol.iterator](), z; !(w = (z = $.next()).done) && (E.push(z.value), !(S && E.length === S)); w = !0); } catch (W) { O = !0, j = W } finally { try { !w && $.return != null && $.return() } finally { if (O) throw j } } return E } } function p(_) { if (Array.isArray(_)) return _ } function v(_) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? v = function (E) { return typeof E } : v = function (E) { return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E }, v(_) } function b(_, S) { if (!(_ instanceof S)) throw new TypeError("Cannot call a class as a function") } function x(_, S) { for (var E = 0; E < S.length; E++) { var w = S[E]; w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(_, w.key, w) } } function P(_, S, E) { return S && x(_.prototype, S), _ } function M(_) { return function () { var S = L(_), E; if (T()) { var w = L(this).constructor; E = Reflect.construct(S, arguments, w) } else E = S.apply(this, arguments); return I(this, E) } } function I(_, S) { return S && (v(S) === "object" || typeof S == "function") ? S : C(_) } function C(_) { if (_ === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return _ } function T() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch { return !1 } } function L(_) { return L = Object.setPrototypeOf ? Object.getPrototypeOf : function (E) { return E.__proto__ || Object.getPrototypeOf(E) }, L(_) } function D(_, S) { if (typeof S != "function" && S !== null) throw new TypeError("Super expression must either be null or a function"); _.prototype = Object.create(S && S.prototype, { constructor: { value: _, writable: !0, configurable: !0 } }), S && N(_, S) } function N(_, S) { return N = Object.setPrototypeOf || function (w, O) { return w.__proto__ = O, w }, N(_, S) } function F(_, S, E) { return S in _ ? Object.defineProperty(_, S, { value: E, enumerable: !0, configurable: !0, writable: !0 }) : _[S] = E, _ } var B = {}, H = function (S) { return e.default.createElement("input", S) }, q = function (S) { var E = S.containerProps, w = S.children; return e.default.createElement("div", E, w) }, V = { container: "react-autowhatever__container", containerOpen: "react-autowhatever__container--open", input: "react-autowhatever__input", inputOpen: "react-autowhatever__input--open", inputFocused: "react-autowhatever__input--focused", itemsContainer: "react-autowhatever__items-container", itemsContainerOpen: "react-autowhatever__items-container--open", itemsList: "react-autowhatever__items-list", item: "react-autowhatever__item", itemFirst: "react-autowhatever__item--first", itemHighlighted: "react-autowhatever__item--highlighted", sectionContainer: "react-autowhatever__section-container", sectionContainerFirst: "react-autowhatever__section-container--first", sectionTitle: "react-autowhatever__section-title" }, A = function (_) { D(E, _); var S = M(E); function E(w) { var O; return b(this, E), O = S.call(this, w), F(C(O), "storeInputReference", function (j) { j !== null && (O.input = j); var $ = O.props.inputProps.ref; $ && (typeof $ == "function" ? $(j) : v($) === "object" && Object.prototype.hasOwnProperty.call($, "current") && ($.current = j)) }), F(C(O), "storeItemsContainerReference", function (j) { j !== null && (O.itemsContainer = j) }), F(C(O), "onHighlightedItemChange", function (j) { O.highlightedItem = j }), F(C(O), "getItemId", function (j, $) { if ($ === null) return null; var z = O.props.id, W = j === null ? "" : "section-".concat(j); return "react-autowhatever-".concat(z, "-").concat(W, "-item-").concat($) }), F(C(O), "onFocus", function (j) { var $ = O.props.inputProps; O.setState({ isInputFocused: !0 }), $.onFocus && $.onFocus(j) }), F(C(O), "onBlur", function (j) { var $ = O.props.inputProps; O.setState({ isInputFocused: !1 }), $.onBlur && $.onBlur(j) }), F(C(O), "onKeyDown", function (j) { var $ = O.props, z = $.inputProps, W = $.highlightedSectionIndex, K = $.highlightedItemIndex, Z = j.keyCode; switch (Z) { case 40: case 38: { var re = Z === 40 ? "next" : "prev", ue = O.sectionIterator[re]([W, K]), tt = h(ue, 2), ot = tt[0], Qt = tt[1]; z.onKeyDown(j, { newHighlightedSectionIndex: ot, newHighlightedItemIndex: Qt }); break } default: z.onKeyDown(j, { highlightedSectionIndex: W, highlightedItemIndex: K }) } }), O.highlightedItem = null, O.state = { isInputFocused: !1 }, O.setSectionsItems(w), O.setSectionIterator(w), O.setTheme(w), O } return P(E, [{ key: "componentDidMount", value: function () { this.ensureHighlightedItemIsVisible() } }, { key: "UNSAFE_componentWillReceiveProps", value: function (O) { O.items !== this.props.items && this.setSectionsItems(O), (O.items !== this.props.items || O.multiSection !== this.props.multiSection) && this.setSectionIterator(O), O.theme !== this.props.theme && this.setTheme(O) } }, { key: "componentDidUpdate", value: function () { this.ensureHighlightedItemIsVisible() } }, { key: "setSectionsItems", value: function (O) { O.multiSection && (this.sectionsItems = O.items.map(function (j) { return O.getSectionItems(j) }), this.sectionsLengths = this.sectionsItems.map(function (j) { return j.length }), this.allSectionsAreEmpty = this.sectionsLengths.every(function (j) { return j === 0 })) } }, { key: "setSectionIterator", value: function (O) { this.sectionIterator = (0, r.default)({ multiSection: O.multiSection, data: O.multiSection ? this.sectionsLengths : O.items.length }) } }, { key: "setTheme", value: function (O) { this.theme = (0, i.default)(O.theme) } }, { key: "renderSections", value: function () { var O = this; if (this.allSectionsAreEmpty) return null; var j = this.theme, $ = this.props, z = $.id, W = $.items, K = $.renderItem, Z = $.renderItemData, re = $.renderSectionTitle, ue = $.highlightedSectionIndex, tt = $.highlightedItemIndex, ot = $.itemProps; return W.map(function (Qt, qe) { var Wr = "react-autowhatever-".concat(z, "-"), qr = "".concat(Wr, "section-").concat(qe, "-"), dn = qe === 0; return e.default.createElement("div", j("".concat(qr, "container"), "sectionContainer", dn && "sectionContainerFirst"), e.default.createElement(s.default, { section: Qt, renderSectionTitle: re, theme: j, sectionKeyPrefix: qr }), e.default.createElement(o.default, { items: O.sectionsItems[qe], itemProps: ot, renderItem: K, renderItemData: Z, sectionIndex: qe, highlightedItemIndex: ue === qe ? tt : null, onHighlightedItemChange: O.onHighlightedItemChange, getItemId: O.getItemId, theme: j, keyPrefix: Wr, ref: O.storeItemsListReference })) }) } }, { key: "renderItems", value: function () { var O = this.props.items; if (O.length === 0) return null; var j = this.theme, $ = this.props, z = $.id, W = $.renderItem, K = $.renderItemData, Z = $.highlightedSectionIndex, re = $.highlightedItemIndex, ue = $.itemProps; return e.default.createElement(o.default, { items: O, itemProps: ue, renderItem: W, renderItemData: K, highlightedItemIndex: Z === null ? re : null, onHighlightedItemChange: this.onHighlightedItemChange, getItemId: this.getItemId, theme: j, keyPrefix: "react-autowhatever-".concat(z, "-") }) } }, { key: "ensureHighlightedItemIsVisible", value: function () { var O = this.highlightedItem; if (O) { var j = this.itemsContainer, $ = O.offsetParent === j ? O.offsetTop : O.offsetTop - j.offsetTop, z = j.scrollTop; $ < z ? z = $ : $ + O.offsetHeight > z + j.offsetHeight && (z = $ + O.offsetHeight - j.offsetHeight), z !== j.scrollTop && (j.scrollTop = z) } } }, { key: "render", value: function () { var O = this.theme, j = this.props, $ = j.id, z = j.multiSection, W = j.renderInputComponent, K = j.renderItemsContainer, Z = j.highlightedSectionIndex, re = j.highlightedItemIndex, ue = this.state.isInputFocused, tt = z ? this.renderSections() : this.renderItems(), ot = tt !== null, Qt = this.getItemId(Z, re), qe = "react-autowhatever-".concat($), Wr = d({ role: "combobox", "aria-haspopup": "listbox", "aria-owns": qe, "aria-expanded": ot }, O("react-autowhatever-".concat($, "-container"), "container", ot && "containerOpen"), {}, this.props.containerProps), qr = W(d({ type: "text", value: "", autoComplete: "off", "aria-autocomplete": "list", "aria-controls": qe, "aria-activedescendant": Qt }, O("react-autowhatever-".concat($, "-input"), "input", ot && "inputOpen", ue && "inputFocused"), {}, this.props.inputProps, { onFocus: this.onFocus, onBlur: this.onBlur, onKeyDown: this.props.inputProps.onKeyDown && this.onKeyDown, ref: this.storeInputReference })), dn = K({ containerProps: d({ id: qe, role: "listbox" }, O("react-autowhatever-".concat($, "-items-container"), "itemsContainer", ot && "itemsContainerOpen"), { ref: this.storeItemsContainerReference }), children: tt }); return e.default.createElement("div", Wr, qr, dn) } }]), E }(e.Component); t.default = A, F(A, "propTypes", { id: n.default.string, multiSection: n.default.bool, renderInputComponent: n.default.func, renderItemsContainer: n.default.func, items: n.default.array.isRequired, renderItem: n.default.func, renderItemData: n.default.object, renderSectionTitle: n.default.func, getSectionItems: n.default.func, containerProps: n.default.object, inputProps: n.default.object, itemProps: n.default.oneOfType([n.default.object, n.default.func]), highlightedSectionIndex: n.default.number, highlightedItemIndex: n.default.number, theme: n.default.oneOfType([n.default.object, n.default.array]) }), F(A, "defaultProps", { id: "1", multiSection: !1, renderInputComponent: H, renderItemsContainer: q, renderItem: function () { throw new Error("`renderItem` must be provided") }, renderItemData: B, renderSectionTitle: function () { throw new Error("`renderSectionTitle` must be provided") }, getSectionItems: function () { throw new Error("`getSectionItems` must be provided") }, containerProps: B, inputProps: B, itemProps: B, highlightedSectionIndex: null, highlightedItemIndex: null, theme: V })
})(gb); var Mi = {}; Object.defineProperty(Mi, "__esModule", { value: !0 }); Mi.mapToAutowhateverTheme = Mi.defaultTheme = void 0; var _P = { container: "react-autosuggest__container", containerOpen: "react-autosuggest__container--open", input: "react-autosuggest__input", inputOpen: "react-autosuggest__input--open", inputFocused: "react-autosuggest__input--focused", suggestionsContainer: "react-autosuggest__suggestions-container", suggestionsContainerOpen: "react-autosuggest__suggestions-container--open", suggestionsList: "react-autosuggest__suggestions-list", suggestion: "react-autosuggest__suggestion", suggestionFirst: "react-autosuggest__suggestion--first", suggestionHighlighted: "react-autosuggest__suggestion--highlighted", sectionContainer: "react-autosuggest__section-container", sectionContainerFirst: "react-autosuggest__section-container--first", sectionTitle: "react-autosuggest__section-title" }; Mi.defaultTheme = _P; var wP = function (e) { var n = {}; for (var r in e) switch (r) { case "suggestionsContainer": n.itemsContainer = e[r]; break; case "suggestionsContainerOpen": n.itemsContainerOpen = e[r]; break; case "suggestion": n.item = e[r]; break; case "suggestionFirst": n.itemFirst = e[r]; break; case "suggestionHighlighted": n.itemHighlighted = e[r]; break; case "suggestionsList": n.itemsList = e[r]; break; default: n[r] = e[r] }return n }; Mi.mapToAutowhateverTheme = wP; (function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var e = l(R), n = o(_o), r = o(fP), i = o(gb), s = Mi; function o(A) { return A && A.__esModule ? A : { default: A } } function a() { if (typeof WeakMap != "function") return null; var A = new WeakMap; return a = function () { return A }, A } function l(A) { if (A && A.__esModule) return A; if (A === null || u(A) !== "object" && typeof A != "function") return { default: A }; var _ = a(); if (_ && _.has(A)) return _.get(A); var S = {}, E = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var w in A) if (Object.prototype.hasOwnProperty.call(A, w)) { var O = E ? Object.getOwnPropertyDescriptor(A, w) : null; O && (O.get || O.set) ? Object.defineProperty(S, w, O) : S[w] = A[w] } return S.default = A, _ && _.set(A, S), S } function u(A) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? u = function (S) { return typeof S } : u = function (S) { return S && typeof Symbol == "function" && S.constructor === Symbol && S !== Symbol.prototype ? "symbol" : typeof S }, u(A) } function c(A, _) { var S = Object.keys(A); if (Object.getOwnPropertySymbols) { var E = Object.getOwnPropertySymbols(A); _ && (E = E.filter(function (w) { return Object.getOwnPropertyDescriptor(A, w).enumerable })), S.push.apply(S, E) } return S } function d(A) { for (var _ = 1; _ < arguments.length; _++) { var S = arguments[_] != null ? arguments[_] : {}; _ % 2 ? c(Object(S), !0).forEach(function (E) { M(A, E, S[E]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(A, Object.getOwnPropertyDescriptors(S)) : c(Object(S)).forEach(function (E) { Object.defineProperty(A, E, Object.getOwnPropertyDescriptor(S, E)) }) } return A } function h(A, _) { if (!(A instanceof _)) throw new TypeError("Cannot call a class as a function") } function f(A, _) { for (var S = 0; S < _.length; S++) { var E = _[S]; E.enumerable = E.enumerable || !1, E.configurable = !0, "value" in E && (E.writable = !0), Object.defineProperty(A, E.key, E) } } function g(A, _, S) { return _ && f(A.prototype, _), A } function m(A) { return function () { var _ = b(A), S; if (v()) { var E = b(this).constructor; S = Reflect.construct(_, arguments, E) } else S = _.apply(this, arguments); return y(this, S) } } function y(A, _) { return _ && (u(_) === "object" || typeof _ == "function") ? _ : p(A) } function p(A) { if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return A } function v() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch { return !1 } } function b(A) { return b = Object.setPrototypeOf ? Object.getPrototypeOf : function (S) { return S.__proto__ || Object.getPrototypeOf(S) }, b(A) } function x(A, _) { if (typeof _ != "function" && _ !== null) throw new TypeError("Super expression must either be null or a function"); A.prototype = Object.create(_ && _.prototype, { constructor: { value: A, writable: !0, configurable: !0 } }), _ && P(A, _) } function P(A, _) { return P = Object.setPrototypeOf || function (E, w) { return E.__proto__ = w, E }, P(A, _) } function M(A, _, S) { return _ in A ? Object.defineProperty(A, _, { value: S, enumerable: !0, configurable: !0, writable: !0 }) : A[_] = S, A } var I = function () { return !0 }, C = function (_) { return _.trim().length > 0 }, T = function (_) { var S = _.containerProps, E = _.children; return e.default.createElement("div", S, E) }, L = "suggestions-revealed", D = "suggestions-updated", N = "suggestion-selected", F = "input-focused", B = "input-changed", H = "input-blurred", q = "escape-pressed", V = function (A) { x(S, A); var _ = m(S); function S(E) { var w, O = E.alwaysRenderSuggestions; return h(this, S), w = _.call(this), M(p(w), "onDocumentMouseDown", function (j) { w.justClickedOnSuggestionsContainer = !1; for (var $ = j.detail && j.detail.target || j.target; $ !== null && $ !== document;) { if ($.getAttribute && $.getAttribute("data-suggestion-index") !== null) return; if ($ === w.suggestionsContainer) { w.justClickedOnSuggestionsContainer = !0; return } $ = $.parentNode } }), M(p(w), "storeAutowhateverRef", function (j) { j !== null && (w.autowhatever = j) }), M(p(w), "onSuggestionMouseEnter", function (j, $) { var z = $.sectionIndex, W = $.itemIndex; w.updateHighlightedSuggestion(z, W), j.target === w.pressedSuggestion && (w.justSelectedSuggestion = !0), w.justMouseEntered = !0, setTimeout(function () { w.justMouseEntered = !1 }) }), M(p(w), "highlightFirstSuggestion", function () { w.updateHighlightedSuggestion(w.props.multiSection ? 0 : null, 0) }), M(p(w), "onDocumentMouseUp", function () { w.pressedSuggestion && !w.justSelectedSuggestion && w.input.focus(), w.pressedSuggestion = null }), M(p(w), "onSuggestionMouseDown", function (j) { w.justSelectedSuggestion || (w.justSelectedSuggestion = !0, w.pressedSuggestion = j.target) }), M(p(w), "onSuggestionsClearRequested", function () { var j = w.props.onSuggestionsClearRequested; j && j() }), M(p(w), "onSuggestionSelected", function (j, $) { var z = w.props, W = z.alwaysRenderSuggestions, K = z.onSuggestionSelected, Z = z.onSuggestionsFetchRequested; K && K(j, $); var re = w.props.shouldKeepSuggestionsOnSelect($.suggestion); W || re ? Z({ value: $.suggestionValue, reason: N }) : w.onSuggestionsClearRequested(), w.resetHighlightedSuggestion() }), M(p(w), "onSuggestionClick", function (j) { var $ = w.props, z = $.alwaysRenderSuggestions, W = $.focusInputOnSuggestionClick, K = w.getSuggestionIndices(w.findSuggestionElement(j.target)), Z = K.sectionIndex, re = K.suggestionIndex, ue = w.getSuggestion(Z, re), tt = w.props.getSuggestionValue(ue); w.maybeCallOnChange(j, tt, "click"), w.onSuggestionSelected(j, { suggestion: ue, suggestionValue: tt, suggestionIndex: re, sectionIndex: Z, method: "click" }); var ot = w.props.shouldKeepSuggestionsOnSelect(ue); z || ot || w.closeSuggestions(), W === !0 ? w.input.focus() : w.onBlur(), setTimeout(function () { w.justSelectedSuggestion = !1 }) }), M(p(w), "onBlur", function () { var j = w.props, $ = j.inputProps, z = j.shouldRenderSuggestions, W = $.value, K = $.onBlur, Z = w.getHighlightedSuggestion(), re = z(W, H); w.setState({ isFocused: !1, highlightedSectionIndex: null, highlightedSuggestionIndex: null, highlightedSuggestion: null, valueBeforeUpDown: null, isCollapsed: !re }), K && K(w.blurEvent, { highlightedSuggestion: Z }) }), M(p(w), "onSuggestionMouseLeave", function (j) { w.resetHighlightedSuggestion(!1), w.justSelectedSuggestion && j.target === w.pressedSuggestion && (w.justSelectedSuggestion = !1) }), M(p(w), "onSuggestionTouchStart", function () { w.justSelectedSuggestion = !0 }), M(p(w), "onSuggestionTouchMove", function () { w.justSelectedSuggestion = !1, w.pressedSuggestion = null, w.input.focus() }), M(p(w), "itemProps", function (j) { var $ = j.sectionIndex, z = j.itemIndex; return { "data-section-index": $, "data-suggestion-index": z, onMouseEnter: w.onSuggestionMouseEnter, onMouseLeave: w.onSuggestionMouseLeave, onMouseDown: w.onSuggestionMouseDown, onTouchStart: w.onSuggestionTouchStart, onTouchMove: w.onSuggestionTouchMove, onClick: w.onSuggestionClick } }), M(p(w), "renderSuggestionsContainer", function (j) { var $ = j.containerProps, z = j.children, W = w.props.renderSuggestionsContainer; return W({ containerProps: $, children: z, query: w.getQuery() }) }), w.state = { isFocused: !1, isCollapsed: !O, highlightedSectionIndex: null, highlightedSuggestionIndex: null, highlightedSuggestion: null, valueBeforeUpDown: null }, w.justPressedUpDown = !1, w.justMouseEntered = !1, w.pressedSuggestion = null, w } return g(S, [{ key: "componentDidMount", value: function () { document.addEventListener("mousedown", this.onDocumentMouseDown), document.addEventListener("mouseup", this.onDocumentMouseUp), this.input = this.autowhatever.input, this.suggestionsContainer = this.autowhatever.itemsContainer } }, { key: "UNSAFE_componentWillReceiveProps", value: function (w) { var O = this.state.highlightedSuggestionIndex === 0 && this.props.highlightFirstSuggestion && !w.highlightFirstSuggestion; (0, r.default)(w.suggestions, this.props.suggestions) ? w.highlightFirstSuggestion && w.suggestions.length > 0 && this.justPressedUpDown === !1 && this.justMouseEntered === !1 ? this.highlightFirstSuggestion() : O && this.resetHighlightedSuggestion() : this.willRenderSuggestions(w, D) ? (this.state.isCollapsed && !this.justSelectedSuggestion && this.revealSuggestions(), O && this.resetHighlightedSuggestion()) : this.resetHighlightedSuggestion() } }, { key: "componentDidUpdate", value: function (w, O) { var j = this.props, $ = j.suggestions, z = j.onSuggestionHighlighted, W = j.highlightFirstSuggestion; if (!(0, r.default)($, w.suggestions) && $.length > 0 && W) { this.highlightFirstSuggestion(); return } if (z) { var K = this.getHighlightedSuggestion(), Z = O.highlightedSuggestion; K != Z && z({ suggestion: K }) } } }, { key: "componentWillUnmount", value: function () { document.removeEventListener("mousedown", this.onDocumentMouseDown), document.removeEventListener("mouseup", this.onDocumentMouseUp) } }, { key: "updateHighlightedSuggestion", value: function (w, O, j) { var $ = this; this.setState(function (z) { var W = z.valueBeforeUpDown; return O === null ? W = null : W === null && typeof j < "u" && (W = j), { highlightedSectionIndex: w, highlightedSuggestionIndex: O, highlightedSuggestion: O === null ? null : $.getSuggestion(w, O), valueBeforeUpDown: W } }) } }, { key: "resetHighlightedSuggestion", value: function () { var w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0; this.setState(function (O) { var j = O.valueBeforeUpDown; return { highlightedSectionIndex: null, highlightedSuggestionIndex: null, highlightedSuggestion: null, valueBeforeUpDown: w ? null : j } }) } }, { key: "revealSuggestions", value: function () { this.setState({ isCollapsed: !1 }) } }, { key: "closeSuggestions", value: function () { this.setState({ highlightedSectionIndex: null, highlightedSuggestionIndex: null, highlightedSuggestion: null, valueBeforeUpDown: null, isCollapsed: !0 }) } }, { key: "getSuggestion", value: function (w, O) { var j = this.props, $ = j.suggestions, z = j.multiSection, W = j.getSectionSuggestions; return z ? W($[w])[O] : $[O] } }, { key: "getHighlightedSuggestion", value: function () { var w = this.state, O = w.highlightedSectionIndex, j = w.highlightedSuggestionIndex; return j === null ? null : this.getSuggestion(O, j) } }, { key: "getSuggestionValueByIndex", value: function (w, O) { var j = this.props.getSuggestionValue; return j(this.getSuggestion(w, O)) } }, { key: "getSuggestionIndices", value: function (w) { var O = w.getAttribute("data-section-index"), j = w.getAttribute("data-suggestion-index"); return { sectionIndex: typeof O == "string" ? parseInt(O, 10) : null, suggestionIndex: parseInt(j, 10) } } }, { key: "findSuggestionElement", value: function (w) { var O = w; do { if (O.getAttribute && O.getAttribute("data-suggestion-index") !== null) return O; O = O.parentNode } while (O !== null); throw console.error("Clicked element:", w), new Error("Couldn't find suggestion element") } }, { key: "maybeCallOnChange", value: function (w, O, j) { var $ = this.props.inputProps, z = $.value, W = $.onChange; O !== z && W(w, { newValue: O, method: j }) } }, { key: "willRenderSuggestions", value: function (w, O) { var j = w.suggestions, $ = w.inputProps, z = w.shouldRenderSuggestions, W = $.value; return j.length > 0 && z(W, O) } }, { key: "getQuery", value: function () { var w = this.props.inputProps, O = w.value, j = this.state.valueBeforeUpDown; return (j === null ? O : j).trim() } }, { key: "render", value: function () { var w = this, O = this.props, j = O.suggestions, $ = O.renderInputComponent, z = O.onSuggestionsFetchRequested, W = O.renderSuggestion, K = O.inputProps, Z = O.multiSection, re = O.renderSectionTitle, ue = O.id, tt = O.getSectionSuggestions, ot = O.theme, Qt = O.getSuggestionValue, qe = O.alwaysRenderSuggestions, Wr = O.highlightFirstSuggestion, qr = O.containerProps, dn = this.state, tw = dn.isFocused, Ef = dn.isCollapsed, Tf = dn.highlightedSectionIndex, If = dn.highlightedSuggestionIndex, ko = dn.valueBeforeUpDown, Co = qe ? I : this.props.shouldRenderSuggestions, Kr = K.value, Rf = K.onFocus, Mf = K.onKeyDown, nw = this.willRenderSuggestions(this.props, "render"), Oo = qe || tw && !Ef && nw, rw = Oo ? j : [], iw = d({}, K, { onFocus: function (Me) { if (!w.justSelectedSuggestion && !w.justClickedOnSuggestionsContainer) { var hn = Co(Kr, F); w.setState({ isFocused: !0, isCollapsed: !hn }), Rf && Rf(Me), hn && z({ value: Kr, reason: F }) } }, onBlur: function (Me) { if (w.justClickedOnSuggestionsContainer) { w.input.focus(); return } w.blurEvent = Me, w.justSelectedSuggestion || (w.onBlur(), w.onSuggestionsClearRequested()) }, onChange: function (Me) { var hn = Me.target.value, qi = Co(hn, B); w.maybeCallOnChange(Me, hn, "type"), w.suggestionsContainer && (w.suggestionsContainer.scrollTop = 0), w.setState(d({}, Wr ? {} : { highlightedSectionIndex: null, highlightedSuggestionIndex: null, highlightedSuggestion: null }, { valueBeforeUpDown: null, isCollapsed: !qi })), qi ? z({ value: hn, reason: B }) : w.onSuggestionsClearRequested() }, onKeyDown: function (Me, hn) { var qi = Me.keyCode; switch (qi) { case 40: case 38: if (Ef) Co(Kr, L) && (z({ value: Kr, reason: L }), w.revealSuggestions(), Me.preventDefault()); else if (j.length > 0) { var Lf = hn.newHighlightedSectionIndex, vu = hn.newHighlightedItemIndex, yu; vu === null ? yu = ko === null ? Kr : ko : yu = w.getSuggestionValueByIndex(Lf, vu), w.updateHighlightedSuggestion(Lf, vu, Kr), w.maybeCallOnChange(Me, yu, qi === 40 ? "down" : "up"), Me.preventDefault() } w.justPressedUpDown = !0, setTimeout(function () { w.justPressedUpDown = !1 }); break; case 13: { if (Me.keyCode === 229) break; var bu = w.getHighlightedSuggestion(); if (Oo && !qe && w.closeSuggestions(), bu != null) { Me.preventDefault(); var Df = Qt(bu); w.maybeCallOnChange(Me, Df, "enter"), w.onSuggestionSelected(Me, { suggestion: bu, suggestionValue: Df, suggestionIndex: If, sectionIndex: Tf, method: "enter" }), w.justSelectedSuggestion = !0, setTimeout(function () { w.justSelectedSuggestion = !1 }) } break } case 27: { Oo && Me.preventDefault(); var jf = Oo && !qe; if (ko === null) { if (!jf) { var _u = ""; w.maybeCallOnChange(Me, _u, "escape"), Co(_u, q) ? z({ value: _u, reason: q }) : w.onSuggestionsClearRequested() } } else w.maybeCallOnChange(Me, ko, "escape"); jf ? (w.onSuggestionsClearRequested(), w.closeSuggestions()) : w.resetHighlightedSuggestion(); break } }Mf && Mf(Me) } }), sw = { query: this.getQuery() }; return e.default.createElement(i.default, { multiSection: Z, items: rw, renderInputComponent: $, renderItemsContainer: this.renderSuggestionsContainer, renderItem: W, renderItemData: sw, renderSectionTitle: re, getSectionItems: tt, highlightedSectionIndex: Tf, highlightedItemIndex: If, containerProps: qr, inputProps: iw, itemProps: this.itemProps, theme: (0, s.mapToAutowhateverTheme)(ot), id: ue, ref: this.storeAutowhateverRef }) } }]), S }(e.Component); t.default = V, M(V, "propTypes", { suggestions: n.default.array.isRequired, onSuggestionsFetchRequested: function (_, S) { var E = _[S]; if (typeof E != "function") throw new Error("'onSuggestionsFetchRequested' must be implemented. See: https://github.com/moroshko/react-autosuggest#onSuggestionsFetchRequestedProp") }, onSuggestionsClearRequested: function (_, S) { var E = _[S]; if (_.alwaysRenderSuggestions === !1 && typeof E != "function") throw new Error("'onSuggestionsClearRequested' must be implemented. See: https://github.com/moroshko/react-autosuggest#onSuggestionsClearRequestedProp") }, shouldKeepSuggestionsOnSelect: n.default.func, onSuggestionSelected: n.default.func, onSuggestionHighlighted: n.default.func, renderInputComponent: n.default.func, renderSuggestionsContainer: n.default.func, getSuggestionValue: n.default.func.isRequired, renderSuggestion: n.default.func.isRequired, inputProps: function (_, S) { var E = _[S]; if (!E) throw new Error("'inputProps' must be passed."); if (!Object.prototype.hasOwnProperty.call(E, "value")) throw new Error("'inputProps' must have 'value'."); if (!Object.prototype.hasOwnProperty.call(E, "onChange")) throw new Error("'inputProps' must have 'onChange'.") }, shouldRenderSuggestions: n.default.func, alwaysRenderSuggestions: n.default.bool, multiSection: n.default.bool, renderSectionTitle: function (_, S) { var E = _[S]; if (_.multiSection === !0 && typeof E != "function") throw new Error("'renderSectionTitle' must be implemented. See: https://github.com/moroshko/react-autosuggest#renderSectionTitleProp") }, getSectionSuggestions: function (_, S) { var E = _[S]; if (_.multiSection === !0 && typeof E != "function") throw new Error("'getSectionSuggestions' must be implemented. See: https://github.com/moroshko/react-autosuggest#getSectionSuggestionsProp") }, focusInputOnSuggestionClick: n.default.bool, highlightFirstSuggestion: n.default.bool, theme: n.default.object, id: n.default.string, containerProps: n.default.object }), M(V, "defaultProps", { renderSuggestionsContainer: T, shouldRenderSuggestions: C, alwaysRenderSuggestions: !1, multiSection: !1, shouldKeepSuggestionsOnSelect: function () { return !1 }, focusInputOnSuggestionClick: !0, highlightFirstSuggestion: !1, theme: s.defaultTheme, id: "1", containerProps: {} }) })(db); var xP = db.default; const SP = Bd(xP), kP = ({ addAccount: t, accounts: e, livrets: n }) => { const [r, i] = R.useState(""), [s, o] = R.useState(""), [a, l] = R.useState(""), [u, c] = R.useState([]), [d, h] = R.useState(""), [f, g] = R.useState({}), [m, y] = R.useState("Oui"), [p, v] = R.useState(!1), [b, x] = R.useState(!1), [P, M] = R.useState(null), [I, C] = R.useState(!1), T = Vr(); R.useEffect(() => { (async () => { const { data: { user: O } } = await we.auth.getUser(); M(O) })() }, []); const L = w => { h(w.target.value) }, D = w => { const { name: O, value: j } = w.target; g($ => ({ ...$, [O]: j })) }, N = async w => { var j; const O = (j = w.target.files) == null ? void 0 : j[0]; if (O) { v(!0); const { data: { text: $ } } = await tP.recognize(O, "fra"), z = nP($); i(z.Date), o(z.NomDeLaDepense), h(z.selectedOption), g(W => ({ ...W, [z.selectedOption]: z.DepenseCarteBleue })) } }, F = async w => { try { const O = w.trim(), { error: j } = await we.rpc("check_and_add_column", { p_table_name: "accounts", p_column_name: O, p_column_type: "text" }); if (j) throw j; const { data: $, error: z } = await we.from("accounts").select(O).limit(1); if (z) throw z } catch (O) { console.error(`Erreur lors de la vrification/ajout de la colonne ${w} :`, O) } }, B = async w => { if (C(!0), w.preventDefault(), b) return; if ((!r || !s || !a || !d) && !p) { alert("Veuillez remplir au minimum la date, le nom de la dpense, la catgorie et slectionner un type de dpense, ou tlcharger une image."); return } x(!0); const [O, j, $] = r.split("-"), z = `${$}/${j}/${O}`; let W = { id: Qh(), date: z, NomDeLaDepense: s, Categorie: a, DepenseCarteBleue: "", ObtenuCarteBleue: "", DeplaceCarteBleueVersLivretA: "", DeplaceLivretAVersCarteBleue: "", ObtenuLivretA: "", ObtenuMozaque: "", ARevoir: m, ...f }; try { await F("date"), await F("NomDeLaDepense"), await F("Categorie"), await F("DepenseCarteBleue"), await F("ObtenuCarteBleue"), await F("DeplaceCarteBleueVersLivretA"), await F("DeplaceLivretAVersCarteBleue"), await F("ObtenuLivretA"), await F("ObtenuMozaque"), await F("ARevoir"); for (const re in f) f.hasOwnProperty(re) && await F(re); if (!P || !P.id) { console.error("Erreur: Utilisateur non dfini ou non connect."), x(!1); return } const { data: K, error: Z } = await we.from("accounts").insert([{ ...W, user_id: P.id }]); if (Z) { console.error("Erreur lors de l'ajout du compte :", Z), x(!1); return } } catch (K) { console.error("Erreur lors de l'ajout du compte :", K) } i(""), o(""), l(""), h(""), g({}), y("Oui"), v(!1), x(!1), C(!1), T("/"), window.location.reload(), T("/") }, H = w => { const O = w.trim().toLowerCase(); return O.length === 0 ? [] : e.map($ => $.Categorie).filter(($, z, W) => $.toLowerCase().includes(O) && W.indexOf($) === z) }, q = ({ value: w }) => { c(H(w)) }, V = () => { c([]) }, A = (w, { suggestion: O }) => { l(O) }, _ = w => w, S = w => k.jsx("div", { children: w }), E = { placeholder: "Catgorie", value: a, onChange: (w, { newValue: O }) => { l(O) } }; return k.jsxs("form", { onSubmit: B, className: "p-4 account-form", children: [k.jsxs("div", { className: "flex flex-col gap-5 lg:flex-row", children: [k.jsxs("div", { className: "w-full lg:w-3/4 my-auto form-group", children: [k.jsxs("div", { className: "flex flex-col gap-5 lg:flex-row", children: [k.jsxs("div", { className: "w-full lg:w-1/3 p-2 input-field", children: [k.jsx("label", { className: "block", children: "Date" }), k.jsx("input", { type: "date", value: r, onChange: w => i(w.target.value), className: "border p-2 w-full" })] }), k.jsxs("div", { className: "w-full lg:w-1/3 p-2 input-field", children: [k.jsx("label", { className: "block", children: "Nom de la dpense" }), k.jsx("input", { type: "text", value: s, onChange: w => o(w.target.value), className: "border p-2 w-full" })] }), k.jsxs("div", { className: "w-full lg:w-1/3 p-2 input-field", children: [k.jsx("label", { className: "block", children: "Catgorie" }), k.jsx(SP, { suggestions: u, onSuggestionsFetchRequested: q, onSuggestionsClearRequested: V, onSuggestionSelected: A, getSuggestionValue: _, renderSuggestion: S, inputProps: E })] })] }), k.jsxs("div", { className: "flex flex-col gap-5 lg:flex-row", children: [k.jsxs("div", { className: "w-full lg:w-1/2 p-2 input-field", children: [k.jsx("label", { className: "block", children: "Type de dpense" }), k.jsxs("select", { value: d, onChange: L, className: "border p-2 w-full", children: [k.jsx("option", { value: "", children: "Slectionner le type de dpense" }), k.jsx("option", { value: "DepenseCarteBleue", children: "Dpense Carte Bleue" }), k.jsx("option", { value: "ObtenuCarteBleue", children: "Obtenu Carte Bleue" }), n.map(w => { var O; return k.jsxs(Dt.Fragment, { children: [w.expense && k.jsxs("option", { value: `Depense${w.name}`, children: ["Dpense ", w.name] }), w.obtained && k.jsxs("option", { value: `Obtenu${w.name}`, children: ["Obtenu ", w.name] }), w.move && ((O = w.moveTo) == null ? void 0 : O.map(j => k.jsxs("option", { value: `Deplace${w.name}Vers${j}`, children: ["Dplac ", w.name, " vers ", j] }, `Deplace${w.name}Vers${j}`)))] }, w.name) })] })] }), k.jsxs("div", { className: "w-full lg:w-1/2 p-2 input-field", children: [k.jsx("label", { className: "block", children: "Montant" }), k.jsx("input", { type: "number", name: d, value: f[d] || "", onChange: D, className: "border p-2 w-full" })] })] }), k.jsx("div", { className: "my-2", children: k.jsxs("label", { className: "block", children: ["A revoir", k.jsx("input", { type: "checkbox", checked: m === "Oui", onChange: w => y(w.target.checked ? "Oui" : ""), className: "ml-2" })] }) }), k.jsx("button", { type: "submit", className: "bg-green-500 text-white p-2 mt-2", children: "Ajouter" }), I && k.jsx("div", { className: "text-center text-blue-500 mb-4 loading-message", children: "En cours de chargement..." })] }), k.jsxs("div", { className: "w-full lg:w-1/4 file-upload", children: [k.jsx("input", { type: "file", id: "imageUpload", onChange: N, style: { display: "none" } }), k.jsxs("label", { htmlFor: "imageUpload", className: "flex flex-col items-center cursor-pointer", children: [k.jsx("span", { className: "block bg-slate-500 text-center py-2 px-4", children: "Cliquez sur l'image pour insrer depuis une image" }), k.jsx("span", { className: "block bg-slate-500 text-center", children: "        " }), k.jsx("img", { src: Is, alt: "Logo", className: "preview-image rounded-full mt-2 lg:mt-0 max-w-[100px] sm:max-w-full" }), "          "] })] })] }), k.jsx(Yh, { accounts: e })] }) }, CP = ({ accounts: t, deleteAccount: e, updateAccount: n, livrets: r }) => { const [i, s] = R.useState("date"), [o, a] = R.useState("asc"), [l, u] = R.useState([]), [c, d] = R.useState(!1), [h, f] = R.useState(!1), [g, m] = R.useState([]), [y, p] = R.useState(!1), [v, b] = R.useState(["date", "NomDeLaDepense", "Categorie", "ARevoir"]), x = Vr(), P = R.useRef(null), M = R.useRef(null); R.useEffect(() => { (async () => { var E; const { data: A, error: _ } = await we.auth.getUser(); if (_) { console.error("Erreur lors de la rcupration de lordre des colonnes :", _); return } const S = A.user; b(((E = S == null ? void 0 : S.user_metadata) == null ? void 0 : E.columnOrder) || ["date", "NomDeLaDepense", "Categorie", "ARevoir"]) })() }, []), R.useEffect(() => { const V = P.current, A = M.current; if (V && A) { const _ = () => { A.scrollLeft = V.scrollLeft }; return V.addEventListener("scroll", _), () => V.removeEventListener("scroll", _) } }, []); const I = V => { i === V ? a(o === "asc" ? "desc" : "asc") : (s(V), a("asc")) }, C = V => { const [A, _, S] = V.split("/").map(Number); return new Date(S, _ - 1, A) }, T = [...t].sort((V, A) => { const _ = o === "asc" ? 1 : -1, S = !V[i] && V[i] !== 0, E = !A[i] && A[i] !== 0; if (S && E) return 0; if (S) return 1; if (E) return -1; if (i === "date") { const w = C(V.date), O = C(A.date); return (w.getTime() - O.getTime()) * _ } else return !isNaN(Number(V[i])) && !isNaN(Number(A[i])) ? (Number(V[i]) - Number(A[i])) * _ : V[i].localeCompare(A[i]) * _ }), L = () => { u(c ? [] : t.map(V => V.id)), d(!c) }, D = V => { l.includes(V) ? u(l.filter(A => A !== V)) : u([...l, V]) }, N = async () => { f(!1), p(!0), await Promise.all(l.map(V => e(V))), u([]), d(!1), p(!1) }, F = () => { f(!0), m(t) }, B = async () => { f(!1), p(!0), await Promise.all(g.map(V => { const { id: A, ..._ } = V; return n(A, _) })), p(!1), x("/tableau"), window.location.reload(), x("/tableau") }, H = (V, A) => { const { name: _, value: S } = A.target; m(g.map(E => E.id === V ? { ...E, [_]: S } : E)) }, q = V => V.replace(/([A-Z])/g, " $1").trim(); return k.jsxs("div", { className: "flex flex-col pr-4 overflowX-hidden", children: [k.jsx(Yh, { accounts: t }), k.jsx("div", { className: "sm:hidden", children: k.jsx("h1", { children: "Tableau non disponible sur tlphne, veuillez vous connecter depuis un ordinateur" }) }), k.jsxs("div", { className: "max-sm:hidden", children: [k.jsx("h2", { className: "text-xl mb-2", children: "Liste des comptes" }), k.jsxs("div", { className: "flex flex-wrap justify-evenly mb-4", children: [k.jsx("button", { className: "bg-blue-500 text-white px-4 py-2 mr-2 rounded", onClick: F, disabled: h, children: "diter" }), k.jsx("button", { className: "bg-red-500 text-white px-4 py-2 mr-2 rounded", onClick: N, disabled: l.length === 0, children: "Supprimer Slectionns" }), k.jsx("button", { className: "bg-green-500 text-white px-4 py-2 rounded", onClick: B, disabled: !h, children: "Enregistrer" })] }), y && k.jsx("div", { className: "text-blue-500 mb-4", children: "En cours de chargement..." }), k.jsx("div", { className: "relative flex-1 p-2 mx-auto", children: k.jsx("div", { ref: P, className: "overflow-auto h-full", children: k.jsxs("table", { className: "min-w-full bg-white text-black border-collapse border text-center", children: [k.jsx("thead", { children: k.jsxs("tr", { children: [k.jsx("th", { className: "py-2", children: k.jsx("input", { type: "checkbox", checked: c, onChange: L }) }), v.map(V => k.jsx("th", { className: "py-2", children: k.jsxs("button", { className: "focus:outline-none flex bg-transparent mx-auto", onClick: () => I(V), children: [q(V), " ", i === V && (o === "asc" ? "" : "")] }) }, V))] }) }), k.jsx("tbody", { children: T.map((V, A) => k.jsxs("tr", { className: "border-b border-gray-200", children: [k.jsx("td", { className: "py-2 border border-gray-200", children: k.jsx("input", { type: "checkbox", checked: l.includes(V.id), onChange: () => D(V.id) }) }), h ? k.jsx(k.Fragment, { children: v.map(_ => { var S; return k.jsx("td", { className: "py-2 border border-gray-200 bg-gray-100", children: k.jsx("input", { type: "text", name: _, value: ((S = g.find(E => E.id === V.id)) == null ? void 0 : S[_]) || "", onChange: E => H(V.id, E), className: "border p-1 w-full text-center bg-gray-200" }) }, _) }) }) : k.jsx(k.Fragment, { children: v.map(_ => k.jsx("td", { className: "py-2 border border-gray-200", children: V[_] }, _)) })] }, A)) })] }) }) })] })] }) };/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */function wo(t) { return t + .5 | 0 } const Un = (t, e, n) => Math.max(Math.min(t, n), e); function gs(t) { return Un(wo(t * 2.55), 0, 255) } function nr(t) { return Un(wo(t * 255), 0, 255) } function yn(t) { return Un(wo(t / 2.55) / 100, 0, 1) } function Sg(t) { return Un(wo(t * 100), 0, 100) } const Pt = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Cd = [..."0123456789ABCDEF"], OP = t => Cd[t & 15], PP = t => Cd[(t & 240) >> 4] + Cd[t & 15], Yo = t => (t & 240) >> 4 === (t & 15), EP = t => Yo(t.r) && Yo(t.g) && Yo(t.b) && Yo(t.a); function TP(t) { var e = t.length, n; return t[0] === "#" && (e === 4 || e === 5 ? n = { r: 255 & Pt[t[1]] * 17, g: 255 & Pt[t[2]] * 17, b: 255 & Pt[t[3]] * 17, a: e === 5 ? Pt[t[4]] * 17 : 255 } : (e === 7 || e === 9) && (n = { r: Pt[t[1]] << 4 | Pt[t[2]], g: Pt[t[3]] << 4 | Pt[t[4]], b: Pt[t[5]] << 4 | Pt[t[6]], a: e === 9 ? Pt[t[7]] << 4 | Pt[t[8]] : 255 })), n } const IP = (t, e) => t < 255 ? e(t) : ""; function RP(t) { var e = EP(t) ? OP : PP; return t ? "#" + e(t.r) + e(t.g) + e(t.b) + IP(t.a, e) : void 0 } const MP = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function bb(t, e, n) { const r = e * Math.min(n, 1 - n), i = (s, o = (s + t / 30) % 12) => n - r * Math.max(Math.min(o - 3, 9 - o, 1), -1); return [i(0), i(8), i(4)] } function LP(t, e, n) { const r = (i, s = (i + t / 60) % 6) => n - n * e * Math.max(Math.min(s, 4 - s, 1), 0); return [r(5), r(3), r(1)] } function DP(t, e, n) { const r = bb(t, 1, .5); let i; for (e + n > 1 && (i = 1 / (e + n), e *= i, n *= i), i = 0; i < 3; i++)r[i] *= 1 - e - n, r[i] += e; return r } function jP(t, e, n, r, i) { return t === i ? (e - n) / r + (e < n ? 6 : 0) : e === i ? (n - t) / r + 2 : (t - e) / r + 4 } function Xh(t) { const n = t.r / 255, r = t.g / 255, i = t.b / 255, s = Math.max(n, r, i), o = Math.min(n, r, i), a = (s + o) / 2; let l, u, c; return s !== o && (c = s - o, u = a > .5 ? c / (2 - s - o) : c / (s + o), l = jP(n, r, i, c, s), l = l * 60 + .5), [l | 0, u || 0, a] } function Jh(t, e, n, r) { return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, n, r)).map(nr) } function Zh(t, e, n) { return Jh(bb, t, e, n) } function AP(t, e, n) { return Jh(DP, t, e, n) } function NP(t, e, n) { return Jh(LP, t, e, n) } function _b(t) { return (t % 360 + 360) % 360 } function FP(t) { const e = MP.exec(t); let n = 255, r; if (!e) return; e[5] !== r && (n = e[6] ? gs(+e[5]) : nr(+e[5])); const i = _b(+e[2]), s = +e[3] / 100, o = +e[4] / 100; return e[1] === "hwb" ? r = AP(i, s, o) : e[1] === "hsv" ? r = NP(i, s, o) : r = Zh(i, s, o), { r: r[0], g: r[1], b: r[2], a: n } } function $P(t, e) { var n = Xh(t); n[0] = _b(n[0] + e), n = Zh(n), t.r = n[0], t.g = n[1], t.b = n[2] } function zP(t) { if (!t) return; const e = Xh(t), n = e[0], r = Sg(e[1]), i = Sg(e[2]); return t.a < 255 ? `hsla(${n}, ${r}%, ${i}%, ${yn(t.a)})` : `hsl(${n}, ${r}%, ${i}%)` } const kg = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, Cg = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" }; function VP() { const t = {}, e = Object.keys(Cg), n = Object.keys(kg); let r, i, s, o, a; for (r = 0; r < e.length; r++) { for (o = a = e[r], i = 0; i < n.length; i++)s = n[i], a = a.replace(s, kg[s]); s = parseInt(Cg[o], 16), t[a] = [s >> 16 & 255, s >> 8 & 255, s & 255] } return t } let Qo; function BP(t) { Qo || (Qo = VP(), Qo.transparent = [0, 0, 0, 0]); const e = Qo[t.toLowerCase()]; return e && { r: e[0], g: e[1], b: e[2], a: e.length === 4 ? e[3] : 255 } } const UP = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/; function HP(t) { const e = UP.exec(t); let n = 255, r, i, s; if (e) { if (e[7] !== r) { const o = +e[7]; n = e[8] ? gs(o) : Un(o * 255, 0, 255) } return r = +e[1], i = +e[3], s = +e[5], r = 255 & (e[2] ? gs(r) : Un(r, 0, 255)), i = 255 & (e[4] ? gs(i) : Un(i, 0, 255)), s = 255 & (e[6] ? gs(s) : Un(s, 0, 255)), { r, g: i, b: s, a: n } } } function WP(t) { return t && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${yn(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) } const nc = t => t <= .0031308 ? t * 12.92 : Math.pow(t, 1 / 2.4) * 1.055 - .055, Jr = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4); function qP(t, e, n) { const r = Jr(yn(t.r)), i = Jr(yn(t.g)), s = Jr(yn(t.b)); return { r: nr(nc(r + n * (Jr(yn(e.r)) - r))), g: nr(nc(i + n * (Jr(yn(e.g)) - i))), b: nr(nc(s + n * (Jr(yn(e.b)) - s))), a: t.a + n * (e.a - t.a) } } function Xo(t, e, n) { if (t) { let r = Xh(t); r[e] = Math.max(0, Math.min(r[e] + r[e] * n, e === 0 ? 360 : 1)), r = Zh(r), t.r = r[0], t.g = r[1], t.b = r[2] } } function wb(t, e) { return t && Object.assign(e || {}, t) } function Og(t) { var e = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = nr(t[3]))) : (e = wb(t, { r: 0, g: 0, b: 0, a: 1 }), e.a = nr(e.a)), e } function KP(t) { return t.charAt(0) === "r" ? HP(t) : FP(t) } class to { constructor(e) { if (e instanceof to) return e; const n = typeof e; let r; n === "object" ? r = Og(e) : n === "string" && (r = TP(e) || BP(e) || KP(e)), this._rgb = r, this._valid = !!r } get valid() { return this._valid } get rgb() { var e = wb(this._rgb); return e && (e.a = yn(e.a)), e } set rgb(e) { this._rgb = Og(e) } rgbString() { return this._valid ? WP(this._rgb) : void 0 } hexString() { return this._valid ? RP(this._rgb) : void 0 } hslString() { return this._valid ? zP(this._rgb) : void 0 } mix(e, n) { if (e) { const r = this.rgb, i = e.rgb; let s; const o = n === s ? .5 : n, a = 2 * o - 1, l = r.a - i.a, u = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2; s = 1 - u, r.r = 255 & u * r.r + s * i.r + .5, r.g = 255 & u * r.g + s * i.g + .5, r.b = 255 & u * r.b + s * i.b + .5, r.a = o * r.a + (1 - o) * i.a, this.rgb = r } return this } interpolate(e, n) { return e && (this._rgb = qP(this._rgb, e._rgb, n)), this } clone() { return new to(this.rgb) } alpha(e) { return this._rgb.a = nr(e), this } clearer(e) { const n = this._rgb; return n.a *= 1 - e, this } greyscale() { const e = this._rgb, n = wo(e.r * .3 + e.g * .59 + e.b * .11); return e.r = e.g = e.b = n, this } opaquer(e) { const n = this._rgb; return n.a *= 1 + e, this } negate() { const e = this._rgb; return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this } lighten(e) { return Xo(this._rgb, 2, e), this } darken(e) { return Xo(this._rgb, 2, -e), this } saturate(e) { return Xo(this._rgb, 1, e), this } desaturate(e) { return Xo(this._rgb, 1, -e), this } rotate(e) { return $P(this._rgb, e), this } }/*!
 * Chart.js v4.4.3
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */function fn() { } const GP = (() => { let t = 0; return () => t++ })(); function fe(t) { return t === null || typeof t > "u" } function xe(t) { if (Array.isArray && Array.isArray(t)) return !0; const e = Object.prototype.toString.call(t); return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]" } function se(t) { return t !== null && Object.prototype.toString.call(t) === "[object Object]" } function Ne(t) { return (typeof t == "number" || t instanceof Number) && isFinite(+t) } function mt(t, e) { return Ne(t) ? t : e } function le(t, e) { return typeof t > "u" ? e : t } const YP = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 * e : +t; function ge(t, e, n) { if (t && typeof t.call == "function") return t.apply(n, e) } function ce(t, e, n, r) { let i, s, o; if (xe(t)) for (s = t.length, i = 0; i < s; i++)e.call(n, t[i], i); else if (se(t)) for (o = Object.keys(t), s = o.length, i = 0; i < s; i++)e.call(n, t[o[i]], o[i]) } function ll(t, e) { let n, r, i, s; if (!t || !e || t.length !== e.length) return !1; for (n = 0, r = t.length; n < r; ++n)if (i = t[n], s = e[n], i.datasetIndex !== s.datasetIndex || i.index !== s.index) return !1; return !0 } function ul(t) { if (xe(t)) return t.map(ul); if (se(t)) { const e = Object.create(null), n = Object.keys(t), r = n.length; let i = 0; for (; i < r; ++i)e[n[i]] = ul(t[n[i]]); return e } return t } function xb(t) { return ["__proto__", "prototype", "constructor"].indexOf(t) === -1 } function QP(t, e, n, r) { if (!xb(t)) return; const i = e[t], s = n[t]; se(i) && se(s) ? no(i, s, r) : e[t] = ul(s) } function no(t, e, n) { const r = xe(e) ? e : [e], i = r.length; if (!se(t)) return t; n = n || {}; const s = n.merger || QP; let o; for (let a = 0; a < i; ++a) { if (o = r[a], !se(o)) continue; const l = Object.keys(o); for (let u = 0, c = l.length; u < c; ++u)s(l[u], t, o, n) } return t } function Rs(t, e) { return no(t, e, { merger: XP }) } function XP(t, e, n) { if (!xb(t)) return; const r = e[t], i = n[t]; se(r) && se(i) ? Rs(r, i) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = ul(i)) } const Pg = { "": t => t, x: t => t.x, y: t => t.y }; function JP(t) { const e = t.split("."), n = []; let r = ""; for (const i of e) r += i, r.endsWith("\\") ? r = r.slice(0, -1) + "." : (n.push(r), r = ""); return n } function ZP(t) { const e = JP(t); return n => { for (const r of e) { if (r === "") break; n = n && n[r] } return n } } function Li(t, e) { return (Pg[e] || (Pg[e] = ZP(e)))(t) } function ef(t) { return t.charAt(0).toUpperCase() + t.slice(1) } const ro = t => typeof t < "u", or = t => typeof t == "function", Eg = (t, e) => { if (t.size !== e.size) return !1; for (const n of t) if (!e.has(n)) return !1; return !0 }; function eE(t) { return t.type === "mouseup" || t.type === "click" || t.type === "contextmenu" } const $e = Math.PI, un = 2 * $e, cl = Number.POSITIVE_INFINITY, tE = $e / 180, bt = $e / 2, gr = $e / 4, Tg = $e * 2 / 3, Hn = Math.log10, rr = Math.sign; function Pa(t, e, n) { return Math.abs(t - e) < n } function Ig(t) { const e = Math.round(t); t = Pa(t, e, t / 1e3) ? e : t; const n = Math.pow(10, Math.floor(Hn(t))), r = t / n; return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n } function nE(t) { const e = [], n = Math.sqrt(t); let r; for (r = 1; r < n; r++)t % r === 0 && (e.push(r), e.push(t / r)); return n === (n | 0) && e.push(n), e.sort((i, s) => i - s).pop(), e } function dl(t) { return !isNaN(parseFloat(t)) && isFinite(t) } function rE(t, e) { const n = Math.round(t); return n - e <= t && n + e >= t } function Sb(t, e, n) { let r, i, s; for (r = 0, i = t.length; r < i; r++)s = t[r][n], isNaN(s) || (e.min = Math.min(e.min, s), e.max = Math.max(e.max, s)) } function Wn(t) { return t * ($e / 180) } function tf(t) { return t * (180 / $e) } function Rg(t) { if (!Ne(t)) return; let e = 1, n = 0; for (; Math.round(t * e) / e !== t;)e *= 10, n++; return n } function iE(t, e) { const n = e.x - t.x, r = e.y - t.y, i = Math.sqrt(n * n + r * r); let s = Math.atan2(r, n); return s < -.5 * $e && (s += un), { angle: s, distance: i } } function sE(t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) } function nn(t) { return (t % un + un) % un } function oE(t, e, n, r) { const i = nn(t), s = nn(e), o = nn(n), a = nn(s - i), l = nn(o - i), u = nn(i - s), c = nn(i - o); return i === s || i === o || r && s === o || a > l && u < c } function qt(t, e, n) { return Math.max(e, Math.min(n, t)) } function aE(t) { return qt(t, -32768, 32767) } function hi(t, e, n, r = 1e-6) { return t >= Math.min(e, n) - r && t <= Math.max(e, n) + r } function nf(t, e, n) { n = n || (o => t[o] < e); let r = t.length - 1, i = 0, s; for (; r - i > 1;)s = i + r >> 1, n(s) ? i = s : r = s; return { lo: i, hi: r } } const Od = (t, e, n, r) => nf(t, n, r ? i => { const s = t[i][e]; return s < n || s === n && t[i + 1][e] === n } : i => t[i][e] < n), lE = (t, e, n) => nf(t, n, r => t[r][e] >= n); function uE(t, e, n) { let r = 0, i = t.length; for (; r < i && t[r] < e;)r++; for (; i > r && t[i - 1] > n;)i--; return r > 0 || i < t.length ? t.slice(r, i) : t } const kb = ["push", "pop", "shift", "splice", "unshift"]; function cE(t, e) { if (t._chartjs) { t._chartjs.listeners.push(e); return } Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [e] } }), kb.forEach(n => { const r = "_onData" + ef(n), i = t[n]; Object.defineProperty(t, n, { configurable: !0, enumerable: !1, value(...s) { const o = i.apply(this, s); return t._chartjs.listeners.forEach(a => { typeof a[r] == "function" && a[r](...s) }), o } }) }) } function Mg(t, e) { const n = t._chartjs; if (!n) return; const r = n.listeners, i = r.indexOf(e); i !== -1 && r.splice(i, 1), !(r.length > 0) && (kb.forEach(s => { delete t[s] }), delete t._chartjs) } function Cb(t) { const e = new Set(t); return e.size === t.length ? t : Array.from(e) } const Ob = function () { return typeof window > "u" ? function (t) { return t() } : window.requestAnimationFrame }(); function Pb(t, e) { let n = [], r = !1; return function (...i) { n = i, r || (r = !0, Ob.call(window, () => { r = !1, t.apply(e, n) })) } } function dE(t, e) { let n; return function (...r) { return e ? (clearTimeout(n), n = setTimeout(t, e, r)) : t.apply(this, r), e } } const rf = t => t === "start" ? "left" : t === "end" ? "right" : "center", Qe = (t, e, n) => t === "start" ? e : t === "end" ? n : (e + n) / 2, hE = (t, e, n, r) => t === (r ? "left" : "right") ? n : t === "center" ? (e + n) / 2 : e, Jo = t => t === 0 || t === 1, Lg = (t, e, n) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * un / n)), Dg = (t, e, n) => Math.pow(2, -10 * t) * Math.sin((t - e) * un / n) + 1, Ms = { linear: t => t, easeInQuad: t => t * t, easeOutQuad: t => -t * (t - 2), easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1), easeInCubic: t => t * t * t, easeOutCubic: t => (t -= 1) * t * t + 1, easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2), easeInQuart: t => t * t * t * t, easeOutQuart: t => -((t -= 1) * t * t * t - 1), easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2), easeInQuint: t => t * t * t * t * t, easeOutQuint: t => (t -= 1) * t * t * t * t + 1, easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2), easeInSine: t => -Math.cos(t * bt) + 1, easeOutSine: t => Math.sin(t * bt), easeInOutSine: t => -.5 * (Math.cos($e * t) - 1), easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)), easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1, easeInOutExpo: t => Jo(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (t * 2 - 1)) : .5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2), easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1), easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t), easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1), easeInElastic: t => Jo(t) ? t : Lg(t, .075, .3), easeOutElastic: t => Jo(t) ? t : Dg(t, .075, .3), easeInOutElastic(t) { return Jo(t) ? t : t < .5 ? .5 * Lg(t * 2, .1125, .45) : .5 + .5 * Dg(t * 2 - 1, .1125, .45) }, easeInBack(t) { return t * t * ((1.70158 + 1) * t - 1.70158) }, easeOutBack(t) { return (t -= 1) * t * ((1.70158 + 1) * t + 1.70158) + 1 }, easeInOutBack(t) { let e = 1.70158; return (t /= .5) < 1 ? .5 * (t * t * (((e *= 1.525) + 1) * t - e)) : .5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2) }, easeInBounce: t => 1 - Ms.easeOutBounce(1 - t), easeOutBounce(t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, easeInOutBounce: t => t < .5 ? Ms.easeInBounce(t * 2) * .5 : Ms.easeOutBounce(t * 2 - 1) * .5 + .5 }; function Eb(t) { if (t && typeof t == "object") { const e = t.toString(); return e === "[object CanvasPattern]" || e === "[object CanvasGradient]" } return !1 } function jg(t) { return Eb(t) ? t : new to(t) } function rc(t) { return Eb(t) ? t : new to(t).saturate(.5).darken(.1).hexString() } const fE = ["x", "y", "borderWidth", "radius", "tension"], pE = ["color", "borderColor", "backgroundColor"]; function gE(t) { t.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }), t.describe("animation", { _fallback: !1, _indexable: !1, _scriptable: e => e !== "onProgress" && e !== "onComplete" && e !== "fn" }), t.set("animations", { colors: { type: "color", properties: pE }, numbers: { type: "number", properties: fE } }), t.describe("animations", { _fallback: "animation" }), t.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: e => e | 0 } } } }) } function mE(t) { t.set("layout", { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } }) } const Ag = new Map; function vE(t, e) { e = e || {}; const n = t + JSON.stringify(e); let r = Ag.get(n); return r || (r = new Intl.NumberFormat(t, e), Ag.set(n, r)), r } function sf(t, e, n) { return vE(e, n).format(t) } const Tb = { values(t) { return xe(t) ? t : "" + t }, numeric(t, e, n) { if (t === 0) return "0"; const r = this.chart.options.locale; let i, s = t; if (n.length > 1) { const u = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value)); (u < 1e-4 || u > 1e15) && (i = "scientific"), s = yE(t, n) } const o = Hn(Math.abs(s)), a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = { notation: i, minimumFractionDigits: a, maximumFractionDigits: a }; return Object.assign(l, this.options.ticks.format), sf(t, r, l) }, logarithmic(t, e, n) { if (t === 0) return "0"; const r = n[e].significand || t / Math.pow(10, Math.floor(Hn(t))); return [1, 2, 3, 5, 10, 15].includes(r) || e > .8 * n.length ? Tb.numeric.call(this, t, e, n) : "" } }; function yE(t, e) { let n = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value; return Math.abs(n) >= 1 && t !== Math.floor(t) && (n = t - Math.floor(t)), n } var Jl = { formatters: Tb }; function bE(t) { t.set("scale", { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: "ticks", clip: !0, grace: 0, grid: { display: !0, lineWidth: 1, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: (e, n) => n.lineWidth, tickColor: (e, n) => n.color, offset: !1 }, border: { display: !0, dash: [], dashOffset: 0, width: 1 }, title: { display: !1, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: Jl.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: !1, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", { _fallback: !1, _scriptable: e => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser", _indexable: e => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash" }), t.describe("scales", { _fallback: "scale" }), t.describe("scale.ticks", { _scriptable: e => e !== "backdropPadding" && e !== "callback", _indexable: e => e !== "backdropPadding" }) } const Ar = Object.create(null), Pd = Object.create(null); function Ls(t, e) { if (!e) return t; const n = e.split("."); for (let r = 0, i = n.length; r < i; ++r) { const s = n[r]; t = t[s] || (t[s] = Object.create(null)) } return t } function ic(t, e, n) { return typeof e == "string" ? no(Ls(t, e), n) : no(Ls(t, ""), e) } class _E { constructor(e, n) { this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = r => r.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (r, i) => rc(i.backgroundColor), this.hoverBorderColor = (r, i) => rc(i.borderColor), this.hoverColor = (r, i) => rc(i.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: !0, includeInvisible: !1 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(n) } set(e, n) { return ic(this, e, n) } get(e) { return Ls(this, e) } describe(e, n) { return ic(Pd, e, n) } override(e, n) { return ic(Ar, e, n) } route(e, n, r, i) { const s = Ls(this, e), o = Ls(this, r), a = "_" + n; Object.defineProperties(s, { [a]: { value: s[n], writable: !0 }, [n]: { enumerable: !0, get() { const l = this[a], u = o[i]; return se(l) ? Object.assign({}, u, l) : le(l, u) }, set(l) { this[a] = l } } }) } apply(e) { e.forEach(n => n(this)) } } var Oe = new _E({ _scriptable: t => !t.startsWith("on"), _indexable: t => t !== "events", hover: { _fallback: "interaction" }, interaction: { _scriptable: !1, _indexable: !1 } }, [gE, mE, bE]); function wE(t) { return !t || fe(t.size) || fe(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family } function hl(t, e, n, r, i) { let s = e[i]; return s || (s = e[i] = t.measureText(i).width, n.push(i)), s > r && (r = s), r } function xE(t, e, n, r) { r = r || {}; let i = r.data = r.data || {}, s = r.garbageCollect = r.garbageCollect || []; r.font !== e && (i = r.data = {}, s = r.garbageCollect = [], r.font = e), t.save(), t.font = e; let o = 0; const a = n.length; let l, u, c, d, h; for (l = 0; l < a; l++)if (d = n[l], d != null && !xe(d)) o = hl(t, i, s, o, d); else if (xe(d)) for (u = 0, c = d.length; u < c; u++)h = d[u], h != null && !xe(h) && (o = hl(t, i, s, o, h)); t.restore(); const f = s.length / 2; if (f > n.length) { for (l = 0; l < f; l++)delete i[s[l]]; s.splice(0, f) } return o } function mr(t, e, n) { const r = t.currentDevicePixelRatio, i = n !== 0 ? Math.max(n / 2, .5) : 0; return Math.round((e - i) * r) / r + i } function Ng(t, e) { !e && !t || (e = e || t.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore()) } function Fg(t, e, n, r) { Ib(t, e, n, r, null) } function Ib(t, e, n, r, i) { let s, o, a, l, u, c, d, h; const f = e.pointStyle, g = e.rotation, m = e.radius; let y = (g || 0) * tE; if (f && typeof f == "object" && (s = f.toString(), s === "[object HTMLImageElement]" || s === "[object HTMLCanvasElement]")) { t.save(), t.translate(n, r), t.rotate(y), t.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), t.restore(); return } if (!(isNaN(m) || m <= 0)) { switch (t.beginPath(), f) { default: i ? t.ellipse(n, r, i / 2, m, 0, 0, un) : t.arc(n, r, m, 0, un), t.closePath(); break; case "triangle": c = i ? i / 2 : m, t.moveTo(n + Math.sin(y) * c, r - Math.cos(y) * m), y += Tg, t.lineTo(n + Math.sin(y) * c, r - Math.cos(y) * m), y += Tg, t.lineTo(n + Math.sin(y) * c, r - Math.cos(y) * m), t.closePath(); break; case "rectRounded": u = m * .516, l = m - u, o = Math.cos(y + gr) * l, d = Math.cos(y + gr) * (i ? i / 2 - u : l), a = Math.sin(y + gr) * l, h = Math.sin(y + gr) * (i ? i / 2 - u : l), t.arc(n - d, r - a, u, y - $e, y - bt), t.arc(n + h, r - o, u, y - bt, y), t.arc(n + d, r + a, u, y, y + bt), t.arc(n - h, r + o, u, y + bt, y + $e), t.closePath(); break; case "rect": if (!g) { l = Math.SQRT1_2 * m, c = i ? i / 2 : l, t.rect(n - c, r - l, 2 * c, 2 * l); break } y += gr; case "rectRot": d = Math.cos(y) * (i ? i / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, h = Math.sin(y) * (i ? i / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + h, r - o), t.lineTo(n + d, r + a), t.lineTo(n - h, r + o), t.closePath(); break; case "crossRot": y += gr; case "cross": d = Math.cos(y) * (i ? i / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, h = Math.sin(y) * (i ? i / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + d, r + a), t.moveTo(n + h, r - o), t.lineTo(n - h, r + o); break; case "star": d = Math.cos(y) * (i ? i / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, h = Math.sin(y) * (i ? i / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + d, r + a), t.moveTo(n + h, r - o), t.lineTo(n - h, r + o), y += gr, d = Math.cos(y) * (i ? i / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, h = Math.sin(y) * (i ? i / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + d, r + a), t.moveTo(n + h, r - o), t.lineTo(n - h, r + o); break; case "line": o = i ? i / 2 : Math.cos(y) * m, a = Math.sin(y) * m, t.moveTo(n - o, r - a), t.lineTo(n + o, r + a); break; case "dash": t.moveTo(n, r), t.lineTo(n + Math.cos(y) * (i ? i / 2 : m), r + Math.sin(y) * m); break; case !1: t.closePath(); break }t.fill(), e.borderWidth > 0 && t.stroke() } } function fi(t, e, n) { return n = n || .5, !e || t && t.x > e.left - n && t.x < e.right + n && t.y > e.top - n && t.y < e.bottom + n } function of(t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() } function af(t) { t.restore() } function SE(t, e) { e.translation && t.translate(e.translation[0], e.translation[1]), fe(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline) } function kE(t, e, n, r, i) { if (i.strikethrough || i.underline) { const s = t.measureText(r), o = e - s.actualBoundingBoxLeft, a = e + s.actualBoundingBoxRight, l = n - s.actualBoundingBoxAscent, u = n + s.actualBoundingBoxDescent, c = i.strikethrough ? (l + u) / 2 : u; t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = i.decorationWidth || 2, t.moveTo(o, c), t.lineTo(a, c), t.stroke() } } function CE(t, e) { const n = t.fillStyle; t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = n } function Nr(t, e, n, r, i, s = {}) { const o = xe(e) ? e : [e], a = s.strokeWidth > 0 && s.strokeColor !== ""; let l, u; for (t.save(), t.font = i.string, SE(t, s), l = 0; l < o.length; ++l)u = o[l], s.backdrop && CE(t, s.backdrop), a && (s.strokeColor && (t.strokeStyle = s.strokeColor), fe(s.strokeWidth) || (t.lineWidth = s.strokeWidth), t.strokeText(u, n, r, s.maxWidth)), t.fillText(u, n, r, s.maxWidth), kE(t, n, r, u, s), r += Number(i.lineHeight); t.restore() } function io(t, e) { const { x: n, y: r, w: i, h: s, radius: o } = e; t.arc(n + o.topLeft, r + o.topLeft, o.topLeft, 1.5 * $e, $e, !0), t.lineTo(n, r + s - o.bottomLeft), t.arc(n + o.bottomLeft, r + s - o.bottomLeft, o.bottomLeft, $e, bt, !0), t.lineTo(n + i - o.bottomRight, r + s), t.arc(n + i - o.bottomRight, r + s - o.bottomRight, o.bottomRight, bt, 0, !0), t.lineTo(n + i, r + o.topRight), t.arc(n + i - o.topRight, r + o.topRight, o.topRight, 0, -bt, !0), t.lineTo(n + o.topLeft, r) } const OE = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, PE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/; function EE(t, e) { const n = ("" + t).match(OE); if (!n || n[1] === "normal") return e * 1.2; switch (t = +n[2], n[3]) { case "px": return t; case "%": t /= 100; break }return e * t } const TE = t => +t || 0; function Rb(t, e) { const n = {}, r = se(e), i = r ? Object.keys(e) : e, s = se(t) ? r ? o => le(t[o], t[e[o]]) : o => t[o] : () => t; for (const o of i) n[o] = TE(s(o)); return n } function Mb(t) { return Rb(t, { top: "y", right: "x", bottom: "y", left: "x" }) } function Tr(t) { return Rb(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"]) } function et(t) { const e = Mb(t); return e.width = e.left + e.right, e.height = e.top + e.bottom, e } function je(t, e) { t = t || {}, e = e || Oe.font; let n = le(t.size, e.size); typeof n == "string" && (n = parseInt(n, 10)); let r = le(t.style, e.style); r && !("" + r).match(PE) && (console.warn('Invalid font style specified: "' + r + '"'), r = void 0); const i = { family: le(t.family, e.family), lineHeight: EE(le(t.lineHeight, e.lineHeight), n), size: n, style: r, weight: le(t.weight, e.weight), string: "" }; return i.string = wE(i), i } function Zo(t, e, n, r) { let i, s, o; for (i = 0, s = t.length; i < s; ++i)if (o = t[i], o !== void 0 && o !== void 0) return o } function IE(t, e, n) { const { min: r, max: i } = t, s = YP(e, (i - r) / 2), o = (a, l) => n && a === 0 ? 0 : a + l; return { min: o(r, -Math.abs(s)), max: o(i, s) } } function Ur(t, e) { return Object.assign(Object.create(t), e) } function lf(t, e = [""], n, r, i = () => t[0]) { const s = n || t; typeof r > "u" && (r = Ab("_fallback", t)); const o = { [Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: t, _rootScopes: s, _fallback: r, _getTarget: i, override: a => lf([a, ...t], e, s, r) }; return new Proxy(o, { deleteProperty(a, l) { return delete a[l], delete a._keys, delete t[0][l], !0 }, get(a, l) { return Db(a, l, () => FE(l, e, t, a)) }, getOwnPropertyDescriptor(a, l) { return Reflect.getOwnPropertyDescriptor(a._scopes[0], l) }, getPrototypeOf() { return Reflect.getPrototypeOf(t[0]) }, has(a, l) { return zg(a).includes(l) }, ownKeys(a) { return zg(a) }, set(a, l, u) { const c = a._storage || (a._storage = i()); return a[l] = c[l] = u, delete a._keys, !0 } }) } function Di(t, e, n, r) { const i = { _cacheable: !1, _proxy: t, _context: e, _subProxy: n, _stack: new Set, _descriptors: Lb(t, r), setContext: s => Di(t, s, n, r), override: s => Di(t.override(s), e, n, r) }; return new Proxy(i, { deleteProperty(s, o) { return delete s[o], delete t[o], !0 }, get(s, o, a) { return Db(s, o, () => ME(s, o, a)) }, getOwnPropertyDescriptor(s, o) { return s._descriptors.allKeys ? Reflect.has(t, o) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(t, o) }, getPrototypeOf() { return Reflect.getPrototypeOf(t) }, has(s, o) { return Reflect.has(t, o) }, ownKeys() { return Reflect.ownKeys(t) }, set(s, o, a) { return t[o] = a, delete s[o], !0 } }) } function Lb(t, e = { scriptable: !0, indexable: !0 }) { const { _scriptable: n = e.scriptable, _indexable: r = e.indexable, _allKeys: i = e.allKeys } = t; return { allKeys: i, scriptable: n, indexable: r, isScriptable: or(n) ? n : () => n, isIndexable: or(r) ? r : () => r } } const RE = (t, e) => t ? t + ef(e) : e, uf = (t, e) => se(e) && t !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object); function Db(t, e, n) { if (Object.prototype.hasOwnProperty.call(t, e) || e === "constructor") return t[e]; const r = n(); return t[e] = r, r } function ME(t, e, n) { const { _proxy: r, _context: i, _subProxy: s, _descriptors: o } = t; let a = r[e]; return or(a) && o.isScriptable(e) && (a = LE(e, a, t, n)), xe(a) && a.length && (a = DE(e, a, t, o.isIndexable)), uf(e, a) && (a = Di(a, i, s && s[e], o)), a } function LE(t, e, n, r) { const { _proxy: i, _context: s, _subProxy: o, _stack: a } = n; if (a.has(t)) throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + t); a.add(t); let l = e(s, o || r); return a.delete(t), uf(t, l) && (l = cf(i._scopes, i, t, l)), l } function DE(t, e, n, r) { const { _proxy: i, _context: s, _subProxy: o, _descriptors: a } = n; if (typeof s.index < "u" && r(t)) return e[s.index % e.length]; if (se(e[0])) { const l = e, u = i._scopes.filter(c => c !== l); e = []; for (const c of l) { const d = cf(u, i, t, c); e.push(Di(d, s, o && o[t], a)) } } return e } function jb(t, e, n) { return or(t) ? t(e, n) : t } const jE = (t, e) => t === !0 ? e : typeof t == "string" ? Li(e, t) : void 0; function AE(t, e, n, r, i) { for (const s of e) { const o = jE(n, s); if (o) { t.add(o); const a = jb(o._fallback, n, i); if (typeof a < "u" && a !== n && a !== r) return a } else if (o === !1 && typeof r < "u" && n !== r) return null } return !1 } function cf(t, e, n, r) { const i = e._rootScopes, s = jb(e._fallback, n, r), o = [...t, ...i], a = new Set; a.add(r); let l = $g(a, o, n, s || n, r); return l === null || typeof s < "u" && s !== n && (l = $g(a, o, s, l, r), l === null) ? !1 : lf(Array.from(a), [""], i, s, () => NE(e, n, r)) } function $g(t, e, n, r, i) { for (; n;)n = AE(t, e, n, r, i); return n } function NE(t, e, n) { const r = t._getTarget(); e in r || (r[e] = {}); const i = r[e]; return xe(i) && se(n) ? n : i || {} } function FE(t, e, n, r) { let i; for (const s of e) if (i = Ab(RE(s, t), n), typeof i < "u") return uf(t, i) ? cf(n, r, t, i) : i } function Ab(t, e) { for (const n of e) { if (!n) continue; const r = n[t]; if (typeof r < "u") return r } } function zg(t) { let e = t._keys; return e || (e = t._keys = $E(t._scopes)), e } function $E(t) { const e = new Set; for (const n of t) for (const r of Object.keys(n).filter(i => !i.startsWith("_"))) e.add(r); return Array.from(e) } function df() { return typeof window < "u" && typeof document < "u" } function hf(t) { let e = t.parentNode; return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e } function fl(t, e, n) { let r; return typeof t == "string" ? (r = parseInt(t, 10), t.indexOf("%") !== -1 && (r = r / 100 * e.parentNode[n])) : r = t, r } const Zl = t => t.ownerDocument.defaultView.getComputedStyle(t, null); function zE(t, e) { return Zl(t).getPropertyValue(e) } const VE = ["top", "right", "bottom", "left"]; function Ir(t, e, n) { const r = {}; n = n ? "-" + n : ""; for (let i = 0; i < 4; i++) { const s = VE[i]; r[s] = parseFloat(t[e + "-" + s + n]) || 0 } return r.width = r.left + r.right, r.height = r.top + r.bottom, r } const BE = (t, e, n) => (t > 0 || e > 0) && (!n || !n.shadowRoot); function UE(t, e) { const n = t.touches, r = n && n.length ? n[0] : t, { offsetX: i, offsetY: s } = r; let o = !1, a, l; if (BE(i, s, t.target)) a = i, l = s; else { const u = e.getBoundingClientRect(); a = r.clientX - u.left, l = r.clientY - u.top, o = !0 } return { x: a, y: l, box: o } } function xr(t, e) { if ("native" in t) return t; const { canvas: n, currentDevicePixelRatio: r } = e, i = Zl(n), s = i.boxSizing === "border-box", o = Ir(i, "padding"), a = Ir(i, "border", "width"), { x: l, y: u, box: c } = UE(t, n), d = o.left + (c && a.left), h = o.top + (c && a.top); let { width: f, height: g } = e; return s && (f -= o.width + a.width, g -= o.height + a.height), { x: Math.round((l - d) / f * n.width / r), y: Math.round((u - h) / g * n.height / r) } } function HE(t, e, n) { let r, i; if (e === void 0 || n === void 0) { const s = t && hf(t); if (!s) e = t.clientWidth, n = t.clientHeight; else { const o = s.getBoundingClientRect(), a = Zl(s), l = Ir(a, "border", "width"), u = Ir(a, "padding"); e = o.width - u.width - l.width, n = o.height - u.height - l.height, r = fl(a.maxWidth, s, "clientWidth"), i = fl(a.maxHeight, s, "clientHeight") } } return { width: e, height: n, maxWidth: r || cl, maxHeight: i || cl } } const ea = t => Math.round(t * 10) / 10; function WE(t, e, n, r) { const i = Zl(t), s = Ir(i, "margin"), o = fl(i.maxWidth, t, "clientWidth") || cl, a = fl(i.maxHeight, t, "clientHeight") || cl, l = HE(t, e, n); let { width: u, height: c } = l; if (i.boxSizing === "content-box") { const h = Ir(i, "border", "width"), f = Ir(i, "padding"); u -= f.width + h.width, c -= f.height + h.height } return u = Math.max(0, u - s.width), c = Math.max(0, r ? u / r : c - s.height), u = ea(Math.min(u, o, l.maxWidth)), c = ea(Math.min(c, a, l.maxHeight)), u && !c && (c = ea(u / 2)), (e !== void 0 || n !== void 0) && r && l.height && c > l.height && (c = l.height, u = ea(Math.floor(c * r))), { width: u, height: c } } function Vg(t, e, n) { const r = e || 1, i = Math.floor(t.height * r), s = Math.floor(t.width * r); t.height = Math.floor(t.height), t.width = Math.floor(t.width); const o = t.canvas; return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = `${t.height}px`, o.style.width = `${t.width}px`), t.currentDevicePixelRatio !== r || o.height !== i || o.width !== s ? (t.currentDevicePixelRatio = r, o.height = i, o.width = s, t.ctx.setTransform(r, 0, 0, r, 0, 0), !0) : !1 } const qE = function () { let t = !1; try { const e = { get passive() { return t = !0, !1 } }; df() && (window.addEventListener("test", null, e), window.removeEventListener("test", null, e)) } catch { } return t }(); function Bg(t, e) { const n = zE(t, e), r = n && n.match(/^(\d+)(\.\d+)?px$/); return r ? +r[1] : void 0 } const KE = function (t, e) { return { x(n) { return t + t + e - n }, setWidth(n) { e = n }, textAlign(n) { return n === "center" ? n : n === "right" ? "left" : "right" }, xPlus(n, r) { return n - r }, leftForLtr(n, r) { return n - r } } }, GE = function () { return { x(t) { return t }, setWidth(t) { }, textAlign(t) { return t }, xPlus(t, e) { return t + e }, leftForLtr(t, e) { return t } } }; function wi(t, e, n) { return t ? KE(e, n) : GE() } function Nb(t, e) { let n, r; (e === "ltr" || e === "rtl") && (n = t.canvas.style, r = [n.getPropertyValue("direction"), n.getPropertyPriority("direction")], n.setProperty("direction", e, "important"), t.prevTextDirection = r) } function Fb(t, e) { e !== void 0 && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1])) }/*!
 * Chart.js v4.4.3
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */class YE { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify(e, n, r, i) { const s = n.listeners[i], o = n.duration; s.forEach(a => a({ chart: e, initial: n.initial, numSteps: o, currentStep: Math.min(r - n.start, o) })) } _refresh() { this._request || (this._running = !0, this._request = Ob.call(window, () => { this._update(), this._request = null, this._running && this._refresh() })) } _update(e = Date.now()) { let n = 0; this._charts.forEach((r, i) => { if (!r.running || !r.items.length) return; const s = r.items; let o = s.length - 1, a = !1, l; for (; o >= 0; --o)l = s[o], l._active ? (l._total > r.duration && (r.duration = l._total), l.tick(e), a = !0) : (s[o] = s[s.length - 1], s.pop()); a && (i.draw(), this._notify(i, r, e, "progress")), s.length || (r.running = !1, this._notify(i, r, e, "complete"), r.initial = !1), n += s.length }), this._lastDate = e, n === 0 && (this._running = !1) } _getAnims(e) { const n = this._charts; let r = n.get(e); return r || (r = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, n.set(e, r)), r } listen(e, n, r) { this._getAnims(e).listeners[n].push(r) } add(e, n) { !n || !n.length || this._getAnims(e).items.push(...n) } has(e) { return this._getAnims(e).items.length > 0 } start(e) { const n = this._charts.get(e); n && (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((r, i) => Math.max(r, i._duration), 0), this._refresh()) } running(e) { if (!this._running) return !1; const n = this._charts.get(e); return !(!n || !n.running || !n.items.length) } stop(e) { const n = this._charts.get(e); if (!n || !n.items.length) return; const r = n.items; let i = r.length - 1; for (; i >= 0; --i)r[i].cancel(); n.items = [], this._notify(e, n, Date.now(), "complete") } remove(e) { return this._charts.delete(e) } } var pn = new YE; const Ug = "transparent", QE = { boolean(t, e, n) { return n > .5 ? e : t }, color(t, e, n) { const r = jg(t || Ug), i = r.valid && jg(e || Ug); return i && i.valid ? i.mix(r, n).hexString() : e }, number(t, e, n) { return t + (e - t) * n } }; class XE { constructor(e, n, r, i) { const s = n[r]; i = Zo([e.to, i, s, e.from]); const o = Zo([e.from, s, i]); this._active = !0, this._fn = e.fn || QE[e.type || typeof o], this._easing = Ms[e.easing] || Ms.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = n, this._prop = r, this._from = o, this._to = i, this._promises = void 0 } active() { return this._active } update(e, n, r) { if (this._active) { this._notify(!1); const i = this._target[this._prop], s = r - this._start, o = this._duration - s; this._start = r, this._duration = Math.floor(Math.max(o, e.duration)), this._total += s, this._loop = !!e.loop, this._to = Zo([e.to, n, i, e.from]), this._from = Zo([e.from, i, n]) } } cancel() { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } tick(e) { const n = e - this._start, r = this._duration, i = this._prop, s = this._from, o = this._loop, a = this._to; let l; if (this._active = s !== a && (o || n < r), !this._active) { this._target[i] = a, this._notify(!0); return } if (n < 0) { this._target[i] = s; return } l = n / r % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[i] = this._fn(s, a, l) } wait() { const e = this._promises || (this._promises = []); return new Promise((n, r) => { e.push({ res: n, rej: r }) }) } _notify(e) { const n = e ? "res" : "rej", r = this._promises || []; for (let i = 0; i < r.length; i++)r[i][n]() } } class $b { constructor(e, n) { this._chart = e, this._properties = new Map, this.configure(n) } configure(e) { if (!se(e)) return; const n = Object.keys(Oe.animation), r = this._properties; Object.getOwnPropertyNames(e).forEach(i => { const s = e[i]; if (!se(s)) return; const o = {}; for (const a of n) o[a] = s[a]; (xe(s.properties) && s.properties || [i]).forEach(a => { (a === i || !r.has(a)) && r.set(a, o) }) }) } _animateOptions(e, n) { const r = n.options, i = ZE(e, r); if (!i) return []; const s = this._createAnimations(i, r); return r.$shared && JE(e.options.$animations, r).then(() => { e.options = r }, () => { }), s } _createAnimations(e, n) { const r = this._properties, i = [], s = e.$animations || (e.$animations = {}), o = Object.keys(n), a = Date.now(); let l; for (l = o.length - 1; l >= 0; --l) { const u = o[l]; if (u.charAt(0) === "$") continue; if (u === "options") { i.push(...this._animateOptions(e, n)); continue } const c = n[u]; let d = s[u]; const h = r.get(u); if (d) if (h && d.active()) { d.update(h, c, a); continue } else d.cancel(); if (!h || !h.duration) { e[u] = c; continue } s[u] = d = new XE(h, e, u, c), i.push(d) } return i } update(e, n) { if (this._properties.size === 0) { Object.assign(e, n); return } const r = this._createAnimations(e, n); if (r.length) return pn.add(this._chart, r), !0 } } function JE(t, e) { const n = [], r = Object.keys(e); for (let i = 0; i < r.length; i++) { const s = t[r[i]]; s && s.active() && n.push(s.wait()) } return Promise.all(n) } function ZE(t, e) { if (!e) return; let n = t.options; if (!n) { t.options = e; return } return n.$shared && (t.options = n = Object.assign({}, n, { $shared: !1, $animations: {} })), n } function Hg(t, e) { const n = t && t.options || {}, r = n.reverse, i = n.min === void 0 ? e : 0, s = n.max === void 0 ? e : 0; return { start: r ? s : i, end: r ? i : s } } function eT(t, e, n) { if (n === !1) return !1; const r = Hg(t, n), i = Hg(e, n); return { top: i.end, right: r.end, bottom: i.start, left: r.start } } function tT(t) { let e, n, r, i; return se(t) ? (e = t.top, n = t.right, r = t.bottom, i = t.left) : e = n = r = i = t, { top: e, right: n, bottom: r, left: i, disabled: t === !1 } } function zb(t, e) { const n = [], r = t._getSortedDatasetMetas(e); let i, s; for (i = 0, s = r.length; i < s; ++i)n.push(r[i].index); return n } function Wg(t, e, n, r = {}) { const i = t.keys, s = r.mode === "single"; let o, a, l, u; if (e !== null) { for (o = 0, a = i.length; o < a; ++o) { if (l = +i[o], l === n) { if (r.all) continue; break } u = t.values[l], Ne(u) && (s || e === 0 || rr(e) === rr(u)) && (e += u) } return e } } function nT(t, e) { const { iScale: n, vScale: r } = e, i = n.axis === "x" ? "x" : "y", s = r.axis === "x" ? "x" : "y", o = Object.keys(t), a = new Array(o.length); let l, u, c; for (l = 0, u = o.length; l < u; ++l)c = o[l], a[l] = { [i]: c, [s]: t[c] }; return a } function qg(t, e) { const n = t && t.options.stacked; return n || n === void 0 && e.stack !== void 0 } function rT(t, e, n) { return `${t.id}.${e.id}.${n.stack || n.type}` } function iT(t) { const { min: e, max: n, minDefined: r, maxDefined: i } = t.getUserBounds(); return { min: r ? e : Number.NEGATIVE_INFINITY, max: i ? n : Number.POSITIVE_INFINITY } } function sT(t, e, n) { const r = t[e] || (t[e] = {}); return r[n] || (r[n] = {}) } function Kg(t, e, n, r) { for (const i of e.getMatchingVisibleMetas(r).reverse()) { const s = t[i.index]; if (n && s > 0 || !n && s < 0) return i.index } return null } function Gg(t, e) { const { chart: n, _cachedMeta: r } = t, i = n._stacks || (n._stacks = {}), { iScale: s, vScale: o, index: a } = r, l = s.axis, u = o.axis, c = rT(s, o, r), d = e.length; let h; for (let f = 0; f < d; ++f) { const g = e[f], { [l]: m, [u]: y } = g, p = g._stacks || (g._stacks = {}); h = p[u] = sT(i, c, m), h[a] = y, h._top = Kg(h, o, !0, r.type), h._bottom = Kg(h, o, !1, r.type); const v = h._visualValues || (h._visualValues = {}); v[a] = y } } function sc(t, e) { const n = t.scales; return Object.keys(n).filter(r => n[r].axis === e).shift() } function oT(t, e) { return Ur(t, { active: !1, dataset: void 0, datasetIndex: e, index: e, mode: "default", type: "dataset" }) } function aT(t, e, n) { return Ur(t, { active: !1, dataIndex: e, parsed: void 0, raw: void 0, element: n, index: e, mode: "default", type: "data" }) } function rs(t, e) { const n = t.controller.index, r = t.vScale && t.vScale.axis; if (r) { e = e || t._parsed; for (const i of e) { const s = i._stacks; if (!s || s[r] === void 0 || s[r][n] === void 0) return; delete s[r][n], s[r]._visualValues !== void 0 && s[r]._visualValues[n] !== void 0 && delete s[r]._visualValues[n] } } } const oc = t => t === "reset" || t === "none", Yg = (t, e) => e ? t : Object.assign({}, t), lT = (t, e, n) => t && !e.hidden && e._stacked && { keys: zb(n, !0), values: null }; class Ds { constructor(e, n) { this.chart = e, this._ctx = e.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize() } initialize() { const e = this._cachedMeta; this.configure(), this.linkScales(), e._stacked = qg(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options") } updateIndex(e) { this.index !== e && rs(this._cachedMeta), this.index = e } linkScales() { const e = this.chart, n = this._cachedMeta, r = this.getDataset(), i = (d, h, f, g) => d === "x" ? h : d === "r" ? g : f, s = n.xAxisID = le(r.xAxisID, sc(e, "x")), o = n.yAxisID = le(r.yAxisID, sc(e, "y")), a = n.rAxisID = le(r.rAxisID, sc(e, "r")), l = n.indexAxis, u = n.iAxisID = i(l, s, o, a), c = n.vAxisID = i(l, o, s, a); n.xScale = this.getScaleForId(s), n.yScale = this.getScaleForId(o), n.rScale = this.getScaleForId(a), n.iScale = this.getScaleForId(u), n.vScale = this.getScaleForId(c) } getDataset() { return this.chart.data.datasets[this.index] } getMeta() { return this.chart.getDatasetMeta(this.index) } getScaleForId(e) { return this.chart.scales[e] } _getOtherScale(e) { const n = this._cachedMeta; return e === n.iScale ? n.vScale : n.iScale } reset() { this._update("reset") } _destroy() { const e = this._cachedMeta; this._data && Mg(this._data, this), e._stacked && rs(e) } _dataCheck() { const e = this.getDataset(), n = e.data || (e.data = []), r = this._data; if (se(n)) { const i = this._cachedMeta; this._data = nT(n, i) } else if (r !== n) { if (r) { Mg(r, this); const i = this._cachedMeta; rs(i), i._parsed = [] } n && Object.isExtensible(n) && cE(n, this), this._syncList = [], this._data = n } } addElements() { const e = this._cachedMeta; this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType) } buildOrUpdateElements(e) { const n = this._cachedMeta, r = this.getDataset(); let i = !1; this._dataCheck(); const s = n._stacked; n._stacked = qg(n.vScale, n), n.stack !== r.stack && (i = !0, rs(n), n.stack = r.stack), this._resyncElements(e), (i || s !== n._stacked) && Gg(this, n._parsed) } configure() { const e = this.chart.config, n = e.datasetScopeKeys(this._type), r = e.getOptionScopes(this.getDataset(), n, !0); this.options = e.createResolver(r, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } parse(e, n) { const { _cachedMeta: r, _data: i } = this, { iScale: s, _stacked: o } = r, a = s.axis; let l = e === 0 && n === i.length ? !0 : r._sorted, u = e > 0 && r._parsed[e - 1], c, d, h; if (this._parsing === !1) r._parsed = i, r._sorted = !0, h = i; else { xe(i[e]) ? h = this.parseArrayData(r, i, e, n) : se(i[e]) ? h = this.parseObjectData(r, i, e, n) : h = this.parsePrimitiveData(r, i, e, n); const f = () => d[a] === null || u && d[a] < u[a]; for (c = 0; c < n; ++c)r._parsed[c + e] = d = h[c], l && (f() && (l = !1), u = d); r._sorted = l } o && Gg(this, h) } parsePrimitiveData(e, n, r, i) { const { iScale: s, vScale: o } = e, a = s.axis, l = o.axis, u = s.getLabels(), c = s === o, d = new Array(i); let h, f, g; for (h = 0, f = i; h < f; ++h)g = h + r, d[h] = { [a]: c || s.parse(u[g], g), [l]: o.parse(n[g], g) }; return d } parseArrayData(e, n, r, i) { const { xScale: s, yScale: o } = e, a = new Array(i); let l, u, c, d; for (l = 0, u = i; l < u; ++l)c = l + r, d = n[c], a[l] = { x: s.parse(d[0], c), y: o.parse(d[1], c) }; return a } parseObjectData(e, n, r, i) { const { xScale: s, yScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, u = new Array(i); let c, d, h, f; for (c = 0, d = i; c < d; ++c)h = c + r, f = n[h], u[c] = { x: s.parse(Li(f, a), h), y: o.parse(Li(f, l), h) }; return u } getParsed(e) { return this._cachedMeta._parsed[e] } getDataElement(e) { return this._cachedMeta.data[e] } applyStack(e, n, r) { const i = this.chart, s = this._cachedMeta, o = n[e.axis], a = { keys: zb(i, !0), values: n._stacks[e.axis]._visualValues }; return Wg(a, o, s.index, { mode: r }) } updateRangeFromParsed(e, n, r, i) { const s = r[n.axis]; let o = s === null ? NaN : s; const a = i && r._stacks[n.axis]; i && a && (i.values = a, o = Wg(i, s, this._cachedMeta.index)), e.min = Math.min(e.min, o), e.max = Math.max(e.max, o) } getMinMax(e, n) { const r = this._cachedMeta, i = r._parsed, s = r._sorted && e === r.iScale, o = i.length, a = this._getOtherScale(e), l = lT(n, r, this.chart), u = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: c, max: d } = iT(a); let h, f; function g() { f = i[h]; const m = f[a.axis]; return !Ne(f[e.axis]) || c > m || d < m } for (h = 0; h < o && !(!g() && (this.updateRangeFromParsed(u, e, f, l), s)); ++h); if (s) { for (h = o - 1; h >= 0; --h)if (!g()) { this.updateRangeFromParsed(u, e, f, l); break } } return u } getAllParsedValues(e) { const n = this._cachedMeta._parsed, r = []; let i, s, o; for (i = 0, s = n.length; i < s; ++i)o = n[i][e.axis], Ne(o) && r.push(o); return r } getMaxOverflow() { return !1 } getLabelAndValue(e) { const n = this._cachedMeta, r = n.iScale, i = n.vScale, s = this.getParsed(e); return { label: r ? "" + r.getLabelForValue(s[r.axis]) : "", value: i ? "" + i.getLabelForValue(s[i.axis]) : "" } } _update(e) { const n = this._cachedMeta; this.update(e || "default"), n._clip = tT(le(this.options.clip, eT(n.xScale, n.yScale, this.getMaxOverflow()))) } update(e) { } draw() { const e = this._ctx, n = this.chart, r = this._cachedMeta, i = r.data || [], s = n.chartArea, o = [], a = this._drawStart || 0, l = this._drawCount || i.length - a, u = this.options.drawActiveElementsOnTop; let c; for (r.dataset && r.dataset.draw(e, s, a, l), c = a; c < a + l; ++c) { const d = i[c]; d.hidden || (d.active && u ? o.push(d) : d.draw(e, s)) } for (c = 0; c < o.length; ++c)o[c].draw(e, s) } getStyle(e, n) { const r = n ? "active" : "default"; return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(r) : this.resolveDataElementOptions(e || 0, r) } getContext(e, n, r) { const i = this.getDataset(); let s; if (e >= 0 && e < this._cachedMeta.data.length) { const o = this._cachedMeta.data[e]; s = o.$context || (o.$context = aT(this.getContext(), e, o)), s.parsed = this.getParsed(e), s.raw = i.data[e], s.index = s.dataIndex = e } else s = this.$context || (this.$context = oT(this.chart.getContext(), this.index)), s.dataset = i, s.index = s.datasetIndex = this.index; return s.active = !!n, s.mode = r, s } resolveDatasetElementOptions(e) { return this._resolveElementOptions(this.datasetElementType.id, e) } resolveDataElementOptions(e, n) { return this._resolveElementOptions(this.dataElementType.id, n, e) } _resolveElementOptions(e, n = "default", r) { const i = n === "active", s = this._cachedDataOpts, o = e + "-" + n, a = s[o], l = this.enableOptionSharing && ro(r); if (a) return Yg(a, l); const u = this.chart.config, c = u.datasetElementScopeKeys(this._type, e), d = i ? [`${e}Hover`, "hover", e, ""] : [e, ""], h = u.getOptionScopes(this.getDataset(), c), f = Object.keys(Oe.elements[e]), g = () => this.getContext(r, i, n), m = u.resolveNamedOptions(h, f, g, d); return m.$shared && (m.$shared = l, s[o] = Object.freeze(Yg(m, l))), m } _resolveAnimations(e, n, r) { const i = this.chart, s = this._cachedDataOpts, o = `animation-${n}`, a = s[o]; if (a) return a; let l; if (i.options.animation !== !1) { const c = this.chart.config, d = c.datasetAnimationScopeKeys(this._type, n), h = c.getOptionScopes(this.getDataset(), d); l = c.createResolver(h, this.getContext(e, r, n)) } const u = new $b(i, l && l.animations); return l && l._cacheable && (s[o] = Object.freeze(u)), u } getSharedOptions(e) { if (e.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, e)) } includeOptions(e, n) { return !n || oc(e) || this.chart._animationsDisabled } _getSharedOptions(e, n) { const r = this.resolveDataElementOptions(e, n), i = this._sharedOptions, s = this.getSharedOptions(r), o = this.includeOptions(n, s) || s !== i; return this.updateSharedOptions(s, n, r), { sharedOptions: s, includeOptions: o } } updateElement(e, n, r, i) { oc(i) ? Object.assign(e, r) : this._resolveAnimations(n, i).update(e, r) } updateSharedOptions(e, n, r) { e && !oc(n) && this._resolveAnimations(void 0, n).update(e, r) } _setStyle(e, n, r, i) { e.active = i; const s = this.getStyle(n, i); this._resolveAnimations(n, r, i).update(e, { options: !i && this.getSharedOptions(s) || s }) } removeHoverStyle(e, n, r) { this._setStyle(e, r, "active", !1) } setHoverStyle(e, n, r) { this._setStyle(e, r, "active", !0) } _removeDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !1) } _setDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !0) } _resyncElements(e) { const n = this._data, r = this._cachedMeta.data; for (const [a, l, u] of this._syncList) this[a](l, u); this._syncList = []; const i = r.length, s = n.length, o = Math.min(s, i); o && this.parse(0, o), s > i ? this._insertElements(i, s - i, e) : s < i && this._removeElements(s, i - s) } _insertElements(e, n, r = !0) { const i = this._cachedMeta, s = i.data, o = e + n; let a; const l = u => { for (u.length += n, a = u.length - 1; a >= o; a--)u[a] = u[a - n] }; for (l(s), a = e; a < o; ++a)s[a] = new this.dataElementType; this._parsing && l(i._parsed), this.parse(e, n), r && this.updateElements(s, e, n, "reset") } updateElements(e, n, r, i) { } _removeElements(e, n) { const r = this._cachedMeta; if (this._parsing) { const i = r._parsed.splice(e, n); r._stacked && rs(r, i) } r.data.splice(e, n) } _sync(e) { if (this._parsing) this._syncList.push(e); else { const [n, r, i] = e; this[n](r, i) } this.chart._dataChanges.push([this.index, ...e]) } _onDataPush() { const e = arguments.length; this._sync(["_insertElements", this.getDataset().data.length - e, e]) } _onDataPop() { this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift() { this._sync(["_removeElements", 0, 1]) } _onDataSplice(e, n) { n && this._sync(["_removeElements", e, n]); const r = arguments.length - 2; r && this._sync(["_insertElements", e, r]) } _onDataUnshift() { this._sync(["_insertElements", 0, arguments.length]) } } J(Ds, "defaults", {}), J(Ds, "datasetElementType", null), J(Ds, "dataElementType", null); function uT(t, e) { if (!t._cache.$bar) { const n = t.getMatchingVisibleMetas(e); let r = []; for (let i = 0, s = n.length; i < s; i++)r = r.concat(n[i].controller.getAllParsedValues(t)); t._cache.$bar = Cb(r.sort((i, s) => i - s)) } return t._cache.$bar } function cT(t) { const e = t.iScale, n = uT(e, t.type); let r = e._length, i, s, o, a; const l = () => { o === 32767 || o === -32768 || (ro(a) && (r = Math.min(r, Math.abs(o - a) || r)), a = o) }; for (i = 0, s = n.length; i < s; ++i)o = e.getPixelForValue(n[i]), l(); for (a = void 0, i = 0, s = e.ticks.length; i < s; ++i)o = e.getPixelForTick(i), l(); return r } function dT(t, e, n, r) { const i = n.barThickness; let s, o; return fe(i) ? (s = e.min * n.categoryPercentage, o = n.barPercentage) : (s = i * r, o = 1), { chunk: s / r, ratio: o, start: e.pixels[t] - s / 2 } } function hT(t, e, n, r) { const i = e.pixels, s = i[t]; let o = t > 0 ? i[t - 1] : null, a = t < i.length - 1 ? i[t + 1] : null; const l = n.categoryPercentage; o === null && (o = s - (a === null ? e.end - e.start : a - s)), a === null && (a = s + s - o); const u = s - (s - Math.min(o, a)) / 2 * l; return { chunk: Math.abs(a - o) / 2 * l / r, ratio: n.barPercentage, start: u } } function fT(t, e, n, r) { const i = n.parse(t[0], r), s = n.parse(t[1], r), o = Math.min(i, s), a = Math.max(i, s); let l = o, u = a; Math.abs(o) > Math.abs(a) && (l = a, u = o), e[n.axis] = u, e._custom = { barStart: l, barEnd: u, start: i, end: s, min: o, max: a } } function Vb(t, e, n, r) { return xe(t) ? fT(t, e, n, r) : e[n.axis] = n.parse(t, r), e } function Qg(t, e, n, r) { const i = t.iScale, s = t.vScale, o = i.getLabels(), a = i === s, l = []; let u, c, d, h; for (u = n, c = n + r; u < c; ++u)h = e[u], d = {}, d[i.axis] = a || i.parse(o[u], u), l.push(Vb(h, d, s, u)); return l } function ac(t) { return t && t.barStart !== void 0 && t.barEnd !== void 0 } function pT(t, e, n) { return t !== 0 ? rr(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= n ? 1 : -1) } function gT(t) { let e, n, r, i, s; return t.horizontal ? (e = t.base > t.x, n = "left", r = "right") : (e = t.base < t.y, n = "bottom", r = "top"), e ? (i = "end", s = "start") : (i = "start", s = "end"), { start: n, end: r, reverse: e, top: i, bottom: s } } function mT(t, e, n, r) { let i = e.borderSkipped; const s = {}; if (!i) { t.borderSkipped = s; return } if (i === !0) { t.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 }; return } const { start: o, end: a, reverse: l, top: u, bottom: c } = gT(t); i === "middle" && n && (t.enableBorderRadius = !0, (n._top || 0) === r ? i = u : (n._bottom || 0) === r ? i = c : (s[Xg(c, o, a, l)] = !0, i = u)), s[Xg(i, o, a, l)] = !0, t.borderSkipped = s } function Xg(t, e, n, r) { return r ? (t = vT(t, e, n), t = Jg(t, n, e)) : t = Jg(t, e, n), t } function vT(t, e, n) { return t === e ? n : t === n ? e : t } function Jg(t, e, n) { return t === "start" ? e : t === "end" ? n : t } function yT(t, { inflateAmount: e }, n) { t.inflateAmount = e === "auto" ? n === 1 ? .33 : 0 : e } class Ea extends Ds { parsePrimitiveData(e, n, r, i) { return Qg(e, n, r, i) } parseArrayData(e, n, r, i) { return Qg(e, n, r, i) } parseObjectData(e, n, r, i) { const { iScale: s, vScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, u = s.axis === "x" ? a : l, c = o.axis === "x" ? a : l, d = []; let h, f, g, m; for (h = r, f = r + i; h < f; ++h)m = n[h], g = {}, g[s.axis] = s.parse(Li(m, u), h), d.push(Vb(Li(m, c), g, o, h)); return d } updateRangeFromParsed(e, n, r, i) { super.updateRangeFromParsed(e, n, r, i); const s = r._custom; s && n === this._cachedMeta.vScale && (e.min = Math.min(e.min, s.min), e.max = Math.max(e.max, s.max)) } getMaxOverflow() { return 0 } getLabelAndValue(e) { const n = this._cachedMeta, { iScale: r, vScale: i } = n, s = this.getParsed(e), o = s._custom, a = ac(o) ? "[" + o.start + ", " + o.end + "]" : "" + i.getLabelForValue(s[i.axis]); return { label: "" + r.getLabelForValue(s[r.axis]), value: a } } initialize() { this.enableOptionSharing = !0, super.initialize(); const e = this._cachedMeta; e.stack = this.getDataset().stack } update(e) { const n = this._cachedMeta; this.updateElements(n.data, 0, n.data.length, e) } updateElements(e, n, r, i) { const s = i === "reset", { index: o, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), u = a.isHorizontal(), c = this._getRuler(), { sharedOptions: d, includeOptions: h } = this._getSharedOptions(n, i); for (let f = n; f < n + r; f++) { const g = this.getParsed(f), m = s || fe(g[a.axis]) ? { base: l, head: l } : this._calculateBarValuePixels(f), y = this._calculateBarIndexPixels(f, c), p = (g._stacks || {})[a.axis], v = { horizontal: u, base: m.base, enableBorderRadius: !p || ac(g._custom) || o === p._top || o === p._bottom, x: u ? m.head : y.center, y: u ? y.center : m.head, height: u ? y.size : Math.abs(m.size), width: u ? Math.abs(m.size) : y.size }; h && (v.options = d || this.resolveDataElementOptions(f, e[f].active ? "active" : i)); const b = v.options || e[f].options; mT(v, b, p, o), yT(v, b, c.ratio), this.updateElement(e[f], f, v, i) } } _getStacks(e, n) { const { iScale: r } = this._cachedMeta, i = r.getMatchingVisibleMetas(this._type).filter(l => l.controller.options.grouped), s = r.options.stacked, o = [], a = l => { const u = l.controller.getParsed(n), c = u && u[l.vScale.axis]; if (fe(c) || isNaN(c)) return !0 }; for (const l of i) if (!(n !== void 0 && a(l)) && ((s === !1 || o.indexOf(l.stack) === -1 || s === void 0 && l.stack === void 0) && o.push(l.stack), l.index === e)) break; return o.length || o.push(void 0), o } _getStackCount(e) { return this._getStacks(void 0, e).length } _getStackIndex(e, n, r) { const i = this._getStacks(e, r), s = n !== void 0 ? i.indexOf(n) : -1; return s === -1 ? i.length - 1 : s } _getRuler() { const e = this.options, n = this._cachedMeta, r = n.iScale, i = []; let s, o; for (s = 0, o = n.data.length; s < o; ++s)i.push(r.getPixelForValue(this.getParsed(s)[r.axis], s)); const a = e.barThickness; return { min: a || cT(n), pixels: i, start: r._startPixel, end: r._endPixel, stackCount: this._getStackCount(), scale: r, grouped: e.grouped, ratio: a ? 1 : e.categoryPercentage * e.barPercentage } } _calculateBarValuePixels(e) { const { _cachedMeta: { vScale: n, _stacked: r, index: i }, options: { base: s, minBarLength: o } } = this, a = s || 0, l = this.getParsed(e), u = l._custom, c = ac(u); let d = l[n.axis], h = 0, f = r ? this.applyStack(n, l, r) : d, g, m; f !== d && (h = f - d, f = d), c && (d = u.barStart, f = u.barEnd - u.barStart, d !== 0 && rr(d) !== rr(u.barEnd) && (h = 0), h += d); const y = !fe(s) && !c ? s : h; let p = n.getPixelForValue(y); if (this.chart.getDataVisibility(e) ? g = n.getPixelForValue(h + f) : g = p, m = g - p, Math.abs(m) < o) { m = pT(m, n, a) * o, d === a && (p -= m / 2); const v = n.getPixelForDecimal(0), b = n.getPixelForDecimal(1), x = Math.min(v, b), P = Math.max(v, b); p = Math.max(Math.min(p, P), x), g = p + m, r && !c && (l._stacks[n.axis]._visualValues[i] = n.getValueForPixel(g) - n.getValueForPixel(p)) } if (p === n.getPixelForValue(a)) { const v = rr(m) * n.getLineWidthForValue(a) / 2; p += v, m -= v } return { size: m, base: p, head: g, center: g + m / 2 } } _calculateBarIndexPixels(e, n) { const r = n.scale, i = this.options, s = i.skipNull, o = le(i.maxBarThickness, 1 / 0); let a, l; if (n.grouped) { const u = s ? this._getStackCount(e) : n.stackCount, c = i.barThickness === "flex" ? hT(e, n, i, u) : dT(e, n, i, u), d = this._getStackIndex(this.index, this._cachedMeta.stack, s ? e : void 0); a = c.start + c.chunk * d + c.chunk / 2, l = Math.min(o, c.chunk * c.ratio) } else a = r.getPixelForValue(this.getParsed(e)[r.axis], e), l = Math.min(o, n.min * n.ratio); return { base: a - l / 2, head: a + l / 2, center: a, size: l } } draw() { const e = this._cachedMeta, n = e.vScale, r = e.data, i = r.length; let s = 0; for (; s < i; ++s)this.getParsed(s)[n.axis] !== null && !r[s].hidden && r[s].draw(this._ctx) } } J(Ea, "id", "bar"), J(Ea, "defaults", { datasetElementType: !1, dataElementType: "bar", categoryPercentage: .8, barPercentage: .9, grouped: !0, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }), J(Ea, "overrides", { scales: { _index_: { type: "category", offset: !0, grid: { offset: !0 } }, _value_: { type: "linear", beginAtZero: !0 } } }); function vr() { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } class ff { constructor(e) { J(this, "options"); this.options = e || {} } static override(e) { Object.assign(ff.prototype, e) } init() { } formats() { return vr() } parse() { return vr() } format() { return vr() } add() { return vr() } diff() { return vr() } startOf() { return vr() } endOf() { return vr() } } var bT = { _date: ff }; function _T(t, e, n, r) { const { controller: i, data: s, _sorted: o } = t, a = i._cachedMeta.iScale; if (a && e === a.axis && e !== "r" && o && s.length) { const l = a._reversePixels ? lE : Od; if (r) { if (i._sharedOptions) { const u = s[0], c = typeof u.getRange == "function" && u.getRange(e); if (c) { const d = l(s, e, n - c), h = l(s, e, n + c); return { lo: d.lo, hi: h.hi } } } } else return l(s, e, n) } return { lo: 0, hi: s.length - 1 } } function xo(t, e, n, r, i) { const s = t.getSortedVisibleDatasetMetas(), o = n[e]; for (let a = 0, l = s.length; a < l; ++a) { const { index: u, data: c } = s[a], { lo: d, hi: h } = _T(s[a], e, o, i); for (let f = d; f <= h; ++f) { const g = c[f]; g.skip || r(g, u, f) } } } function wT(t) { const e = t.indexOf("x") !== -1, n = t.indexOf("y") !== -1; return function (r, i) { const s = e ? Math.abs(r.x - i.x) : 0, o = n ? Math.abs(r.y - i.y) : 0; return Math.sqrt(Math.pow(s, 2) + Math.pow(o, 2)) } } function lc(t, e, n, r, i) { const s = []; return !i && !t.isPointInArea(e) || xo(t, n, e, function (a, l, u) { !i && !fi(a, t.chartArea, 0) || a.inRange(e.x, e.y, r) && s.push({ element: a, datasetIndex: l, index: u }) }, !0), s } function xT(t, e, n, r) { let i = []; function s(o, a, l) { const { startAngle: u, endAngle: c } = o.getProps(["startAngle", "endAngle"], r), { angle: d } = iE(o, { x: e.x, y: e.y }); oE(d, u, c) && i.push({ element: o, datasetIndex: a, index: l }) } return xo(t, n, e, s), i } function ST(t, e, n, r, i, s) { let o = []; const a = wT(n); let l = Number.POSITIVE_INFINITY; function u(c, d, h) { const f = c.inRange(e.x, e.y, i); if (r && !f) return; const g = c.getCenterPoint(i); if (!(!!s || t.isPointInArea(g)) && !f) return; const y = a(e, g); y < l ? (o = [{ element: c, datasetIndex: d, index: h }], l = y) : y === l && o.push({ element: c, datasetIndex: d, index: h }) } return xo(t, n, e, u), o } function uc(t, e, n, r, i, s) { return !s && !t.isPointInArea(e) ? [] : n === "r" && !r ? xT(t, e, n, i) : ST(t, e, n, r, i, s) } function Zg(t, e, n, r, i) { const s = [], o = n === "x" ? "inXRange" : "inYRange"; let a = !1; return xo(t, n, e, (l, u, c) => { l[o](e[n], i) && (s.push({ element: l, datasetIndex: u, index: c }), a = a || l.inRange(e.x, e.y, i)) }), r && !a ? [] : s } var kT = { evaluateInteractionItems: xo, modes: { index(t, e, n, r) { const i = xr(e, t), s = n.axis || "x", o = n.includeInvisible || !1, a = n.intersect ? lc(t, i, s, r, o) : uc(t, i, s, !1, r, o), l = []; return a.length ? (t.getSortedVisibleDatasetMetas().forEach(u => { const c = a[0].index, d = u.data[c]; d && !d.skip && l.push({ element: d, datasetIndex: u.index, index: c }) }), l) : [] }, dataset(t, e, n, r) { const i = xr(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; let a = n.intersect ? lc(t, i, s, r, o) : uc(t, i, s, !1, r, o); if (a.length > 0) { const l = a[0].datasetIndex, u = t.getDatasetMeta(l).data; a = []; for (let c = 0; c < u.length; ++c)a.push({ element: u[c], datasetIndex: l, index: c }) } return a }, point(t, e, n, r) { const i = xr(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; return lc(t, i, s, r, o) }, nearest(t, e, n, r) { const i = xr(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; return uc(t, i, s, n.intersect, r, o) }, x(t, e, n, r) { const i = xr(e, t); return Zg(t, i, "x", n.intersect, r) }, y(t, e, n, r) { const i = xr(e, t); return Zg(t, i, "y", n.intersect, r) } } }; const Bb = ["left", "top", "right", "bottom"]; function is(t, e) { return t.filter(n => n.pos === e) } function em(t, e) { return t.filter(n => Bb.indexOf(n.pos) === -1 && n.box.axis === e) } function ss(t, e) { return t.sort((n, r) => { const i = e ? r : n, s = e ? n : r; return i.weight === s.weight ? i.index - s.index : i.weight - s.weight }) } function CT(t) { const e = []; let n, r, i, s, o, a; for (n = 0, r = (t || []).length; n < r; ++n)i = t[n], { position: s, options: { stack: o, stackWeight: a = 1 } } = i, e.push({ index: n, box: i, pos: s, horizontal: i.isHorizontal(), weight: i.weight, stack: o && s + o, stackWeight: a }); return e } function OT(t) { const e = {}; for (const n of t) { const { stack: r, pos: i, stackWeight: s } = n; if (!r || !Bb.includes(i)) continue; const o = e[r] || (e[r] = { count: 0, placed: 0, weight: 0, size: 0 }); o.count++, o.weight += s } return e } function PT(t, e) { const n = OT(t), { vBoxMaxWidth: r, hBoxMaxHeight: i } = e; let s, o, a; for (s = 0, o = t.length; s < o; ++s) { a = t[s]; const { fullSize: l } = a.box, u = n[a.stack], c = u && a.stackWeight / u.weight; a.horizontal ? (a.width = c ? c * r : l && e.availableWidth, a.height = i) : (a.width = r, a.height = c ? c * i : l && e.availableHeight) } return n } function ET(t) { const e = CT(t), n = ss(e.filter(u => u.box.fullSize), !0), r = ss(is(e, "left"), !0), i = ss(is(e, "right")), s = ss(is(e, "top"), !0), o = ss(is(e, "bottom")), a = em(e, "x"), l = em(e, "y"); return { fullSize: n, leftAndTop: r.concat(s), rightAndBottom: i.concat(l).concat(o).concat(a), chartArea: is(e, "chartArea"), vertical: r.concat(i).concat(l), horizontal: s.concat(o).concat(a) } } function tm(t, e, n, r) { return Math.max(t[n], e[n]) + Math.max(t[r], e[r]) } function Ub(t, e) { t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right) } function TT(t, e, n, r) { const { pos: i, box: s } = n, o = t.maxPadding; if (!se(i)) { n.size && (t[i] -= n.size); const d = r[n.stack] || { size: 0, count: 1 }; d.size = Math.max(d.size, n.horizontal ? s.height : s.width), n.size = d.size / d.count, t[i] += n.size } s.getPadding && Ub(o, s.getPadding()); const a = Math.max(0, e.outerWidth - tm(o, t, "left", "right")), l = Math.max(0, e.outerHeight - tm(o, t, "top", "bottom")), u = a !== t.w, c = l !== t.h; return t.w = a, t.h = l, n.horizontal ? { same: u, other: c } : { same: c, other: u } } function IT(t) { const e = t.maxPadding; function n(r) { const i = Math.max(e[r] - t[r], 0); return t[r] += i, i } t.y += n("top"), t.x += n("left"), n("right"), n("bottom") } function RT(t, e) { const n = e.maxPadding; function r(i) { const s = { left: 0, top: 0, right: 0, bottom: 0 }; return i.forEach(o => { s[o] = Math.max(e[o], n[o]) }), s } return r(t ? ["left", "right"] : ["top", "bottom"]) } function ms(t, e, n, r) { const i = []; let s, o, a, l, u, c; for (s = 0, o = t.length, u = 0; s < o; ++s) { a = t[s], l = a.box, l.update(a.width || e.w, a.height || e.h, RT(a.horizontal, e)); const { same: d, other: h } = TT(e, n, a, r); u |= d && i.length, c = c || h, l.fullSize || i.push(a) } return u && ms(i, e, n, r) || c } function ta(t, e, n, r, i) { t.top = n, t.left = e, t.right = e + r, t.bottom = n + i, t.width = r, t.height = i } function nm(t, e, n, r) { const i = n.padding; let { x: s, y: o } = e; for (const a of t) { const l = a.box, u = r[a.stack] || { count: 1, placed: 0, weight: 1 }, c = a.stackWeight / u.weight || 1; if (a.horizontal) { const d = e.w * c, h = u.size || l.height; ro(u.start) && (o = u.start), l.fullSize ? ta(l, i.left, o, n.outerWidth - i.right - i.left, h) : ta(l, e.left + u.placed, o, d, h), u.start = o, u.placed += d, o = l.bottom } else { const d = e.h * c, h = u.size || l.width; ro(u.start) && (s = u.start), l.fullSize ? ta(l, s, i.top, h, n.outerHeight - i.bottom - i.top) : ta(l, s, e.top + u.placed, h, d), u.start = s, u.placed += d, s = l.right } } e.x = s, e.y = o } var Lt = { addBox(t, e) { t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () { return [{ z: 0, draw(n) { e.draw(n) } }] }, t.boxes.push(e) }, removeBox(t, e) { const n = t.boxes ? t.boxes.indexOf(e) : -1; n !== -1 && t.boxes.splice(n, 1) }, configure(t, e, n) { e.fullSize = n.fullSize, e.position = n.position, e.weight = n.weight }, update(t, e, n, r) { if (!t) return; const i = et(t.options.layout.padding), s = Math.max(e - i.width, 0), o = Math.max(n - i.height, 0), a = ET(t.boxes), l = a.vertical, u = a.horizontal; ce(t.boxes, m => { typeof m.beforeLayout == "function" && m.beforeLayout() }); const c = l.reduce((m, y) => y.box.options && y.box.options.display === !1 ? m : m + 1, 0) || 1, d = Object.freeze({ outerWidth: e, outerHeight: n, padding: i, availableWidth: s, availableHeight: o, vBoxMaxWidth: s / 2 / c, hBoxMaxHeight: o / 2 }), h = Object.assign({}, i); Ub(h, et(r)); const f = Object.assign({ maxPadding: h, w: s, h: o, x: i.left, y: i.top }, i), g = PT(l.concat(u), d); ms(a.fullSize, f, d, g), ms(l, f, d, g), ms(u, f, d, g) && ms(l, f, d, g), IT(f), nm(a.leftAndTop, f, d, g), f.x += f.w, f.y += f.h, nm(a.rightAndBottom, f, d, g), t.chartArea = { left: f.left, top: f.top, right: f.left + f.w, bottom: f.top + f.h, height: f.h, width: f.w }, ce(a.chartArea, m => { const y = m.box; Object.assign(y, t.chartArea), y.update(f.w, f.h, { left: 0, top: 0, right: 0, bottom: 0 }) }) } }; class Hb { acquireContext(e, n) { } releaseContext(e) { return !1 } addEventListener(e, n, r) { } removeEventListener(e, n, r) { } getDevicePixelRatio() { return 1 } getMaximumSize(e, n, r, i) { return n = Math.max(0, n || e.width), r = r || e.height, { width: n, height: Math.max(0, i ? Math.floor(n / i) : r) } } isAttached(e) { return !0 } updateConfig(e) { } } class MT extends Hb { acquireContext(e) { return e && e.getContext && e.getContext("2d") || null } updateConfig(e) { e.options.animation = !1 } } const Ta = "$chartjs", LT = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, rm = t => t === null || t === ""; function DT(t, e) { const n = t.style, r = t.getAttribute("height"), i = t.getAttribute("width"); if (t[Ta] = { initial: { height: r, width: i, style: { display: n.display, height: n.height, width: n.width } } }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", rm(i)) { const s = Bg(t, "width"); s !== void 0 && (t.width = s) } if (rm(r)) if (t.style.height === "") t.height = t.width / (e || 2); else { const s = Bg(t, "height"); s !== void 0 && (t.height = s) } return t } const Wb = qE ? { passive: !0 } : !1; function jT(t, e, n) { t && t.addEventListener(e, n, Wb) } function AT(t, e, n) { t && t.canvas && t.canvas.removeEventListener(e, n, Wb) } function NT(t, e) { const n = LT[t.type] || t.type, { x: r, y: i } = xr(t, e); return { type: n, chart: e, native: t, x: r !== void 0 ? r : null, y: i !== void 0 ? i : null } } function pl(t, e) { for (const n of t) if (n === e || n.contains(e)) return !0 } function FT(t, e, n) { const r = t.canvas, i = new MutationObserver(s => { let o = !1; for (const a of s) o = o || pl(a.addedNodes, r), o = o && !pl(a.removedNodes, r); o && n() }); return i.observe(document, { childList: !0, subtree: !0 }), i } function $T(t, e, n) { const r = t.canvas, i = new MutationObserver(s => { let o = !1; for (const a of s) o = o || pl(a.removedNodes, r), o = o && !pl(a.addedNodes, r); o && n() }); return i.observe(document, { childList: !0, subtree: !0 }), i } const so = new Map; let im = 0; function qb() { const t = window.devicePixelRatio; t !== im && (im = t, so.forEach((e, n) => { n.currentDevicePixelRatio !== t && e() })) } function zT(t, e) { so.size || window.addEventListener("resize", qb), so.set(t, e) } function VT(t) { so.delete(t), so.size || window.removeEventListener("resize", qb) } function BT(t, e, n) { const r = t.canvas, i = r && hf(r); if (!i) return; const s = Pb((a, l) => { const u = i.clientWidth; n(a, l), u < i.clientWidth && n() }, window), o = new ResizeObserver(a => { const l = a[0], u = l.contentRect.width, c = l.contentRect.height; u === 0 && c === 0 || s(u, c) }); return o.observe(i), zT(t, s), o } function cc(t, e, n) { n && n.disconnect(), e === "resize" && VT(t) } function UT(t, e, n) { const r = t.canvas, i = Pb(s => { t.ctx !== null && n(NT(s, t)) }, t); return jT(r, e, i), i } class HT extends Hb { acquireContext(e, n) { const r = e && e.getContext && e.getContext("2d"); return r && r.canvas === e ? (DT(e, n), r) : null } releaseContext(e) { const n = e.canvas; if (!n[Ta]) return !1; const r = n[Ta].initial;["height", "width"].forEach(s => { const o = r[s]; fe(o) ? n.removeAttribute(s) : n.setAttribute(s, o) }); const i = r.style || {}; return Object.keys(i).forEach(s => { n.style[s] = i[s] }), n.width = n.width, delete n[Ta], !0 } addEventListener(e, n, r) { this.removeEventListener(e, n); const i = e.$proxies || (e.$proxies = {}), o = { attach: FT, detach: $T, resize: BT }[n] || UT; i[n] = o(e, n, r) } removeEventListener(e, n) { const r = e.$proxies || (e.$proxies = {}), i = r[n]; if (!i) return; ({ attach: cc, detach: cc, resize: cc }[n] || AT)(e, n, i), r[n] = void 0 } getDevicePixelRatio() { return window.devicePixelRatio } getMaximumSize(e, n, r, i) { return WE(e, n, r, i) } isAttached(e) { const n = e && hf(e); return !!(n && n.isConnected) } } function WT(t) { return !df() || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas ? MT : HT } var pa; let Hi = (pa = class { constructor() { J(this, "x"); J(this, "y"); J(this, "active", !1); J(this, "options"); J(this, "$animations") } tooltipPosition(e) { const { x: n, y: r } = this.getProps(["x", "y"], e); return { x: n, y: r } } hasValue() { return dl(this.x) && dl(this.y) } getProps(e, n) { const r = this.$animations; if (!n || !r) return this; const i = {}; return e.forEach(s => { i[s] = r[s] && r[s].active() ? r[s]._to : this[s] }), i } }, J(pa, "defaults", {}), J(pa, "defaultRoutes"), pa); function qT(t, e) { const n = t.options.ticks, r = KT(t), i = Math.min(n.maxTicksLimit || r, r), s = n.major.enabled ? YT(e) : [], o = s.length, a = s[0], l = s[o - 1], u = []; if (o > i) return QT(e, u, s, o / i), u; const c = GT(s, e, i); if (o > 0) { let d, h; const f = o > 1 ? Math.round((l - a) / (o - 1)) : null; for (na(e, u, c, fe(f) ? 0 : a - f, a), d = 0, h = o - 1; d < h; d++)na(e, u, c, s[d], s[d + 1]); return na(e, u, c, l, fe(f) ? e.length : l + f), u } return na(e, u, c), u } function KT(t) { const e = t.options.offset, n = t._tickSize(), r = t._length / n + (e ? 0 : 1), i = t._maxLength / n; return Math.floor(Math.min(r, i)) } function GT(t, e, n) { const r = XT(t), i = e.length / n; if (!r) return Math.max(i, 1); const s = nE(r); for (let o = 0, a = s.length - 1; o < a; o++) { const l = s[o]; if (l > i) return l } return Math.max(i, 1) } function YT(t) { const e = []; let n, r; for (n = 0, r = t.length; n < r; n++)t[n].major && e.push(n); return e } function QT(t, e, n, r) { let i = 0, s = n[0], o; for (r = Math.ceil(r), o = 0; o < t.length; o++)o === s && (e.push(t[o]), i++, s = n[i * r]) } function na(t, e, n, r, i) { const s = le(r, 0), o = Math.min(le(i, t.length), t.length); let a = 0, l, u, c; for (n = Math.ceil(n), i && (l = i - r, n = l / Math.floor(l / n)), c = s; c < 0;)a++, c = Math.round(s + a * n); for (u = Math.max(s, 0); u < o; u++)u === c && (e.push(t[u]), a++, c = Math.round(s + a * n)) } function XT(t) { const e = t.length; let n, r; if (e < 2) return !1; for (r = t[0], n = 1; n < e; ++n)if (t[n] - t[n - 1] !== r) return !1; return r } const JT = t => t === "left" ? "right" : t === "right" ? "left" : t, sm = (t, e, n) => e === "top" || e === "left" ? t[e] + n : t[e] - n, om = (t, e) => Math.min(e || t, t); function am(t, e) { const n = [], r = t.length / e, i = t.length; let s = 0; for (; s < i; s += r)n.push(t[Math.floor(s)]); return n } function ZT(t, e, n) { const r = t.ticks.length, i = Math.min(e, r - 1), s = t._startPixel, o = t._endPixel, a = 1e-6; let l = t.getPixelForTick(i), u; if (!(n && (r === 1 ? u = Math.max(l - s, o - l) : e === 0 ? u = (t.getPixelForTick(1) - l) / 2 : u = (l - t.getPixelForTick(i - 1)) / 2, l += i < e ? u : -u, l < s - a || l > o + a))) return l } function e2(t, e) { ce(t, n => { const r = n.gc, i = r.length / 2; let s; if (i > e) { for (s = 0; s < i; ++s)delete n.data[r[s]]; r.splice(0, i) } }) } function os(t) { return t.drawTicks ? t.tickLength : 0 } function lm(t, e) { if (!t.display) return 0; const n = je(t.font, e), r = et(t.padding); return (xe(t.text) ? t.text.length : 1) * n.lineHeight + r.height } function t2(t, e) { return Ur(t, { scale: e, type: "scale" }) } function n2(t, e, n) { return Ur(t, { tick: n, index: e, type: "tick" }) } function r2(t, e, n) { let r = rf(t); return (n && e !== "right" || !n && e === "right") && (r = JT(r)), r } function i2(t, e, n, r) { const { top: i, left: s, bottom: o, right: a, chart: l } = t, { chartArea: u, scales: c } = l; let d = 0, h, f, g; const m = o - i, y = a - s; if (t.isHorizontal()) { if (f = Qe(r, s, a), se(n)) { const p = Object.keys(n)[0], v = n[p]; g = c[p].getPixelForValue(v) + m - e } else n === "center" ? g = (u.bottom + u.top) / 2 + m - e : g = sm(t, n, e); h = a - s } else { if (se(n)) { const p = Object.keys(n)[0], v = n[p]; f = c[p].getPixelForValue(v) - y + e } else n === "center" ? f = (u.left + u.right) / 2 - y + e : f = sm(t, n, e); g = Qe(r, o, i), d = n === "left" ? -bt : bt } return { titleX: f, titleY: g, maxWidth: h, rotation: d } } class Hr extends Hi { constructor(e) { super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init(e) { this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax) } parse(e, n) { return e } getUserBounds() { let { _userMin: e, _userMax: n, _suggestedMin: r, _suggestedMax: i } = this; return e = mt(e, Number.POSITIVE_INFINITY), n = mt(n, Number.NEGATIVE_INFINITY), r = mt(r, Number.POSITIVE_INFINITY), i = mt(i, Number.NEGATIVE_INFINITY), { min: mt(e, r), max: mt(n, i), minDefined: Ne(e), maxDefined: Ne(n) } } getMinMax(e) { let { min: n, max: r, minDefined: i, maxDefined: s } = this.getUserBounds(), o; if (i && s) return { min: n, max: r }; const a = this.getMatchingVisibleMetas(); for (let l = 0, u = a.length; l < u; ++l)o = a[l].controller.getMinMax(this, e), i || (n = Math.min(n, o.min)), s || (r = Math.max(r, o.max)); return n = s && n > r ? r : n, r = i && n > r ? n : r, { min: mt(n, mt(r, n)), max: mt(r, mt(n, r)) } } getPadding() { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } getTicks() { return this.ticks } getLabels() { const e = this.chart.data; return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [] } getLabelItems(e = this.chart.chartArea) { return this._labelItems || (this._labelItems = this._computeLabelItems(e)) } beforeLayout() { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate() { ge(this.options.beforeUpdate, [this]) } update(e, n, r) { const { beginAtZero: i, grace: s, ticks: o } = this.options, a = o.sampleSize; this.beforeUpdate(), this.maxWidth = e, this.maxHeight = n, this._margins = r = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, r), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + r.left + r.right : this.height + r.top + r.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = IE(this, s, i), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const l = a < this.ticks.length; this._convertTicksToLabels(l ? am(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = qT(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } configure() { let e = this.options.reverse, n, r; this.isHorizontal() ? (n = this.left, r = this.right) : (n = this.top, r = this.bottom, e = !e), this._startPixel = n, this._endPixel = r, this._reversePixels = e, this._length = r - n, this._alignToPixels = this.options.alignToPixels } afterUpdate() { ge(this.options.afterUpdate, [this]) } beforeSetDimensions() { ge(this.options.beforeSetDimensions, [this]) } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } afterSetDimensions() { ge(this.options.afterSetDimensions, [this]) } _callHooks(e) { this.chart.notifyPlugins(e, this.getContext()), ge(this.options[e], [this]) } beforeDataLimits() { this._callHooks("beforeDataLimits") } determineDataLimits() { } afterDataLimits() { this._callHooks("afterDataLimits") } beforeBuildTicks() { this._callHooks("beforeBuildTicks") } buildTicks() { return [] } afterBuildTicks() { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion() { ge(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels(e) { const n = this.options.ticks; let r, i, s; for (r = 0, i = e.length; r < i; r++)s = e[r], s.label = ge(n.callback, [s.value, r, e], this) } afterTickToLabelConversion() { ge(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation() { ge(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation() { const e = this.options, n = e.ticks, r = om(this.ticks.length, e.ticks.maxTicksLimit), i = n.minRotation || 0, s = n.maxRotation; let o = i, a, l, u; if (!this._isVisible() || !n.display || i >= s || r <= 1 || !this.isHorizontal()) { this.labelRotation = i; return } const c = this._getLabelSizes(), d = c.widest.width, h = c.highest.height, f = qt(this.chart.width - d, 0, this.maxWidth); a = e.offset ? this.maxWidth / r : f / (r - 1), d + 6 > a && (a = f / (r - (e.offset ? .5 : 1)), l = this.maxHeight - os(e.grid) - n.padding - lm(e.title, this.chart.options.font), u = Math.sqrt(d * d + h * h), o = tf(Math.min(Math.asin(qt((c.highest.height + 6) / a, -1, 1)), Math.asin(qt(l / u, -1, 1)) - Math.asin(qt(h / u, -1, 1)))), o = Math.max(i, Math.min(s, o))), this.labelRotation = o } afterCalculateLabelRotation() { ge(this.options.afterCalculateLabelRotation, [this]) } afterAutoSkip() { } beforeFit() { ge(this.options.beforeFit, [this]) } fit() { const e = { width: 0, height: 0 }, { chart: n, options: { ticks: r, title: i, grid: s } } = this, o = this._isVisible(), a = this.isHorizontal(); if (o) { const l = lm(i, n.options.font); if (a ? (e.width = this.maxWidth, e.height = os(s) + l) : (e.height = this.maxHeight, e.width = os(s) + l), r.display && this.ticks.length) { const { first: u, last: c, widest: d, highest: h } = this._getLabelSizes(), f = r.padding * 2, g = Wn(this.labelRotation), m = Math.cos(g), y = Math.sin(g); if (a) { const p = r.mirror ? 0 : y * d.width + m * h.height; e.height = Math.min(this.maxHeight, e.height + p + f) } else { const p = r.mirror ? 0 : m * d.width + y * h.height; e.width = Math.min(this.maxWidth, e.width + p + f) } this._calculatePadding(u, c, y, m) } } this._handleMargins(), a ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom) } _calculatePadding(e, n, r, i) { const { ticks: { align: s, padding: o }, position: a } = this.options, l = this.labelRotation !== 0, u = a !== "top" && this.axis === "x"; if (this.isHorizontal()) { const c = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1); let h = 0, f = 0; l ? u ? (h = i * e.width, f = r * n.height) : (h = r * e.height, f = i * n.width) : s === "start" ? f = n.width : s === "end" ? h = e.width : s !== "inner" && (h = e.width / 2, f = n.width / 2), this.paddingLeft = Math.max((h - c + o) * this.width / (this.width - c), 0), this.paddingRight = Math.max((f - d + o) * this.width / (this.width - d), 0) } else { let c = n.height / 2, d = e.height / 2; s === "start" ? (c = 0, d = e.height) : s === "end" && (c = n.height, d = 0), this.paddingTop = c + o, this.paddingBottom = d + o } } _handleMargins() { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } afterFit() { ge(this.options.afterFit, [this]) } isHorizontal() { const { axis: e, position: n } = this.options; return n === "top" || n === "bottom" || e === "x" } isFullSize() { return this.options.fullSize } _convertTicksToLabels(e) { this.beforeTickToLabelConversion(), this.generateTickLabels(e); let n, r; for (n = 0, r = e.length; n < r; n++)fe(e[n].label) && (e.splice(n, 1), r--, n--); this.afterTickToLabelConversion() } _getLabelSizes() { let e = this._labelSizes; if (!e) { const n = this.options.ticks.sampleSize; let r = this.ticks; n < r.length && (r = am(r, n)), this._labelSizes = e = this._computeLabelSizes(r, r.length, this.options.ticks.maxTicksLimit) } return e } _computeLabelSizes(e, n, r) { const { ctx: i, _longestTextCache: s } = this, o = [], a = [], l = Math.floor(n / om(n, r)); let u = 0, c = 0, d, h, f, g, m, y, p, v, b, x, P; for (d = 0; d < n; d += l) { if (g = e[d].label, m = this._resolveTickFontOptions(d), i.font = y = m.string, p = s[y] = s[y] || { data: {}, gc: [] }, v = m.lineHeight, b = x = 0, !fe(g) && !xe(g)) b = hl(i, p.data, p.gc, b, g), x = v; else if (xe(g)) for (h = 0, f = g.length; h < f; ++h)P = g[h], !fe(P) && !xe(P) && (b = hl(i, p.data, p.gc, b, P), x += v); o.push(b), a.push(x), u = Math.max(b, u), c = Math.max(x, c) } e2(s, n); const M = o.indexOf(u), I = a.indexOf(c), C = T => ({ width: o[T] || 0, height: a[T] || 0 }); return { first: C(0), last: C(n - 1), widest: C(M), highest: C(I), widths: o, heights: a } } getLabelForValue(e) { return e } getPixelForValue(e, n) { return NaN } getValueForPixel(e) { } getPixelForTick(e) { const n = this.ticks; return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value) } getPixelForDecimal(e) { this._reversePixels && (e = 1 - e); const n = this._startPixel + e * this._length; return aE(this._alignToPixels ? mr(this.chart, n, 0) : n) } getDecimalForPixel(e) { const n = (e - this._startPixel) / this._length; return this._reversePixels ? 1 - n : n } getBasePixel() { return this.getPixelForValue(this.getBaseValue()) } getBaseValue() { const { min: e, max: n } = this; return e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0 } getContext(e) { const n = this.ticks || []; if (e >= 0 && e < n.length) { const r = n[e]; return r.$context || (r.$context = n2(this.getContext(), e, r)) } return this.$context || (this.$context = t2(this.chart.getContext(), this)) } _tickSize() { const e = this.options.ticks, n = Wn(this.labelRotation), r = Math.abs(Math.cos(n)), i = Math.abs(Math.sin(n)), s = this._getLabelSizes(), o = e.autoSkipPadding || 0, a = s ? s.widest.width + o : 0, l = s ? s.highest.height + o : 0; return this.isHorizontal() ? l * r > a * i ? a / r : l / i : l * i < a * r ? l / r : a / i } _isVisible() { const e = this.options.display; return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems(e) { const n = this.axis, r = this.chart, i = this.options, { grid: s, position: o, border: a } = i, l = s.offset, u = this.isHorizontal(), d = this.ticks.length + (l ? 1 : 0), h = os(s), f = [], g = a.setContext(this.getContext()), m = g.display ? g.width : 0, y = m / 2, p = function (q) { return mr(r, q, m) }; let v, b, x, P, M, I, C, T, L, D, N, F; if (o === "top") v = p(this.bottom), I = this.bottom - h, T = v - y, D = p(e.top) + y, F = e.bottom; else if (o === "bottom") v = p(this.top), D = e.top, F = p(e.bottom) - y, I = v + y, T = this.top + h; else if (o === "left") v = p(this.right), M = this.right - h, C = v - y, L = p(e.left) + y, N = e.right; else if (o === "right") v = p(this.left), L = e.left, N = p(e.right) - y, M = v + y, C = this.left + h; else if (n === "x") { if (o === "center") v = p((e.top + e.bottom) / 2 + .5); else if (se(o)) { const q = Object.keys(o)[0], V = o[q]; v = p(this.chart.scales[q].getPixelForValue(V)) } D = e.top, F = e.bottom, I = v + y, T = I + h } else if (n === "y") { if (o === "center") v = p((e.left + e.right) / 2); else if (se(o)) { const q = Object.keys(o)[0], V = o[q]; v = p(this.chart.scales[q].getPixelForValue(V)) } M = v - y, C = M - h, L = e.left, N = e.right } const B = le(i.ticks.maxTicksLimit, d), H = Math.max(1, Math.ceil(d / B)); for (b = 0; b < d; b += H) { const q = this.getContext(b), V = s.setContext(q), A = a.setContext(q), _ = V.lineWidth, S = V.color, E = A.dash || [], w = A.dashOffset, O = V.tickWidth, j = V.tickColor, $ = V.tickBorderDash || [], z = V.tickBorderDashOffset; x = ZT(this, b, l), x !== void 0 && (P = mr(r, x, _), u ? M = C = L = N = P : I = T = D = F = P, f.push({ tx1: M, ty1: I, tx2: C, ty2: T, x1: L, y1: D, x2: N, y2: F, width: _, color: S, borderDash: E, borderDashOffset: w, tickWidth: O, tickColor: j, tickBorderDash: $, tickBorderDashOffset: z })) } return this._ticksLength = d, this._borderValue = v, f } _computeLabelItems(e) { const n = this.axis, r = this.options, { position: i, ticks: s } = r, o = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: u, padding: c, mirror: d } = s, h = os(r.grid), f = h + c, g = d ? -c : f, m = -Wn(this.labelRotation), y = []; let p, v, b, x, P, M, I, C, T, L, D, N, F = "middle"; if (i === "top") M = this.bottom - g, I = this._getXAxisLabelAlignment(); else if (i === "bottom") M = this.top + g, I = this._getXAxisLabelAlignment(); else if (i === "left") { const H = this._getYAxisLabelAlignment(h); I = H.textAlign, P = H.x } else if (i === "right") { const H = this._getYAxisLabelAlignment(h); I = H.textAlign, P = H.x } else if (n === "x") { if (i === "center") M = (e.top + e.bottom) / 2 + f; else if (se(i)) { const H = Object.keys(i)[0], q = i[H]; M = this.chart.scales[H].getPixelForValue(q) + f } I = this._getXAxisLabelAlignment() } else if (n === "y") { if (i === "center") P = (e.left + e.right) / 2 - f; else if (se(i)) { const H = Object.keys(i)[0], q = i[H]; P = this.chart.scales[H].getPixelForValue(q) } I = this._getYAxisLabelAlignment(h).textAlign } n === "y" && (l === "start" ? F = "top" : l === "end" && (F = "bottom")); const B = this._getLabelSizes(); for (p = 0, v = a.length; p < v; ++p) { b = a[p], x = b.label; const H = s.setContext(this.getContext(p)); C = this.getPixelForTick(p) + s.labelOffset, T = this._resolveTickFontOptions(p), L = T.lineHeight, D = xe(x) ? x.length : 1; const q = D / 2, V = H.color, A = H.textStrokeColor, _ = H.textStrokeWidth; let S = I; o ? (P = C, I === "inner" && (p === v - 1 ? S = this.options.reverse ? "left" : "right" : p === 0 ? S = this.options.reverse ? "right" : "left" : S = "center"), i === "top" ? u === "near" || m !== 0 ? N = -D * L + L / 2 : u === "center" ? N = -B.highest.height / 2 - q * L + L : N = -B.highest.height + L / 2 : u === "near" || m !== 0 ? N = L / 2 : u === "center" ? N = B.highest.height / 2 - q * L : N = B.highest.height - D * L, d && (N *= -1), m !== 0 && !H.showLabelBackdrop && (P += L / 2 * Math.sin(m))) : (M = C, N = (1 - D) * L / 2); let E; if (H.showLabelBackdrop) { const w = et(H.backdropPadding), O = B.heights[p], j = B.widths[p]; let $ = N - w.top, z = 0 - w.left; switch (F) { case "middle": $ -= O / 2; break; case "bottom": $ -= O; break }switch (I) { case "center": z -= j / 2; break; case "right": z -= j; break; case "inner": p === v - 1 ? z -= j : p > 0 && (z -= j / 2); break }E = { left: z, top: $, width: j + w.width, height: O + w.height, color: H.backdropColor } } y.push({ label: x, font: T, textOffset: N, options: { rotation: m, color: V, strokeColor: A, strokeWidth: _, textAlign: S, textBaseline: F, translation: [P, M], backdrop: E } }) } return y } _getXAxisLabelAlignment() { const { position: e, ticks: n } = this.options; if (-Wn(this.labelRotation)) return e === "top" ? "left" : "right"; let i = "center"; return n.align === "start" ? i = "left" : n.align === "end" ? i = "right" : n.align === "inner" && (i = "inner"), i } _getYAxisLabelAlignment(e) { const { position: n, ticks: { crossAlign: r, mirror: i, padding: s } } = this.options, o = this._getLabelSizes(), a = e + s, l = o.widest.width; let u, c; return n === "left" ? i ? (c = this.right + s, r === "near" ? u = "left" : r === "center" ? (u = "center", c += l / 2) : (u = "right", c += l)) : (c = this.right - a, r === "near" ? u = "right" : r === "center" ? (u = "center", c -= l / 2) : (u = "left", c = this.left)) : n === "right" ? i ? (c = this.left + s, r === "near" ? u = "right" : r === "center" ? (u = "center", c -= l / 2) : (u = "left", c -= l)) : (c = this.left + a, r === "near" ? u = "left" : r === "center" ? (u = "center", c += l / 2) : (u = "right", c = this.right)) : u = "right", { textAlign: u, x: c } } _computeLabelArea() { if (this.options.ticks.mirror) return; const e = this.chart, n = this.options.position; if (n === "left" || n === "right") return { top: 0, left: this.left, bottom: e.height, right: this.right }; if (n === "top" || n === "bottom") return { top: this.top, left: 0, bottom: this.bottom, right: e.width } } drawBackground() { const { ctx: e, options: { backgroundColor: n }, left: r, top: i, width: s, height: o } = this; n && (e.save(), e.fillStyle = n, e.fillRect(r, i, s, o), e.restore()) } getLineWidthForValue(e) { const n = this.options.grid; if (!this._isVisible() || !n.display) return 0; const i = this.ticks.findIndex(s => s.value === e); return i >= 0 ? n.setContext(this.getContext(i)).lineWidth : 0 } drawGrid(e) { const n = this.options.grid, r = this.ctx, i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e)); let s, o; const a = (l, u, c) => { !c.width || !c.color || (r.save(), r.lineWidth = c.width, r.strokeStyle = c.color, r.setLineDash(c.borderDash || []), r.lineDashOffset = c.borderDashOffset, r.beginPath(), r.moveTo(l.x, l.y), r.lineTo(u.x, u.y), r.stroke(), r.restore()) }; if (n.display) for (s = 0, o = i.length; s < o; ++s) { const l = i[s]; n.drawOnChartArea && a({ x: l.x1, y: l.y1 }, { x: l.x2, y: l.y2 }, l), n.drawTicks && a({ x: l.tx1, y: l.ty1 }, { x: l.tx2, y: l.ty2 }, { color: l.tickColor, width: l.tickWidth, borderDash: l.tickBorderDash, borderDashOffset: l.tickBorderDashOffset }) } } drawBorder() { const { chart: e, ctx: n, options: { border: r, grid: i } } = this, s = r.setContext(this.getContext()), o = r.display ? s.width : 0; if (!o) return; const a = i.setContext(this.getContext(0)).lineWidth, l = this._borderValue; let u, c, d, h; this.isHorizontal() ? (u = mr(e, this.left, o) - o / 2, c = mr(e, this.right, a) + a / 2, d = h = l) : (d = mr(e, this.top, o) - o / 2, h = mr(e, this.bottom, a) + a / 2, u = c = l), n.save(), n.lineWidth = s.width, n.strokeStyle = s.color, n.beginPath(), n.moveTo(u, d), n.lineTo(c, h), n.stroke(), n.restore() } drawLabels(e) { if (!this.options.ticks.display) return; const r = this.ctx, i = this._computeLabelArea(); i && of(r, i); const s = this.getLabelItems(e); for (const o of s) { const a = o.options, l = o.font, u = o.label, c = o.textOffset; Nr(r, u, 0, c, l, a) } i && af(r) } drawTitle() { const { ctx: e, options: { position: n, title: r, reverse: i } } = this; if (!r.display) return; const s = je(r.font), o = et(r.padding), a = r.align; let l = s.lineHeight / 2; n === "bottom" || n === "center" || se(n) ? (l += o.bottom, xe(r.text) && (l += s.lineHeight * (r.text.length - 1))) : l += o.top; const { titleX: u, titleY: c, maxWidth: d, rotation: h } = i2(this, l, n, a); Nr(e, r.text, 0, 0, s, { color: r.color, maxWidth: d, rotation: h, textAlign: r2(a, n, i), textBaseline: "middle", translation: [u, c] }) } draw(e) { this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e)) } _layers() { const e = this.options, n = e.ticks && e.ticks.z || 0, r = le(e.grid && e.grid.z, -1), i = le(e.border && e.border.z, 0); return !this._isVisible() || this.draw !== Hr.prototype.draw ? [{ z: n, draw: s => { this.draw(s) } }] : [{ z: r, draw: s => { this.drawBackground(), this.drawGrid(s), this.drawTitle() } }, { z: i, draw: () => { this.drawBorder() } }, { z: n, draw: s => { this.drawLabels(s) } }] } getMatchingVisibleMetas(e) { const n = this.chart.getSortedVisibleDatasetMetas(), r = this.axis + "AxisID", i = []; let s, o; for (s = 0, o = n.length; s < o; ++s) { const a = n[s]; a[r] === this.id && (!e || a.type === e) && i.push(a) } return i } _resolveTickFontOptions(e) { const n = this.options.ticks.setContext(this.getContext(e)); return je(n.font) } _maxDigits() { const e = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / e } } class ra { constructor(e, n, r) { this.type = e, this.scope = n, this.override = r, this.items = Object.create(null) } isForType(e) { return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype) } register(e) { const n = Object.getPrototypeOf(e); let r; a2(n) && (r = this.register(n)); const i = this.items, s = e.id, o = this.scope + "." + s; if (!s) throw new Error("class does not have id: " + e); return s in i || (i[s] = e, s2(e, o, r), this.override && Oe.override(e.id, e.overrides)), o } get(e) { return this.items[e] } unregister(e) { const n = this.items, r = e.id, i = this.scope; r in n && delete n[r], i && r in Oe[i] && (delete Oe[i][r], this.override && delete Ar[r]) } } function s2(t, e, n) { const r = no(Object.create(null), [n ? Oe.get(n) : {}, Oe.get(e), t.defaults]); Oe.set(e, r), t.defaultRoutes && o2(e, t.defaultRoutes), t.descriptors && Oe.describe(e, t.descriptors) } function o2(t, e) { Object.keys(e).forEach(n => { const r = n.split("."), i = r.pop(), s = [t].concat(r).join("."), o = e[n].split("."), a = o.pop(), l = o.join("."); Oe.route(s, i, l, a) }) } function a2(t) { return "id" in t && "defaults" in t } class l2 { constructor() { this.controllers = new ra(Ds, "datasets", !0), this.elements = new ra(Hi, "elements"), this.plugins = new ra(Object, "plugins"), this.scales = new ra(Hr, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add(...e) { this._each("register", e) } remove(...e) { this._each("unregister", e) } addControllers(...e) { this._each("register", e, this.controllers) } addElements(...e) { this._each("register", e, this.elements) } addPlugins(...e) { this._each("register", e, this.plugins) } addScales(...e) { this._each("register", e, this.scales) } getController(e) { return this._get(e, this.controllers, "controller") } getElement(e) { return this._get(e, this.elements, "element") } getPlugin(e) { return this._get(e, this.plugins, "plugin") } getScale(e) { return this._get(e, this.scales, "scale") } removeControllers(...e) { this._each("unregister", e, this.controllers) } removeElements(...e) { this._each("unregister", e, this.elements) } removePlugins(...e) { this._each("unregister", e, this.plugins) } removeScales(...e) { this._each("unregister", e, this.scales) } _each(e, n, r) { [...n].forEach(i => { const s = r || this._getRegistryForType(i); r || s.isForType(i) || s === this.plugins && i.id ? this._exec(e, s, i) : ce(i, o => { const a = r || this._getRegistryForType(o); this._exec(e, a, o) }) }) } _exec(e, n, r) { const i = ef(e); ge(r["before" + i], [], r), n[e](r), ge(r["after" + i], [], r) } _getRegistryForType(e) { for (let n = 0; n < this._typedRegistries.length; n++) { const r = this._typedRegistries[n]; if (r.isForType(e)) return r } return this.plugins } _get(e, n, r) { const i = n.get(e); if (i === void 0) throw new Error('"' + e + '" is not a registered ' + r + "."); return i } } var tn = new l2; class u2 { constructor() { this._init = [] } notify(e, n, r, i) { n === "beforeInit" && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install")); const s = i ? this._descriptors(e).filter(i) : this._descriptors(e), o = this._notify(s, e, n, r); return n === "afterDestroy" && (this._notify(s, e, "stop"), this._notify(this._init, e, "uninstall")), o } _notify(e, n, r, i) { i = i || {}; for (const s of e) { const o = s.plugin, a = o[r], l = [n, i, s.options]; if (ge(a, l, o) === !1 && i.cancelable) return !1 } return !0 } invalidate() { fe(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(e) { if (this._cache) return this._cache; const n = this._cache = this._createDescriptors(e); return this._notifyStateChanges(e), n } _createDescriptors(e, n) { const r = e && e.config, i = le(r.options && r.options.plugins, {}), s = c2(r); return i === !1 && !n ? [] : h2(e, s, i, n) } _notifyStateChanges(e) { const n = this._oldCache || [], r = this._cache, i = (s, o) => s.filter(a => !o.some(l => a.plugin.id === l.plugin.id)); this._notify(i(n, r), e, "stop"), this._notify(i(r, n), e, "start") } } function c2(t) { const e = {}, n = [], r = Object.keys(tn.plugins.items); for (let s = 0; s < r.length; s++)n.push(tn.getPlugin(r[s])); const i = t.plugins || []; for (let s = 0; s < i.length; s++) { const o = i[s]; n.indexOf(o) === -1 && (n.push(o), e[o.id] = !0) } return { plugins: n, localIds: e } } function d2(t, e) { return !e && t === !1 ? null : t === !0 ? {} : t } function h2(t, { plugins: e, localIds: n }, r, i) { const s = [], o = t.getContext(); for (const a of e) { const l = a.id, u = d2(r[l], i); u !== null && s.push({ plugin: a, options: f2(t.config, { plugin: a, local: n[l] }, u, o) }) } return s } function f2(t, { plugin: e, local: n }, r, i) { const s = t.pluginScopeKeys(e), o = t.getOptionScopes(r, s); return n && e.defaults && o.push(e.defaults), t.createResolver(o, i, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function Ed(t, e) { const n = Oe.datasets[t] || {}; return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || n.indexAxis || "x" } function p2(t, e) { let n = t; return t === "_index_" ? n = e : t === "_value_" && (n = e === "x" ? "y" : "x"), n } function g2(t, e) { return t === e ? "_index_" : "_value_" } function um(t) { if (t === "x" || t === "y" || t === "r") return t } function m2(t) { if (t === "top" || t === "bottom") return "x"; if (t === "left" || t === "right") return "y" } function Td(t, ...e) { if (um(t)) return t; for (const n of e) { const r = n.axis || m2(n.position) || t.length > 1 && um(t[0].toLowerCase()); if (r) return r } throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`) } function cm(t, e, n) { if (n[e + "AxisID"] === t) return { axis: e } } function v2(t, e) { if (e.data && e.data.datasets) { const n = e.data.datasets.filter(r => r.xAxisID === t || r.yAxisID === t); if (n.length) return cm(t, "x", n[0]) || cm(t, "y", n[0]) } return {} } function y2(t, e) { const n = Ar[t.type] || { scales: {} }, r = e.scales || {}, i = Ed(t.type, e), s = Object.create(null); return Object.keys(r).forEach(o => { const a = r[o]; if (!se(a)) return console.error(`Invalid scale configuration for scale: ${o}`); if (a._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${o}`); const l = Td(o, a, v2(o, t), Oe.scales[a.type]), u = g2(l, i), c = n.scales || {}; s[o] = Rs(Object.create(null), [{ axis: l }, a, c[l], c[u]]) }), t.data.datasets.forEach(o => { const a = o.type || t.type, l = o.indexAxis || Ed(a, e), c = (Ar[a] || {}).scales || {}; Object.keys(c).forEach(d => { const h = p2(d, l), f = o[h + "AxisID"] || h; s[f] = s[f] || Object.create(null), Rs(s[f], [{ axis: h }, r[f], c[d]]) }) }), Object.keys(s).forEach(o => { const a = s[o]; Rs(a, [Oe.scales[a.type], Oe.scale]) }), s } function Kb(t) { const e = t.options || (t.options = {}); e.plugins = le(e.plugins, {}), e.scales = y2(t, e) } function Gb(t) { return t = t || {}, t.datasets = t.datasets || [], t.labels = t.labels || [], t } function b2(t) { return t = t || {}, t.data = Gb(t.data), Kb(t), t } const dm = new Map, Yb = new Set; function ia(t, e) { let n = dm.get(t); return n || (n = e(), dm.set(t, n), Yb.add(n)), n } const as = (t, e, n) => { const r = Li(e, n); r !== void 0 && t.add(r) }; class _2 { constructor(e) { this._config = b2(e), this._scopeCache = new Map, this._resolverCache = new Map } get platform() { return this._config.platform } get type() { return this._config.type } set type(e) { this._config.type = e } get data() { return this._config.data } set data(e) { this._config.data = Gb(e) } get options() { return this._config.options } set options(e) { this._config.options = e } get plugins() { return this._config.plugins } update() { const e = this._config; this.clearCache(), Kb(e) } clearCache() { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(e) { return ia(e, () => [[`datasets.${e}`, ""]]) } datasetAnimationScopeKeys(e, n) { return ia(`${e}.transition.${n}`, () => [[`datasets.${e}.transitions.${n}`, `transitions.${n}`], [`datasets.${e}`, ""]]) } datasetElementScopeKeys(e, n) { return ia(`${e}-${n}`, () => [[`datasets.${e}.elements.${n}`, `datasets.${e}`, `elements.${n}`, ""]]) } pluginScopeKeys(e) { const n = e.id, r = this.type; return ia(`${r}-plugin-${n}`, () => [[`plugins.${n}`, ...e.additionalOptionScopes || []]]) } _cachedScopes(e, n) { const r = this._scopeCache; let i = r.get(e); return (!i || n) && (i = new Map, r.set(e, i)), i } getOptionScopes(e, n, r) { const { options: i, type: s } = this, o = this._cachedScopes(e, r), a = o.get(n); if (a) return a; const l = new Set; n.forEach(c => { e && (l.add(e), c.forEach(d => as(l, e, d))), c.forEach(d => as(l, i, d)), c.forEach(d => as(l, Ar[s] || {}, d)), c.forEach(d => as(l, Oe, d)), c.forEach(d => as(l, Pd, d)) }); const u = Array.from(l); return u.length === 0 && u.push(Object.create(null)), Yb.has(n) && o.set(n, u), u } chartOptionScopes() { const { options: e, type: n } = this; return [e, Ar[n] || {}, Oe.datasets[n] || {}, { type: n }, Oe, Pd] } resolveNamedOptions(e, n, r, i = [""]) { const s = { $shared: !0 }, { resolver: o, subPrefixes: a } = hm(this._resolverCache, e, i); let l = o; if (x2(o, n)) { s.$shared = !1, r = or(r) ? r() : r; const u = this.createResolver(e, r, a); l = Di(o, r, u) } for (const u of n) s[u] = l[u]; return s } createResolver(e, n, r = [""], i) { const { resolver: s } = hm(this._resolverCache, e, r); return se(n) ? Di(s, n, void 0, i) : s } } function hm(t, e, n) { let r = t.get(e); r || (r = new Map, t.set(e, r)); const i = n.join(); let s = r.get(i); return s || (s = { resolver: lf(e, n), subPrefixes: n.filter(a => !a.toLowerCase().includes("hover")) }, r.set(i, s)), s } const w2 = t => se(t) && Object.getOwnPropertyNames(t).some(e => or(t[e])); function x2(t, e) { const { isScriptable: n, isIndexable: r } = Lb(t); for (const i of e) { const s = n(i), o = r(i), a = (o || s) && t[i]; if (s && (or(a) || w2(a)) || o && xe(a)) return !0 } return !1 } var S2 = "4.4.3"; const k2 = ["top", "bottom", "left", "right", "chartArea"]; function fm(t, e) { return t === "top" || t === "bottom" || k2.indexOf(t) === -1 && e === "x" } function pm(t, e) { return function (n, r) { return n[t] === r[t] ? n[e] - r[e] : n[t] - r[t] } } function gm(t) { const e = t.chart, n = e.options.animation; e.notifyPlugins("afterRender"), ge(n && n.onComplete, [t], e) } function C2(t) { const e = t.chart, n = e.options.animation; ge(n && n.onProgress, [t], e) } function Qb(t) { return df() && typeof t == "string" ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t } const Ia = {}, mm = t => { const e = Qb(t); return Object.values(Ia).filter(n => n.canvas === e).pop() }; function O2(t, e, n) { const r = Object.keys(t); for (const i of r) { const s = +i; if (s >= e) { const o = t[i]; delete t[i], (n > 0 || s > e) && (t[s + n] = o) } } } function P2(t, e, n, r) { return !n || t.type === "mouseout" ? null : r ? e : t } function sa(t, e, n) { return t.options.clip ? t[n] : e[n] } function E2(t, e) { const { xScale: n, yScale: r } = t; return n && r ? { left: sa(n, e, "left"), right: sa(n, e, "right"), top: sa(r, e, "top"), bottom: sa(r, e, "bottom") } : e } var Mn; let eu = (Mn = class { static register(...e) { tn.add(...e), vm() } static unregister(...e) { tn.remove(...e), vm() } constructor(e, n) { const r = this.config = new _2(n), i = Qb(e), s = mm(i); if (s) throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas with ID '" + s.canvas.id + "' can be reused."); const o = r.createResolver(r.chartOptionScopes(), this.getContext()); this.platform = new (r.platform || WT(i)), this.platform.updateConfig(r); const a = this.platform.acquireContext(i, o.aspectRatio), l = a && a.canvas, u = l && l.height, c = l && l.width; if (this.id = GP(), this.ctx = a, this.canvas = l, this.width = c, this.height = u, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new u2, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = dE(d => this.update(d), o.resizeDelay || 0), this._dataChanges = [], Ia[this.id] = this, !a || !l) { console.error("Failed to create chart: can't acquire context from the given item"); return } pn.listen(this, "complete", gm), pn.listen(this, "progress", C2), this._initialize(), this.attached && this.update() } get aspectRatio() { const { options: { aspectRatio: e, maintainAspectRatio: n }, width: r, height: i, _aspectRatio: s } = this; return fe(e) ? n && s ? s : i ? r / i : null : e } get data() { return this.config.data } set data(e) { this.config.data = e } get options() { return this._options } set options(e) { this.config.options = e } get registry() { return tn } _initialize() { return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Vg(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear() { return Ng(this.canvas, this.ctx), this } stop() { return pn.stop(this), this } resize(e, n) { pn.running(this) ? this._resizeBeforeDraw = { width: e, height: n } : this._resize(e, n) } _resize(e, n) { const r = this.options, i = this.canvas, s = r.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(i, e, n, s), a = r.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach"; this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, Vg(this, a, !0) && (this.notifyPlugins("resize", { size: o }), ge(r.onResize, [this, o], this), this.attached && this._doResize(l) && this.render()) } ensureScalesHaveIDs() { const n = this.options.scales || {}; ce(n, (r, i) => { r.id = i }) } buildOrUpdateScales() { const e = this.options, n = e.scales, r = this.scales, i = Object.keys(r).reduce((o, a) => (o[a] = !1, o), {}); let s = []; n && (s = s.concat(Object.keys(n).map(o => { const a = n[o], l = Td(o, a), u = l === "r", c = l === "x"; return { options: a, dposition: u ? "chartArea" : c ? "bottom" : "left", dtype: u ? "radialLinear" : c ? "category" : "linear" } }))), ce(s, o => { const a = o.options, l = a.id, u = Td(l, a), c = le(a.type, o.dtype); (a.position === void 0 || fm(a.position, u) !== fm(o.dposition)) && (a.position = o.dposition), i[l] = !0; let d = null; if (l in r && r[l].type === c) d = r[l]; else { const h = tn.getScale(c); d = new h({ id: l, type: c, ctx: this.ctx, chart: this }), r[d.id] = d } d.init(a, e) }), ce(i, (o, a) => { o || delete r[a] }), ce(r, o => { Lt.configure(this, o, o.options), Lt.addBox(this, o) }) } _updateMetasets() { const e = this._metasets, n = this.data.datasets.length, r = e.length; if (e.sort((i, s) => i.index - s.index), r > n) { for (let i = n; i < r; ++i)this._destroyDatasetMeta(i); e.splice(n, r - n) } this._sortedMetasets = e.slice(0).sort(pm("order", "index")) } _removeUnreferencedMetasets() { const { _metasets: e, data: { datasets: n } } = this; e.length > n.length && delete this._stacks, e.forEach((r, i) => { n.filter(s => s === r._dataset).length === 0 && this._destroyDatasetMeta(i) }) } buildOrUpdateControllers() { const e = [], n = this.data.datasets; let r, i; for (this._removeUnreferencedMetasets(), r = 0, i = n.length; r < i; r++) { const s = n[r]; let o = this.getDatasetMeta(r); const a = s.type || this.config.type; if (o.type && o.type !== a && (this._destroyDatasetMeta(r), o = this.getDatasetMeta(r)), o.type = a, o.indexAxis = s.indexAxis || Ed(a, this.options), o.order = s.order || 0, o.index = r, o.label = "" + s.label, o.visible = this.isDatasetVisible(r), o.controller) o.controller.updateIndex(r), o.controller.linkScales(); else { const l = tn.getController(a), { datasetElementType: u, dataElementType: c } = Oe.datasets[a]; Object.assign(l, { dataElementType: tn.getElement(c), datasetElementType: u && tn.getElement(u) }), o.controller = new l(this, r), e.push(o.controller) } } return this._updateMetasets(), e } _resetElements() { ce(this.data.datasets, (e, n) => { this.getDatasetMeta(n).controller.reset() }, this) } reset() { this._resetElements(), this.notifyPlugins("reset") } update(e) { const n = this.config; n.update(); const r = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), i = this._animationsDisabled = !r.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", { mode: e, cancelable: !0 }) === !1) return; const s = this.buildOrUpdateControllers(); this.notifyPlugins("beforeElementsUpdate"); let o = 0; for (let u = 0, c = this.data.datasets.length; u < c; u++) { const { controller: d } = this.getDatasetMeta(u), h = !i && s.indexOf(d) === -1; d.buildOrUpdateElements(h), o = Math.max(+d.getMaxOverflow(), o) } o = this._minPadding = r.layout.autoPadding ? o : 0, this._updateLayout(o), i || ce(s, u => { u.reset() }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", { mode: e }), this._layers.sort(pm("z", "_idx")); const { _active: a, _lastEvent: l } = this; l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render() } _updateScales() { ce(this.scales, e => { Lt.removeBox(this, e) }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings() { const e = this.options, n = new Set(Object.keys(this._listeners)), r = new Set(e.events); (!Eg(n, r) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices() { const { _hiddenIndices: e } = this, n = this._getUniformDataChanges() || []; for (const { method: r, start: i, count: s } of n) { const o = r === "_removeElements" ? -s : s; O2(e, i, o) } } _getUniformDataChanges() { const e = this._dataChanges; if (!e || !e.length) return; this._dataChanges = []; const n = this.data.datasets.length, r = s => new Set(e.filter(o => o[0] === s).map((o, a) => a + "," + o.splice(1).join(","))), i = r(0); for (let s = 1; s < n; s++)if (!Eg(i, r(s))) return; return Array.from(i).map(s => s.split(",")).map(s => ({ method: s[1], start: +s[2], count: +s[3] })) } _updateLayout(e) { if (this.notifyPlugins("beforeLayout", { cancelable: !0 }) === !1) return; Lt.update(this, this.width, this.height, e); const n = this.chartArea, r = n.width <= 0 || n.height <= 0; this._layers = [], ce(this.boxes, i => { r && i.position === "chartArea" || (i.configure && i.configure(), this._layers.push(...i._layers())) }, this), this._layers.forEach((i, s) => { i._idx = s }), this.notifyPlugins("afterLayout") } _updateDatasets(e) { if (this.notifyPlugins("beforeDatasetsUpdate", { mode: e, cancelable: !0 }) !== !1) { for (let n = 0, r = this.data.datasets.length; n < r; ++n)this.getDatasetMeta(n).controller.configure(); for (let n = 0, r = this.data.datasets.length; n < r; ++n)this._updateDataset(n, or(e) ? e({ datasetIndex: n }) : e); this.notifyPlugins("afterDatasetsUpdate", { mode: e }) } } _updateDataset(e, n) { const r = this.getDatasetMeta(e), i = { meta: r, index: e, mode: n, cancelable: !0 }; this.notifyPlugins("beforeDatasetUpdate", i) !== !1 && (r.controller._update(n), i.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", i)) } render() { this.notifyPlugins("beforeRender", { cancelable: !0 }) !== !1 && (pn.has(this) ? this.attached && !pn.running(this) && pn.start(this) : (this.draw(), gm({ chart: this }))) } draw() { let e; if (this._resizeBeforeDraw) { const { width: r, height: i } = this._resizeBeforeDraw; this._resize(r, i), this._resizeBeforeDraw = null } if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", { cancelable: !0 }) === !1) return; const n = this._layers; for (e = 0; e < n.length && n[e].z <= 0; ++e)n[e].draw(this.chartArea); for (this._drawDatasets(); e < n.length; ++e)n[e].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas(e) { const n = this._sortedMetasets, r = []; let i, s; for (i = 0, s = n.length; i < s; ++i) { const o = n[i]; (!e || o.visible) && r.push(o) } return r } getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0) } _drawDatasets() { if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 }) === !1) return; const e = this.getSortedVisibleDatasetMetas(); for (let n = e.length - 1; n >= 0; --n)this._drawDataset(e[n]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset(e) { const n = this.ctx, r = e._clip, i = !r.disabled, s = E2(e, this.chartArea), o = { meta: e, index: e.index, cancelable: !0 }; this.notifyPlugins("beforeDatasetDraw", o) !== !1 && (i && of(n, { left: r.left === !1 ? 0 : s.left - r.left, right: r.right === !1 ? this.width : s.right + r.right, top: r.top === !1 ? 0 : s.top - r.top, bottom: r.bottom === !1 ? this.height : s.bottom + r.bottom }), e.controller.draw(), i && af(n), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o)) } isPointInArea(e) { return fi(e, this.chartArea, this._minPadding) } getElementsAtEventForMode(e, n, r, i) { const s = kT.modes[n]; return typeof s == "function" ? s(this, e, r, i) : [] } getDatasetMeta(e) { const n = this.data.datasets[e], r = this._metasets; let i = r.filter(s => s && s._dataset === n).pop(); return i || (i = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: n && n.order || 0, index: e, _dataset: n, _parsed: [], _sorted: !1 }, r.push(i)), i } getContext() { return this.$context || (this.$context = Ur(null, { chart: this, type: "chart" })) } getVisibleDatasetCount() { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible(e) { const n = this.data.datasets[e]; if (!n) return !1; const r = this.getDatasetMeta(e); return typeof r.hidden == "boolean" ? !r.hidden : !n.hidden } setDatasetVisibility(e, n) { const r = this.getDatasetMeta(e); r.hidden = !n } toggleDataVisibility(e) { this._hiddenIndices[e] = !this._hiddenIndices[e] } getDataVisibility(e) { return !this._hiddenIndices[e] } _updateVisibility(e, n, r) { const i = r ? "show" : "hide", s = this.getDatasetMeta(e), o = s.controller._resolveAnimations(void 0, i); ro(n) ? (s.data[n].hidden = !r, this.update()) : (this.setDatasetVisibility(e, r), o.update(s, { visible: r }), this.update(a => a.datasetIndex === e ? i : void 0)) } hide(e, n) { this._updateVisibility(e, n, !1) } show(e, n) { this._updateVisibility(e, n, !0) } _destroyDatasetMeta(e) { const n = this._metasets[e]; n && n.controller && n.controller._destroy(), delete this._metasets[e] } _stop() { let e, n; for (this.stop(), pn.remove(this), e = 0, n = this.data.datasets.length; e < n; ++e)this._destroyDatasetMeta(e) } destroy() { this.notifyPlugins("beforeDestroy"); const { canvas: e, ctx: n } = this; this._stop(), this.config.clearCache(), e && (this.unbindEvents(), Ng(e, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete Ia[this.id], this.notifyPlugins("afterDestroy") } toBase64Image(...e) { return this.canvas.toDataURL(...e) } bindEvents() { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents() { const e = this._listeners, n = this.platform, r = (s, o) => { n.addEventListener(this, s, o), e[s] = o }, i = (s, o, a) => { s.offsetX = o, s.offsetY = a, this._eventHandler(s) }; ce(this.options.events, s => r(s, i)) } bindResponsiveEvents() { this._responsiveListeners || (this._responsiveListeners = {}); const e = this._responsiveListeners, n = this.platform, r = (l, u) => { n.addEventListener(this, l, u), e[l] = u }, i = (l, u) => { e[l] && (n.removeEventListener(this, l, u), delete e[l]) }, s = (l, u) => { this.canvas && this.resize(l, u) }; let o; const a = () => { i("attach", a), this.attached = !0, this.resize(), r("resize", s), r("detach", o) }; o = () => { this.attached = !1, i("resize", s), this._stop(), this._resize(0, 0), r("attach", a) }, n.isAttached(this.canvas) ? a() : o() } unbindEvents() { ce(this._listeners, (e, n) => { this.platform.removeEventListener(this, n, e) }), this._listeners = {}, ce(this._responsiveListeners, (e, n) => { this.platform.removeEventListener(this, n, e) }), this._responsiveListeners = void 0 } updateHoverStyle(e, n, r) { const i = r ? "set" : "remove"; let s, o, a, l; for (n === "dataset" && (s = this.getDatasetMeta(e[0].datasetIndex), s.controller["_" + i + "DatasetHoverStyle"]()), a = 0, l = e.length; a < l; ++a) { o = e[a]; const u = o && this.getDatasetMeta(o.datasetIndex).controller; u && u[i + "HoverStyle"](o.element, o.datasetIndex, o.index) } } getActiveElements() { return this._active || [] } setActiveElements(e) { const n = this._active || [], r = e.map(({ datasetIndex: s, index: o }) => { const a = this.getDatasetMeta(s); if (!a) throw new Error("No dataset found at index " + s); return { datasetIndex: s, element: a.data[o], index: o } }); !ll(r, n) && (this._active = r, this._lastEvent = null, this._updateHoverStyles(r, n)) } notifyPlugins(e, n, r) { return this._plugins.notify(this, e, n, r) } isPluginEnabled(e) { return this._plugins._cache.filter(n => n.plugin.id === e).length === 1 } _updateHoverStyles(e, n, r) { const i = this.options.hover, s = (l, u) => l.filter(c => !u.some(d => c.datasetIndex === d.datasetIndex && c.index === d.index)), o = s(n, e), a = r ? e : s(e, n); o.length && this.updateHoverStyle(o, i.mode, !1), a.length && i.mode && this.updateHoverStyle(a, i.mode, !0) } _eventHandler(e, n) { const r = { event: e, replay: n, cancelable: !0, inChartArea: this.isPointInArea(e) }, i = o => (o.options.events || this.options.events).includes(e.native.type); if (this.notifyPlugins("beforeEvent", r, i) === !1) return; const s = this._handleEvent(e, n, r.inChartArea); return r.cancelable = !1, this.notifyPlugins("afterEvent", r, i), (s || r.changed) && this.render(), this } _handleEvent(e, n, r) { const { _active: i = [], options: s } = this, o = n, a = this._getActiveElements(e, i, r, o), l = eE(e), u = P2(e, this._lastEvent, r, l); r && (this._lastEvent = null, ge(s.onHover, [e, a, this], this), l && ge(s.onClick, [e, a, this], this)); const c = !ll(a, i); return (c || n) && (this._active = a, this._updateHoverStyles(a, i, n)), this._lastEvent = u, c } _getActiveElements(e, n, r, i) { if (e.type === "mouseout") return []; if (!r) return n; const s = this.options.hover; return this.getElementsAtEventForMode(e, s.mode, s, i) } }, J(Mn, "defaults", Oe), J(Mn, "instances", Ia), J(Mn, "overrides", Ar), J(Mn, "registry", tn), J(Mn, "version", S2), J(Mn, "getChart", mm), Mn); function vm() { return ce(eu.instances, t => t._plugins.invalidate()) } function Xb(t, e) { const { x: n, y: r, base: i, width: s, height: o } = t.getProps(["x", "y", "base", "width", "height"], e); let a, l, u, c, d; return t.horizontal ? (d = o / 2, a = Math.min(n, i), l = Math.max(n, i), u = r - d, c = r + d) : (d = s / 2, a = n - d, l = n + d, u = Math.min(r, i), c = Math.max(r, i)), { left: a, top: u, right: l, bottom: c } } function qn(t, e, n, r) { return t ? 0 : qt(e, n, r) } function T2(t, e, n) { const r = t.options.borderWidth, i = t.borderSkipped, s = Mb(r); return { t: qn(i.top, s.top, 0, n), r: qn(i.right, s.right, 0, e), b: qn(i.bottom, s.bottom, 0, n), l: qn(i.left, s.left, 0, e) } } function I2(t, e, n) { const { enableBorderRadius: r } = t.getProps(["enableBorderRadius"]), i = t.options.borderRadius, s = Tr(i), o = Math.min(e, n), a = t.borderSkipped, l = r || se(i); return { topLeft: qn(!l || a.top || a.left, s.topLeft, 0, o), topRight: qn(!l || a.top || a.right, s.topRight, 0, o), bottomLeft: qn(!l || a.bottom || a.left, s.bottomLeft, 0, o), bottomRight: qn(!l || a.bottom || a.right, s.bottomRight, 0, o) } } function R2(t) { const e = Xb(t), n = e.right - e.left, r = e.bottom - e.top, i = T2(t, n / 2, r / 2), s = I2(t, n / 2, r / 2); return { outer: { x: e.left, y: e.top, w: n, h: r, radius: s }, inner: { x: e.left + i.l, y: e.top + i.t, w: n - i.l - i.r, h: r - i.t - i.b, radius: { topLeft: Math.max(0, s.topLeft - Math.max(i.t, i.l)), topRight: Math.max(0, s.topRight - Math.max(i.t, i.r)), bottomLeft: Math.max(0, s.bottomLeft - Math.max(i.b, i.l)), bottomRight: Math.max(0, s.bottomRight - Math.max(i.b, i.r)) } } } } function dc(t, e, n, r) { const i = e === null, s = n === null, a = t && !(i && s) && Xb(t, r); return a && (i || hi(e, a.left, a.right)) && (s || hi(n, a.top, a.bottom)) } function M2(t) { return t.topLeft || t.topRight || t.bottomLeft || t.bottomRight } function L2(t, e) { t.rect(e.x, e.y, e.w, e.h) } function hc(t, e, n = {}) { const r = t.x !== n.x ? -e : 0, i = t.y !== n.y ? -e : 0, s = (t.x + t.w !== n.x + n.w ? e : 0) - r, o = (t.y + t.h !== n.y + n.h ? e : 0) - i; return { x: t.x + r, y: t.y + i, w: t.w + s, h: t.h + o, radius: t.radius } } class Ra extends Hi { constructor(e) { super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e) } draw(e) { const { inflateAmount: n, options: { borderColor: r, backgroundColor: i } } = this, { inner: s, outer: o } = R2(this), a = M2(o.radius) ? io : L2; e.save(), (o.w !== s.w || o.h !== s.h) && (e.beginPath(), a(e, hc(o, n, s)), e.clip(), a(e, hc(s, -n, o)), e.fillStyle = r, e.fill("evenodd")), e.beginPath(), a(e, hc(s, n)), e.fillStyle = i, e.fill(), e.restore() } inRange(e, n, r) { return dc(this, e, n, r) } inXRange(e, n) { return dc(this, e, null, n) } inYRange(e, n) { return dc(this, null, e, n) } getCenterPoint(e) { const { x: n, y: r, base: i, horizontal: s } = this.getProps(["x", "y", "base", "horizontal"], e); return { x: s ? (n + i) / 2 : n, y: s ? r : (r + i) / 2 } } getRange(e) { return e === "x" ? this.width / 2 : this.height / 2 } } J(Ra, "id", "bar"), J(Ra, "defaults", { borderSkipped: "start", borderWidth: 0, borderRadius: 0, inflateAmount: "auto", pointStyle: void 0 }), J(Ra, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); const ym = (t, e) => { let { boxHeight: n = e, boxWidth: r = e } = t; return t.usePointStyle && (n = Math.min(n, e), r = t.pointStyleWidth || Math.min(r, e)), { boxWidth: r, boxHeight: n, itemHeight: Math.max(e, n) } }, D2 = (t, e) => t !== null && e !== null && t.datasetIndex === e.datasetIndex && t.index === e.index; class bm extends Hi { constructor(e) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, n, r) { this.maxWidth = e, this.maxHeight = n, this._margins = r, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels() { const e = this.options.labels || {}; let n = ge(e.generateLabels, [this.chart], this) || []; e.filter && (n = n.filter(r => e.filter(r, this.chart.data))), e.sort && (n = n.sort((r, i) => e.sort(r, i, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n } fit() { const { options: e, ctx: n } = this; if (!e.display) { this.width = this.height = 0; return } const r = e.labels, i = je(r.font), s = i.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = ym(r, s); let u, c; n.font = i.string, this.isHorizontal() ? (u = this.maxWidth, c = this._fitRows(o, s, a, l) + 10) : (c = this.maxHeight, u = this._fitCols(o, i, a, l) + 10), this.width = Math.min(u, e.maxWidth || this.maxWidth), this.height = Math.min(c, e.maxHeight || this.maxHeight) } _fitRows(e, n, r, i) { const { ctx: s, maxWidth: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], u = this.lineWidths = [0], c = i + a; let d = e; s.textAlign = "left", s.textBaseline = "middle"; let h = -1, f = -c; return this.legendItems.forEach((g, m) => { const y = r + n / 2 + s.measureText(g.text).width; (m === 0 || u[u.length - 1] + y + 2 * a > o) && (d += c, u[u.length - (m > 0 ? 0 : 1)] = 0, f += c, h++), l[m] = { left: 0, top: f, row: h, width: y, height: i }, u[u.length - 1] += y + a }), d } _fitCols(e, n, r, i) { const { ctx: s, maxHeight: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], u = this.columnSizes = [], c = o - e; let d = a, h = 0, f = 0, g = 0, m = 0; return this.legendItems.forEach((y, p) => { const { itemWidth: v, itemHeight: b } = j2(r, n, s, y, i); p > 0 && f + b + 2 * a > c && (d += h + a, u.push({ width: h, height: f }), g += h + a, m++, h = f = 0), l[p] = { left: g, top: f, col: m, width: v, height: b }, h = Math.max(h, v), f += b + a }), d += h, u.push({ width: h, height: f }), d } adjustHitBoxes() { if (!this.options.display) return; const e = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: r, labels: { padding: i }, rtl: s } } = this, o = wi(s, this.left, this.width); if (this.isHorizontal()) { let a = 0, l = Qe(r, this.left + i, this.right - this.lineWidths[a]); for (const u of n) a !== u.row && (a = u.row, l = Qe(r, this.left + i, this.right - this.lineWidths[a])), u.top += this.top + e + i, u.left = o.leftForLtr(o.x(l), u.width), l += u.width + i } else { let a = 0, l = Qe(r, this.top + e + i, this.bottom - this.columnSizes[a].height); for (const u of n) u.col !== a && (a = u.col, l = Qe(r, this.top + e + i, this.bottom - this.columnSizes[a].height)), u.top = l, u.left += this.left + i, u.left = o.leftForLtr(o.x(u.left), u.width), l += u.height + i } } isHorizontal() { return this.options.position === "top" || this.options.position === "bottom" } draw() { if (this.options.display) { const e = this.ctx; of(e, this), this._draw(), af(e) } } _draw() { const { options: e, columnSizes: n, lineWidths: r, ctx: i } = this, { align: s, labels: o } = e, a = Oe.color, l = wi(e.rtl, this.left, this.width), u = je(o.font), { padding: c } = o, d = u.size, h = d / 2; let f; this.drawTitle(), i.textAlign = l.textAlign("left"), i.textBaseline = "middle", i.lineWidth = .5, i.font = u.string; const { boxWidth: g, boxHeight: m, itemHeight: y } = ym(o, d), p = function (M, I, C) { if (isNaN(g) || g <= 0 || isNaN(m) || m < 0) return; i.save(); const T = le(C.lineWidth, 1); if (i.fillStyle = le(C.fillStyle, a), i.lineCap = le(C.lineCap, "butt"), i.lineDashOffset = le(C.lineDashOffset, 0), i.lineJoin = le(C.lineJoin, "miter"), i.lineWidth = T, i.strokeStyle = le(C.strokeStyle, a), i.setLineDash(le(C.lineDash, [])), o.usePointStyle) { const L = { radius: m * Math.SQRT2 / 2, pointStyle: C.pointStyle, rotation: C.rotation, borderWidth: T }, D = l.xPlus(M, g / 2), N = I + h; Ib(i, L, D, N, o.pointStyleWidth && g) } else { const L = I + Math.max((d - m) / 2, 0), D = l.leftForLtr(M, g), N = Tr(C.borderRadius); i.beginPath(), Object.values(N).some(F => F !== 0) ? io(i, { x: D, y: L, w: g, h: m, radius: N }) : i.rect(D, L, g, m), i.fill(), T !== 0 && i.stroke() } i.restore() }, v = function (M, I, C) { Nr(i, C.text, M, I + y / 2, u, { strikethrough: C.hidden, textAlign: l.textAlign(C.textAlign) }) }, b = this.isHorizontal(), x = this._computeTitleHeight(); b ? f = { x: Qe(s, this.left + c, this.right - r[0]), y: this.top + c + x, line: 0 } : f = { x: this.left + c, y: Qe(s, this.top + x + c, this.bottom - n[0].height), line: 0 }, Nb(this.ctx, e.textDirection); const P = y + c; this.legendItems.forEach((M, I) => { i.strokeStyle = M.fontColor, i.fillStyle = M.fontColor; const C = i.measureText(M.text).width, T = l.textAlign(M.textAlign || (M.textAlign = o.textAlign)), L = g + h + C; let D = f.x, N = f.y; l.setWidth(this.width), b ? I > 0 && D + L + c > this.right && (N = f.y += P, f.line++, D = f.x = Qe(s, this.left + c, this.right - r[f.line])) : I > 0 && N + P > this.bottom && (D = f.x = D + n[f.line].width + c, f.line++, N = f.y = Qe(s, this.top + x + c, this.bottom - n[f.line].height)); const F = l.x(D); if (p(F, N, M), D = hE(T, D + g + h, b ? D + L : this.right, e.rtl), v(l.x(D), N, M), b) f.x += L + c; else if (typeof M.text != "string") { const B = u.lineHeight; f.y += Jb(M, B) + c } else f.y += P }), Fb(this.ctx, e.textDirection) } drawTitle() { const e = this.options, n = e.title, r = je(n.font), i = et(n.padding); if (!n.display) return; const s = wi(e.rtl, this.left, this.width), o = this.ctx, a = n.position, l = r.size / 2, u = i.top + l; let c, d = this.left, h = this.width; if (this.isHorizontal()) h = Math.max(...this.lineWidths), c = this.top + u, d = Qe(e.align, d, this.right - h); else { const g = this.columnSizes.reduce((m, y) => Math.max(m, y.height), 0); c = u + Qe(e.align, this.top, this.bottom - g - e.labels.padding - this._computeTitleHeight()) } const f = Qe(a, d, d + h); o.textAlign = s.textAlign(rf(a)), o.textBaseline = "middle", o.strokeStyle = n.color, o.fillStyle = n.color, o.font = r.string, Nr(o, n.text, f, c, r) } _computeTitleHeight() { const e = this.options.title, n = je(e.font), r = et(e.padding); return e.display ? n.lineHeight + r.height : 0 } _getLegendItemAt(e, n) { let r, i, s; if (hi(e, this.left, this.right) && hi(n, this.top, this.bottom)) { for (s = this.legendHitBoxes, r = 0; r < s.length; ++r)if (i = s[r], hi(e, i.left, i.left + i.width) && hi(n, i.top, i.top + i.height)) return this.legendItems[r] } return null } handleEvent(e) { const n = this.options; if (!F2(e.type, n)) return; const r = this._getLegendItemAt(e.x, e.y); if (e.type === "mousemove" || e.type === "mouseout") { const i = this._hoveredItem, s = D2(i, r); i && !s && ge(n.onLeave, [e, i, this], this), this._hoveredItem = r, r && !s && ge(n.onHover, [e, r, this], this) } else r && ge(n.onClick, [e, r, this], this) } } function j2(t, e, n, r, i) { const s = A2(r, t, e, n), o = N2(i, r, e.lineHeight); return { itemWidth: s, itemHeight: o } } function A2(t, e, n, r) { let i = t.text; return i && typeof i != "string" && (i = i.reduce((s, o) => s.length > o.length ? s : o)), e + n.size / 2 + r.measureText(i).width } function N2(t, e, n) { let r = t; return typeof e.text != "string" && (r = Jb(e, n)), r } function Jb(t, e) { const n = t.text ? t.text.length : 0; return e * n } function F2(t, e) { return !!((t === "mousemove" || t === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t === "click" || t === "mouseup")) } var $2 = { id: "legend", _element: bm, start(t, e, n) { const r = t.legend = new bm({ ctx: t.ctx, options: n, chart: t }); Lt.configure(t, r, n), Lt.addBox(t, r) }, stop(t) { Lt.removeBox(t, t.legend), delete t.legend }, beforeUpdate(t, e, n) { const r = t.legend; Lt.configure(t, r, n), r.options = n }, afterUpdate(t) { const e = t.legend; e.buildLabels(), e.adjustHitBoxes() }, afterEvent(t, e) { e.replay || t.legend.handleEvent(e.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(t, e, n) { const r = e.datasetIndex, i = n.chart; i.isDatasetVisible(r) ? (i.hide(r), e.hidden = !0) : (i.show(r), e.hidden = !1) }, onHover: null, onLeave: null, labels: { color: t => t.chart.options.color, boxWidth: 40, padding: 10, generateLabels(t) { const e = t.data.datasets, { labels: { usePointStyle: n, pointStyle: r, textAlign: i, color: s, useBorderRadius: o, borderRadius: a } } = t.legend.options; return t._getSortedDatasetMetas().map(l => { const u = l.controller.getStyle(n ? 0 : void 0), c = et(u.borderWidth); return { text: e[l.index].label, fillStyle: u.backgroundColor, fontColor: s, hidden: !l.visible, lineCap: u.borderCapStyle, lineDash: u.borderDash, lineDashOffset: u.borderDashOffset, lineJoin: u.borderJoinStyle, lineWidth: (c.width + c.height) / 4, strokeStyle: u.borderColor, pointStyle: r || u.pointStyle, rotation: u.rotation, textAlign: i || u.textAlign, borderRadius: o && (a || u.borderRadius), datasetIndex: l.index } }, this) } }, title: { color: t => t.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: t => !t.startsWith("on"), labels: { _scriptable: t => !["generateLabels", "filter", "sort"].includes(t) } } }; class Zb extends Hi { constructor(e) { super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, n) { const r = this.options; if (this.left = 0, this.top = 0, !r.display) { this.width = this.height = this.right = this.bottom = 0; return } this.width = this.right = e, this.height = this.bottom = n; const i = xe(r.text) ? r.text.length : 1; this._padding = et(r.padding); const s = i * je(r.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = s : this.width = s } isHorizontal() { const e = this.options.position; return e === "top" || e === "bottom" } _drawArgs(e) { const { top: n, left: r, bottom: i, right: s, options: o } = this, a = o.align; let l = 0, u, c, d; return this.isHorizontal() ? (c = Qe(a, r, s), d = n + e, u = s - r) : (o.position === "left" ? (c = r + e, d = Qe(a, i, n), l = $e * -.5) : (c = s - e, d = Qe(a, n, i), l = $e * .5), u = i - n), { titleX: c, titleY: d, maxWidth: u, rotation: l } } draw() { const e = this.ctx, n = this.options; if (!n.display) return; const r = je(n.font), s = r.lineHeight / 2 + this._padding.top, { titleX: o, titleY: a, maxWidth: l, rotation: u } = this._drawArgs(s); Nr(e, n.text, 0, 0, r, { color: n.color, maxWidth: l, rotation: u, textAlign: rf(n.align), textBaseline: "middle", translation: [o, a] }) } } function z2(t, e) { const n = new Zb({ ctx: t.ctx, options: e, chart: t }); Lt.configure(t, n, e), Lt.addBox(t, n), t.titleBlock = n } var V2 = { id: "title", _element: Zb, start(t, e, n) { z2(t, n) }, stop(t) { const e = t.titleBlock; Lt.removeBox(t, e), delete t.titleBlock }, beforeUpdate(t, e, n) { const r = t.titleBlock; Lt.configure(t, r, n), r.options = n }, defaults: { align: "center", display: !1, font: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const vs = { average(t) { if (!t.length) return !1; let e, n, r = new Set, i = 0, s = 0; for (e = 0, n = t.length; e < n; ++e) { const a = t[e].element; if (a && a.hasValue()) { const l = a.tooltipPosition(); r.add(l.x), i += l.y, ++s } } return { x: [...r].reduce((a, l) => a + l) / r.size, y: i / s } }, nearest(t, e) { if (!t.length) return !1; let n = e.x, r = e.y, i = Number.POSITIVE_INFINITY, s, o, a; for (s = 0, o = t.length; s < o; ++s) { const l = t[s].element; if (l && l.hasValue()) { const u = l.getCenterPoint(), c = sE(e, u); c < i && (i = c, a = l) } } if (a) { const l = a.tooltipPosition(); n = l.x, r = l.y } return { x: n, y: r } } }; function Zt(t, e) { return e && (xe(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function gn(t) {
  return (typeof t == "string" || t instanceof String) && t.indexOf(`
`) > -1 ? t.split(`
`) : t
} function B2(t, e) { const { element: n, datasetIndex: r, index: i } = e, s = t.getDatasetMeta(r).controller, { label: o, value: a } = s.getLabelAndValue(i); return { chart: t, label: o, parsed: s.getParsed(i), raw: t.data.datasets[r].data[i], formattedValue: a, dataset: s.getDataset(), dataIndex: i, datasetIndex: r, element: n } } function _m(t, e) { const n = t.chart.ctx, { body: r, footer: i, title: s } = t, { boxWidth: o, boxHeight: a } = e, l = je(e.bodyFont), u = je(e.titleFont), c = je(e.footerFont), d = s.length, h = i.length, f = r.length, g = et(e.padding); let m = g.height, y = 0, p = r.reduce((x, P) => x + P.before.length + P.lines.length + P.after.length, 0); if (p += t.beforeBody.length + t.afterBody.length, d && (m += d * u.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), p) { const x = e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight; m += f * x + (p - f) * l.lineHeight + (p - 1) * e.bodySpacing } h && (m += e.footerMarginTop + h * c.lineHeight + (h - 1) * e.footerSpacing); let v = 0; const b = function (x) { y = Math.max(y, n.measureText(x).width + v) }; return n.save(), n.font = u.string, ce(t.title, b), n.font = l.string, ce(t.beforeBody.concat(t.afterBody), b), v = e.displayColors ? o + 2 + e.boxPadding : 0, ce(r, x => { ce(x.before, b), ce(x.lines, b), ce(x.after, b) }), v = 0, n.font = c.string, ce(t.footer, b), n.restore(), y += g.width, { width: y, height: m } } function U2(t, e) { const { y: n, height: r } = e; return n < r / 2 ? "top" : n > t.height - r / 2 ? "bottom" : "center" } function H2(t, e, n, r) { const { x: i, width: s } = r, o = n.caretSize + n.caretPadding; if (t === "left" && i + s + o > e.width || t === "right" && i - s - o < 0) return !0 } function W2(t, e, n, r) { const { x: i, width: s } = n, { width: o, chartArea: { left: a, right: l } } = t; let u = "center"; return r === "center" ? u = i <= (a + l) / 2 ? "left" : "right" : i <= s / 2 ? u = "left" : i >= o - s / 2 && (u = "right"), H2(u, t, e, n) && (u = "center"), u } function wm(t, e, n) { const r = n.yAlign || e.yAlign || U2(t, n); return { xAlign: n.xAlign || e.xAlign || W2(t, e, n, r), yAlign: r } } function q2(t, e) { let { x: n, width: r } = t; return e === "right" ? n -= r : e === "center" && (n -= r / 2), n } function K2(t, e, n) { let { y: r, height: i } = t; return e === "top" ? r += n : e === "bottom" ? r -= i + n : r -= i / 2, r } function xm(t, e, n, r) { const { caretSize: i, caretPadding: s, cornerRadius: o } = t, { xAlign: a, yAlign: l } = n, u = i + s, { topLeft: c, topRight: d, bottomLeft: h, bottomRight: f } = Tr(o); let g = q2(e, a); const m = K2(e, l, u); return l === "center" ? a === "left" ? g += u : a === "right" && (g -= u) : a === "left" ? g -= Math.max(c, h) + i : a === "right" && (g += Math.max(d, f) + i), { x: qt(g, 0, r.width - e.width), y: qt(m, 0, r.height - e.height) } } function oa(t, e, n) { const r = et(n.padding); return e === "center" ? t.x + t.width / 2 : e === "right" ? t.x + t.width - r.right : t.x + r.left } function Sm(t) { return Zt([], gn(t)) } function G2(t, e, n) { return Ur(t, { tooltip: e, tooltipItems: n, type: "tooltip" }) } function km(t, e) { const n = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks; return n ? t.override(n) : t } const e_ = { beforeTitle: fn, title(t) { if (t.length > 0) { const e = t[0], n = e.chart.data.labels, r = n ? n.length : 0; if (this && this.options && this.options.mode === "dataset") return e.dataset.label || ""; if (e.label) return e.label; if (r > 0 && e.dataIndex < r) return n[e.dataIndex] } return "" }, afterTitle: fn, beforeBody: fn, beforeLabel: fn, label(t) { if (this && this.options && this.options.mode === "dataset") return t.label + ": " + t.formattedValue || t.formattedValue; let e = t.dataset.label || ""; e && (e += ": "); const n = t.formattedValue; return fe(n) || (e += n), e }, labelColor(t) { const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { borderColor: n.borderColor, backgroundColor: n.backgroundColor, borderWidth: n.borderWidth, borderDash: n.borderDash, borderDashOffset: n.borderDashOffset, borderRadius: 0 } }, labelTextColor() { return this.options.bodyColor }, labelPointStyle(t) { const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { pointStyle: n.pointStyle, rotation: n.rotation } }, afterLabel: fn, afterBody: fn, beforeFooter: fn, footer: fn, afterFooter: fn }; function at(t, e, n, r) { const i = t[e].call(n, r); return typeof i > "u" ? e_[e].call(n, r) : i } class Id extends Hi { constructor(e) { super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(e) { this.options = e, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations() { const e = this._cachedAnimations; if (e) return e; const n = this.chart, r = this.options.setContext(this.getContext()), i = r.enabled && n.options.animation && r.animations, s = new $b(this.chart, i); return i._cacheable && (this._cachedAnimations = Object.freeze(s)), s } getContext() { return this.$context || (this.$context = G2(this.chart.getContext(), this, this._tooltipItems)) } getTitle(e, n) { const { callbacks: r } = n, i = at(r, "beforeTitle", this, e), s = at(r, "title", this, e), o = at(r, "afterTitle", this, e); let a = []; return a = Zt(a, gn(i)), a = Zt(a, gn(s)), a = Zt(a, gn(o)), a } getBeforeBody(e, n) { return Sm(at(n.callbacks, "beforeBody", this, e)) } getBody(e, n) { const { callbacks: r } = n, i = []; return ce(e, s => { const o = { before: [], lines: [], after: [] }, a = km(r, s); Zt(o.before, gn(at(a, "beforeLabel", this, s))), Zt(o.lines, at(a, "label", this, s)), Zt(o.after, gn(at(a, "afterLabel", this, s))), i.push(o) }), i } getAfterBody(e, n) { return Sm(at(n.callbacks, "afterBody", this, e)) } getFooter(e, n) { const { callbacks: r } = n, i = at(r, "beforeFooter", this, e), s = at(r, "footer", this, e), o = at(r, "afterFooter", this, e); let a = []; return a = Zt(a, gn(i)), a = Zt(a, gn(s)), a = Zt(a, gn(o)), a } _createItems(e) { const n = this._active, r = this.chart.data, i = [], s = [], o = []; let a = [], l, u; for (l = 0, u = n.length; l < u; ++l)a.push(B2(this.chart, n[l])); return e.filter && (a = a.filter((c, d, h) => e.filter(c, d, h, r))), e.itemSort && (a = a.sort((c, d) => e.itemSort(c, d, r))), ce(a, c => { const d = km(e.callbacks, c); i.push(at(d, "labelColor", this, c)), s.push(at(d, "labelPointStyle", this, c)), o.push(at(d, "labelTextColor", this, c)) }), this.labelColors = i, this.labelPointStyles = s, this.labelTextColors = o, this.dataPoints = a, a } update(e, n) { const r = this.options.setContext(this.getContext()), i = this._active; let s, o = []; if (!i.length) this.opacity !== 0 && (s = { opacity: 0 }); else { const a = vs[r.position].call(this, i, this._eventPosition); o = this._createItems(r), this.title = this.getTitle(o, r), this.beforeBody = this.getBeforeBody(o, r), this.body = this.getBody(o, r), this.afterBody = this.getAfterBody(o, r), this.footer = this.getFooter(o, r); const l = this._size = _m(this, r), u = Object.assign({}, a, l), c = wm(this.chart, r, u), d = xm(r, u, c, this.chart); this.xAlign = c.xAlign, this.yAlign = c.yAlign, s = { opacity: 1, x: d.x, y: d.y, width: l.width, height: l.height, caretX: a.x, caretY: a.y } } this._tooltipItems = o, this.$context = void 0, s && this._resolveAnimations().update(this, s), e && r.external && r.external.call(this, { chart: this.chart, tooltip: this, replay: n }) } drawCaret(e, n, r, i) { const s = this.getCaretPosition(e, r, i); n.lineTo(s.x1, s.y1), n.lineTo(s.x2, s.y2), n.lineTo(s.x3, s.y3) } getCaretPosition(e, n, r) { const { xAlign: i, yAlign: s } = this, { caretSize: o, cornerRadius: a } = r, { topLeft: l, topRight: u, bottomLeft: c, bottomRight: d } = Tr(a), { x: h, y: f } = e, { width: g, height: m } = n; let y, p, v, b, x, P; return s === "center" ? (x = f + m / 2, i === "left" ? (y = h, p = y - o, b = x + o, P = x - o) : (y = h + g, p = y + o, b = x - o, P = x + o), v = y) : (i === "left" ? p = h + Math.max(l, c) + o : i === "right" ? p = h + g - Math.max(u, d) - o : p = this.caretX, s === "top" ? (b = f, x = b - o, y = p - o, v = p + o) : (b = f + m, x = b + o, y = p + o, v = p - o), P = b), { x1: y, x2: p, x3: v, y1: b, y2: x, y3: P } } drawTitle(e, n, r) { const i = this.title, s = i.length; let o, a, l; if (s) { const u = wi(r.rtl, this.x, this.width); for (e.x = oa(this, r.titleAlign, r), n.textAlign = u.textAlign(r.titleAlign), n.textBaseline = "middle", o = je(r.titleFont), a = r.titleSpacing, n.fillStyle = r.titleColor, n.font = o.string, l = 0; l < s; ++l)n.fillText(i[l], u.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + a, l + 1 === s && (e.y += r.titleMarginBottom - a) } } _drawColorBox(e, n, r, i, s) { const o = this.labelColors[r], a = this.labelPointStyles[r], { boxHeight: l, boxWidth: u } = s, c = je(s.bodyFont), d = oa(this, "left", s), h = i.x(d), f = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, g = n.y + f; if (s.usePointStyle) { const m = { radius: Math.min(u, l) / 2, pointStyle: a.pointStyle, rotation: a.rotation, borderWidth: 1 }, y = i.leftForLtr(h, u) + u / 2, p = g + l / 2; e.strokeStyle = s.multiKeyBackground, e.fillStyle = s.multiKeyBackground, Fg(e, m, y, p), e.strokeStyle = o.borderColor, e.fillStyle = o.backgroundColor, Fg(e, m, y, p) } else { e.lineWidth = se(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, e.strokeStyle = o.borderColor, e.setLineDash(o.borderDash || []), e.lineDashOffset = o.borderDashOffset || 0; const m = i.leftForLtr(h, u), y = i.leftForLtr(i.xPlus(h, 1), u - 2), p = Tr(o.borderRadius); Object.values(p).some(v => v !== 0) ? (e.beginPath(), e.fillStyle = s.multiKeyBackground, io(e, { x: m, y: g, w: u, h: l, radius: p }), e.fill(), e.stroke(), e.fillStyle = o.backgroundColor, e.beginPath(), io(e, { x: y, y: g + 1, w: u - 2, h: l - 2, radius: p }), e.fill()) : (e.fillStyle = s.multiKeyBackground, e.fillRect(m, g, u, l), e.strokeRect(m, g, u, l), e.fillStyle = o.backgroundColor, e.fillRect(y, g + 1, u - 2, l - 2)) } e.fillStyle = this.labelTextColors[r] } drawBody(e, n, r) { const { body: i } = this, { bodySpacing: s, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: u, boxPadding: c } = r, d = je(r.bodyFont); let h = d.lineHeight, f = 0; const g = wi(r.rtl, this.x, this.width), m = function (C) { n.fillText(C, g.x(e.x + f), e.y + h / 2), e.y += h + s }, y = g.textAlign(o); let p, v, b, x, P, M, I; for (n.textAlign = o, n.textBaseline = "middle", n.font = d.string, e.x = oa(this, y, r), n.fillStyle = r.bodyColor, ce(this.beforeBody, m), f = a && y !== "right" ? o === "center" ? u / 2 + c : u + 2 + c : 0, x = 0, M = i.length; x < M; ++x) { for (p = i[x], v = this.labelTextColors[x], n.fillStyle = v, ce(p.before, m), b = p.lines, a && b.length && (this._drawColorBox(n, e, x, g, r), h = Math.max(d.lineHeight, l)), P = 0, I = b.length; P < I; ++P)m(b[P]), h = d.lineHeight; ce(p.after, m) } f = 0, h = d.lineHeight, ce(this.afterBody, m), e.y -= s } drawFooter(e, n, r) { const i = this.footer, s = i.length; let o, a; if (s) { const l = wi(r.rtl, this.x, this.width); for (e.x = oa(this, r.footerAlign, r), e.y += r.footerMarginTop, n.textAlign = l.textAlign(r.footerAlign), n.textBaseline = "middle", o = je(r.footerFont), n.fillStyle = r.footerColor, n.font = o.string, a = 0; a < s; ++a)n.fillText(i[a], l.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + r.footerSpacing } } drawBackground(e, n, r, i) { const { xAlign: s, yAlign: o } = this, { x: a, y: l } = e, { width: u, height: c } = r, { topLeft: d, topRight: h, bottomLeft: f, bottomRight: g } = Tr(i.cornerRadius); n.fillStyle = i.backgroundColor, n.strokeStyle = i.borderColor, n.lineWidth = i.borderWidth, n.beginPath(), n.moveTo(a + d, l), o === "top" && this.drawCaret(e, n, r, i), n.lineTo(a + u - h, l), n.quadraticCurveTo(a + u, l, a + u, l + h), o === "center" && s === "right" && this.drawCaret(e, n, r, i), n.lineTo(a + u, l + c - g), n.quadraticCurveTo(a + u, l + c, a + u - g, l + c), o === "bottom" && this.drawCaret(e, n, r, i), n.lineTo(a + f, l + c), n.quadraticCurveTo(a, l + c, a, l + c - f), o === "center" && s === "left" && this.drawCaret(e, n, r, i), n.lineTo(a, l + d), n.quadraticCurveTo(a, l, a + d, l), n.closePath(), n.fill(), i.borderWidth > 0 && n.stroke() } _updateAnimationTarget(e) { const n = this.chart, r = this.$animations, i = r && r.x, s = r && r.y; if (i || s) { const o = vs[e.position].call(this, this._active, this._eventPosition); if (!o) return; const a = this._size = _m(this, e), l = Object.assign({}, o, this._size), u = wm(n, e, l), c = xm(e, l, u, n); (i._to !== c.x || s._to !== c.y) && (this.xAlign = u.xAlign, this.yAlign = u.yAlign, this.width = a.width, this.height = a.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, c)) } } _willRender() { return !!this.opacity } draw(e) { const n = this.options.setContext(this.getContext()); let r = this.opacity; if (!r) return; this._updateAnimationTarget(n); const i = { width: this.width, height: this.height }, s = { x: this.x, y: this.y }; r = Math.abs(r) < .001 ? 0 : r; const o = et(n.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length; n.enabled && a && (e.save(), e.globalAlpha = r, this.drawBackground(s, e, i, n), Nb(e, n.textDirection), s.y += o.top, this.drawTitle(s, e, n), this.drawBody(s, e, n), this.drawFooter(s, e, n), Fb(e, n.textDirection), e.restore()) } getActiveElements() { return this._active || [] } setActiveElements(e, n) { const r = this._active, i = e.map(({ datasetIndex: a, index: l }) => { const u = this.chart.getDatasetMeta(a); if (!u) throw new Error("Cannot find a dataset at index " + a); return { datasetIndex: a, element: u.data[l], index: l } }), s = !ll(r, i), o = this._positionChanged(i, n); (s || o) && (this._active = i, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent(e, n, r = !0) { if (n && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const i = this.options, s = this._active || [], o = this._getActiveElements(e, s, n, r), a = this._positionChanged(o, e), l = n || !ll(o, s) || a; return l && (this._active = o, (i.enabled || i.external) && (this._eventPosition = { x: e.x, y: e.y }, this.update(!0, n))), l } _getActiveElements(e, n, r, i) { const s = this.options; if (e.type === "mouseout") return []; if (!i) return n.filter(a => this.chart.data.datasets[a.datasetIndex] && this.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0); const o = this.chart.getElementsAtEventForMode(e, s.mode, s, r); return s.reverse && o.reverse(), o } _positionChanged(e, n) { const { caretX: r, caretY: i, options: s } = this, o = vs[s.position].call(this, e, n); return o !== !1 && (r !== o.x || i !== o.y) } } J(Id, "positioners", vs); var Y2 = { id: "tooltip", _element: Id, positioners: vs, afterInit(t, e, n) { n && (t.tooltip = new Id({ chart: t, options: n })) }, beforeUpdate(t, e, n) { t.tooltip && t.tooltip.initialize(n) }, reset(t, e, n) { t.tooltip && t.tooltip.initialize(n) }, afterDraw(t) { const e = t.tooltip; if (e && e._willRender()) { const n = { tooltip: e }; if (t.notifyPlugins("beforeTooltipDraw", { ...n, cancelable: !0 }) === !1) return; e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", n) } }, afterEvent(t, e) { if (t.tooltip) { const n = e.replay; t.tooltip.handleEvent(e.event, n, e.inChartArea) && (e.changed = !0) } }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (t, e) => e.bodyFont.size, boxWidth: (t, e) => e.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: e_ }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: t => t !== "filter" && t !== "itemSort" && t !== "external", _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] }; const Q2 = (t, e, n, r) => (typeof e == "string" ? (n = t.push(e) - 1, r.unshift({ index: n, label: e })) : isNaN(e) && (n = null), n); function X2(t, e, n, r) { const i = t.indexOf(e); if (i === -1) return Q2(t, e, n, r); const s = t.lastIndexOf(e); return i !== s ? n : i } const J2 = (t, e) => t === null ? null : qt(Math.round(t), 0, e); function Cm(t) { const e = this.getLabels(); return t >= 0 && t < e.length ? e[t] : t } class Rd extends Hr { constructor(e) { super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [] } init(e) { const n = this._addedLabels; if (n.length) { const r = this.getLabels(); for (const { index: i, label: s } of n) r[i] === s && r.splice(i, 1); this._addedLabels = [] } super.init(e) } parse(e, n) { if (fe(e)) return null; const r = this.getLabels(); return n = isFinite(n) && r[n] === e ? n : X2(r, e, le(n, e), this._addedLabels), J2(n, r.length - 1) } determineDataLimits() { const { minDefined: e, maxDefined: n } = this.getUserBounds(); let { min: r, max: i } = this.getMinMax(!0); this.options.bounds === "ticks" && (e || (r = 0), n || (i = this.getLabels().length - 1)), this.min = r, this.max = i } buildTicks() { const e = this.min, n = this.max, r = this.options.offset, i = []; let s = this.getLabels(); s = e === 0 && n === s.length - 1 ? s : s.slice(e, n + 1), this._valueRange = Math.max(s.length - (r ? 0 : 1), 1), this._startValue = this.min - (r ? .5 : 0); for (let o = e; o <= n; o++)i.push({ value: o }); return i } getLabelForValue(e) { return Cm.call(this, e) } configure() { super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } getPixelForValue(e) { return typeof e != "number" && (e = this.parse(e)), e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getPixelForTick(e) { const n = this.ticks; return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value) } getValueForPixel(e) { return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange) } getBasePixel() { return this.bottom } } J(Rd, "id", "category"), J(Rd, "defaults", { ticks: { callback: Cm } }); function Z2(t, e) { const n = [], { bounds: i, step: s, min: o, max: a, precision: l, count: u, maxTicks: c, maxDigits: d, includeBounds: h } = t, f = s || 1, g = c - 1, { min: m, max: y } = e, p = !fe(o), v = !fe(a), b = !fe(u), x = (y - m) / (d + 1); let P = Ig((y - m) / g / f) * f, M, I, C, T; if (P < 1e-14 && !p && !v) return [{ value: m }, { value: y }]; T = Math.ceil(y / P) - Math.floor(m / P), T > g && (P = Ig(T * P / g / f) * f), fe(l) || (M = Math.pow(10, l), P = Math.ceil(P * M) / M), i === "ticks" ? (I = Math.floor(m / P) * P, C = Math.ceil(y / P) * P) : (I = m, C = y), p && v && s && rE((a - o) / s, P / 1e3) ? (T = Math.round(Math.min((a - o) / P, c)), P = (a - o) / T, I = o, C = a) : b ? (I = p ? o : I, C = v ? a : C, T = u - 1, P = (C - I) / T) : (T = (C - I) / P, Pa(T, Math.round(T), P / 1e3) ? T = Math.round(T) : T = Math.ceil(T)); const L = Math.max(Rg(P), Rg(I)); M = Math.pow(10, fe(l) ? L : l), I = Math.round(I * M) / M, C = Math.round(C * M) / M; let D = 0; for (p && (h && I !== o ? (n.push({ value: o }), I < o && D++, Pa(Math.round((I + D * P) * M) / M, o, Om(o, x, t)) && D++) : I < o && D++); D < T; ++D) { const N = Math.round((I + D * P) * M) / M; if (v && N > a) break; n.push({ value: N }) } return v && h && C !== a ? n.length && Pa(n[n.length - 1].value, a, Om(a, x, t)) ? n[n.length - 1].value = a : n.push({ value: a }) : (!v || C === a) && n.push({ value: C }), n } function Om(t, e, { horizontal: n, minRotation: r }) { const i = Wn(r), s = (n ? Math.sin(i) : Math.cos(i)) || .001, o = .75 * e * ("" + t).length; return Math.min(e / s, o) } class gl extends Hr { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse(e, n) { return fe(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e } handleTickRangeOptions() { const { beginAtZero: e } = this.options, { minDefined: n, maxDefined: r } = this.getUserBounds(); let { min: i, max: s } = this; const o = l => i = n ? i : l, a = l => s = r ? s : l; if (e) { const l = rr(i), u = rr(s); l < 0 && u < 0 ? a(0) : l > 0 && u > 0 && o(0) } if (i === s) { let l = s === 0 ? 1 : Math.abs(s * .05); a(s + l), e || o(i - l) } this.min = i, this.max = s } getTickLimit() { const e = this.options.ticks; let { maxTicksLimit: n, stepSize: r } = e, i; return r ? (i = Math.ceil(this.max / r) - Math.floor(this.min / r) + 1, i > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${i} ticks. Limiting to 1000.`), i = 1e3)) : (i = this.computeTickLimit(), n = n || 11), n && (i = Math.min(n, i)), i } computeTickLimit() { return Number.POSITIVE_INFINITY } buildTicks() { const e = this.options, n = e.ticks; let r = this.getTickLimit(); r = Math.max(2, r); const i = { maxTicks: r, bounds: e.bounds, min: e.min, max: e.max, precision: n.precision, step: n.stepSize, count: n.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: n.minRotation || 0, includeBounds: n.includeBounds !== !1 }, s = this._range || this, o = Z2(i, s); return e.bounds === "ticks" && Sb(o, this, "value"), e.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o } configure() { const e = this.ticks; let n = this.min, r = this.max; if (super.configure(), this.options.offset && e.length) { const i = (r - n) / Math.max(e.length - 1, 1) / 2; n -= i, r += i } this._startValue = n, this._endValue = r, this._valueRange = r - n } getLabelForValue(e) { return sf(e, this.chart.options.locale, this.options.ticks.format) } } class Md extends gl { determineDataLimits() { const { min: e, max: n } = this.getMinMax(!0); this.min = Ne(e) ? e : 0, this.max = Ne(n) ? n : 1, this.handleTickRangeOptions() } computeTickLimit() { const e = this.isHorizontal(), n = e ? this.width : this.height, r = Wn(this.options.ticks.minRotation), i = (e ? Math.sin(r) : Math.cos(r)) || .001, s = this._resolveTickFontOptions(0); return Math.ceil(n / Math.min(40, s.lineHeight / i)) } getPixelForValue(e) { return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getValueForPixel(e) { return this._startValue + this.getDecimalForPixel(e) * this._valueRange } } J(Md, "id", "linear"), J(Md, "defaults", { ticks: { callback: Jl.formatters.numeric } }); const oo = t => Math.floor(Hn(t)), yr = (t, e) => Math.pow(10, oo(t) + e); function Pm(t) { return t / Math.pow(10, oo(t)) === 1 } function Em(t, e, n) { const r = Math.pow(10, n), i = Math.floor(t / r); return Math.ceil(e / r) - i } function eI(t, e) { const n = e - t; let r = oo(n); for (; Em(t, e, r) > 10;)r++; for (; Em(t, e, r) < 10;)r--; return Math.min(r, oo(t)) } function tI(t, { min: e, max: n }) { e = mt(t.min, e); const r = [], i = oo(e); let s = eI(e, n), o = s < 0 ? Math.pow(10, Math.abs(s)) : 1; const a = Math.pow(10, s), l = i > s ? Math.pow(10, i) : 0, u = Math.round((e - l) * o) / o, c = Math.floor((e - l) / a / 10) * a * 10; let d = Math.floor((u - c) / Math.pow(10, s)), h = mt(t.min, Math.round((l + c + d * Math.pow(10, s)) * o) / o); for (; h < n;)r.push({ value: h, major: Pm(h), significand: d }), d >= 10 ? d = d < 15 ? 15 : 20 : d++, d >= 20 && (s++, d = 2, o = s >= 0 ? 1 : o), h = Math.round((l + c + d * Math.pow(10, s)) * o) / o; const f = mt(t.max, h); return r.push({ value: f, major: Pm(f), significand: d }), r } class Tm extends Hr { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(e, n) { const r = gl.prototype.parse.apply(this, [e, n]); if (r === 0) { this._zero = !0; return } return Ne(r) && r > 0 ? r : null } determineDataLimits() { const { min: e, max: n } = this.getMinMax(!0); this.min = Ne(e) ? Math.max(0, e) : null, this.max = Ne(n) ? Math.max(0, n) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Ne(this._userMin) && (this.min = e === yr(this.min, 0) ? yr(this.min, -1) : yr(this.min, 0)), this.handleTickRangeOptions() } handleTickRangeOptions() { const { minDefined: e, maxDefined: n } = this.getUserBounds(); let r = this.min, i = this.max; const s = a => r = e ? r : a, o = a => i = n ? i : a; r === i && (r <= 0 ? (s(1), o(10)) : (s(yr(r, -1)), o(yr(i, 1)))), r <= 0 && s(yr(i, -1)), i <= 0 && o(yr(r, 1)), this.min = r, this.max = i } buildTicks() { const e = this.options, n = { min: this._userMin, max: this._userMax }, r = tI(n, this); return e.bounds === "ticks" && Sb(r, this, "value"), e.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r } getLabelForValue(e) { return e === void 0 ? "0" : sf(e, this.chart.options.locale, this.options.ticks.format) } configure() { const e = this.min; super.configure(), this._startValue = Hn(e), this._valueRange = Hn(this.max) - Hn(e) } getPixelForValue(e) { return (e === void 0 || e === 0) && (e = this.min), e === null || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (Hn(e) - this._startValue) / this._valueRange) } getValueForPixel(e) { const n = this.getDecimalForPixel(e); return Math.pow(10, this._startValue + n * this._valueRange) } } J(Tm, "id", "logarithmic"), J(Tm, "defaults", { ticks: { callback: Jl.formatters.logarithmic, major: { enabled: !0 } } }); function Ld(t) { const e = t.ticks; if (e.display && t.display) { const n = et(e.backdropPadding); return le(e.font && e.font.size, Oe.font.size) + n.height } return 0 } function nI(t, e, n) { return n = xe(n) ? n : [n], { w: xE(t, e.string, n), h: n.length * e.lineHeight } } function Im(t, e, n, r, i) { return t === r || t === i ? { start: e - n / 2, end: e + n / 2 } : t < r || t > i ? { start: e - n, end: e } : { start: e, end: e + n } } function rI(t) { const e = { l: t.left + t._padding.left, r: t.right - t._padding.right, t: t.top + t._padding.top, b: t.bottom - t._padding.bottom }, n = Object.assign({}, e), r = [], i = [], s = t._pointLabels.length, o = t.options.pointLabels, a = o.centerPointLabels ? $e / s : 0; for (let l = 0; l < s; l++) { const u = o.setContext(t.getPointLabelContext(l)); i[l] = u.padding; const c = t.getPointPosition(l, t.drawingArea + i[l], a), d = je(u.font), h = nI(t.ctx, d, t._pointLabels[l]); r[l] = h; const f = nn(t.getIndexAngle(l) + a), g = Math.round(tf(f)), m = Im(g, c.x, h.w, 0, 180), y = Im(g, c.y, h.h, 90, 270); iI(n, e, f, m, y) } t.setCenterPoint(e.l - n.l, n.r - e.r, e.t - n.t, n.b - e.b), t._pointLabelItems = aI(t, r, i) } function iI(t, e, n, r, i) { const s = Math.abs(Math.sin(n)), o = Math.abs(Math.cos(n)); let a = 0, l = 0; r.start < e.l ? (a = (e.l - r.start) / s, t.l = Math.min(t.l, e.l - a)) : r.end > e.r && (a = (r.end - e.r) / s, t.r = Math.max(t.r, e.r + a)), i.start < e.t ? (l = (e.t - i.start) / o, t.t = Math.min(t.t, e.t - l)) : i.end > e.b && (l = (i.end - e.b) / o, t.b = Math.max(t.b, e.b + l)) } function sI(t, e, n) { const r = t.drawingArea, { extra: i, additionalAngle: s, padding: o, size: a } = n, l = t.getPointPosition(e, r + i + o, s), u = Math.round(tf(nn(l.angle + bt))), c = cI(l.y, a.h, u), d = lI(u), h = uI(l.x, a.w, d); return { visible: !0, x: l.x, y: c, textAlign: d, left: h, top: c, right: h + a.w, bottom: c + a.h } } function oI(t, e) { if (!e) return !0; const { left: n, top: r, right: i, bottom: s } = t; return !(fi({ x: n, y: r }, e) || fi({ x: n, y: s }, e) || fi({ x: i, y: r }, e) || fi({ x: i, y: s }, e)) } function aI(t, e, n) { const r = [], i = t._pointLabels.length, s = t.options, { centerPointLabels: o, display: a } = s.pointLabels, l = { extra: Ld(s) / 2, additionalAngle: o ? $e / i : 0 }; let u; for (let c = 0; c < i; c++) { l.padding = n[c], l.size = e[c]; const d = sI(t, c, l); r.push(d), a === "auto" && (d.visible = oI(d, u), d.visible && (u = d)) } return r } function lI(t) { return t === 0 || t === 180 ? "center" : t < 180 ? "left" : "right" } function uI(t, e, n) { return n === "right" ? t -= e : n === "center" && (t -= e / 2), t } function cI(t, e, n) { return n === 90 || n === 270 ? t -= e / 2 : (n > 270 || n < 90) && (t -= e), t } function dI(t, e, n) { const { left: r, top: i, right: s, bottom: o } = n, { backdropColor: a } = e; if (!fe(a)) { const l = Tr(e.borderRadius), u = et(e.backdropPadding); t.fillStyle = a; const c = r - u.left, d = i - u.top, h = s - r + u.width, f = o - i + u.height; Object.values(l).some(g => g !== 0) ? (t.beginPath(), io(t, { x: c, y: d, w: h, h: f, radius: l }), t.fill()) : t.fillRect(c, d, h, f) } } function hI(t, e) { const { ctx: n, options: { pointLabels: r } } = t; for (let i = e - 1; i >= 0; i--) { const s = t._pointLabelItems[i]; if (!s.visible) continue; const o = r.setContext(t.getPointLabelContext(i)); dI(n, o, s); const a = je(o.font), { x: l, y: u, textAlign: c } = s; Nr(n, t._pointLabels[i], l, u + a.lineHeight / 2, a, { color: o.color, textAlign: c, textBaseline: "middle" }) } } function t_(t, e, n, r) { const { ctx: i } = t; if (n) i.arc(t.xCenter, t.yCenter, e, 0, un); else { let s = t.getPointPosition(0, e); i.moveTo(s.x, s.y); for (let o = 1; o < r; o++)s = t.getPointPosition(o, e), i.lineTo(s.x, s.y) } } function fI(t, e, n, r, i) { const s = t.ctx, o = e.circular, { color: a, lineWidth: l } = e; !o && !r || !a || !l || n < 0 || (s.save(), s.strokeStyle = a, s.lineWidth = l, s.setLineDash(i.dash), s.lineDashOffset = i.dashOffset, s.beginPath(), t_(t, n, o, r), s.closePath(), s.stroke(), s.restore()) } function pI(t, e, n) { return Ur(t, { label: n, index: e, type: "pointLabel" }) } class aa extends gl { constructor(e) { super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions() { const e = this._padding = et(Ld(this.options) / 2), n = this.width = this.maxWidth - e.width, r = this.height = this.maxHeight - e.height; this.xCenter = Math.floor(this.left + n / 2 + e.left), this.yCenter = Math.floor(this.top + r / 2 + e.top), this.drawingArea = Math.floor(Math.min(n, r) / 2) } determineDataLimits() { const { min: e, max: n } = this.getMinMax(!1); this.min = Ne(e) && !isNaN(e) ? e : 0, this.max = Ne(n) && !isNaN(n) ? n : 0, this.handleTickRangeOptions() } computeTickLimit() { return Math.ceil(this.drawingArea / Ld(this.options)) } generateTickLabels(e) { gl.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((n, r) => { const i = ge(this.options.pointLabels.callback, [n, r], this); return i || i === 0 ? i : "" }).filter((n, r) => this.chart.getDataVisibility(r)) } fit() { const e = this.options; e.display && e.pointLabels.display ? rI(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint(e, n, r, i) { this.xCenter += Math.floor((e - n) / 2), this.yCenter += Math.floor((r - i) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, n, r, i)) } getIndexAngle(e) { const n = un / (this._pointLabels.length || 1), r = this.options.startAngle || 0; return nn(e * n + Wn(r)) } getDistanceFromCenterForValue(e) { if (fe(e)) return NaN; const n = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - e) * n : (e - this.min) * n } getValueForDistanceFromCenter(e) { if (fe(e)) return NaN; const n = e / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - n : this.min + n } getPointLabelContext(e) { const n = this._pointLabels || []; if (e >= 0 && e < n.length) { const r = n[e]; return pI(this.getContext(), e, r) } } getPointPosition(e, n, r = 0) { const i = this.getIndexAngle(e) - bt + r; return { x: Math.cos(i) * n + this.xCenter, y: Math.sin(i) * n + this.yCenter, angle: i } } getPointPositionForValue(e, n) { return this.getPointPosition(e, this.getDistanceFromCenterForValue(n)) } getBasePosition(e) { return this.getPointPositionForValue(e || 0, this.getBaseValue()) } getPointLabelPosition(e) { const { left: n, top: r, right: i, bottom: s } = this._pointLabelItems[e]; return { left: n, top: r, right: i, bottom: s } } drawBackground() { const { backgroundColor: e, grid: { circular: n } } = this.options; if (e) { const r = this.ctx; r.save(), r.beginPath(), t_(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length), r.closePath(), r.fillStyle = e, r.fill(), r.restore() } } drawGrid() { const e = this.ctx, n = this.options, { angleLines: r, grid: i, border: s } = n, o = this._pointLabels.length; let a, l, u; if (n.pointLabels.display && hI(this, o), i.display && this.ticks.forEach((c, d) => { if (d !== 0 || d === 0 && this.min < 0) { l = this.getDistanceFromCenterForValue(c.value); const h = this.getContext(d), f = i.setContext(h), g = s.setContext(h); fI(this, f, l, o, g) } }), r.display) { for (e.save(), a = o - 1; a >= 0; a--) { const c = r.setContext(this.getPointLabelContext(a)), { color: d, lineWidth: h } = c; !h || !d || (e.lineWidth = h, e.strokeStyle = d, e.setLineDash(c.borderDash), e.lineDashOffset = c.borderDashOffset, l = this.getDistanceFromCenterForValue(n.ticks.reverse ? this.min : this.max), u = this.getPointPosition(a, l), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(u.x, u.y), e.stroke()) } e.restore() } } drawBorder() { } drawLabels() { const e = this.ctx, n = this.options, r = n.ticks; if (!r.display) return; const i = this.getIndexAngle(0); let s, o; e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(i), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((a, l) => { if (l === 0 && this.min >= 0 && !n.reverse) return; const u = r.setContext(this.getContext(l)), c = je(u.font); if (s = this.getDistanceFromCenterForValue(this.ticks[l].value), u.showLabelBackdrop) { e.font = c.string, o = e.measureText(a.label).width, e.fillStyle = u.backdropColor; const d = et(u.backdropPadding); e.fillRect(-o / 2 - d.left, -s - c.size / 2 - d.top, o + d.width, c.size + d.height) } Nr(e, a.label, 0, -s, c, { color: u.color, strokeColor: u.textStrokeColor, strokeWidth: u.textStrokeWidth }) }), e.restore() } drawTitle() { } } J(aa, "id", "radialLinear"), J(aa, "defaults", { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: Jl.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback(e) { return e }, padding: 5, centerPointLabels: !1 } }), J(aa, "defaultRoutes", { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }), J(aa, "descriptors", { angleLines: { _fallback: "grid" } }); const tu = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, ut = Object.keys(tu); function Rm(t, e) { return t - e } function Mm(t, e) { if (fe(e)) return null; const n = t._adapter, { parser: r, round: i, isoWeekday: s } = t._parseOpts; let o = e; return typeof r == "function" && (o = r(o)), Ne(o) || (o = typeof r == "string" ? n.parse(o, r) : n.parse(o)), o === null ? null : (i && (o = i === "week" && (dl(s) || s === !0) ? n.startOf(o, "isoWeek", s) : n.startOf(o, i)), +o) } function Lm(t, e, n, r) { const i = ut.length; for (let s = ut.indexOf(t); s < i - 1; ++s) { const o = tu[ut[s]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER; if (o.common && Math.ceil((n - e) / (a * o.size)) <= r) return ut[s] } return ut[i - 1] } function gI(t, e, n, r, i) { for (let s = ut.length - 1; s >= ut.indexOf(n); s--) { const o = ut[s]; if (tu[o].common && t._adapter.diff(i, r, o) >= e - 1) return o } return ut[n ? ut.indexOf(n) : 0] } function mI(t) { for (let e = ut.indexOf(t) + 1, n = ut.length; e < n; ++e)if (tu[ut[e]].common) return ut[e] } function Dm(t, e, n) { if (!n) t[e] = !0; else if (n.length) { const { lo: r, hi: i } = nf(n, e), s = n[r] >= e ? n[r] : n[i]; t[s] = !0 } } function vI(t, e, n, r) { const i = t._adapter, s = +i.startOf(e[0].value, r), o = e[e.length - 1].value; let a, l; for (a = s; a <= o; a = +i.add(a, 1, r))l = n[a], l >= 0 && (e[l].major = !0); return e } function jm(t, e, n) { const r = [], i = {}, s = e.length; let o, a; for (o = 0; o < s; ++o)a = e[o], i[a] = o, r.push({ value: a, major: !1 }); return s === 0 || !n ? r : vI(t, r, i, n) } class ml extends Hr { constructor(e) { super(e), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(e, n = {}) { const r = e.time || (e.time = {}), i = this._adapter = new bT._date(e.adapters.date); i.init(n), Rs(r.displayFormats, i.formats()), this._parseOpts = { parser: r.parser, round: r.round, isoWeekday: r.isoWeekday }, super.init(e), this._normalized = n.normalized } parse(e, n) { return e === void 0 ? null : Mm(this, e) } beforeLayout() { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits() { const e = this.options, n = this._adapter, r = e.time.unit || "day"; let { min: i, max: s, minDefined: o, maxDefined: a } = this.getUserBounds(); function l(u) { !o && !isNaN(u.min) && (i = Math.min(i, u.min)), !a && !isNaN(u.max) && (s = Math.max(s, u.max)) } (!o || !a) && (l(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && l(this.getMinMax(!1))), i = Ne(i) && !isNaN(i) ? i : +n.startOf(Date.now(), r), s = Ne(s) && !isNaN(s) ? s : +n.endOf(Date.now(), r) + 1, this.min = Math.min(i, s - 1), this.max = Math.max(i + 1, s) } _getLabelBounds() { const e = this.getLabelTimestamps(); let n = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY; return e.length && (n = e[0], r = e[e.length - 1]), { min: n, max: r } } buildTicks() { const e = this.options, n = e.time, r = e.ticks, i = r.source === "labels" ? this.getLabelTimestamps() : this._generate(); e.bounds === "ticks" && i.length && (this.min = this._userMin || i[0], this.max = this._userMax || i[i.length - 1]); const s = this.min, o = this.max, a = uE(i, s, o); return this._unit = n.unit || (r.autoSkip ? Lm(n.minUnit, this.min, this.max, this._getLabelCapacity(s)) : gI(this, a.length, n.minUnit, this.min, this.max)), this._majorUnit = !r.major.enabled || this._unit === "year" ? void 0 : mI(this._unit), this.initOffsets(i), e.reverse && a.reverse(), jm(this, a, this._majorUnit) } afterAutoSkip() { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(e => +e.value)) } initOffsets(e = []) { let n = 0, r = 0, i, s; this.options.offset && e.length && (i = this.getDecimalForValue(e[0]), e.length === 1 ? n = 1 - i : n = (this.getDecimalForValue(e[1]) - i) / 2, s = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? r = s : r = (s - this.getDecimalForValue(e[e.length - 2])) / 2); const o = e.length < 3 ? .5 : .25; n = qt(n, 0, o), r = qt(r, 0, o), this._offsets = { start: n, end: r, factor: 1 / (n + 1 + r) } } _generate() { const e = this._adapter, n = this.min, r = this.max, i = this.options, s = i.time, o = s.unit || Lm(s.minUnit, n, r, this._getLabelCapacity(n)), a = le(i.ticks.stepSize, 1), l = o === "week" ? s.isoWeekday : !1, u = dl(l) || l === !0, c = {}; let d = n, h, f; if (u && (d = +e.startOf(d, "isoWeek", l)), d = +e.startOf(d, u ? "day" : o), e.diff(r, n, o) > 1e5 * a) throw new Error(n + " and " + r + " are too far apart with stepSize of " + a + " " + o); const g = i.ticks.source === "data" && this.getDataTimestamps(); for (h = d, f = 0; h < r; h = +e.add(h, a, o), f++)Dm(c, h, g); return (h === r || i.bounds === "ticks" || f === 1) && Dm(c, h, g), Object.keys(c).sort(Rm).map(m => +m) } getLabelForValue(e) { const n = this._adapter, r = this.options.time; return r.tooltipFormat ? n.format(e, r.tooltipFormat) : n.format(e, r.displayFormats.datetime) } format(e, n) { const i = this.options.time.displayFormats, s = this._unit, o = n || i[s]; return this._adapter.format(e, o) } _tickFormatFunction(e, n, r, i) { const s = this.options, o = s.ticks.callback; if (o) return ge(o, [e, n, r], this); const a = s.time.displayFormats, l = this._unit, u = this._majorUnit, c = l && a[l], d = u && a[u], h = r[n], f = u && d && h && h.major; return this._adapter.format(e, i || (f ? d : c)) } generateTickLabels(e) { let n, r, i; for (n = 0, r = e.length; n < r; ++n)i = e[n], i.label = this._tickFormatFunction(i.value, n, e) } getDecimalForValue(e) { return e === null ? NaN : (e - this.min) / (this.max - this.min) } getPixelForValue(e) { const n = this._offsets, r = this.getDecimalForValue(e); return this.getPixelForDecimal((n.start + r) * n.factor) } getValueForPixel(e) { const n = this._offsets, r = this.getDecimalForPixel(e) / n.factor - n.end; return this.min + r * (this.max - this.min) } _getLabelSize(e) { const n = this.options.ticks, r = this.ctx.measureText(e).width, i = Wn(this.isHorizontal() ? n.maxRotation : n.minRotation), s = Math.cos(i), o = Math.sin(i), a = this._resolveTickFontOptions(0).size; return { w: r * s + a * o, h: r * o + a * s } } _getLabelCapacity(e) { const n = this.options.time, r = n.displayFormats, i = r[n.unit] || r.millisecond, s = this._tickFormatFunction(e, 0, jm(this, [e], this._majorUnit), i), o = this._getLabelSize(s), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1; return a > 0 ? a : 1 } getDataTimestamps() { let e = this._cache.data || [], n, r; if (e.length) return e; const i = this.getMatchingVisibleMetas(); if (this._normalized && i.length) return this._cache.data = i[0].controller.getAllParsedValues(this); for (n = 0, r = i.length; n < r; ++n)e = e.concat(i[n].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(e) } getLabelTimestamps() { const e = this._cache.labels || []; let n, r; if (e.length) return e; const i = this.getLabels(); for (n = 0, r = i.length; n < r; ++n)e.push(Mm(this, i[n])); return this._cache.labels = this._normalized ? e : this.normalize(e) } normalize(e) { return Cb(e.sort(Rm)) } } J(ml, "id", "time"), J(ml, "defaults", { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: !1, major: { enabled: !1 } } }); function la(t, e, n) { let r = 0, i = t.length - 1, s, o, a, l; n ? (e >= t[r].pos && e <= t[i].pos && ({ lo: r, hi: i } = Od(t, "pos", e)), { pos: s, time: a } = t[r], { pos: o, time: l } = t[i]) : (e >= t[r].time && e <= t[i].time && ({ lo: r, hi: i } = Od(t, "time", e)), { time: s, pos: a } = t[r], { time: o, pos: l } = t[i]); const u = o - s; return u ? a + (l - a) * (e - s) / u : a } class Am extends ml { constructor(e) { super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets() { const e = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(e); this._minPos = la(n, this.min), this._tableRange = la(n, this.max) - this._minPos, super.initOffsets(e) } buildLookupTable(e) { const { min: n, max: r } = this, i = [], s = []; let o, a, l, u, c; for (o = 0, a = e.length; o < a; ++o)u = e[o], u >= n && u <= r && i.push(u); if (i.length < 2) return [{ time: n, pos: 0 }, { time: r, pos: 1 }]; for (o = 0, a = i.length; o < a; ++o)c = i[o + 1], l = i[o - 1], u = i[o], Math.round((c + l) / 2) !== u && s.push({ time: u, pos: o / (a - 1) }); return s } _generate() { const e = this.min, n = this.max; let r = super.getDataTimestamps(); return (!r.includes(e) || !r.length) && r.splice(0, 0, e), (!r.includes(n) || r.length === 1) && r.push(n), r.sort((i, s) => i - s) } _getTimestampsForTable() { let e = this._cache.all || []; if (e.length) return e; const n = this.getDataTimestamps(), r = this.getLabelTimestamps(); return n.length && r.length ? e = this.normalize(n.concat(r)) : e = n.length ? n : r, e = this._cache.all = e, e } getDecimalForValue(e) { return (la(this._table, e) - this._minPos) / this._tableRange } getValueForPixel(e) { const n = this._offsets, r = this.getDecimalForPixel(e) / n.factor - n.end; return la(this._table, r * this._tableRange + this._minPos, !0) } } J(Am, "id", "timeseries"), J(Am, "defaults", ml.defaults); const n_ = "label"; function Nm(t, e) { typeof t == "function" ? t(e) : t && (t.current = e) } function yI(t, e) { const n = t.options; n && e && Object.assign(n, e) } function r_(t, e) { t.labels = e } function i_(t, e) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : n_; const r = []; t.datasets = e.map(i => { const s = t.datasets.find(o => o[n] === i[n]); return !s || !i.data || r.includes(s) ? { ...i } : (r.push(s), Object.assign(s, i), s) }) } function bI(t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : n_; const n = { labels: [], datasets: [] }; return r_(n, t.labels), i_(n, t.datasets, e), n } function _I(t, e) { const { height: n = 150, width: r = 300, redraw: i = !1, datasetIdKey: s, type: o, data: a, options: l, plugins: u = [], fallbackContent: c, updateMode: d, ...h } = t, f = R.useRef(null), g = R.useRef(), m = () => { f.current && (g.current = new eu(f.current, { type: o, data: bI(a, s), options: l && { ...l }, plugins: u }), Nm(e, g.current)) }, y = () => { Nm(e, null), g.current && (g.current.destroy(), g.current = null) }; return R.useEffect(() => { !i && g.current && l && yI(g.current, l) }, [i, l]), R.useEffect(() => { !i && g.current && r_(g.current.config.data, a.labels) }, [i, a.labels]), R.useEffect(() => { !i && g.current && a.datasets && i_(g.current.config.data, a.datasets, s) }, [i, a.datasets]), R.useEffect(() => { g.current && (i ? (y(), setTimeout(m)) : g.current.update(d)) }, [i, l, a.labels, a.datasets, d]), R.useEffect(() => { g.current && (y(), setTimeout(m)) }, [o]), R.useEffect(() => (m(), () => y()), []), Dt.createElement("canvas", Object.assign({ ref: f, role: "img", height: n, width: r }, h), c) } const wI = R.forwardRef(_I); function xI(t, e) { return eu.register(e), R.forwardRef((n, r) => Dt.createElement(wI, Object.assign({}, n, { ref: r, type: t }))) } const SI = xI("bar", Ea); function Fr(t) { "@babel/helpers - typeof"; return Fr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Fr(t) } function kI(t, e) { if (Fr(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e || "default"); if (Fr(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function s_(t) { var e = kI(t, "string"); return Fr(e) == "symbol" ? e : e + "" } function ys(t, e, n) { return (e = s_(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Fm(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Q(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? Fm(Object(n), !0).forEach(function (r) { ys(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Fm(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function CI(t) { if (Array.isArray(t)) return t } function OI(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, s, o, a = [], l = !0, u = !1; try { if (s = (n = n.call(t)).next, e === 0) { if (Object(n) !== n) return; l = !1 } else for (; !(l = (r = s.call(n)).done) && (a.push(r.value), a.length !== e); l = !0); } catch (c) { u = !0, i = c } finally { try { if (!l && n.return != null && (o = n.return(), Object(o) !== o)) return } finally { if (u) throw i } } return a } } function Dd(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } function o_(t, e) { if (t) { if (typeof t == "string") return Dd(t, e); var n = {}.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Dd(t, e) : void 0 } } function PI() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function xn(t, e) { return CI(t) || OI(t, e) || o_(t, e) || PI() } function EI(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if ({}.hasOwnProperty.call(t, r)) { if (e.includes(r)) continue; n[r] = t[r] } return n } function Tn(t, e) { if (t == null) return {}; var n, r, i = EI(t, e); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(t); for (r = 0; r < s.length; r++)n = s[r], e.includes(n) || {}.propertyIsEnumerable.call(t, n) && (i[n] = t[n]) } return i } var TI = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"]; function II(t) { var e = t.defaultInputValue, n = e === void 0 ? "" : e, r = t.defaultMenuIsOpen, i = r === void 0 ? !1 : r, s = t.defaultValue, o = s === void 0 ? null : s, a = t.inputValue, l = t.menuIsOpen, u = t.onChange, c = t.onInputChange, d = t.onMenuClose, h = t.onMenuOpen, f = t.value, g = Tn(t, TI), m = R.useState(a !== void 0 ? a : n), y = xn(m, 2), p = y[0], v = y[1], b = R.useState(l !== void 0 ? l : i), x = xn(b, 2), P = x[0], M = x[1], I = R.useState(f !== void 0 ? f : o), C = xn(I, 2), T = C[0], L = C[1], D = R.useCallback(function (A, _) { typeof u == "function" && u(A, _), L(A) }, [u]), N = R.useCallback(function (A, _) { var S; typeof c == "function" && (S = c(A, _)), v(S !== void 0 ? S : A) }, [c]), F = R.useCallback(function () { typeof h == "function" && h(), M(!0) }, [h]), B = R.useCallback(function () { typeof d == "function" && d(), M(!1) }, [d]), H = a !== void 0 ? a : p, q = l !== void 0 ? l : P, V = f !== void 0 ? f : T; return Q(Q({}, g), {}, { inputValue: H, menuIsOpen: q, onChange: D, onInputChange: N, onMenuClose: B, onMenuOpen: F, value: V }) } function X() { return X = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, X.apply(null, arguments) } function RI(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function $m(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, s_(r.key), r) } } function MI(t, e, n) { return e && $m(t.prototype, e), n && $m(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function jd(t, e) { return jd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (n, r) { return n.__proto__ = r, n }, jd(t, e) } function LI(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && jd(t, e) } function vl(t) { return vl = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, vl(t) } function a_() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (a_ = function () { return !!t })() } function DI(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function jI(t, e) { if (e && (Fr(e) == "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return DI(t) } function AI(t) { var e = a_(); return function () { var n, r = vl(t); if (e) { var i = vl(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return jI(this, n) } } function NI(t) { if (Array.isArray(t)) return Dd(t) } function FI(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function $I() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function pf(t) { return NI(t) || FI(t) || o_(t) || $I() } var zI = !1; function VI(t) { if (t.sheet) return t.sheet; for (var e = 0; e < document.styleSheets.length; e++)if (document.styleSheets[e].ownerNode === t) return document.styleSheets[e] } function BI(t) { var e = document.createElement("style"); return e.setAttribute("data-emotion", t.key), t.nonce !== void 0 && e.setAttribute("nonce", t.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e } var UI = function () { function t(n) { var r = this; this._insertTag = function (i) { var s; r.tags.length === 0 ? r.insertionPoint ? s = r.insertionPoint.nextSibling : r.prepend ? s = r.container.firstChild : s = r.before : s = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, s), r.tags.push(i) }, this.isSpeedy = n.speedy === void 0 ? !zI : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null } var e = t.prototype; return e.hydrate = function (r) { r.forEach(this._insertTag) }, e.insert = function (r) { this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(BI(this)); var i = this.tags[this.tags.length - 1]; if (this.isSpeedy) { var s = VI(i); try { s.insertRule(r, s.cssRules.length) } catch { } } else i.appendChild(document.createTextNode(r)); this.ctr++ }, e.flush = function () { this.tags.forEach(function (r) { var i; return (i = r.parentNode) == null ? void 0 : i.removeChild(r) }), this.tags = [], this.ctr = 0 }, t }(), Ye = "-ms-", yl = "-moz-", oe = "-webkit-", l_ = "comm", gf = "rule", mf = "decl", HI = "@import", u_ = "@keyframes", WI = "@layer", qI = Math.abs, nu = String.fromCharCode, KI = Object.assign; function GI(t, e) { return Ue(t, 0) ^ 45 ? (((e << 2 ^ Ue(t, 0)) << 2 ^ Ue(t, 1)) << 2 ^ Ue(t, 2)) << 2 ^ Ue(t, 3) : 0 } function c_(t) { return t.trim() } function YI(t, e) { return (t = e.exec(t)) ? t[0] : t } function ae(t, e, n) { return t.replace(e, n) } function Ad(t, e) { return t.indexOf(e) } function Ue(t, e) { return t.charCodeAt(e) | 0 } function ao(t, e, n) { return t.slice(e, n) } function rn(t) { return t.length } function vf(t) { return t.length } function ua(t, e) { return e.push(t), t } function QI(t, e) { return t.map(e).join("") } var ru = 1, ji = 1, d_ = 0, pt = 0, Ie = 0, Wi = ""; function iu(t, e, n, r, i, s, o) { return { value: t, root: e, parent: n, type: r, props: i, children: s, line: ru, column: ji, length: o, return: "" } } function ls(t, e) { return KI(iu("", null, null, "", null, null, 0), t, { length: -t.length }, e) } function XI() { return Ie } function JI() { return Ie = pt > 0 ? Ue(Wi, --pt) : 0, ji--, Ie === 10 && (ji = 1, ru--), Ie } function wt() { return Ie = pt < d_ ? Ue(Wi, pt++) : 0, ji++, Ie === 10 && (ji = 1, ru++), Ie } function cn() { return Ue(Wi, pt) } function Ma() { return pt } function So(t, e) { return ao(Wi, t, e) } function lo(t) { switch (t) { case 0: case 9: case 10: case 13: case 32: return 5; case 33: case 43: case 44: case 47: case 62: case 64: case 126: case 59: case 123: case 125: return 4; case 58: return 3; case 34: case 39: case 40: case 91: return 2; case 41: case 93: return 1 }return 0 } function h_(t) { return ru = ji = 1, d_ = rn(Wi = t), pt = 0, [] } function f_(t) { return Wi = "", t } function La(t) { return c_(So(pt - 1, Nd(t === 91 ? t + 2 : t === 40 ? t + 1 : t))) } function ZI(t) { for (; (Ie = cn()) && Ie < 33;)wt(); return lo(t) > 2 || lo(Ie) > 3 ? "" : " " } function eR(t, e) { for (; --e && wt() && !(Ie < 48 || Ie > 102 || Ie > 57 && Ie < 65 || Ie > 70 && Ie < 97);); return So(t, Ma() + (e < 6 && cn() == 32 && wt() == 32)) } function Nd(t) { for (; wt();)switch (Ie) { case t: return pt; case 34: case 39: t !== 34 && t !== 39 && Nd(Ie); break; case 40: t === 41 && Nd(t); break; case 92: wt(); break }return pt } function tR(t, e) { for (; wt() && t + Ie !== 57;)if (t + Ie === 84 && cn() === 47) break; return "/*" + So(e, pt - 1) + "*" + nu(t === 47 ? t : wt()) } function nR(t) { for (; !lo(cn());)wt(); return So(t, pt) } function rR(t) { return f_(Da("", null, null, null, [""], t = h_(t), 0, [0], t)) } function Da(t, e, n, r, i, s, o, a, l) { for (var u = 0, c = 0, d = o, h = 0, f = 0, g = 0, m = 1, y = 1, p = 1, v = 0, b = "", x = i, P = s, M = r, I = b; y;)switch (g = v, v = wt()) { case 40: if (g != 108 && Ue(I, d - 1) == 58) { Ad(I += ae(La(v), "&", "&\f"), "&\f") != -1 && (p = -1); break } case 34: case 39: case 91: I += La(v); break; case 9: case 10: case 13: case 32: I += ZI(g); break; case 92: I += eR(Ma() - 1, 7); continue; case 47: switch (cn()) { case 42: case 47: ua(iR(tR(wt(), Ma()), e, n), l); break; default: I += "/" }break; case 123 * m: a[u++] = rn(I) * p; case 125 * m: case 59: case 0: switch (v) { case 0: case 125: y = 0; case 59 + c: p == -1 && (I = ae(I, /\f/g, "")), f > 0 && rn(I) - d && ua(f > 32 ? Vm(I + ";", r, n, d - 1) : Vm(ae(I, " ", "") + ";", r, n, d - 2), l); break; case 59: I += ";"; default: if (ua(M = zm(I, e, n, u, c, i, a, b, x = [], P = [], d), s), v === 123) if (c === 0) Da(I, e, M, M, x, s, d, a, P); else switch (h === 99 && Ue(I, 3) === 110 ? 100 : h) { case 100: case 108: case 109: case 115: Da(t, M, M, r && ua(zm(t, M, M, 0, 0, i, a, b, i, x = [], d), P), i, P, d, a, r ? x : P); break; default: Da(I, M, M, M, [""], P, 0, a, P) } }u = c = f = 0, m = p = 1, b = I = "", d = o; break; case 58: d = 1 + rn(I), f = g; default: if (m < 1) { if (v == 123) --m; else if (v == 125 && m++ == 0 && JI() == 125) continue } switch (I += nu(v), v * m) { case 38: p = c > 0 ? 1 : (I += "\f", -1); break; case 44: a[u++] = (rn(I) - 1) * p, p = 1; break; case 64: cn() === 45 && (I += La(wt())), h = cn(), c = d = rn(b = I += nR(Ma())), v++; break; case 45: g === 45 && rn(I) == 2 && (m = 0) } }return s } function zm(t, e, n, r, i, s, o, a, l, u, c) { for (var d = i - 1, h = i === 0 ? s : [""], f = vf(h), g = 0, m = 0, y = 0; g < r; ++g)for (var p = 0, v = ao(t, d + 1, d = qI(m = o[g])), b = t; p < f; ++p)(b = c_(m > 0 ? h[p] + " " + v : ae(v, /&\f/g, h[p]))) && (l[y++] = b); return iu(t, e, n, i === 0 ? gf : a, l, u, c) } function iR(t, e, n) { return iu(t, e, n, l_, nu(XI()), ao(t, 2, -2), 0) } function Vm(t, e, n, r) { return iu(t, e, n, mf, ao(t, 0, r), ao(t, r + 1, -1), r) } function xi(t, e) { for (var n = "", r = vf(t), i = 0; i < r; i++)n += e(t[i], i, t, e) || ""; return n } function sR(t, e, n, r) { switch (t.type) { case WI: if (t.children.length) break; case HI: case mf: return t.return = t.return || t.value; case l_: return ""; case u_: return t.return = t.value + "{" + xi(t.children, r) + "}"; case gf: t.value = t.props.join(",") }return rn(n = xi(t.children, r)) ? t.return = t.value + "{" + n + "}" : "" } function oR(t) { var e = vf(t); return function (n, r, i, s) { for (var o = "", a = 0; a < e; a++)o += t[a](n, r, i, s) || ""; return o } } function aR(t) { return function (e) { e.root || (e = e.return) && t(e) } } function lR(t) { var e = Object.create(null); return function (n) { return e[n] === void 0 && (e[n] = t(n)), e[n] } } var uR = function (e, n, r) { for (var i = 0, s = 0; i = s, s = cn(), i === 38 && s === 12 && (n[r] = 1), !lo(s);)wt(); return So(e, pt) }, cR = function (e, n) { var r = -1, i = 44; do switch (lo(i)) { case 0: i === 38 && cn() === 12 && (n[r] = 1), e[r] += uR(pt - 1, n, r); break; case 2: e[r] += La(i); break; case 4: if (i === 44) { e[++r] = cn() === 58 ? "&\f" : "", n[r] = e[r].length; break } default: e[r] += nu(i) } while (i = wt()); return e }, dR = function (e, n) { return f_(cR(h_(e), n)) }, Bm = new WeakMap, hR = function (e) { if (!(e.type !== "rule" || !e.parent || e.length < 1)) { for (var n = e.value, r = e.parent, i = e.column === r.column && e.line === r.line; r.type !== "rule";)if (r = r.parent, !r) return; if (!(e.props.length === 1 && n.charCodeAt(0) !== 58 && !Bm.get(r)) && !i) { Bm.set(e, !0); for (var s = [], o = dR(n, s), a = r.props, l = 0, u = 0; l < o.length; l++)for (var c = 0; c < a.length; c++, u++)e.props[u] = s[l] ? o[l].replace(/&\f/g, a[c]) : a[c] + " " + o[l] } } }, fR = function (e) { if (e.type === "decl") { var n = e.value; n.charCodeAt(0) === 108 && n.charCodeAt(2) === 98 && (e.return = "", e.value = "") } }; function p_(t, e) { switch (GI(t, e)) { case 5103: return oe + "print-" + t + t; case 5737: case 4201: case 3177: case 3433: case 1641: case 4457: case 2921: case 5572: case 6356: case 5844: case 3191: case 6645: case 3005: case 6391: case 5879: case 5623: case 6135: case 4599: case 4855: case 4215: case 6389: case 5109: case 5365: case 5621: case 3829: return oe + t + t; case 5349: case 4246: case 4810: case 6968: case 2756: return oe + t + yl + t + Ye + t + t; case 6828: case 4268: return oe + t + Ye + t + t; case 6165: return oe + t + Ye + "flex-" + t + t; case 5187: return oe + t + ae(t, /(\w+).+(:[^]+)/, oe + "box-$1$2" + Ye + "flex-$1$2") + t; case 5443: return oe + t + Ye + "flex-item-" + ae(t, /flex-|-self/, "") + t; case 4675: return oe + t + Ye + "flex-line-pack" + ae(t, /align-content|flex-|-self/, "") + t; case 5548: return oe + t + Ye + ae(t, "shrink", "negative") + t; case 5292: return oe + t + Ye + ae(t, "basis", "preferred-size") + t; case 6060: return oe + "box-" + ae(t, "-grow", "") + oe + t + Ye + ae(t, "grow", "positive") + t; case 4554: return oe + ae(t, /([^-])(transform)/g, "$1" + oe + "$2") + t; case 6187: return ae(ae(ae(t, /(zoom-|grab)/, oe + "$1"), /(image-set)/, oe + "$1"), t, "") + t; case 5495: case 3959: return ae(t, /(image-set\([^]*)/, oe + "$1$`$1"); case 4968: return ae(ae(t, /(.+:)(flex-)?(.*)/, oe + "box-pack:$3" + Ye + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + oe + t + t; case 4095: case 3583: case 4068: case 2532: return ae(t, /(.+)-inline(.+)/, oe + "$1$2") + t; case 8116: case 7059: case 5753: case 5535: case 5445: case 5701: case 4933: case 4677: case 5533: case 5789: case 5021: case 4765: if (rn(t) - 1 - e > 6) switch (Ue(t, e + 1)) { case 109: if (Ue(t, e + 4) !== 45) break; case 102: return ae(t, /(.+:)(.+)-([^]+)/, "$1" + oe + "$2-$3$1" + yl + (Ue(t, e + 3) == 108 ? "$3" : "$2-$3")) + t; case 115: return ~Ad(t, "stretch") ? p_(ae(t, "stretch", "fill-available"), e) + t : t }break; case 4949: if (Ue(t, e + 1) !== 115) break; case 6444: switch (Ue(t, rn(t) - 3 - (~Ad(t, "!important") && 10))) { case 107: return ae(t, ":", ":" + oe) + t; case 101: return ae(t, /(.+:)([^;!]+)(;|!.+)?/, "$1" + oe + (Ue(t, 14) === 45 ? "inline-" : "") + "box$3$1" + oe + "$2$3$1" + Ye + "$2box$3") + t }break; case 5936: switch (Ue(t, e + 11)) { case 114: return oe + t + Ye + ae(t, /[svh]\w+-[tblr]{2}/, "tb") + t; case 108: return oe + t + Ye + ae(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t; case 45: return oe + t + Ye + ae(t, /[svh]\w+-[tblr]{2}/, "lr") + t }return oe + t + Ye + t + t }return t } var pR = function (e, n, r, i) { if (e.length > -1 && !e.return) switch (e.type) { case mf: e.return = p_(e.value, e.length); break; case u_: return xi([ls(e, { value: ae(e.value, "@", "@" + oe) })], i); case gf: if (e.length) return QI(e.props, function (s) { switch (YI(s, /(::plac\w+|:read-\w+)/)) { case ":read-only": case ":read-write": return xi([ls(e, { props: [ae(s, /:(read-\w+)/, ":" + yl + "$1")] })], i); case "::placeholder": return xi([ls(e, { props: [ae(s, /:(plac\w+)/, ":" + oe + "input-$1")] }), ls(e, { props: [ae(s, /:(plac\w+)/, ":" + yl + "$1")] }), ls(e, { props: [ae(s, /:(plac\w+)/, Ye + "input-$1")] })], i) }return "" }) } }, gR = [pR], mR = function (e) { var n = e.key; if (n === "css") { var r = document.querySelectorAll("style[data-emotion]:not([data-s])"); Array.prototype.forEach.call(r, function (m) { var y = m.getAttribute("data-emotion"); y.indexOf(" ") !== -1 && (document.head.appendChild(m), m.setAttribute("data-s", "")) }) } var i = e.stylisPlugins || gR, s = {}, o, a = []; o = e.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + n + ' "]'), function (m) { for (var y = m.getAttribute("data-emotion").split(" "), p = 1; p < y.length; p++)s[y[p]] = !0; a.push(m) }); var l, u = [hR, fR]; { var c, d = [sR, aR(function (m) { c.insert(m) })], h = oR(u.concat(i, d)), f = function (y) { return xi(rR(y), h) }; l = function (y, p, v, b) { c = v, f(y ? y + "{" + p.styles + "}" : p.styles), b && (g.inserted[p.name] = !0) } } var g = { key: n, sheet: new UI({ key: n, container: o, nonce: e.nonce, speedy: e.speedy, prepend: e.prepend, insertionPoint: e.insertionPoint }), nonce: e.nonce, inserted: s, registered: {}, insert: l }; return g.sheet.hydrate(a), g }, g_ = { exports: {} }, he = {};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ze = typeof Symbol == "function" && Symbol.for, yf = ze ? Symbol.for("react.element") : 60103, bf = ze ? Symbol.for("react.portal") : 60106, su = ze ? Symbol.for("react.fragment") : 60107, ou = ze ? Symbol.for("react.strict_mode") : 60108, au = ze ? Symbol.for("react.profiler") : 60114, lu = ze ? Symbol.for("react.provider") : 60109, uu = ze ? Symbol.for("react.context") : 60110, _f = ze ? Symbol.for("react.async_mode") : 60111, cu = ze ? Symbol.for("react.concurrent_mode") : 60111, du = ze ? Symbol.for("react.forward_ref") : 60112, hu = ze ? Symbol.for("react.suspense") : 60113, vR = ze ? Symbol.for("react.suspense_list") : 60120, fu = ze ? Symbol.for("react.memo") : 60115, pu = ze ? Symbol.for("react.lazy") : 60116, yR = ze ? Symbol.for("react.block") : 60121, bR = ze ? Symbol.for("react.fundamental") : 60117, _R = ze ? Symbol.for("react.responder") : 60118, wR = ze ? Symbol.for("react.scope") : 60119; function Ct(t) { if (typeof t == "object" && t !== null) { var e = t.$$typeof; switch (e) { case yf: switch (t = t.type, t) { case _f: case cu: case su: case au: case ou: case hu: return t; default: switch (t = t && t.$$typeof, t) { case uu: case du: case pu: case fu: case lu: return t; default: return e } }case bf: return e } } } function m_(t) { return Ct(t) === cu } he.AsyncMode = _f; he.ConcurrentMode = cu; he.ContextConsumer = uu; he.ContextProvider = lu; he.Element = yf; he.ForwardRef = du; he.Fragment = su; he.Lazy = pu; he.Memo = fu; he.Portal = bf; he.Profiler = au; he.StrictMode = ou; he.Suspense = hu; he.isAsyncMode = function (t) { return m_(t) || Ct(t) === _f }; he.isConcurrentMode = m_; he.isContextConsumer = function (t) { return Ct(t) === uu }; he.isContextProvider = function (t) { return Ct(t) === lu }; he.isElement = function (t) { return typeof t == "object" && t !== null && t.$$typeof === yf }; he.isForwardRef = function (t) { return Ct(t) === du }; he.isFragment = function (t) { return Ct(t) === su }; he.isLazy = function (t) { return Ct(t) === pu }; he.isMemo = function (t) { return Ct(t) === fu }; he.isPortal = function (t) { return Ct(t) === bf }; he.isProfiler = function (t) { return Ct(t) === au }; he.isStrictMode = function (t) { return Ct(t) === ou }; he.isSuspense = function (t) { return Ct(t) === hu }; he.isValidElementType = function (t) { return typeof t == "string" || typeof t == "function" || t === su || t === cu || t === au || t === ou || t === hu || t === vR || typeof t == "object" && t !== null && (t.$$typeof === pu || t.$$typeof === fu || t.$$typeof === lu || t.$$typeof === uu || t.$$typeof === du || t.$$typeof === bR || t.$$typeof === _R || t.$$typeof === wR || t.$$typeof === yR) }; he.typeOf = Ct; g_.exports = he; var xR = g_.exports, v_ = xR, SR = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, kR = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, y_ = {}; y_[v_.ForwardRef] = SR; y_[v_.Memo] = kR; var CR = !0; function OR(t, e, n) { var r = ""; return n.split(" ").forEach(function (i) { t[i] !== void 0 ? e.push(t[i] + ";") : r += i + " " }), r } var b_ = function (e, n, r) { var i = e.key + "-" + n.name; (r === !1 || CR === !1) && e.registered[i] === void 0 && (e.registered[i] = n.styles) }, PR = function (e, n, r) { b_(e, n, r); var i = e.key + "-" + n.name; if (e.inserted[n.name] === void 0) { var s = n; do e.insert(n === s ? "." + i : "", s, e.sheet, !0), s = s.next; while (s !== void 0) } }; function ER(t) { for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4)n = t.charCodeAt(r) & 255 | (t.charCodeAt(++r) & 255) << 8 | (t.charCodeAt(++r) & 255) << 16 | (t.charCodeAt(++r) & 255) << 24, n = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= n >>> 24, e = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16); switch (i) { case 3: e ^= (t.charCodeAt(r + 2) & 255) << 16; case 2: e ^= (t.charCodeAt(r + 1) & 255) << 8; case 1: e ^= t.charCodeAt(r) & 255, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16) }return e ^= e >>> 13, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36) } var TR = { animationIterationCount: 1, aspectRatio: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 }, IR = !1, RR = /[A-Z]|^ms/g, MR = /_EMO_([^_]+?)_([^]*?)_EMO_/g, __ = function (e) { return e.charCodeAt(1) === 45 }, Um = function (e) { return e != null && typeof e != "boolean" }, fc = lR(function (t) { return __(t) ? t : t.replace(RR, "-$&").toLowerCase() }), Hm = function (e, n) { switch (e) { case "animation": case "animationName": if (typeof n == "string") return n.replace(MR, function (r, i, s) { return sn = { name: i, styles: s, next: sn }, i }) }return TR[e] !== 1 && !__(e) && typeof n == "number" && n !== 0 ? n + "px" : n }, LR = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform."; function uo(t, e, n) { if (n == null) return ""; var r = n; if (r.__emotion_styles !== void 0) return r; switch (typeof n) { case "boolean": return ""; case "object": { var i = n; if (i.anim === 1) return sn = { name: i.name, styles: i.styles, next: sn }, i.name; var s = n; if (s.styles !== void 0) { var o = s.next; if (o !== void 0) for (; o !== void 0;)sn = { name: o.name, styles: o.styles, next: sn }, o = o.next; var a = s.styles + ";"; return a } return DR(t, e, n) } case "function": { if (t !== void 0) { var l = sn, u = n(t); return sn = l, uo(t, e, u) } break } }var c = n; return c } function DR(t, e, n) { var r = ""; if (Array.isArray(n)) for (var i = 0; i < n.length; i++)r += uo(t, e, n[i]) + ";"; else for (var s in n) { var o = n[s]; if (typeof o != "object") { var a = o; Um(a) && (r += fc(s) + ":" + Hm(s, a) + ";") } else { if (s === "NO_COMPONENT_SELECTOR" && IR) throw new Error(LR); if (Array.isArray(o) && typeof o[0] == "string" && e == null) for (var l = 0; l < o.length; l++)Um(o[l]) && (r += fc(s) + ":" + Hm(s, o[l]) + ";"); else { var u = uo(t, e, o); switch (s) { case "animation": case "animationName": { r += fc(s) + ":" + u + ";"; break } default: r += s + "{" + u + "}" } } } } return r } var Wm = /label:\s*([^\s;\n{]+)\s*(;|$)/g, sn; function w_(t, e, n) { if (t.length === 1 && typeof t[0] == "object" && t[0] !== null && t[0].styles !== void 0) return t[0]; var r = !0, i = ""; sn = void 0; var s = t[0]; if (s == null || s.raw === void 0) r = !1, i += uo(n, e, s); else { var o = s; i += o[0] } for (var a = 1; a < t.length; a++)if (i += uo(n, e, t[a]), r) { var l = s; i += l[a] } Wm.lastIndex = 0; for (var u = "", c; (c = Wm.exec(i)) !== null;)u += "-" + c[1]; var d = ER(i) + u; return { name: d, styles: i, next: sn } } var jR = function (e) { return e() }, AR = wc.useInsertionEffect ? wc.useInsertionEffect : !1, NR = AR || jR, FR = !1, x_ = R.createContext(typeof HTMLElement < "u" ? mR({ key: "css" }) : null); x_.Provider; var $R = function (e) { return R.forwardRef(function (n, r) { var i = R.useContext(x_); return e(n, i, r) }) }, zR = R.createContext({}), wf = {}.hasOwnProperty, Fd = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", VR = function (e, n) { var r = {}; for (var i in n) wf.call(n, i) && (r[i] = n[i]); return r[Fd] = e, r }, BR = function (e) { var n = e.cache, r = e.serialized, i = e.isStringTag; return b_(n, r, i), NR(function () { return PR(n, r, i) }), null }, UR = $R(function (t, e, n) { var r = t.css; typeof r == "string" && e.registered[r] !== void 0 && (r = e.registered[r]); var i = t[Fd], s = [r], o = ""; typeof t.className == "string" ? o = OR(e.registered, s, t.className) : t.className != null && (o = t.className + " "); var a = w_(s, void 0, R.useContext(zR)); o += e.key + "-" + a.name; var l = {}; for (var u in t) wf.call(t, u) && u !== "css" && u !== Fd && !FR && (l[u] = t[u]); return l.className = o, n && (l.ref = n), R.createElement(R.Fragment, null, R.createElement(BR, { cache: e, serialized: a, isStringTag: typeof i == "string" }), R.createElement(i, l)) }), HR = UR, Y = function (e, n) { var r = arguments; if (n == null || !wf.call(n, "css")) return R.createElement.apply(void 0, r); var i = r.length, s = new Array(i); s[0] = HR, s[1] = VR(e, n); for (var o = 2; o < i; o++)s[o] = r[o]; return R.createElement.apply(null, s) }; function xf() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return w_(e) } var WR = function () { var e = xf.apply(void 0, arguments), n = "animation-" + e.name; return { name: n, styles: "@keyframes " + n + "{" + e.styles + "}", anim: 1, toString: function () { return "_EMO_" + this.name + "_" + this.styles + "_EMO_" } } }; function qR(t, e) { return e || (e = t.slice(0)), Object.freeze(Object.defineProperties(t, { raw: { value: Object.freeze(e) } })) } const KR = Math.min, GR = Math.max, bl = Math.round, ca = Math.floor, _l = t => ({ x: t, y: t }); function YR(t) { const { x: e, y: n, width: r, height: i } = t; return { width: r, height: i, top: n, left: e, right: e + r, bottom: n + i, x: e, y: n } } function S_(t) { return C_(t) ? (t.nodeName || "").toLowerCase() : "#document" } function Pn(t) { var e; return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window } function k_(t) { var e; return (e = (C_(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement } function C_(t) { return t instanceof Node || t instanceof Pn(t).Node } function QR(t) { return t instanceof Element || t instanceof Pn(t).Element } function Sf(t) { return t instanceof HTMLElement || t instanceof Pn(t).HTMLElement } function qm(t) { return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Pn(t).ShadowRoot } function O_(t) { const { overflow: e, overflowX: n, overflowY: r, display: i } = kf(t); return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(i) } function XR() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } function JR(t) { return ["html", "body", "#document"].includes(S_(t)) } function kf(t) { return Pn(t).getComputedStyle(t) } function ZR(t) { if (S_(t) === "html") return t; const e = t.assignedSlot || t.parentNode || qm(t) && t.host || k_(t); return qm(e) ? e.host : e } function P_(t) { const e = ZR(t); return JR(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Sf(e) && O_(e) ? e : P_(e) } function wl(t, e, n) { var r; e === void 0 && (e = []), n === void 0 && (n = !0); const i = P_(t), s = i === ((r = t.ownerDocument) == null ? void 0 : r.body), o = Pn(i); if (s) { const a = $d(o); return e.concat(o, o.visualViewport || [], O_(i) ? i : [], a && n ? wl(a) : []) } return e.concat(i, wl(i, [], n)) } function $d(t) { return Object.getPrototypeOf(t.parent) ? t.frameElement : null } function eM(t) { const e = kf(t); let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0; const i = Sf(t), s = i ? t.offsetWidth : n, o = i ? t.offsetHeight : r, a = bl(n) !== s || bl(r) !== o; return a && (n = s, r = o), { width: n, height: r, $: a } } function Cf(t) { return QR(t) ? t : t.contextElement } function Km(t) { const e = Cf(t); if (!Sf(e)) return _l(1); const n = e.getBoundingClientRect(), { width: r, height: i, $: s } = eM(e); let o = (s ? bl(n.width) : n.width) / r, a = (s ? bl(n.height) : n.height) / i; return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), { x: o, y: a } } const tM = _l(0); function nM(t) { const e = Pn(t); return !XR() || !e.visualViewport ? tM : { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop } } function rM(t, e, n) { return !1 } function Gm(t, e, n, r) { e === void 0 && (e = !1); const i = t.getBoundingClientRect(), s = Cf(t); let o = _l(1); e && (o = Km(t)); const a = rM() ? nM(s) : _l(0); let l = (i.left + a.x) / o.x, u = (i.top + a.y) / o.y, c = i.width / o.x, d = i.height / o.y; if (s) { const h = Pn(s), f = r; let g = h, m = $d(g); for (; m && r && f !== g;) { const y = Km(m), p = m.getBoundingClientRect(), v = kf(m), b = p.left + (m.clientLeft + parseFloat(v.paddingLeft)) * y.x, x = p.top + (m.clientTop + parseFloat(v.paddingTop)) * y.y; l *= y.x, u *= y.y, c *= y.x, d *= y.y, l += b, u += x, g = Pn(m), m = $d(g) } } return YR({ width: c, height: d, x: l, y: u }) } function iM(t, e) { let n = null, r; const i = k_(t); function s() { var a; clearTimeout(r), (a = n) == null || a.disconnect(), n = null } function o(a, l) { a === void 0 && (a = !1), l === void 0 && (l = 1), s(); const { left: u, top: c, width: d, height: h } = t.getBoundingClientRect(); if (a || e(), !d || !h) return; const f = ca(c), g = ca(i.clientWidth - (u + d)), m = ca(i.clientHeight - (c + h)), y = ca(u), v = { rootMargin: -f + "px " + -g + "px " + -m + "px " + -y + "px", threshold: GR(0, KR(1, l)) || 1 }; let b = !0; function x(P) { const M = P[0].intersectionRatio; if (M !== l) { if (!b) return o(); M ? o(!1, M) : r = setTimeout(() => { o(!1, 1e-7) }, 1e3) } b = !1 } try { n = new IntersectionObserver(x, { ...v, root: i.ownerDocument }) } catch { n = new IntersectionObserver(x, v) } n.observe(t) } return o(!0), s } function sM(t, e, n, r) { r === void 0 && (r = {}); const { ancestorScroll: i = !0, ancestorResize: s = !0, elementResize: o = typeof ResizeObserver == "function", layoutShift: a = typeof IntersectionObserver == "function", animationFrame: l = !1 } = r, u = Cf(t), c = i || s ? [...u ? wl(u) : [], ...wl(e)] : []; c.forEach(p => { i && p.addEventListener("scroll", n, { passive: !0 }), s && p.addEventListener("resize", n) }); const d = u && a ? iM(u, n) : null; let h = -1, f = null; o && (f = new ResizeObserver(p => { let [v] = p; v && v.target === u && f && (f.unobserve(e), cancelAnimationFrame(h), h = requestAnimationFrame(() => { var b; (b = f) == null || b.observe(e) })), n() }), u && !l && f.observe(u), f.observe(e)); let g, m = l ? Gm(t) : null; l && y(); function y() { const p = Gm(t); m && (p.x !== m.x || p.y !== m.y || p.width !== m.width || p.height !== m.height) && n(), m = p, g = requestAnimationFrame(y) } return n(), () => { var p; c.forEach(v => { i && v.removeEventListener("scroll", n), s && v.removeEventListener("resize", n) }), d == null || d(), (p = f) == null || p.disconnect(), f = null, l && cancelAnimationFrame(g) } } var zd = R.useLayoutEffect, oM = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], xl = function () { }; function aM(t, e) { return e ? e[0] === "-" ? t + e : t + "__" + e : t } function lM(t, e) { for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)r[i - 2] = arguments[i]; var s = [].concat(r); if (e && t) for (var o in e) e.hasOwnProperty(o) && e[o] && s.push("".concat(aM(t, o))); return s.filter(function (a) { return a }).map(function (a) { return String(a).trim() }).join(" ") } var Ym = function (e) { return vM(e) ? e.filter(Boolean) : Fr(e) === "object" && e !== null ? [e] : [] }, E_ = function (e) { e.className, e.clearValue, e.cx, e.getStyles, e.getClassNames, e.getValue, e.hasValue, e.isMulti, e.isRtl, e.options, e.selectOption, e.selectProps, e.setValue, e.theme; var n = Tn(e, oM); return Q({}, n) }, Pe = function (e, n, r) { var i = e.cx, s = e.getStyles, o = e.getClassNames, a = e.className; return { css: s(n, e), className: i(r ?? {}, o(n, e), a) } }; function gu(t) { return [document.documentElement, document.body, window].indexOf(t) > -1 } function uM(t) { return gu(t) ? window.innerHeight : t.clientHeight } function T_(t) { return gu(t) ? window.pageYOffset : t.scrollTop } function Sl(t, e) { if (gu(t)) { window.scrollTo(0, e); return } t.scrollTop = e } function cM(t) { var e = getComputedStyle(t), n = e.position === "absolute", r = /(auto|scroll)/; if (e.position === "fixed") return document.documentElement; for (var i = t; i = i.parentElement;)if (e = getComputedStyle(i), !(n && e.position === "static") && r.test(e.overflow + e.overflowY + e.overflowX)) return i; return document.documentElement } function dM(t, e, n, r) { return n * ((t = t / r - 1) * t * t + 1) + e } function da(t, e) { var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : xl, i = T_(t), s = e - i, o = 10, a = 0; function l() { a += o; var u = dM(a, i, s, n); Sl(t, u), a < n ? window.requestAnimationFrame(l) : r(t) } l() } function Qm(t, e) { var n = t.getBoundingClientRect(), r = e.getBoundingClientRect(), i = e.offsetHeight / 3; r.bottom + i > n.bottom ? Sl(t, Math.min(e.offsetTop + e.clientHeight - t.offsetHeight + i, t.scrollHeight)) : r.top - i < n.top && Sl(t, Math.max(e.offsetTop - i, 0)) } function hM(t) { var e = t.getBoundingClientRect(); return { bottom: e.bottom, height: e.height, left: e.left, right: e.right, top: e.top, width: e.width } } function Xm() { try { return document.createEvent("TouchEvent"), !0 } catch { return !1 } } function fM() { try { return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) } catch { return !1 } } var I_ = !1, pM = { get passive() { return I_ = !0 } }, ha = typeof window < "u" ? window : {}; ha.addEventListener && ha.removeEventListener && (ha.addEventListener("p", xl, pM), ha.removeEventListener("p", xl, !1)); var gM = I_; function mM(t) { return t != null } function vM(t) { return Array.isArray(t) } function fa(t, e, n) { return t ? e : n } var yM = function (e) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; var s = Object.entries(e).filter(function (o) { var a = xn(o, 1), l = a[0]; return !r.includes(l) }); return s.reduce(function (o, a) { var l = xn(a, 2), u = l[0], c = l[1]; return o[u] = c, o }, {}) }, bM = ["children", "innerProps"], _M = ["children", "innerProps"]; function wM(t) { var e = t.maxHeight, n = t.menuEl, r = t.minHeight, i = t.placement, s = t.shouldScroll, o = t.isFixedPosition, a = t.controlHeight, l = cM(n), u = { placement: "bottom", maxHeight: e }; if (!n || !n.offsetParent) return u; var c = l.getBoundingClientRect(), d = c.height, h = n.getBoundingClientRect(), f = h.bottom, g = h.height, m = h.top, y = n.offsetParent.getBoundingClientRect(), p = y.top, v = o ? window.innerHeight : uM(l), b = T_(l), x = parseInt(getComputedStyle(n).marginBottom, 10), P = parseInt(getComputedStyle(n).marginTop, 10), M = p - P, I = v - m, C = M + b, T = d - b - m, L = f - v + b + x, D = b + m - P, N = 160; switch (i) { case "auto": case "bottom": if (I >= g) return { placement: "bottom", maxHeight: e }; if (T >= g && !o) return s && da(l, L, N), { placement: "bottom", maxHeight: e }; if (!o && T >= r || o && I >= r) { s && da(l, L, N); var F = o ? I - x : T - x; return { placement: "bottom", maxHeight: F } } if (i === "auto" || o) { var B = e, H = o ? M : C; return H >= r && (B = Math.min(H - x - a, e)), { placement: "top", maxHeight: B } } if (i === "bottom") return s && Sl(l, L), { placement: "bottom", maxHeight: e }; break; case "top": if (M >= g) return { placement: "top", maxHeight: e }; if (C >= g && !o) return s && da(l, D, N), { placement: "top", maxHeight: e }; if (!o && C >= r || o && M >= r) { var q = e; return (!o && C >= r || o && M >= r) && (q = o ? M - P : C - P), s && da(l, D, N), { placement: "top", maxHeight: q } } return { placement: "bottom", maxHeight: e }; default: throw new Error('Invalid placement provided "'.concat(i, '".')) }return u } function xM(t) { var e = { bottom: "top", top: "bottom" }; return t ? e[t] : "bottom" } var R_ = function (e) { return e === "auto" ? "bottom" : e }, SM = function (e, n) { var r, i = e.placement, s = e.theme, o = s.borderRadius, a = s.spacing, l = s.colors; return Q((r = { label: "menu" }, ys(r, xM(i), "100%"), ys(r, "position", "absolute"), ys(r, "width", "100%"), ys(r, "zIndex", 1), r), n ? {} : { backgroundColor: l.neutral0, borderRadius: o, boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)", marginBottom: a.menuGutter, marginTop: a.menuGutter }) }, M_ = R.createContext(null), kM = function (e) { var n = e.children, r = e.minMenuHeight, i = e.maxMenuHeight, s = e.menuPlacement, o = e.menuPosition, a = e.menuShouldScrollIntoView, l = e.theme, u = R.useContext(M_) || {}, c = u.setPortalPlacement, d = R.useRef(null), h = R.useState(i), f = xn(h, 2), g = f[0], m = f[1], y = R.useState(null), p = xn(y, 2), v = p[0], b = p[1], x = l.spacing.controlHeight; return zd(function () { var P = d.current; if (P) { var M = o === "fixed", I = a && !M, C = wM({ maxHeight: i, menuEl: P, minHeight: r, placement: s, shouldScroll: I, isFixedPosition: M, controlHeight: x }); m(C.maxHeight), b(C.placement), c == null || c(C.placement) } }, [i, s, o, a, r, c, x]), n({ ref: d, placerProps: Q(Q({}, e), {}, { placement: v || R_(s), maxHeight: g }) }) }, CM = function (e) { var n = e.children, r = e.innerRef, i = e.innerProps; return Y("div", X({}, Pe(e, "menu", { menu: !0 }), { ref: r }, i), n) }, OM = CM, PM = function (e, n) { var r = e.maxHeight, i = e.theme.spacing.baseUnit; return Q({ maxHeight: r, overflowY: "auto", position: "relative", WebkitOverflowScrolling: "touch" }, n ? {} : { paddingBottom: i, paddingTop: i }) }, EM = function (e) { var n = e.children, r = e.innerProps, i = e.innerRef, s = e.isMulti; return Y("div", X({}, Pe(e, "menuList", { "menu-list": !0, "menu-list--is-multi": s }), { ref: i }, r), n) }, L_ = function (e, n) { var r = e.theme, i = r.spacing.baseUnit, s = r.colors; return Q({ textAlign: "center" }, n ? {} : { color: s.neutral40, padding: "".concat(i * 2, "px ").concat(i * 3, "px") }) }, TM = L_, IM = L_, RM = function (e) { var n = e.children, r = n === void 0 ? "No options" : n, i = e.innerProps, s = Tn(e, bM); return Y("div", X({}, Pe(Q(Q({}, s), {}, { children: r, innerProps: i }), "noOptionsMessage", { "menu-notice": !0, "menu-notice--no-options": !0 }), i), r) }, MM = function (e) { var n = e.children, r = n === void 0 ? "Loading..." : n, i = e.innerProps, s = Tn(e, _M); return Y("div", X({}, Pe(Q(Q({}, s), {}, { children: r, innerProps: i }), "loadingMessage", { "menu-notice": !0, "menu-notice--loading": !0 }), i), r) }, LM = function (e) { var n = e.rect, r = e.offset, i = e.position; return { left: n.left, position: i, top: r, width: n.width, zIndex: 1 } }, DM = function (e) { var n = e.appendTo, r = e.children, i = e.controlElement, s = e.innerProps, o = e.menuPlacement, a = e.menuPosition, l = R.useRef(null), u = R.useRef(null), c = R.useState(R_(o)), d = xn(c, 2), h = d[0], f = d[1], g = R.useMemo(function () { return { setPortalPlacement: f } }, []), m = R.useState(null), y = xn(m, 2), p = y[0], v = y[1], b = R.useCallback(function () { if (i) { var I = hM(i), C = a === "fixed" ? 0 : window.pageYOffset, T = I[h] + C; (T !== (p == null ? void 0 : p.offset) || I.left !== (p == null ? void 0 : p.rect.left) || I.width !== (p == null ? void 0 : p.rect.width)) && v({ offset: T, rect: I }) } }, [i, a, h, p == null ? void 0 : p.offset, p == null ? void 0 : p.rect.left, p == null ? void 0 : p.rect.width]); zd(function () { b() }, [b]); var x = R.useCallback(function () { typeof u.current == "function" && (u.current(), u.current = null), i && l.current && (u.current = sM(i, l.current, b, { elementResize: "ResizeObserver" in window })) }, [i, b]); zd(function () { x() }, [x]); var P = R.useCallback(function (I) { l.current = I, x() }, [x]); if (!n && a !== "fixed" || !p) return null; var M = Y("div", X({ ref: P }, Pe(Q(Q({}, e), {}, { offset: p.offset, position: a, rect: p.rect }), "menuPortal", { "menu-portal": !0 }), s), r); return Y(M_.Provider, { value: g }, n ? E0.createPortal(M, n) : M) }, jM = function (e) { var n = e.isDisabled, r = e.isRtl; return { label: "container", direction: r ? "rtl" : void 0, pointerEvents: n ? "none" : void 0, position: "relative" } }, AM = function (e) { var n = e.children, r = e.innerProps, i = e.isDisabled, s = e.isRtl; return Y("div", X({}, Pe(e, "container", { "--is-disabled": i, "--is-rtl": s }), r), n) }, NM = function (e, n) { var r = e.theme.spacing, i = e.isMulti, s = e.hasValue, o = e.selectProps.controlShouldRenderValue; return Q({ alignItems: "center", display: i && s && o ? "flex" : "grid", flex: 1, flexWrap: "wrap", WebkitOverflowScrolling: "touch", position: "relative", overflow: "hidden" }, n ? {} : { padding: "".concat(r.baseUnit / 2, "px ").concat(r.baseUnit * 2, "px") }) }, FM = function (e) { var n = e.children, r = e.innerProps, i = e.isMulti, s = e.hasValue; return Y("div", X({}, Pe(e, "valueContainer", { "value-container": !0, "value-container--is-multi": i, "value-container--has-value": s }), r), n) }, $M = function () { return { alignItems: "center", alignSelf: "stretch", display: "flex", flexShrink: 0 } }, zM = function (e) { var n = e.children, r = e.innerProps; return Y("div", X({}, Pe(e, "indicatorsContainer", { indicators: !0 }), r), n) }, Jm, VM = ["size"], BM = ["innerProps", "isRtl", "size"], UM = { name: "8mmkcg", styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0" }, D_ = function (e) { var n = e.size, r = Tn(e, VM); return Y("svg", X({ height: n, width: n, viewBox: "0 0 20 20", "aria-hidden": "true", focusable: "false", css: UM }, r)) }, Of = function (e) { return Y(D_, X({ size: 20 }, e), Y("path", { d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z" })) }, j_ = function (e) { return Y(D_, X({ size: 20 }, e), Y("path", { d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z" })) }, A_ = function (e, n) { var r = e.isFocused, i = e.theme, s = i.spacing.baseUnit, o = i.colors; return Q({ label: "indicatorContainer", display: "flex", transition: "color 150ms" }, n ? {} : { color: r ? o.neutral60 : o.neutral20, padding: s * 2, ":hover": { color: r ? o.neutral80 : o.neutral40 } }) }, HM = A_, WM = function (e) { var n = e.children, r = e.innerProps; return Y("div", X({}, Pe(e, "dropdownIndicator", { indicator: !0, "dropdown-indicator": !0 }), r), n || Y(j_, null)) }, qM = A_, KM = function (e) { var n = e.children, r = e.innerProps; return Y("div", X({}, Pe(e, "clearIndicator", { indicator: !0, "clear-indicator": !0 }), r), n || Y(Of, null)) }, GM = function (e, n) { var r = e.isDisabled, i = e.theme, s = i.spacing.baseUnit, o = i.colors; return Q({ label: "indicatorSeparator", alignSelf: "stretch", width: 1 }, n ? {} : { backgroundColor: r ? o.neutral10 : o.neutral20, marginBottom: s * 2, marginTop: s * 2 }) }, YM = function (e) { var n = e.innerProps; return Y("span", X({}, n, Pe(e, "indicatorSeparator", { "indicator-separator": !0 }))) }, QM = WR(Jm || (Jm = qR([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), XM = function (e, n) { var r = e.isFocused, i = e.size, s = e.theme, o = s.colors, a = s.spacing.baseUnit; return Q({ label: "loadingIndicator", display: "flex", transition: "color 150ms", alignSelf: "center", fontSize: i, lineHeight: 1, marginRight: i, textAlign: "center", verticalAlign: "middle" }, n ? {} : { color: r ? o.neutral60 : o.neutral20, padding: a * 2 }) }, pc = function (e) { var n = e.delay, r = e.offset; return Y("span", { css: xf({ animation: "".concat(QM, " 1s ease-in-out ").concat(n, "ms infinite;"), backgroundColor: "currentColor", borderRadius: "1em", display: "inline-block", marginLeft: r ? "1em" : void 0, height: "1em", verticalAlign: "top", width: "1em" }, "", "") }) }, JM = function (e) { var n = e.innerProps, r = e.isRtl, i = e.size, s = i === void 0 ? 4 : i, o = Tn(e, BM); return Y("div", X({}, Pe(Q(Q({}, o), {}, { innerProps: n, isRtl: r, size: s }), "loadingIndicator", { indicator: !0, "loading-indicator": !0 }), n), Y(pc, { delay: 0, offset: r }), Y(pc, { delay: 160, offset: !0 }), Y(pc, { delay: 320, offset: !r })) }, ZM = function (e, n) { var r = e.isDisabled, i = e.isFocused, s = e.theme, o = s.colors, a = s.borderRadius, l = s.spacing; return Q({ label: "control", alignItems: "center", cursor: "default", display: "flex", flexWrap: "wrap", justifyContent: "space-between", minHeight: l.controlHeight, outline: "0 !important", position: "relative", transition: "all 100ms" }, n ? {} : { backgroundColor: r ? o.neutral5 : o.neutral0, borderColor: r ? o.neutral10 : i ? o.primary : o.neutral20, borderRadius: a, borderStyle: "solid", borderWidth: 1, boxShadow: i ? "0 0 0 1px ".concat(o.primary) : void 0, "&:hover": { borderColor: i ? o.primary : o.neutral30 } }) }, eL = function (e) { var n = e.children, r = e.isDisabled, i = e.isFocused, s = e.innerRef, o = e.innerProps, a = e.menuIsOpen; return Y("div", X({ ref: s }, Pe(e, "control", { control: !0, "control--is-disabled": r, "control--is-focused": i, "control--menu-is-open": a }), o, { "aria-disabled": r || void 0 }), n) }, tL = eL, nL = ["data"], rL = function (e, n) { var r = e.theme.spacing; return n ? {} : { paddingBottom: r.baseUnit * 2, paddingTop: r.baseUnit * 2 } }, iL = function (e) { var n = e.children, r = e.cx, i = e.getStyles, s = e.getClassNames, o = e.Heading, a = e.headingProps, l = e.innerProps, u = e.label, c = e.theme, d = e.selectProps; return Y("div", X({}, Pe(e, "group", { group: !0 }), l), Y(o, X({}, a, { selectProps: d, theme: c, getStyles: i, getClassNames: s, cx: r }), u), Y("div", null, n)) }, sL = function (e, n) { var r = e.theme, i = r.colors, s = r.spacing; return Q({ label: "group", cursor: "default", display: "block" }, n ? {} : { color: i.neutral40, fontSize: "75%", fontWeight: 500, marginBottom: "0.25em", paddingLeft: s.baseUnit * 3, paddingRight: s.baseUnit * 3, textTransform: "uppercase" }) }, oL = function (e) { var n = E_(e); n.data; var r = Tn(n, nL); return Y("div", X({}, Pe(e, "groupHeading", { "group-heading": !0 }), r)) }, aL = iL, lL = ["innerRef", "isDisabled", "isHidden", "inputClassName"], uL = function (e, n) { var r = e.isDisabled, i = e.value, s = e.theme, o = s.spacing, a = s.colors; return Q(Q({ visibility: r ? "hidden" : "visible", transform: i ? "translateZ(0)" : "" }, cL), n ? {} : { margin: o.baseUnit / 2, paddingBottom: o.baseUnit / 2, paddingTop: o.baseUnit / 2, color: a.neutral80 }) }, N_ = { gridArea: "1 / 2", font: "inherit", minWidth: "2px", border: 0, margin: 0, outline: 0, padding: 0 }, cL = { flex: "1 1 auto", display: "inline-grid", gridArea: "1 / 1 / 2 / 3", gridTemplateColumns: "0 min-content", "&:after": Q({ content: 'attr(data-value) " "', visibility: "hidden", whiteSpace: "pre" }, N_) }, dL = function (e) { return Q({ label: "input", color: "inherit", background: 0, opacity: e ? 0 : 1, width: "100%" }, N_) }, hL = function (e) { var n = e.cx, r = e.value, i = E_(e), s = i.innerRef, o = i.isDisabled, a = i.isHidden, l = i.inputClassName, u = Tn(i, lL); return Y("div", X({}, Pe(e, "input", { "input-container": !0 }), { "data-value": r || "" }), Y("input", X({ className: n({ input: !0 }, l), ref: s, style: dL(a), disabled: o }, u))) }, fL = hL, pL = function (e, n) { var r = e.theme, i = r.spacing, s = r.borderRadius, o = r.colors; return Q({ label: "multiValue", display: "flex", minWidth: 0 }, n ? {} : { backgroundColor: o.neutral10, borderRadius: s / 2, margin: i.baseUnit / 2 }) }, gL = function (e, n) { var r = e.theme, i = r.borderRadius, s = r.colors, o = e.cropWithEllipsis; return Q({ overflow: "hidden", textOverflow: o || o === void 0 ? "ellipsis" : void 0, whiteSpace: "nowrap" }, n ? {} : { borderRadius: i / 2, color: s.neutral80, fontSize: "85%", padding: 3, paddingLeft: 6 }) }, mL = function (e, n) { var r = e.theme, i = r.spacing, s = r.borderRadius, o = r.colors, a = e.isFocused; return Q({ alignItems: "center", display: "flex" }, n ? {} : { borderRadius: s / 2, backgroundColor: a ? o.dangerLight : void 0, paddingLeft: i.baseUnit, paddingRight: i.baseUnit, ":hover": { backgroundColor: o.dangerLight, color: o.danger } }) }, F_ = function (e) { var n = e.children, r = e.innerProps; return Y("div", r, n) }, vL = F_, yL = F_; function bL(t) { var e = t.children, n = t.innerProps; return Y("div", X({ role: "button" }, n), e || Y(Of, { size: 14 })) } var _L = function (e) { var n = e.children, r = e.components, i = e.data, s = e.innerProps, o = e.isDisabled, a = e.removeProps, l = e.selectProps, u = r.Container, c = r.Label, d = r.Remove; return Y(u, { data: i, innerProps: Q(Q({}, Pe(e, "multiValue", { "multi-value": !0, "multi-value--is-disabled": o })), s), selectProps: l }, Y(c, { data: i, innerProps: Q({}, Pe(e, "multiValueLabel", { "multi-value__label": !0 })), selectProps: l }, n), Y(d, { data: i, innerProps: Q(Q({}, Pe(e, "multiValueRemove", { "multi-value__remove": !0 })), {}, { "aria-label": "Remove ".concat(n || "option") }, a), selectProps: l })) }, wL = _L, xL = function (e, n) { var r = e.isDisabled, i = e.isFocused, s = e.isSelected, o = e.theme, a = o.spacing, l = o.colors; return Q({ label: "option", cursor: "default", display: "block", fontSize: "inherit", width: "100%", userSelect: "none", WebkitTapHighlightColor: "rgba(0, 0, 0, 0)" }, n ? {} : { backgroundColor: s ? l.primary : i ? l.primary25 : "transparent", color: r ? l.neutral20 : s ? l.neutral0 : "inherit", padding: "".concat(a.baseUnit * 2, "px ").concat(a.baseUnit * 3, "px"), ":active": { backgroundColor: r ? void 0 : s ? l.primary : l.primary50 } }) }, SL = function (e) { var n = e.children, r = e.isDisabled, i = e.isFocused, s = e.isSelected, o = e.innerRef, a = e.innerProps; return Y("div", X({}, Pe(e, "option", { option: !0, "option--is-disabled": r, "option--is-focused": i, "option--is-selected": s }), { ref: o, "aria-disabled": r }, a), n) }, kL = SL, CL = function (e, n) { var r = e.theme, i = r.spacing, s = r.colors; return Q({ label: "placeholder", gridArea: "1 / 1 / 2 / 3" }, n ? {} : { color: s.neutral50, marginLeft: i.baseUnit / 2, marginRight: i.baseUnit / 2 }) }, OL = function (e) { var n = e.children, r = e.innerProps; return Y("div", X({}, Pe(e, "placeholder", { placeholder: !0 }), r), n) }, PL = OL, EL = function (e, n) { var r = e.isDisabled, i = e.theme, s = i.spacing, o = i.colors; return Q({ label: "singleValue", gridArea: "1 / 1 / 2 / 3", maxWidth: "100%", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }, n ? {} : { color: r ? o.neutral40 : o.neutral80, marginLeft: s.baseUnit / 2, marginRight: s.baseUnit / 2 }) }, TL = function (e) { var n = e.children, r = e.isDisabled, i = e.innerProps; return Y("div", X({}, Pe(e, "singleValue", { "single-value": !0, "single-value--is-disabled": r }), i), n) }, IL = TL, RL = { ClearIndicator: KM, Control: tL, DropdownIndicator: WM, DownChevron: j_, CrossIcon: Of, Group: aL, GroupHeading: oL, IndicatorsContainer: zM, IndicatorSeparator: YM, Input: fL, LoadingIndicator: JM, Menu: OM, MenuList: EM, MenuPortal: DM, LoadingMessage: MM, NoOptionsMessage: RM, MultiValue: wL, MultiValueContainer: vL, MultiValueLabel: yL, MultiValueRemove: bL, Option: kL, Placeholder: PL, SelectContainer: AM, SingleValue: IL, ValueContainer: FM }, ML = function (e) { return Q(Q({}, RL), e.components) }, Zm = Number.isNaN || function (e) { return typeof e == "number" && e !== e }; function LL(t, e) { return !!(t === e || Zm(t) && Zm(e)) } function DL(t, e) { if (t.length !== e.length) return !1; for (var n = 0; n < t.length; n++)if (!LL(t[n], e[n])) return !1; return !0 } function jL(t, e) { e === void 0 && (e = DL); var n = null; function r() { for (var i = [], s = 0; s < arguments.length; s++)i[s] = arguments[s]; if (n && n.lastThis === this && e(i, n.lastArgs)) return n.lastResult; var o = t.apply(this, i); return n = { lastResult: o, lastArgs: i, lastThis: this }, o } return r.clear = function () { n = null }, r } var AL = { name: "7pg0cj-a11yText", styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap" }, NL = function (e) { return Y("span", X({ css: AL }, e)) }, ev = NL, FL = { guidance: function (e) { var n = e.isSearchable, r = e.isMulti, i = e.tabSelectsValue, s = e.context, o = e.isInitialFocus; switch (s) { case "menu": return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(i ? ", press Tab to select the option and exit the menu" : "", "."); case "input": return o ? "".concat(e["aria-label"] || "Select", " is focused ").concat(n ? ",type to refine list" : "", ", press Down to open the menu, ").concat(r ? " press left to focus selected values" : "") : ""; case "value": return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value"; default: return "" } }, onChange: function (e) { var n = e.action, r = e.label, i = r === void 0 ? "" : r, s = e.labels, o = e.isDisabled; switch (n) { case "deselect-option": case "pop-value": case "remove-value": return "option ".concat(i, ", deselected."); case "clear": return "All selected options have been cleared."; case "initial-input-focus": return "option".concat(s.length > 1 ? "s" : "", " ").concat(s.join(","), ", selected."); case "select-option": return o ? "option ".concat(i, " is disabled. Select another option.") : "option ".concat(i, ", selected."); default: return "" } }, onFocus: function (e) { var n = e.context, r = e.focused, i = e.options, s = e.label, o = s === void 0 ? "" : s, a = e.selectValue, l = e.isDisabled, u = e.isSelected, c = e.isAppleDevice, d = function (m, y) { return m && m.length ? "".concat(m.indexOf(y) + 1, " of ").concat(m.length) : "" }; if (n === "value" && a) return "value ".concat(o, " focused, ").concat(d(a, r), "."); if (n === "menu" && c) { var h = l ? " disabled" : "", f = "".concat(u ? " selected" : "").concat(h); return "".concat(o).concat(f, ", ").concat(d(i, r), ".") } return "" }, onFilter: function (e) { var n = e.inputValue, r = e.resultsMessage; return "".concat(r).concat(n ? " for search term " + n : "", ".") } }, $L = function (e) { var n = e.ariaSelection, r = e.focusedOption, i = e.focusedValue, s = e.focusableOptions, o = e.isFocused, a = e.selectValue, l = e.selectProps, u = e.id, c = e.isAppleDevice, d = l.ariaLiveMessages, h = l.getOptionLabel, f = l.inputValue, g = l.isMulti, m = l.isOptionDisabled, y = l.isSearchable, p = l.menuIsOpen, v = l.options, b = l.screenReaderStatus, x = l.tabSelectsValue, P = l.isLoading, M = l["aria-label"], I = l["aria-live"], C = R.useMemo(function () { return Q(Q({}, FL), d || {}) }, [d]), T = R.useMemo(function () { var H = ""; if (n && C.onChange) { var q = n.option, V = n.options, A = n.removedValue, _ = n.removedValues, S = n.value, E = function (K) { return Array.isArray(K) ? null : K }, w = A || q || E(S), O = w ? h(w) : "", j = V || _ || void 0, $ = j ? j.map(h) : [], z = Q({ isDisabled: w && m(w, a), label: O, labels: $ }, n); H = C.onChange(z) } return H }, [n, C, m, a, h]), L = R.useMemo(function () { var H = "", q = r || i, V = !!(r && a && a.includes(r)); if (q && C.onFocus) { var A = { focused: q, label: h(q), isDisabled: m(q, a), isSelected: V, options: s, context: q === r ? "menu" : "value", selectValue: a, isAppleDevice: c }; H = C.onFocus(A) } return H }, [r, i, h, m, C, s, a, c]), D = R.useMemo(function () { var H = ""; if (p && v.length && !P && C.onFilter) { var q = b({ count: s.length }); H = C.onFilter({ inputValue: f, resultsMessage: q }) } return H }, [s, f, p, C, v, b, P]), N = (n == null ? void 0 : n.action) === "initial-input-focus", F = R.useMemo(function () { var H = ""; if (C.guidance) { var q = i ? "value" : p ? "menu" : "input"; H = C.guidance({ "aria-label": M, context: q, isDisabled: r && m(r, a), isMulti: g, isSearchable: y, tabSelectsValue: x, isInitialFocus: N }) } return H }, [M, r, i, g, m, y, p, C, a, x, N]), B = Y(R.Fragment, null, Y("span", { id: "aria-selection" }, T), Y("span", { id: "aria-focused" }, L), Y("span", { id: "aria-results" }, D), Y("span", { id: "aria-guidance" }, F)); return Y(R.Fragment, null, Y(ev, { id: u }, N && B), Y(ev, { "aria-live": I, "aria-atomic": "false", "aria-relevant": "additions text", role: "log" }, o && !N && B)) }, zL = $L, Vd = [{ base: "A", letters: "A" }, { base: "AA", letters: "" }, { base: "AE", letters: "" }, { base: "AO", letters: "" }, { base: "AU", letters: "" }, { base: "AV", letters: "" }, { base: "AY", letters: "" }, { base: "B", letters: "B" }, { base: "C", letters: "C" }, { base: "D", letters: "D" }, { base: "DZ", letters: "" }, { base: "Dz", letters: "" }, { base: "E", letters: "E" }, { base: "F", letters: "F" }, { base: "G", letters: "G" }, { base: "H", letters: "H" }, { base: "I", letters: "I" }, { base: "J", letters: "J" }, { base: "K", letters: "K" }, { base: "L", letters: "L" }, { base: "LJ", letters: "" }, { base: "Lj", letters: "" }, { base: "M", letters: "M" }, { base: "N", letters: "N" }, { base: "NJ", letters: "" }, { base: "Nj", letters: "" }, { base: "O", letters: "O" }, { base: "OI", letters: "" }, { base: "OO", letters: "" }, { base: "OU", letters: "" }, { base: "P", letters: "P" }, { base: "Q", letters: "Q" }, { base: "R", letters: "R" }, { base: "S", letters: "S" }, { base: "T", letters: "T" }, { base: "TZ", letters: "" }, { base: "U", letters: "U" }, { base: "V", letters: "V" }, { base: "VY", letters: "" }, { base: "W", letters: "W" }, { base: "X", letters: "X" }, { base: "Y", letters: "Y" }, { base: "Z", letters: "Z" }, { base: "a", letters: "a" }, { base: "aa", letters: "" }, { base: "ae", letters: "" }, { base: "ao", letters: "" }, { base: "au", letters: "" }, { base: "av", letters: "" }, { base: "ay", letters: "" }, { base: "b", letters: "b" }, { base: "c", letters: "c" }, { base: "d", letters: "d" }, { base: "dz", letters: "" }, { base: "e", letters: "e" }, { base: "f", letters: "f" }, { base: "g", letters: "g" }, { base: "h", letters: "h" }, { base: "hv", letters: "" }, { base: "i", letters: "i" }, { base: "j", letters: "j" }, { base: "k", letters: "k" }, { base: "l", letters: "l" }, { base: "lj", letters: "" }, { base: "m", letters: "m" }, { base: "n", letters: "n" }, { base: "nj", letters: "" }, { base: "o", letters: "o" }, { base: "oi", letters: "" }, { base: "ou", letters: "" }, { base: "oo", letters: "" }, { base: "p", letters: "p" }, { base: "q", letters: "q" }, { base: "r", letters: "r" }, { base: "s", letters: "s" }, { base: "t", letters: "t" }, { base: "tz", letters: "" }, { base: "u", letters: "u" }, { base: "v", letters: "v" }, { base: "vy", letters: "" }, { base: "w", letters: "w" }, { base: "x", letters: "x" }, { base: "y", letters: "y" }, { base: "z", letters: "z" }], VL = new RegExp("[" + Vd.map(function (t) { return t.letters }).join("") + "]", "g"), $_ = {}; for (var gc = 0; gc < Vd.length; gc++)for (var mc = Vd[gc], vc = 0; vc < mc.letters.length; vc++)$_[mc.letters[vc]] = mc.base; var z_ = function (e) { return e.replace(VL, function (n) { return $_[n] }) }, BL = jL(z_), tv = function (e) { return e.replace(/^\s+|\s+$/g, "") }, UL = function (e) { return "".concat(e.label, " ").concat(e.value) }, HL = function (e) { return function (n, r) { if (n.data.__isNew__) return !0; var i = Q({ ignoreCase: !0, ignoreAccents: !0, stringify: UL, trim: !0, matchFrom: "any" }, e), s = i.ignoreCase, o = i.ignoreAccents, a = i.stringify, l = i.trim, u = i.matchFrom, c = l ? tv(r) : r, d = l ? tv(a(n)) : a(n); return s && (c = c.toLowerCase(), d = d.toLowerCase()), o && (c = BL(c), d = z_(d)), u === "start" ? d.substr(0, c.length) === c : d.indexOf(c) > -1 } }, WL = ["innerRef"]; function qL(t) { var e = t.innerRef, n = Tn(t, WL), r = yM(n, "onExited", "in", "enter", "exit", "appear"); return Y("input", X({ ref: e }, r, { css: xf({ label: "dummyInput", background: 0, border: 0, caretColor: "transparent", fontSize: "inherit", gridArea: "1 / 1 / 2 / 3", outline: 0, padding: 0, width: 1, color: "transparent", left: -100, opacity: 0, position: "relative", transform: "scale(.01)" }, "", "") })) } var KL = function (e) { e.cancelable && e.preventDefault(), e.stopPropagation() }; function GL(t) { var e = t.isEnabled, n = t.onBottomArrive, r = t.onBottomLeave, i = t.onTopArrive, s = t.onTopLeave, o = R.useRef(!1), a = R.useRef(!1), l = R.useRef(0), u = R.useRef(null), c = R.useCallback(function (y, p) { if (u.current !== null) { var v = u.current, b = v.scrollTop, x = v.scrollHeight, P = v.clientHeight, M = u.current, I = p > 0, C = x - P - b, T = !1; C > p && o.current && (r && r(y), o.current = !1), I && a.current && (s && s(y), a.current = !1), I && p > C ? (n && !o.current && n(y), M.scrollTop = x, T = !0, o.current = !0) : !I && -p > b && (i && !a.current && i(y), M.scrollTop = 0, T = !0, a.current = !0), T && KL(y) } }, [n, r, i, s]), d = R.useCallback(function (y) { c(y, y.deltaY) }, [c]), h = R.useCallback(function (y) { l.current = y.changedTouches[0].clientY }, []), f = R.useCallback(function (y) { var p = l.current - y.changedTouches[0].clientY; c(y, p) }, [c]), g = R.useCallback(function (y) { if (y) { var p = gM ? { passive: !1 } : !1; y.addEventListener("wheel", d, p), y.addEventListener("touchstart", h, p), y.addEventListener("touchmove", f, p) } }, [f, h, d]), m = R.useCallback(function (y) { y && (y.removeEventListener("wheel", d, !1), y.removeEventListener("touchstart", h, !1), y.removeEventListener("touchmove", f, !1)) }, [f, h, d]); return R.useEffect(function () { if (e) { var y = u.current; return g(y), function () { m(y) } } }, [e, g, m]), function (y) { u.current = y } } var nv = ["boxSizing", "height", "overflow", "paddingRight", "position"], rv = { boxSizing: "border-box", overflow: "hidden", position: "relative", height: "100%" }; function iv(t) { t.preventDefault() } function sv(t) { t.stopPropagation() } function ov() { var t = this.scrollTop, e = this.scrollHeight, n = t + this.offsetHeight; t === 0 ? this.scrollTop = 1 : n === e && (this.scrollTop = t - 1) } function av() { return "ontouchstart" in window || navigator.maxTouchPoints } var lv = !!(typeof window < "u" && window.document && window.document.createElement), us = 0, Zr = { capture: !1, passive: !1 }; function YL(t) { var e = t.isEnabled, n = t.accountForScrollbars, r = n === void 0 ? !0 : n, i = R.useRef({}), s = R.useRef(null), o = R.useCallback(function (l) { if (lv) { var u = document.body, c = u && u.style; if (r && nv.forEach(function (g) { var m = c && c[g]; i.current[g] = m }), r && us < 1) { var d = parseInt(i.current.paddingRight, 10) || 0, h = document.body ? document.body.clientWidth : 0, f = window.innerWidth - h + d || 0; Object.keys(rv).forEach(function (g) { var m = rv[g]; c && (c[g] = m) }), c && (c.paddingRight = "".concat(f, "px")) } u && av() && (u.addEventListener("touchmove", iv, Zr), l && (l.addEventListener("touchstart", ov, Zr), l.addEventListener("touchmove", sv, Zr))), us += 1 } }, [r]), a = R.useCallback(function (l) { if (lv) { var u = document.body, c = u && u.style; us = Math.max(us - 1, 0), r && us < 1 && nv.forEach(function (d) { var h = i.current[d]; c && (c[d] = h) }), u && av() && (u.removeEventListener("touchmove", iv, Zr), l && (l.removeEventListener("touchstart", ov, Zr), l.removeEventListener("touchmove", sv, Zr))) } }, [r]); return R.useEffect(function () { if (e) { var l = s.current; return o(l), function () { a(l) } } }, [e, o, a]), function (l) { s.current = l } } var QL = function (e) { var n = e.target; return n.ownerDocument.activeElement && n.ownerDocument.activeElement.blur() }, XL = { name: "1kfdb0e", styles: "position:fixed;left:0;bottom:0;right:0;top:0" }; function JL(t) { var e = t.children, n = t.lockEnabled, r = t.captureEnabled, i = r === void 0 ? !0 : r, s = t.onBottomArrive, o = t.onBottomLeave, a = t.onTopArrive, l = t.onTopLeave, u = GL({ isEnabled: i, onBottomArrive: s, onBottomLeave: o, onTopArrive: a, onTopLeave: l }), c = YL({ isEnabled: n }), d = function (f) { u(f), c(f) }; return Y(R.Fragment, null, n && Y("div", { onClick: QL, css: XL }), e(d)) } var ZL = { name: "1a0ro4n-requiredInput", styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%" }, eD = function (e) { var n = e.name, r = e.onFocus; return Y("input", { required: !0, name: n, tabIndex: -1, "aria-hidden": "true", onFocus: r, css: ZL, value: "", onChange: function () { } }) }, tD = eD; function Pf(t) { var e; return typeof window < "u" && window.navigator != null ? t.test(((e = window.navigator.userAgentData) === null || e === void 0 ? void 0 : e.platform) || window.navigator.platform) : !1 } function nD() { return Pf(/^iPhone/i) } function V_() { return Pf(/^Mac/i) } function rD() { return Pf(/^iPad/i) || V_() && navigator.maxTouchPoints > 1 } function iD() { return nD() || rD() } function sD() { return V_() || iD() } var oD = function (e) { return e.label }, aD = function (e) { return e.label }, lD = function (e) { return e.value }, uD = function (e) { return !!e.isDisabled }, cD = { clearIndicator: qM, container: jM, control: ZM, dropdownIndicator: HM, group: rL, groupHeading: sL, indicatorsContainer: $M, indicatorSeparator: GM, input: uL, loadingIndicator: XM, loadingMessage: IM, menu: SM, menuList: PM, menuPortal: LM, multiValue: pL, multiValueLabel: gL, multiValueRemove: mL, noOptionsMessage: TM, option: xL, placeholder: CL, singleValue: EL, valueContainer: NM }, dD = { primary: "#2684FF", primary75: "#4C9AFF", primary50: "#B2D4FF", primary25: "#DEEBFF", danger: "#DE350B", dangerLight: "#FFBDAD", neutral0: "hsl(0, 0%, 100%)", neutral5: "hsl(0, 0%, 95%)", neutral10: "hsl(0, 0%, 90%)", neutral20: "hsl(0, 0%, 80%)", neutral30: "hsl(0, 0%, 70%)", neutral40: "hsl(0, 0%, 60%)", neutral50: "hsl(0, 0%, 50%)", neutral60: "hsl(0, 0%, 40%)", neutral70: "hsl(0, 0%, 30%)", neutral80: "hsl(0, 0%, 20%)", neutral90: "hsl(0, 0%, 10%)" }, hD = 4, B_ = 4, fD = 38, pD = B_ * 2, gD = { baseUnit: B_, controlHeight: fD, menuGutter: pD }, yc = { borderRadius: hD, colors: dD, spacing: gD }, mD = { "aria-live": "polite", backspaceRemovesValue: !0, blurInputOnSelect: Xm(), captureMenuScroll: !Xm(), classNames: {}, closeMenuOnSelect: !0, closeMenuOnScroll: !1, components: {}, controlShouldRenderValue: !0, escapeClearsValue: !1, filterOption: HL(), formatGroupLabel: oD, getOptionLabel: aD, getOptionValue: lD, isDisabled: !1, isLoading: !1, isMulti: !1, isRtl: !1, isSearchable: !0, isOptionDisabled: uD, loadingMessage: function () { return "Loading..." }, maxMenuHeight: 300, minMenuHeight: 140, menuIsOpen: !1, menuPlacement: "bottom", menuPosition: "absolute", menuShouldBlockScroll: !1, menuShouldScrollIntoView: !fM(), noOptionsMessage: function () { return "No options" }, openMenuOnFocus: !1, openMenuOnClick: !0, options: [], pageSize: 5, placeholder: "Select...", screenReaderStatus: function (e) { var n = e.count; return "".concat(n, " result").concat(n !== 1 ? "s" : "", " available") }, styles: {}, tabIndex: 0, tabSelectsValue: !0, unstyled: !1 }; function uv(t, e, n, r) { var i = W_(t, e, n), s = q_(t, e, n), o = H_(t, e), a = kl(t, e); return { type: "option", data: e, isDisabled: i, isSelected: s, label: o, value: a, index: r } } function ja(t, e) { return t.options.map(function (n, r) { if ("options" in n) { var i = n.options.map(function (o, a) { return uv(t, o, e, a) }).filter(function (o) { return dv(t, o) }); return i.length > 0 ? { type: "group", data: n, options: i, index: r } : void 0 } var s = uv(t, n, e, r); return dv(t, s) ? s : void 0 }).filter(mM) } function U_(t) { return t.reduce(function (e, n) { return n.type === "group" ? e.push.apply(e, pf(n.options.map(function (r) { return r.data }))) : e.push(n.data), e }, []) } function cv(t, e) { return t.reduce(function (n, r) { return r.type === "group" ? n.push.apply(n, pf(r.options.map(function (i) { return { data: i.data, id: "".concat(e, "-").concat(r.index, "-").concat(i.index) } }))) : n.push({ data: r.data, id: "".concat(e, "-").concat(r.index) }), n }, []) } function vD(t, e) { return U_(ja(t, e)) } function dv(t, e) { var n = t.inputValue, r = n === void 0 ? "" : n, i = e.data, s = e.isSelected, o = e.label, a = e.value; return (!G_(t) || !s) && K_(t, { label: o, value: a, data: i }, r) } function yD(t, e) { var n = t.focusedValue, r = t.selectValue, i = r.indexOf(n); if (i > -1) { var s = e.indexOf(n); if (s > -1) return n; if (i < e.length) return e[i] } return null } function bD(t, e) { var n = t.focusedOption; return n && e.indexOf(n) > -1 ? n : e[0] } var bc = function (e, n) { var r, i = (r = e.find(function (s) { return s.data === n })) === null || r === void 0 ? void 0 : r.id; return i || null }, H_ = function (e, n) { return e.getOptionLabel(n) }, kl = function (e, n) { return e.getOptionValue(n) }; function W_(t, e, n) { return typeof t.isOptionDisabled == "function" ? t.isOptionDisabled(e, n) : !1 } function q_(t, e, n) { if (n.indexOf(e) > -1) return !0; if (typeof t.isOptionSelected == "function") return t.isOptionSelected(e, n); var r = kl(t, e); return n.some(function (i) { return kl(t, i) === r }) } function K_(t, e, n) { return t.filterOption ? t.filterOption(e, n) : !0 } var G_ = function (e) { var n = e.hideSelectedOptions, r = e.isMulti; return n === void 0 ? r : n }, _D = 1, Y_ = function (t) { LI(n, t); var e = AI(n); function n(r) { var i; if (RI(this, n), i = e.call(this, r), i.state = { ariaSelection: null, focusedOption: null, focusedOptionId: null, focusableOptionsWithIds: [], focusedValue: null, inputIsHidden: !1, isFocused: !1, selectValue: [], clearFocusValueOnUpdate: !1, prevWasFocused: !1, inputIsHiddenAfterUpdate: void 0, prevProps: void 0, instancePrefix: "" }, i.blockOptionHover = !1, i.isComposing = !1, i.commonProps = void 0, i.initialTouchX = 0, i.initialTouchY = 0, i.openAfterFocus = !1, i.scrollToFocusedOptionOnUpdate = !1, i.userIsDragging = void 0, i.isAppleDevice = sD(), i.controlRef = null, i.getControlRef = function (l) { i.controlRef = l }, i.focusedOptionRef = null, i.getFocusedOptionRef = function (l) { i.focusedOptionRef = l }, i.menuListRef = null, i.getMenuListRef = function (l) { i.menuListRef = l }, i.inputRef = null, i.getInputRef = function (l) { i.inputRef = l }, i.focus = i.focusInput, i.blur = i.blurInput, i.onChange = function (l, u) { var c = i.props, d = c.onChange, h = c.name; u.name = h, i.ariaOnChange(l, u), d(l, u) }, i.setValue = function (l, u, c) { var d = i.props, h = d.closeMenuOnSelect, f = d.isMulti, g = d.inputValue; i.onInputChange("", { action: "set-value", prevInputValue: g }), h && (i.setState({ inputIsHiddenAfterUpdate: !f }), i.onMenuClose()), i.setState({ clearFocusValueOnUpdate: !0 }), i.onChange(l, { action: u, option: c }) }, i.selectOption = function (l) { var u = i.props, c = u.blurInputOnSelect, d = u.isMulti, h = u.name, f = i.state.selectValue, g = d && i.isOptionSelected(l, f), m = i.isOptionDisabled(l, f); if (g) { var y = i.getOptionValue(l); i.setValue(f.filter(function (p) { return i.getOptionValue(p) !== y }), "deselect-option", l) } else if (!m) d ? i.setValue([].concat(pf(f), [l]), "select-option", l) : i.setValue(l, "select-option"); else { i.ariaOnChange(l, { action: "select-option", option: l, name: h }); return } c && i.blurInput() }, i.removeValue = function (l) { var u = i.props.isMulti, c = i.state.selectValue, d = i.getOptionValue(l), h = c.filter(function (g) { return i.getOptionValue(g) !== d }), f = fa(u, h, h[0] || null); i.onChange(f, { action: "remove-value", removedValue: l }), i.focusInput() }, i.clearValue = function () { var l = i.state.selectValue; i.onChange(fa(i.props.isMulti, [], null), { action: "clear", removedValues: l }) }, i.popValue = function () { var l = i.props.isMulti, u = i.state.selectValue, c = u[u.length - 1], d = u.slice(0, u.length - 1), h = fa(l, d, d[0] || null); i.onChange(h, { action: "pop-value", removedValue: c }) }, i.getFocusedOptionId = function (l) { return bc(i.state.focusableOptionsWithIds, l) }, i.getFocusableOptionsWithIds = function () { return cv(ja(i.props, i.state.selectValue), i.getElementId("option")) }, i.getValue = function () { return i.state.selectValue }, i.cx = function () { for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)u[c] = arguments[c]; return lM.apply(void 0, [i.props.classNamePrefix].concat(u)) }, i.getOptionLabel = function (l) { return H_(i.props, l) }, i.getOptionValue = function (l) { return kl(i.props, l) }, i.getStyles = function (l, u) { var c = i.props.unstyled, d = cD[l](u, c); d.boxSizing = "border-box"; var h = i.props.styles[l]; return h ? h(d, u) : d }, i.getClassNames = function (l, u) { var c, d; return (c = (d = i.props.classNames)[l]) === null || c === void 0 ? void 0 : c.call(d, u) }, i.getElementId = function (l) { return "".concat(i.state.instancePrefix, "-").concat(l) }, i.getComponents = function () { return ML(i.props) }, i.buildCategorizedOptions = function () { return ja(i.props, i.state.selectValue) }, i.getCategorizedOptions = function () { return i.props.menuIsOpen ? i.buildCategorizedOptions() : [] }, i.buildFocusableOptions = function () { return U_(i.buildCategorizedOptions()) }, i.getFocusableOptions = function () { return i.props.menuIsOpen ? i.buildFocusableOptions() : [] }, i.ariaOnChange = function (l, u) { i.setState({ ariaSelection: Q({ value: l }, u) }) }, i.onMenuMouseDown = function (l) { l.button === 0 && (l.stopPropagation(), l.preventDefault(), i.focusInput()) }, i.onMenuMouseMove = function (l) { i.blockOptionHover = !1 }, i.onControlMouseDown = function (l) { if (!l.defaultPrevented) { var u = i.props.openMenuOnClick; i.state.isFocused ? i.props.menuIsOpen ? l.target.tagName !== "INPUT" && l.target.tagName !== "TEXTAREA" && i.onMenuClose() : u && i.openMenu("first") : (u && (i.openAfterFocus = !0), i.focusInput()), l.target.tagName !== "INPUT" && l.target.tagName !== "TEXTAREA" && l.preventDefault() } }, i.onDropdownIndicatorMouseDown = function (l) { if (!(l && l.type === "mousedown" && l.button !== 0) && !i.props.isDisabled) { var u = i.props, c = u.isMulti, d = u.menuIsOpen; i.focusInput(), d ? (i.setState({ inputIsHiddenAfterUpdate: !c }), i.onMenuClose()) : i.openMenu("first"), l.preventDefault() } }, i.onClearIndicatorMouseDown = function (l) { l && l.type === "mousedown" && l.button !== 0 || (i.clearValue(), l.preventDefault(), i.openAfterFocus = !1, l.type === "touchend" ? i.focusInput() : setTimeout(function () { return i.focusInput() })) }, i.onScroll = function (l) { typeof i.props.closeMenuOnScroll == "boolean" ? l.target instanceof HTMLElement && gu(l.target) && i.props.onMenuClose() : typeof i.props.closeMenuOnScroll == "function" && i.props.closeMenuOnScroll(l) && i.props.onMenuClose() }, i.onCompositionStart = function () { i.isComposing = !0 }, i.onCompositionEnd = function () { i.isComposing = !1 }, i.onTouchStart = function (l) { var u = l.touches, c = u && u.item(0); c && (i.initialTouchX = c.clientX, i.initialTouchY = c.clientY, i.userIsDragging = !1) }, i.onTouchMove = function (l) { var u = l.touches, c = u && u.item(0); if (c) { var d = Math.abs(c.clientX - i.initialTouchX), h = Math.abs(c.clientY - i.initialTouchY), f = 5; i.userIsDragging = d > f || h > f } }, i.onTouchEnd = function (l) { i.userIsDragging || (i.controlRef && !i.controlRef.contains(l.target) && i.menuListRef && !i.menuListRef.contains(l.target) && i.blurInput(), i.initialTouchX = 0, i.initialTouchY = 0) }, i.onControlTouchEnd = function (l) { i.userIsDragging || i.onControlMouseDown(l) }, i.onClearIndicatorTouchEnd = function (l) { i.userIsDragging || i.onClearIndicatorMouseDown(l) }, i.onDropdownIndicatorTouchEnd = function (l) { i.userIsDragging || i.onDropdownIndicatorMouseDown(l) }, i.handleInputChange = function (l) { var u = i.props.inputValue, c = l.currentTarget.value; i.setState({ inputIsHiddenAfterUpdate: !1 }), i.onInputChange(c, { action: "input-change", prevInputValue: u }), i.props.menuIsOpen || i.onMenuOpen() }, i.onInputFocus = function (l) { i.props.onFocus && i.props.onFocus(l), i.setState({ inputIsHiddenAfterUpdate: !1, isFocused: !0 }), (i.openAfterFocus || i.props.openMenuOnFocus) && i.openMenu("first"), i.openAfterFocus = !1 }, i.onInputBlur = function (l) { var u = i.props.inputValue; if (i.menuListRef && i.menuListRef.contains(document.activeElement)) { i.inputRef.focus(); return } i.props.onBlur && i.props.onBlur(l), i.onInputChange("", { action: "input-blur", prevInputValue: u }), i.onMenuClose(), i.setState({ focusedValue: null, isFocused: !1 }) }, i.onOptionHover = function (l) { if (!(i.blockOptionHover || i.state.focusedOption === l)) { var u = i.getFocusableOptions(), c = u.indexOf(l); i.setState({ focusedOption: l, focusedOptionId: c > -1 ? i.getFocusedOptionId(l) : null }) } }, i.shouldHideSelectedOptions = function () { return G_(i.props) }, i.onValueInputFocus = function (l) { l.preventDefault(), l.stopPropagation(), i.focus() }, i.onKeyDown = function (l) { var u = i.props, c = u.isMulti, d = u.backspaceRemovesValue, h = u.escapeClearsValue, f = u.inputValue, g = u.isClearable, m = u.isDisabled, y = u.menuIsOpen, p = u.onKeyDown, v = u.tabSelectsValue, b = u.openMenuOnFocus, x = i.state, P = x.focusedOption, M = x.focusedValue, I = x.selectValue; if (!m && !(typeof p == "function" && (p(l), l.defaultPrevented))) { switch (i.blockOptionHover = !0, l.key) { case "ArrowLeft": if (!c || f) return; i.focusValue("previous"); break; case "ArrowRight": if (!c || f) return; i.focusValue("next"); break; case "Delete": case "Backspace": if (f) return; if (M) i.removeValue(M); else { if (!d) return; c ? i.popValue() : g && i.clearValue() } break; case "Tab": if (i.isComposing || l.shiftKey || !y || !v || !P || b && i.isOptionSelected(P, I)) return; i.selectOption(P); break; case "Enter": if (l.keyCode === 229) break; if (y) { if (!P || i.isComposing) return; i.selectOption(P); break } return; case "Escape": y ? (i.setState({ inputIsHiddenAfterUpdate: !1 }), i.onInputChange("", { action: "menu-close", prevInputValue: f }), i.onMenuClose()) : g && h && i.clearValue(); break; case " ": if (f) return; if (!y) { i.openMenu("first"); break } if (!P) return; i.selectOption(P); break; case "ArrowUp": y ? i.focusOption("up") : i.openMenu("last"); break; case "ArrowDown": y ? i.focusOption("down") : i.openMenu("first"); break; case "PageUp": if (!y) return; i.focusOption("pageup"); break; case "PageDown": if (!y) return; i.focusOption("pagedown"); break; case "Home": if (!y) return; i.focusOption("first"); break; case "End": if (!y) return; i.focusOption("last"); break; default: return }l.preventDefault() } }, i.state.instancePrefix = "react-select-" + (i.props.instanceId || ++_D), i.state.selectValue = Ym(r.value), r.menuIsOpen && i.state.selectValue.length) { var s = i.getFocusableOptionsWithIds(), o = i.buildFocusableOptions(), a = o.indexOf(i.state.selectValue[0]); i.state.focusableOptionsWithIds = s, i.state.focusedOption = o[a], i.state.focusedOptionId = bc(s, o[a]) } return i } return MI(n, [{ key: "componentDidMount", value: function () { this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && Qm(this.menuListRef, this.focusedOptionRef) } }, { key: "componentDidUpdate", value: function (i) { var s = this.props, o = s.isDisabled, a = s.menuIsOpen, l = this.state.isFocused; (l && !o && i.isDisabled || l && a && !i.menuIsOpen) && this.focusInput(), l && o && !i.isDisabled ? this.setState({ isFocused: !1 }, this.onMenuClose) : !l && !o && i.isDisabled && this.inputRef === document.activeElement && this.setState({ isFocused: !0 }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (Qm(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1) } }, { key: "componentWillUnmount", value: function () { this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0) } }, { key: "onMenuOpen", value: function () { this.props.onMenuOpen() } }, { key: "onMenuClose", value: function () { this.onInputChange("", { action: "menu-close", prevInputValue: this.props.inputValue }), this.props.onMenuClose() } }, { key: "onInputChange", value: function (i, s) { this.props.onInputChange(i, s) } }, { key: "focusInput", value: function () { this.inputRef && this.inputRef.focus() } }, { key: "blurInput", value: function () { this.inputRef && this.inputRef.blur() } }, { key: "openMenu", value: function (i) { var s = this, o = this.state, a = o.selectValue, l = o.isFocused, u = this.buildFocusableOptions(), c = i === "first" ? 0 : u.length - 1; if (!this.props.isMulti) { var d = u.indexOf(a[0]); d > -1 && (c = d) } this.scrollToFocusedOptionOnUpdate = !(l && this.menuListRef), this.setState({ inputIsHiddenAfterUpdate: !1, focusedValue: null, focusedOption: u[c], focusedOptionId: this.getFocusedOptionId(u[c]) }, function () { return s.onMenuOpen() }) } }, { key: "focusValue", value: function (i) { var s = this.state, o = s.selectValue, a = s.focusedValue; if (this.props.isMulti) { this.setState({ focusedOption: null }); var l = o.indexOf(a); a || (l = -1); var u = o.length - 1, c = -1; if (o.length) { switch (i) { case "previous": l === 0 ? c = 0 : l === -1 ? c = u : c = l - 1; break; case "next": l > -1 && l < u && (c = l + 1); break }this.setState({ inputIsHidden: c !== -1, focusedValue: o[c] }) } } } }, { key: "focusOption", value: function () { var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", s = this.props.pageSize, o = this.state.focusedOption, a = this.getFocusableOptions(); if (a.length) { var l = 0, u = a.indexOf(o); o || (u = -1), i === "up" ? l = u > 0 ? u - 1 : a.length - 1 : i === "down" ? l = (u + 1) % a.length : i === "pageup" ? (l = u - s, l < 0 && (l = 0)) : i === "pagedown" ? (l = u + s, l > a.length - 1 && (l = a.length - 1)) : i === "last" && (l = a.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({ focusedOption: a[l], focusedValue: null, focusedOptionId: this.getFocusedOptionId(a[l]) }) } } }, { key: "getTheme", value: function () { return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(yc) : Q(Q({}, yc), this.props.theme) : yc } }, { key: "getCommonProps", value: function () { var i = this.clearValue, s = this.cx, o = this.getStyles, a = this.getClassNames, l = this.getValue, u = this.selectOption, c = this.setValue, d = this.props, h = d.isMulti, f = d.isRtl, g = d.options, m = this.hasValue(); return { clearValue: i, cx: s, getStyles: o, getClassNames: a, getValue: l, hasValue: m, isMulti: h, isRtl: f, options: g, selectOption: u, selectProps: d, setValue: c, theme: this.getTheme() } } }, { key: "hasValue", value: function () { var i = this.state.selectValue; return i.length > 0 } }, { key: "hasOptions", value: function () { return !!this.getFocusableOptions().length } }, { key: "isClearable", value: function () { var i = this.props, s = i.isClearable, o = i.isMulti; return s === void 0 ? o : s } }, { key: "isOptionDisabled", value: function (i, s) { return W_(this.props, i, s) } }, { key: "isOptionSelected", value: function (i, s) { return q_(this.props, i, s) } }, { key: "filterOption", value: function (i, s) { return K_(this.props, i, s) } }, { key: "formatOptionLabel", value: function (i, s) { if (typeof this.props.formatOptionLabel == "function") { var o = this.props.inputValue, a = this.state.selectValue; return this.props.formatOptionLabel(i, { context: s, inputValue: o, selectValue: a }) } else return this.getOptionLabel(i) } }, { key: "formatGroupLabel", value: function (i) { return this.props.formatGroupLabel(i) } }, { key: "startListeningComposition", value: function () { document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1)) } }, { key: "stopListeningComposition", value: function () { document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd)) } }, { key: "startListeningToTouch", value: function () { document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1)) } }, { key: "stopListeningToTouch", value: function () { document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd)) } }, { key: "renderInput", value: function () { var i = this.props, s = i.isDisabled, o = i.isSearchable, a = i.inputId, l = i.inputValue, u = i.tabIndex, c = i.form, d = i.menuIsOpen, h = i.required, f = this.getComponents(), g = f.Input, m = this.state, y = m.inputIsHidden, p = m.ariaSelection, v = this.commonProps, b = a || this.getElementId("input"), x = Q(Q(Q({ "aria-autocomplete": "list", "aria-expanded": d, "aria-haspopup": !0, "aria-errormessage": this.props["aria-errormessage"], "aria-invalid": this.props["aria-invalid"], "aria-label": this.props["aria-label"], "aria-labelledby": this.props["aria-labelledby"], "aria-required": h, role: "combobox", "aria-activedescendant": this.isAppleDevice ? void 0 : this.state.focusedOptionId || "" }, d && { "aria-controls": this.getElementId("listbox") }), !o && { "aria-readonly": !0 }), this.hasValue() ? (p == null ? void 0 : p.action) === "initial-input-focus" && { "aria-describedby": this.getElementId("live-region") } : { "aria-describedby": this.getElementId("placeholder") }); return o ? R.createElement(g, X({}, v, { autoCapitalize: "none", autoComplete: "off", autoCorrect: "off", id: b, innerRef: this.getInputRef, isDisabled: s, isHidden: y, onBlur: this.onInputBlur, onChange: this.handleInputChange, onFocus: this.onInputFocus, spellCheck: "false", tabIndex: u, form: c, type: "text", value: l }, x)) : R.createElement(qL, X({ id: b, innerRef: this.getInputRef, onBlur: this.onInputBlur, onChange: xl, onFocus: this.onInputFocus, disabled: s, tabIndex: u, inputMode: "none", form: c, value: "" }, x)) } }, { key: "renderPlaceholderOrValue", value: function () { var i = this, s = this.getComponents(), o = s.MultiValue, a = s.MultiValueContainer, l = s.MultiValueLabel, u = s.MultiValueRemove, c = s.SingleValue, d = s.Placeholder, h = this.commonProps, f = this.props, g = f.controlShouldRenderValue, m = f.isDisabled, y = f.isMulti, p = f.inputValue, v = f.placeholder, b = this.state, x = b.selectValue, P = b.focusedValue, M = b.isFocused; if (!this.hasValue() || !g) return p ? null : R.createElement(d, X({}, h, { key: "placeholder", isDisabled: m, isFocused: M, innerProps: { id: this.getElementId("placeholder") } }), v); if (y) return x.map(function (C, T) { var L = C === P, D = "".concat(i.getOptionLabel(C), "-").concat(i.getOptionValue(C)); return R.createElement(o, X({}, h, { components: { Container: a, Label: l, Remove: u }, isFocused: L, isDisabled: m, key: D, index: T, removeProps: { onClick: function () { return i.removeValue(C) }, onTouchEnd: function () { return i.removeValue(C) }, onMouseDown: function (F) { F.preventDefault() } }, data: C }), i.formatOptionLabel(C, "value")) }); if (p) return null; var I = x[0]; return R.createElement(c, X({}, h, { data: I, isDisabled: m }), this.formatOptionLabel(I, "value")) } }, { key: "renderClearIndicator", value: function () { var i = this.getComponents(), s = i.ClearIndicator, o = this.commonProps, a = this.props, l = a.isDisabled, u = a.isLoading, c = this.state.isFocused; if (!this.isClearable() || !s || l || !this.hasValue() || u) return null; var d = { onMouseDown: this.onClearIndicatorMouseDown, onTouchEnd: this.onClearIndicatorTouchEnd, "aria-hidden": "true" }; return R.createElement(s, X({}, o, { innerProps: d, isFocused: c })) } }, { key: "renderLoadingIndicator", value: function () { var i = this.getComponents(), s = i.LoadingIndicator, o = this.commonProps, a = this.props, l = a.isDisabled, u = a.isLoading, c = this.state.isFocused; if (!s || !u) return null; var d = { "aria-hidden": "true" }; return R.createElement(s, X({}, o, { innerProps: d, isDisabled: l, isFocused: c })) } }, { key: "renderIndicatorSeparator", value: function () { var i = this.getComponents(), s = i.DropdownIndicator, o = i.IndicatorSeparator; if (!s || !o) return null; var a = this.commonProps, l = this.props.isDisabled, u = this.state.isFocused; return R.createElement(o, X({}, a, { isDisabled: l, isFocused: u })) } }, { key: "renderDropdownIndicator", value: function () { var i = this.getComponents(), s = i.DropdownIndicator; if (!s) return null; var o = this.commonProps, a = this.props.isDisabled, l = this.state.isFocused, u = { onMouseDown: this.onDropdownIndicatorMouseDown, onTouchEnd: this.onDropdownIndicatorTouchEnd, "aria-hidden": "true" }; return R.createElement(s, X({}, o, { innerProps: u, isDisabled: a, isFocused: l })) } }, { key: "renderMenu", value: function () { var i = this, s = this.getComponents(), o = s.Group, a = s.GroupHeading, l = s.Menu, u = s.MenuList, c = s.MenuPortal, d = s.LoadingMessage, h = s.NoOptionsMessage, f = s.Option, g = this.commonProps, m = this.state.focusedOption, y = this.props, p = y.captureMenuScroll, v = y.inputValue, b = y.isLoading, x = y.loadingMessage, P = y.minMenuHeight, M = y.maxMenuHeight, I = y.menuIsOpen, C = y.menuPlacement, T = y.menuPosition, L = y.menuPortalTarget, D = y.menuShouldBlockScroll, N = y.menuShouldScrollIntoView, F = y.noOptionsMessage, B = y.onMenuScrollToTop, H = y.onMenuScrollToBottom; if (!I) return null; var q = function (O, j) { var $ = O.type, z = O.data, W = O.isDisabled, K = O.isSelected, Z = O.label, re = O.value, ue = m === z, tt = W ? void 0 : function () { return i.onOptionHover(z) }, ot = W ? void 0 : function () { return i.selectOption(z) }, Qt = "".concat(i.getElementId("option"), "-").concat(j), qe = { id: Qt, onClick: ot, onMouseMove: tt, onMouseOver: tt, tabIndex: -1, role: "option", "aria-selected": i.isAppleDevice ? void 0 : K }; return R.createElement(f, X({}, g, { innerProps: qe, data: z, isDisabled: W, isSelected: K, key: Qt, label: Z, type: $, value: re, isFocused: ue, innerRef: ue ? i.getFocusedOptionRef : void 0 }), i.formatOptionLabel(O.data, "menu")) }, V; if (this.hasOptions()) V = this.getCategorizedOptions().map(function (w) { if (w.type === "group") { var O = w.data, j = w.options, $ = w.index, z = "".concat(i.getElementId("group"), "-").concat($), W = "".concat(z, "-heading"); return R.createElement(o, X({}, g, { key: z, data: O, options: j, Heading: a, headingProps: { id: W, data: w.data }, label: i.formatGroupLabel(w.data) }), w.options.map(function (K) { return q(K, "".concat($, "-").concat(K.index)) })) } else if (w.type === "option") return q(w, "".concat(w.index)) }); else if (b) { var A = x({ inputValue: v }); if (A === null) return null; V = R.createElement(d, g, A) } else { var _ = F({ inputValue: v }); if (_ === null) return null; V = R.createElement(h, g, _) } var S = { minMenuHeight: P, maxMenuHeight: M, menuPlacement: C, menuPosition: T, menuShouldScrollIntoView: N }, E = R.createElement(kM, X({}, g, S), function (w) { var O = w.ref, j = w.placerProps, $ = j.placement, z = j.maxHeight; return R.createElement(l, X({}, g, S, { innerRef: O, innerProps: { onMouseDown: i.onMenuMouseDown, onMouseMove: i.onMenuMouseMove }, isLoading: b, placement: $ }), R.createElement(JL, { captureEnabled: p, onTopArrive: B, onBottomArrive: H, lockEnabled: D }, function (W) { return R.createElement(u, X({}, g, { innerRef: function (Z) { i.getMenuListRef(Z), W(Z) }, innerProps: { role: "listbox", "aria-multiselectable": g.isMulti, id: i.getElementId("listbox") }, isLoading: b, maxHeight: z, focusedOption: m }), V) })) }); return L || T === "fixed" ? R.createElement(c, X({}, g, { appendTo: L, controlElement: this.controlRef, menuPlacement: C, menuPosition: T }), E) : E } }, { key: "renderFormField", value: function () { var i = this, s = this.props, o = s.delimiter, a = s.isDisabled, l = s.isMulti, u = s.name, c = s.required, d = this.state.selectValue; if (c && !this.hasValue() && !a) return R.createElement(tD, { name: u, onFocus: this.onValueInputFocus }); if (!(!u || a)) if (l) if (o) { var h = d.map(function (m) { return i.getOptionValue(m) }).join(o); return R.createElement("input", { name: u, type: "hidden", value: h }) } else { var f = d.length > 0 ? d.map(function (m, y) { return R.createElement("input", { key: "i-".concat(y), name: u, type: "hidden", value: i.getOptionValue(m) }) }) : R.createElement("input", { name: u, type: "hidden", value: "" }); return R.createElement("div", null, f) } else { var g = d[0] ? this.getOptionValue(d[0]) : ""; return R.createElement("input", { name: u, type: "hidden", value: g }) } } }, { key: "renderLiveRegion", value: function () { var i = this.commonProps, s = this.state, o = s.ariaSelection, a = s.focusedOption, l = s.focusedValue, u = s.isFocused, c = s.selectValue, d = this.getFocusableOptions(); return R.createElement(zL, X({}, i, { id: this.getElementId("live-region"), ariaSelection: o, focusedOption: a, focusedValue: l, isFocused: u, selectValue: c, focusableOptions: d, isAppleDevice: this.isAppleDevice })) } }, { key: "render", value: function () { var i = this.getComponents(), s = i.Control, o = i.IndicatorsContainer, a = i.SelectContainer, l = i.ValueContainer, u = this.props, c = u.className, d = u.id, h = u.isDisabled, f = u.menuIsOpen, g = this.state.isFocused, m = this.commonProps = this.getCommonProps(); return R.createElement(a, X({}, m, { className: c, innerProps: { id: d, onKeyDown: this.onKeyDown }, isDisabled: h, isFocused: g }), this.renderLiveRegion(), R.createElement(s, X({}, m, { innerRef: this.getControlRef, innerProps: { onMouseDown: this.onControlMouseDown, onTouchEnd: this.onControlTouchEnd }, isDisabled: h, isFocused: g, menuIsOpen: f }), R.createElement(l, X({}, m, { isDisabled: h }), this.renderPlaceholderOrValue(), this.renderInput()), R.createElement(o, X({}, m, { isDisabled: h }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField()) } }], [{ key: "getDerivedStateFromProps", value: function (i, s) { var o = s.prevProps, a = s.clearFocusValueOnUpdate, l = s.inputIsHiddenAfterUpdate, u = s.ariaSelection, c = s.isFocused, d = s.prevWasFocused, h = s.instancePrefix, f = i.options, g = i.value, m = i.menuIsOpen, y = i.inputValue, p = i.isMulti, v = Ym(g), b = {}; if (o && (g !== o.value || f !== o.options || m !== o.menuIsOpen || y !== o.inputValue)) { var x = m ? vD(i, v) : [], P = m ? cv(ja(i, v), "".concat(h, "-option")) : [], M = a ? yD(s, v) : null, I = bD(s, x), C = bc(P, I); b = { selectValue: v, focusedOption: I, focusedOptionId: C, focusableOptionsWithIds: P, focusedValue: M, clearFocusValueOnUpdate: !1 } } var T = l != null && i !== o ? { inputIsHidden: l, inputIsHiddenAfterUpdate: void 0 } : {}, L = u, D = c && d; return c && !D && (L = { value: fa(p, v, v[0] || null), options: v, action: "initial-input-focus" }, D = !d), (u == null ? void 0 : u.action) === "initial-input-focus" && (L = null), Q(Q(Q({}, b), T), {}, { prevProps: i, ariaSelection: L, prevWasFocused: D }) } }]), n }(R.Component); Y_.defaultProps = mD; var wD = R.forwardRef(function (t, e) { var n = II(t); return R.createElement(Y_, X({ ref: e }, n)) }), _c = wD; eu.register(Rd, Md, Ra, V2, Y2, $2); const xD = ({ accounts: t }) => { const [e, n] = R.useState([]), [r, i] = R.useState([]), [s, o] = R.useState("year"), [a, l] = R.useState("DepenseCarteBleue"), [u, c] = R.useState([]), d = I => { n(I) }, h = I => { o(I.value) }, f = I => { l(I.value) }, g = I => { if (!I) return null; const [C, T, L] = I.split("/").map(Number); return new Date(L, T - 1, C) }, m = R.useMemo(() => t.filter(I => { const C = g(I.date); return C ? (e.length === 0 || e.some(T => T.value === I.Categorie)) && (r.length === 0 || r.some(T => { const L = g(T.value); return L ? s === "month" ? L.getMonth() === C.getMonth() : L.getFullYear() === C.getFullYear() : !1 })) : !1 }), [t, e, r, s]), y = I => { const C = g(I); if (!C) return I; switch (s) { case "year": return C.getFullYear().toString(); case "month": return C.toLocaleString("default", { month: "long", year: "numeric" }); case "day": return I; default: return I } }, [p, v] = R.useState({ labels: [], datasets: [{ label: a, data: [], backgroundColor: "rgba(75, 192, 192, 0.2)", borderColor: "rgba(75, 192, 192, 1)", borderWidth: 1 }] }); R.useEffect(() => { const I = Array.from(new Set(m.map(T => y(T.date)))).sort((T, L) => { let D, N; return s === "day" ? (D = g(T), N = g(L)) : (D = new Date(T), N = new Date(L)), (D ? D.getTime() : 0) - (N ? N.getTime() : 0) }), C = I.map(T => m.filter(L => y(L.date) === T).reduce((L, D) => L + parseFloat(D[a] || "0"), 0)); v({ labels: I, datasets: [{ label: a, data: C, backgroundColor: "rgba(75, 192, 192, 0.2)", borderColor: "rgba(75, 192, 192, 1)", borderWidth: 1 }] }) }, [m, a, s]); const b = R.useMemo(() => { if (t.length === 0) return []; const I = t[0]; return Object.keys(I).filter(C => C !== "id" && C !== "date" && C !== "NomDeLaDepense" && C !== "Categorie" && C !== "ARevoir" && C !== "user_id").map(C => ({ value: C, label: C.replace(/([A-Z])/g, " $1").trim() })) }, [t]), x = R.useMemo(() => t.reduce((I, C) => (b.forEach(T => { const L = T.value; I[L] || (I[L] = new Set), C[L] && parseFloat(C[L]) !== 0 && I[L].add(C.Categorie) }), I), {}), [t, b]); R.useEffect(() => { x[a] ? c(Array.from(x[a]).map(I => ({ value: I, label: I }))) : c([]) }, [a, x]), Array.from(new Set(t.map(I => I.date))).map(I => ({ value: I, label: I })); const P = [{ value: "year", label: "Anne" }, { value: "month", label: "Mois" }, { value: "day", label: "Jour" }], M = { option: (I, C) => ({ ...I, color: C.isSelected ? "darkgray" : "gray" }), singleValue: (I, C) => ({ ...I, color: "darkgray" }), multiValue: (I, C) => ({ ...I, color: "darkgray" }), multiValueLabel: (I, C) => ({ ...I, color: "darkgray" }) }; return k.jsxs("div", { className: "account-charts max-sm:w-11/12 h-[80vh] sm:w-2/3 mx-auto p-4 m-4 bg-gray-100 rounded-md text-center", children: [k.jsx("h2", { className: "text-xl text-black mb-4", children: "Graphiques des Dpenses" }), k.jsxs("div", { className: "mb-4 flex flex-col sm:flex-row justify-around", children: [k.jsx(_c, { options: P, onChange: h, placeholder: "Trier par", className: "mb-2 sm:mb-0 w-full sm:w-1/3", styles: M }), k.jsx(_c, { options: b, onChange: f, placeholder: "Slectionner le type de dpense", className: "mb-2 sm:mb-0 w-full sm:w-1/3", styles: M }), k.jsx(_c, { isMulti: !0, options: u, onChange: d, placeholder: "Filtrer par catgorie", className: "w-full sm:w-1/3", styles: M })] }), k.jsx("div", { className: "sm:h-[60vh] max-sm:h-[50vh]", children: k.jsx(SI, { data: p, options: { responsive: !0, maintainAspectRatio: !1, plugins: { legend: { position: "top" }, title: { display: !0, text: a } } } }) })] }) }, SD = () => { const [t, e] = R.useState(""), [n, r] = R.useState(""), [i, s] = R.useState(!1), o = Vr(), a = async l => { if (l.preventDefault(), i) { const { error: u } = await we.auth.signUp({ email: t, password: n }); u ? alert("Erreur lors de la cration du compte : " + u.message) : (alert("Veuillez vrifier votre bote de rception pour confirmer votre compte."), s(!1)) } else { const { error: u } = await we.auth.signInWithPassword({ email: t, password: n }); u ? alert("Erreur de connexion : " + u.message) : (o("/"), window.location.reload()) } }; return k.jsxs("form", { onSubmit: a, className: "contact-form mx-auto w-96 bg-gray-500 p-8 rounded-lg shadow-md m-8", children: [k.jsx("h2", { className: "text-2xl mb-4", children: i ? "Inscription" : "Connexion" }), k.jsxs("div", { className: "mb-4", children: [k.jsx("label", { children: "Email" }), k.jsx("input", { type: "email", value: t, onChange: l => e(l.target.value), className: "border p-2 w-full" })] }), k.jsxs("div", { className: "mb-4", children: [k.jsx("label", { children: "Password" }), k.jsx("input", { type: "password", value: n, onChange: l => r(l.target.value), className: "border p-2 w-full" })] }), k.jsx("button", { type: "submit", className: "bg-blue-500 text-white p-2", children: i ? "Inscription" : "Connexion" }), k.jsx("div", { className: "mt-4", children: k.jsx("button", { type: "button", onClick: () => s(!i), className: "text-blue-500", children: i ? "Dj un compte ? Connectez-vous !" : "Pas de compte ? Inscrivez-vous !" }) })] }) }; var Q_ = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, hv = Dt.createContext && Dt.createContext(Q_), kD = ["attr", "size", "title"]; function CD(t, e) { if (t == null) return {}; var n = OD(t, e), r, i; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(t); for (i = 0; i < s.length; i++)r = s[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function OD(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function Cl() { return Cl = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Cl.apply(this, arguments) } function fv(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Ol(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? fv(Object(n), !0).forEach(function (r) { PD(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : fv(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function PD(t, e, n) { return e = ED(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function ED(t) { var e = TD(t, "string"); return typeof e == "symbol" ? e : e + "" } function TD(t, e) { if (typeof t != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e || "default"); if (typeof r != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function X_(t) { return t && t.map((e, n) => Dt.createElement(e.tag, Ol({ key: n }, e.attr), X_(e.child))) } function ID(t) { return e => Dt.createElement(RD, Cl({ attr: Ol({}, t.attr) }, e), X_(t.child)) } function RD(t) { var e = n => { var { attr: r, size: i, title: s } = t, o = CD(t, kD), a = i || n.size || "1em", l; return n.className && (l = n.className), t.className && (l = (l ? l + " " : "") + t.className), Dt.createElement("svg", Cl({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, n.attr, r, o, { className: l, style: Ol(Ol({ color: t.color || n.color }, n.style), t.style), height: a, width: a, xmlns: "http://www.w3.org/2000/svg" }), s && Dt.createElement("title", null, s), t.children) }; return hv !== void 0 ? Dt.createElement(hv.Consumer, null, n => e(n)) : e(Q_) } function MD(t) { return ID({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z" }, child: [] }] })(t) } const LD = () => { const [t, e] = R.useState(null), [n, r] = R.useState(""), [i, s] = R.useState([]), [o, a] = R.useState(""), [l, u] = R.useState(["date", "NomDeLaDepense", "Categorie", "ARevoir"]), [c, d] = R.useState(null), [h, f] = R.useState(""); Vr(), R.useEffect(() => { (async () => { var A, _, S; const { data: N, error: F } = await we.auth.getUser(); if (F) { console.error("Erreur lors de la rcupration de lutilisateur :", F); return } const B = N.user; e(B), r(((A = B == null ? void 0 : B.user_metadata) == null ? void 0 : A.full_name) || ""); const q = (((_ = B == null ? void 0 : B.user_metadata) == null ? void 0 : _.livrets) || []).map(E => ({ ...E, id: E.id || `${E.name}-${Date.now()}` })); q.some(E => E.id === "CarteBleue-Initial") || q.push({ id: "CarteBleue-Initial", name: "CarteBleue", obtained: !1, expense: !1, move: !1 }), s(q), u(((S = B == null ? void 0 : B.user_metadata) == null ? void 0 : S.columnOrder) || ["date", "NomDeLaDepense", "Categorie", "ARevoir"]) })() }, []); const g = async D => { if (D.preventDefault(), !window.confirm("tes-vous sr de vouloir sauvegarder les modifications ?")) return; if (!t) { console.error("Utilisateur non authentifi"); return } if (l.some((H, q) => l.indexOf(H) !== q)) { alert("Chaque colonne doit tre unique. Veuillez vrifier lordre des colonnes."); return } const { error: B } = await we.auth.updateUser({ data: { full_name: n, livrets: i, columnOrder: l } }); if (B) { console.error("Erreur lors de la mise  jour des informations de lutilisateur :", B); return } e(H => ({ ...H, user_metadata: { ...H.user_metadata, full_name: n, livrets: i, columnOrder: l } })), window.location.reload() }, m = (D, N) => { const F = [...l]; F[D] = N, u(F) }, y = () => { const D = [...l], N = D.length - 1; D.splice(N, 0, "date"), u(D) }, p = D => { window.confirm("tes-vous sr de vouloir supprimer cette colonne ?") && u(l.filter((F, B) => B !== D)) }, v = D => D.replace(/CarteBleue/, "Carte Bleue"), b = D => D.replace(/Carte Bleue/, "CarteBleue"), x = () => { if (o && !i.find(D => D.name === b(o))) { const D = `${b(o)}-${Date.now()}`; s([...i, { id: D, name: b(o), obtained: !1, expense: !1, move: !1 }]), a("") } }, P = D => { window.confirm("tes-vous sr de vouloir supprimer ce livret ?") && s(i.filter(F => F.id !== D)) }, M = (D, N, F) => { const B = [...i]; B[D][N] = F, s(B) }, I = (D, N, F) => { const B = [...i], H = B[D]; F ? (H.moveTo || (H.moveTo = []), H.moveTo.includes(N) || H.moveTo.push(N)) : H.moveTo && (H.moveTo = H.moveTo.filter(q => q !== N)), s(B) }, C = () => i.every(D => D.obtained || D.expense || D.move), T = D => { d(D), f(i[D].name) }, L = D => { const N = [...i]; N[D].name = b(h), s(N), d(null) }; return k.jsxs("div", { className: "p-4", children: [k.jsx("h2", { className: "text-xl sm:text-2xl mb-4", children: "Paramtres du compte" }), t && k.jsx("form", { onSubmit: g, className: "space-y-4", children: k.jsxs("div", { className: "space-y-4", children: [k.jsxs("div", { className: "flex flex-col sm:flex-row sm:justify-evenly gap-4", children: [k.jsxs("div", { className: "mb-4", children: [k.jsx("label", { children: "Email" }), k.jsx("input", { type: "email", value: t.email, disabled: !0, className: "border p-2 w-full" })] }), k.jsxs("div", { className: "mb-4", children: [k.jsx("label", { children: "Nom" }), k.jsx("input", { type: "text", value: n, onChange: D => r(D.target.value), className: "border p-2 w-full" })] })] }), k.jsxs("div", { className: "mb-4", children: [k.jsx("label", { children: "Mes Livrets" }), k.jsx("div", { className: "grid gap-4 items-center", children: i.map((D, N) => k.jsxs("div", { className: "grid grid-cols-12 gap-2 items-center", children: [k.jsx("div", { className: "col-span-12 sm:col-span-2 flex items-center gap-2", children: c === N ? k.jsxs(k.Fragment, { children: [k.jsx("input", { type: "text", value: h, onChange: F => f(F.target.value), className: "border p-2" }), k.jsx("button", { type: "button", onClick: () => L(N), className: "bg-blue-500 text-white p-2 rounded bg-opacity-60 z-10", children: "Sauvegarder" })] }) : k.jsxs(k.Fragment, { children: [k.jsx("span", { className: "font-bold", children: v(D.name) }), k.jsx(MD, { onClick: () => T(N), className: "cursor-pointer text-blue-500" })] }) }), k.jsxs("label", { className: "col-span-6 sm:col-span-2 flex items-center", children: ["Obtenu", k.jsx("input", { type: "checkbox", checked: D.obtained, onChange: F => M(N, "obtained", F.target.checked), className: "ml-1" })] }), k.jsxs("label", { className: "col-span-6 sm:col-span-2 flex items-center", children: ["Dpense", k.jsx("input", { type: "checkbox", checked: D.expense, onChange: F => M(N, "expense", F.target.checked), className: "ml-1" })] }), k.jsxs("label", { className: "col-span-6 sm:col-span-2 flex items-center", children: ["Dplacer vers", k.jsx("input", { type: "checkbox", checked: D.move, onChange: F => M(N, "move", F.target.checked), className: "ml-1" })] }), k.jsx("div", { className: "col-span-12 sm:col-span-2", children: D.move ? k.jsx("div", { children: i.filter((F, B) => B !== N).map(F => { var B; return k.jsxs("label", { className: "flex items-center gap-2", children: [k.jsx("input", { type: "checkbox", checked: ((B = D.moveTo) == null ? void 0 : B.includes(F.name)) || !1, onChange: H => I(N, F.name, H.target.checked) }), v(F.name)] }, F.id) }) }) : k.jsx("div", {}) }), D.id !== "CarteBleue-Initial" ? k.jsx("button", { type: "button", onClick: () => P(D.id), className: "col-span-12 sm:col-span-1 bg-red-800 text-white px-2 py-1 rounded ml-2", children: "Supprimer" }) : k.jsx("div", { className: "col-span-12 sm:col-span-1" })] }, D.id)) }), k.jsxs("div", { className: "flex flex-col w-fit p-2 mx-auto gap-3", children: [k.jsx("input", { type: "text", value: o, onChange: D => a(D.target.value), className: "border p-2 mb-2", placeholder: "Ajouter un nouveau livret" }), k.jsx("button", { className: "bg-green-600 text-white p-2 rounded", type: "button", onClick: x, children: "Ajouter Livret" })] })] }), k.jsxs("div", { className: "mb-4", children: [k.jsx("label", { children: "Ordre des Colonnes" }), k.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 gap-4 mx-auto mb-4", children: l.map((D, N) => k.jsxs("div", { className: "flex items-center mb-2 gap-4 max-sm:gap-1 max-sm:justify-end mx-auto max-sm:w-[90vw]", children: [k.jsxs("span", { children: [N + 1, "."] }), k.jsxs("select", { value: D, onChange: F => m(N, F.target.value), className: "border p-2 min-w-max max-w-xs", children: [k.jsx("option", { value: "date", children: "Date" }), k.jsx("option", { value: "NomDeLaDepense", children: "Nom de la dpense" }), k.jsx("option", { value: "Categorie", children: "Catgorie" }), k.jsx("option", { value: "ARevoir", children: "A revoir" }), i.map(F => F.obtained && k.jsxs("option", { value: "Obtenu" + F.name, children: ["Obtenu ", v(F.name)] }, "Obtenu" + F.name)), i.map(F => F.expense && k.jsxs("option", { value: "Depense" + F.name, children: ["Dpense ", v(F.name)] }, "Depense" + F.name)), i.map(F => { var B; return F.move && ((B = F.moveTo) == null ? void 0 : B.map(H => k.jsxs("option", { value: "Deplace" + F.name + "Vers" + b(H), children: ["Dplacer ", v(F.name), " vers ", v(H)] }, "Deplace" + F.name + "Vers" + b(H)))) })] }), k.jsx("button", { type: "button", onClick: () => p(N), className: "bg-red-500 text-white p-2 ml-2 rounded", children: "X" })] }, N)) }), k.jsx("button", { type: "button", onClick: y, className: "bg-green-600 text-white px-4 py-2 rounded-full mt-2", children: "+" })] }), k.jsx("button", { type: "submit", className: "bg-blue-500 text-white p-2 rounded", disabled: !C(), children: "Mettre  jour" })] }) })] }) }, co = { _origin: "https://api.emailjs.com" }, DD = (t, e = "https://api.emailjs.com") => { co._userID = t, co._origin = e }, J_ = (t, e, n) => { if (!t) throw "The user ID is required. Visit https://dashboard.emailjs.com/admin/integration"; if (!e) throw "The service ID is required. Visit https://dashboard.emailjs.com/admin"; if (!n) throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates"; return !0 }; class pv { constructor(e) { this.status = e.status, this.text = e.responseText } } const Z_ = (t, e, n = {}) => new Promise((r, i) => { const s = new XMLHttpRequest; s.addEventListener("load", ({ target: o }) => { const a = new pv(o); a.status === 200 || a.text === "OK" ? r(a) : i(a) }), s.addEventListener("error", ({ target: o }) => { i(new pv(o)) }), s.open("POST", co._origin + t, !0), Object.keys(n).forEach(o => { s.setRequestHeader(o, n[o]) }), s.send(e) }), jD = (t, e, n, r) => { const i = r || co._userID; return J_(i, t, e), Z_("/api/v1.0/email/send", JSON.stringify({ lib_version: "3.2.0", user_id: i, service_id: t, template_id: e, template_params: n }), { "Content-type": "application/json" }) }, AD = t => { let e; if (typeof t == "string" ? e = document.querySelector(t) : e = t, !e || e.nodeName !== "FORM") throw "The 3rd parameter is expected to be the HTML form element or the style selector of form"; return e }, ND = (t, e, n, r) => { const i = r || co._userID, s = AD(n); J_(i, t, e); const o = new FormData(s); return o.append("lib_version", "3.2.0"), o.append("service_id", t), o.append("template_id", e), o.append("user_id", i), Z_("/api/v1.0/email/send-form", o) }, gv = { init: DD, send: jD, sendForm: ND }, ew = () => {
  R.useEffect(() => { gv.init("fF2Ie6GtG1pIakaeG") }, []); const t = () => {
    const e = document.getElementById("name").value, n = document.getElementById("email").value, r = document.getElementById("message").value, i = `Message de ${e},

Adresse de contact du client : ${n},
Message : ${r}`, s = { sendername: e, replyto: n, message: i }; gv.send("service_7ytleyo", "template_z5ny6gu", s).then(() => {
      alert(`Message envoy ! 
 (Nous rpondons gnralement en moins d'une semaine)`)
    }).catch(l => {
      console.error(`Une erreur est survenue lors de l'envoi,
 Veuillez nous excuser. Si le problme persiste, contactez le support par un autre moyen. 
 Contact > adresse mail du support:`, l)
    })
  }; return k.jsxs("form", { method: "POST", className: "contact-form mx-auto w-full max-w-lg bg-gray-500 p-8 rounded-lg shadow-md m-8", children: [k.jsx("h2", { className: "text-2xl font-bold mb-4", children: "Formulaire de contact" }), k.jsxs("div", { className: "form-group mb-4", children: [k.jsx("label", { htmlFor: "name", className: "block font-bold mb-2", children: "Nom :" }), k.jsx("input", { type: "text", id: "name", name: "name", placeholder: "Nom*", required: !0, className: "w-full p-2 border border-gray-300 rounded-md" })] }), k.jsxs("div", { className: "form-group mb-4", children: [k.jsx("label", { htmlFor: "email", className: "block font-bold mb-2", children: "Email :" }), k.jsx("input", { type: "email", id: "email", name: "email", placeholder: "Email*", required: !0, className: "w-full p-2 border border-gray-300 rounded-md" })] }), k.jsxs("div", { className: "form-group mb-4", children: [k.jsx("label", { htmlFor: "message", className: "block font-bold mb-2", children: "Message :" }), k.jsx("textarea", { id: "message", name: "message", placeholder: "Votre message*", required: !0, className: "w-full p-2 border border-gray-300 rounded-md" })] }), k.jsx("button", { type: "button", className: "submit-btn w-full py-2 bg-blue-500 text-white font-bold rounded-md hover:bg-blue-600", onClick: t, children: "Envoyer" })] })
}, FD = () => k.jsx("div", { className: "home-container text-center p-8", children: k.jsxs("div", { className: "flex flex-col md:flex-row items-center md:space-x-4 space-y-4 md:space-y-0", children: [k.jsxs("div", { className: "flex-1 md:w-3/4 w-full", children: [k.jsx("h1", { className: "text-3xl font-bold mb-4", children: "Bienvenue sur Personnal Banking" }), k.jsx("p", { className: "mb-4", children: 'Ce site vous permet de faire vos comptes simplement et de regrouper vos diffrents livrets ou "enveloppes de dpense".' }), k.jsx("p", { className: "mb-4", children: "Ce projet a t ralis par Peguin Quentin" }), k.jsx("p", { className: "mt-8", children: "Pour accder  toutes les fonctionnalits, veuillez vous connecter." }), k.jsxs("div", { className: "flex flex-col items-center", children: [k.jsx("button", { className: "bg-gray-300 mt-4 py-2 px-4 rounded", children: k.jsx(Et, { to: "/auth", className: "login-button", children: "Connexion" }) }), k.jsx("p", { className: "mb-4 mt-4 text-center", children: "Pour toutes questions, merci de me contacter via le formulaire suivant :" }), k.jsx("div", { className: "w-full flex justify-center", children: k.jsx(ew, {}) })] })] }), k.jsx("div", { className: "flex-shrink-0 md:w-1/4 w-full", children: k.jsx("img", { src: Is, alt: "Logo", className: "object-contain w-full h-full rounded-full" }) })] }) }), $D = { CarteBleue: "Carte Bleue" }, zD = ({ accounts: t, virtualTransfers: e }) => { const [n, r] = R.useState([]), [i, s] = R.useState({}), [o, a] = R.useState(null); R.useEffect(() => { (async () => { var h; const { data: { user: d } } = await we.auth.getUser(); a(d), (h = d == null ? void 0 : d.user_metadata) != null && h.livrets && r(d.user_metadata.livrets.filter(f => f && typeof f == "object")) })() }, []); const l = (c, d) => { const h = new Date, f = new Date(c); let g = 0; for (; f <= h;)switch (g++, d) { case "par mois": f.setMonth(f.getMonth() + 1); break; case "annuel": f.setFullYear(f.getFullYear() + 1); break; case "quotidien": f.setDate(f.getDate() + 1); break; case "ponctuel": return 1 }return g }; R.useEffect(() => { const c = () => { const d = {}; n.forEach(h => { d[h.name] = 0 }), t.forEach(h => { n.forEach(f => { const g = f.name, m = parseFloat(h[`Depense${g}`] || "0"), y = parseFloat(h[`Obtenu${g}`] || "0"); let p = 0, v = 0; n.forEach(b => { if (g !== b.name) { const x = parseFloat(h[`Deplace${g}Vers${b.name}`] || "0"), P = parseFloat(h[`Deplace${b.name}Vers${g}`] || "0"); p += x, v += P } }), d[g] += y - m - p + v }) }), e.forEach(h => { const f = h.nom, g = h.comptesource, m = l(h.date, h.frequence), y = h.montant * m; d[f] || (d[f] = 0), d[f] += y, g && d[g] !== void 0 && (d[g] = d[g] - y) }), s(d) }; n.length > 0 && c() }, [t, n, e]); const u = Object.keys(i).filter(c => n.some(d => d.name === c)).reduce((c, d) => c + (i[d] || 0), 0); return k.jsxs("div", { className: "account-summary p-4 rounded-md bg-transparent", children: [k.jsx("h2", { className: "text-xl mb-2", children: "Rsum des comptes" }), k.jsx("ul", { className: "flex justify-between gap-4 flex-wrap mb-4 mt-4", children: Object.keys(i).map(c => { const d = $D[c] || c, h = i[c] || 0; return k.jsxs("li", { className: "p-2 border border-gray-200 rounded-md", children: ["Virtuellement ", k.jsx("br", {}), " sur le compte ", d, ": ", k.jsxs("span", { className: `font-semibold ${h < 0 ? "text-red-500" : ""}`, children: [h.toFixed(2), " "] })] }, c) }) }), k.jsx("hr", { className: "my-2" }), k.jsx("div", { className: "flex justify-center mt-4", children: k.jsxs("div", { className: "p-2 border border-gray-200 rounded-md inline-block", children: ["Total: ", k.jsxs("span", { className: `font-bold ${u < 0 ? "text-red-500" : ""}`, children: [u.toFixed(2), " "] })] }) })] }) }, VD = ({ accounts: t, livrets: e }) => { const [n, r] = R.useState([]), [i, s] = R.useState({ nom: "", montant: 0, frequence: "par mois", comptesource: e.length > 0 ? e[0].name : "", occurrences: 1, date: new Date().toISOString().slice(0, 10) }), [o, a] = R.useState(null); R.useEffect(() => { (async () => { const { data: { user: h } } = await we.auth.getUser(); a(h) })() }, []), R.useEffect(() => { if (!o) return; (async () => { try { const { data: h, error: f } = await we.from("virtual_transfers").select("*").eq("user_id", o.id); if (f) throw f; r(h || []) } catch (h) { console.error("Erreur lors de la rcupration des dplacements virtuels:", h) } })() }, [o]), R.useEffect(() => { e.length > 0 && i.comptesource === "" && s(d => ({ ...d, comptesource: e[0].name })) }, [e]); const l = d => { const { name: h, value: f } = d.target; s(g => ({ ...g, [h]: h === "montant" || h === "occurrences" ? parseFloat(f) : f })) }, u = async () => { var h; if (!o) return; const d = { ...i, id: Qh(), user_id: o.id }; try { const { data: f, error: g } = await we.from("virtual_transfers").insert([d]).select(); if (g) throw g; f && (r([...n, f[0]]), s({ nom: "", montant: 0, frequence: "par mois", comptesource: ((h = e[0]) == null ? void 0 : h.name) || "", occurrences: 1, date: new Date().toISOString().slice(0, 10) })) } catch (f) { console.error("Erreur lors de l'ajout du dplacement virtuel:", f) } }, c = async d => { if (window.confirm("Voulez-vous vraiment supprimer ce transfert virtuel ?")) try { const { error: f } = await we.from("virtual_transfers").delete().eq("id", d); if (f) throw f; r(n.filter(g => g.id !== d)) } catch (f) { console.error("Erreur lors de la suppression du dplacement virtuel:", f) } }; return k.jsxs("div", { className: "virtual-transfers p-4", children: [k.jsx(Yh, { accounts: t }), k.jsx("h2", { className: "text-xl mb-4", children: "Dplacements Virtuels" }), k.jsxs("div", { className: "mb-4 flex max-sm:flex-col max-sm:items-center flex-wrap gap-4 items-end justify-evenly", children: [k.jsxs("div", { className: "flex flex-col", children: [k.jsx("label", { htmlFor: "nom", children: "Nom" }), k.jsx("input", { type: "text", id: "nom", name: "nom", value: i.nom, onChange: l, placeholder: "Nom", className: "border p-1" })] }), k.jsxs("div", { className: "flex flex-col", children: [k.jsx("label", { htmlFor: "montant", children: "Montant ()" }), k.jsx("input", { type: "number", id: "montant", name: "montant", value: i.montant, onChange: l, placeholder: "Montant ()", className: "border p-1" })] }), k.jsxs("div", { className: "flex flex-col", children: [k.jsx("label", { htmlFor: "frequence", children: "Frquence" }), k.jsxs("select", { name: "frequence", id: "frequence", value: i.frequence, onChange: l, className: "border p-1", children: [k.jsx("option", { value: "par mois", children: "Par mois" }), k.jsx("option", { value: "annuel", children: "Annuel" }), k.jsx("option", { value: "quotidien", children: "Quotidien" }), k.jsx("option", { value: "ponctuel", children: "Ponctuel" })] })] }), k.jsxs("div", { className: "flex flex-col", children: [k.jsx("label", { htmlFor: "comptesource", children: "Compte Source" }), k.jsx("select", { name: "comptesource", id: "comptesource", value: i.comptesource, onChange: l, className: "border p-1", children: e.map(d => k.jsx("option", { value: d.name, children: d.name }, d.id)) })] }), k.jsxs("div", { className: "flex flex-col", children: [k.jsx("label", { htmlFor: "occurrences", children: "Nombre de fois" }), k.jsx("input", { type: "number", id: "occurrences", name: "occurrences", value: i.occurrences, onChange: l, placeholder: "Nombre de fois", className: "border p-1" })] }), k.jsxs("div", { className: "flex flex-col", children: [k.jsx("label", { htmlFor: "date", children: "Date" }), k.jsx("input", { type: "date", id: "date", name: "date", value: i.date, onChange: l, className: "border p-1" })] }), k.jsx("button", { onClick: u, className: "bg-blue-500 text-white px-4 py-2 rounded", children: "Ajouter" })] }), k.jsx("ul", { className: "mt-4 space-y-4", children: n.map(d => k.jsxs("li", { className: "border p-2 flex justify-between items-center", children: [k.jsxs("span", { className: "mb-2 sm:mb-0", children: ["Transfert virtuel : Date de dbut ", d.date, ", ", d.nom, " de ", d.montant, " (", d.frequence, ") dplac depuis : ", d.comptesource, ", ", d.occurrences, " fois."] }), k.jsx("button", { onClick: () => c(d.id), className: "bg-red-500 text-white px-2 py-1 rounded", children: "Supprimer" })] }, d.id)) }), k.jsx(zD, { accounts: t, virtualTransfers: n })] }) }, BD = () => { const [t, e] = R.useState([]), [n, r] = R.useState(null), [i, s] = R.useState([]), [o, a] = R.useState(!0); R.useEffect(() => { (async () => { var g; const { data: { user: f } } = await we.auth.getUser(); r(f), s(((g = f == null ? void 0 : f.user_metadata) == null ? void 0 : g.livrets) || []), a(!1) })() }, []), R.useEffect(() => { if (!n) return; (async () => { const { data: f, error: g } = await we.from("accounts").select("*").eq("user_id", n.id); if (g) { console.error("Erreur lors de la rcupration des comptes :", g); return } if (f) { const m = f.map(y => ({ id: y.id, ...y })); e(m) } else console.error("Les donnes rcupres sont nulles") })() }, [n]); const l = async h => { try { const f = h.replace(/[^a-zA-Z0-9_]/g, "_"), { error: g } = await we.rpc("check_and_add_column", { table_name: "accounts", column_name: f, column_type: "text" }); if (g) throw g } catch (f) { console.error(`Erreur lors de la vrification/ajout de la colonne ${h} :`, f) } }, u = async h => { h.id = Qh(); for (const f in h) h.hasOwnProperty(f) && f !== "id" && f !== "user_id" && await l(f); try { const { data: f, error: g } = await we.from("accounts").insert({ ...h, user_id: n == null ? void 0 : n.id }).select(); if (g) { console.error("Erreur lors de l'insertion du compte :", g); return } f ? e([...t, { ...h }]) : console.error("Les donnes insres sont nulles") } catch (f) { console.error("Erreur lors de l'ajout du compte :", f) } }, c = async (h, f) => { for (const g in f) f.hasOwnProperty(g) && g !== "id" && g !== "user_id" && await l(g); try { const { error: g } = await we.from("accounts").update(f).eq("id", h).eq("user_id", n == null ? void 0 : n.id); if (g) { console.error("Erreur lors de la mise  jour du compte :", g); return } e(t.map(m => m.id === h ? { ...m, ...f } : m)) } catch (g) { console.error("Erreur lors de la mise  jour du compte :", g) } }, d = async h => { try { const { error: f } = await we.from("accounts").delete().eq("id", h).eq("user_id", n == null ? void 0 : n.id); if (f) { console.error("Erreur lors de la suppression du compte :", f); return } e(t.filter(g => g.id !== h)) } catch (f) { console.error("Erreur lors de la suppression du compte :", f) } }; return o ? k.jsx("div", { children: "Loading..." }) : k.jsx(T1, { basename: "/Personal_Banking", children: k.jsxs("div", { className: "App w-full h-full", children: [k.jsx(NC, {}), k.jsxs(x1, { children: [k.jsx(Jt, { path: "/", element: n ? k.jsx(Rn, { to: "/accountform" }) : k.jsx(Rn, { to: "/Home" }) }, "home"), k.jsx(Jt, { path: "/Home", element: k.jsx(FD, {}) }, "home-alt"), k.jsx(Jt, { path: "/accountform", element: n ? k.jsx(kP, { addAccount: u, accounts: t, livrets: i }) : k.jsx(Rn, { to: "/" }) }, "accountform"), k.jsx(Jt, { path: "/tableau", element: n ? k.jsx(CP, { accounts: t, deleteAccount: d, updateAccount: c, livrets: i }) : k.jsx(Rn, { to: "/" }) }, "tableau"), k.jsx(Jt, { path: "/graphique", element: n ? k.jsx(xD, { accounts: t }) : k.jsx(Rn, { to: "/" }) }, "graphique"), k.jsx(Jt, { path: "/EnvellopesVirtuelles", element: n ? k.jsx(VD, { accounts: t, livrets: i }) : k.jsx(Rn, { to: "/" }) }, "EnvellopesVirtuelles"), k.jsx(Jt, { path: "/auth", element: k.jsx(SD, {}) }, "auth"), k.jsx(Jt, { path: "/parametres", element: n ? k.jsx(LD, {}) : k.jsx(Rn, { to: "/" }) }, "parametres"), k.jsx(Jt, { path: "/contact", element: n ? k.jsx(ew, {}) : k.jsx(Rn, { to: "/" }) }, "contact")] })] }) }) }, UD = document.getElementById("root"), HD = T0(UD); HD.render(k.jsx(Dt.StrictMode, { children: k.jsx(BD, {}) })); export { Bd as g };
